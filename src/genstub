;;;
;;; genstub - simple stub generator
;;;
;;;  Copyright(C) 2000-2001 by Shiro Kawai (shiro@acm.org)
;;;
;;;  Permission to use, copy, modify, distribute this software and
;;;  accompanying documentation for any purpose is hereby granted,
;;;  provided that existing copyright notices are retained in all
;;;  copies and that this notice is included verbatim in all
;;;  distributions.
;;;  This software is provided as is, without express or implied
;;;  warranty.  In no circumstances the author(s) shall be liable
;;;  for any damages arising out of the use of this software.
;;;
;;;  $Id: genstub,v 1.35 2001-05-19 10:56:28 shirok Exp $
;;;

;; (define-cproc scheme-name (argspec)
;;   assertions ...
;;   body)
;;
;; (define-symbol scheme-name c-name [value])
;;
;; (define-type name assert-predicate c-type c-predicate unboxer)

(define *file-prefix* "")
(define *cprocs* '())
(define *symbols* '())
(define *cclasses* '())
(define *insert-sharp-line* #t)         ;if #t, output #line directive
(define *unbound* (cons #f #f))         ;placeholder for unbound value

(define (print fmt . args)
  (if (null? args) (display fmt) (apply format #t fmt args)))

(define (println fmt . args)
  (if (null? args) (display fmt) (apply format #t fmt args))
  (newline))

(define (ensure-string stuff)
  (cond ((string? stuff) stuff)
        ((symbol? stuff) (symbol->string stuff))
        (else (with-output-to-string (lambda () (write stuff))))))

(define (file-exists? file) (sys-access file F_OK))

;;-----------------------------------------------------------------
;; Procedure
;;

(define-class <cproc> ()
  ((scheme-name     :init-keyword :scheme-name :accessor scheme-name-of)
   (args            :initform '() :accessor args-of)
   (num-reqargs     :initform 0   :accessor num-reqargs-of)
   (num-optargs     :initform 0   :accessor num-optargs-of)
   (have-rest-arg?  :initform #f  :accessor have-rest-arg?)
   (keyword-args    :initform '() :accessor keyword-args-of)
   (decls           :initform '() :accessor decls-of)
   (stmts           :initform '() :accessor stmts-of)
   (inliner         :initform #f  :accessor inliner-of)
   (inline-insn     :initform #f  :accessor inline-insn-of)
   (c-name          :accessor c-name-of)
   ))

(define (make-cproc scheme-name)
  (make <cproc> :scheme-name scheme-name))

(define (push-arg! cproc arg)
  (let* ((argname   (car arg))
         (argname-c (get-c-name "" argname))
         (argname-s (string-append argname-c "_scm"))
         (argcnt    (length (args-of cproc))))
    (set! (args-of cproc) (cons arg (args-of cproc)))
    (set-cdr! arg (list* :c-name argname-c :s-name argname-s
                         :count argcnt (cdr arg)))))

(define (get-arg cproc arg)
  (assq arg (args-of cproc)))

(define (arg-attr-get cproc arg key)
  (cond ((get-arg cproc arg) => (lambda (arg) (get-keyword key (cdr arg) #f)))
        (else #f)))

(define (arg-attr-set! cproc arg key val)
  (cond ((get-arg cproc arg)
         => (lambda (arg) (set-cdr! arg (list* key val (cdr arg)))))))

(define (push-stmt! cproc stmt)
  (set! (stmts-of cproc) (cons stmt (stmts-of cproc))))

;;-----------------------------------------------------------------
;; Built-in class
;;

(define *super-table* '())

(define-class <cclass> ()
  ((scheme-class-name :accessor scheme-class-name-of)
   (c-class-name      :accessor c-class-name-of)
   (slots             :accessor slots-of)
   (super             :accessor super-of)
   (extensible?       :accessor extensible?)
  ))

(define (make-cclass scheme-class-name c-class-name super slots)
  (let ((cclass (make <cclass>)))
    (set! (scheme-class-name-of cclass) scheme-class-name)
    (set! (c-class-name-of cclass) c-class-name)
    (set! (super-of cclass) super)
    (set! (slots-of cclass) slots)
    (set! *cclasses* (cons cclass *cclasses*))
    cclass))

(define (register-inheritance class cplname supers)
  (let ((p (assq class *super-table*)))
    (if p
        (unless (equal? (cdr p) (cons cplname supers))
          (error "conflicting built-in class inheritance: ~s vs ~s"
                 (cdr p) (cons cplname supers)))
        (set! *super-table* (acons class (cons cplname supers) *super-table*))
        )))

(register-inheritance '<top> "Scm_DefaultCPL" '())
(register-inheritance '<collection> "Scm_CollectionCPL" '(<top>))
(register-inheritance '<sequence> "Scm_SequenceCPL" '(<collection> <top>))
(register-inheritance '<object> "Scm_ObjectCPL" '(<top>))

;;--------------------------------------------------------------------
;; Types
;;

(define *type-table* '())

(define-class <type> ()
  ((name        :init-keyword :name        :accessor name-of)
   (predicate   :init-keyword :predicate   :accessor predicate-of)
   (c-type      :init-keyword :c-type      :accessor c-type-of)
   (c-predicate :init-keyword :c-predicate :accessor c-predicate-of)
   (unboxer     :init-keyword :unboxer     :accessor unboxer-of)
   ))

(define (make-type name predicate c-type c-predicate unboxer)
  (let ((i (make <type> :name name :predicate predicate
                 :c-type c-type :c-predicate c-predicate :unboxer unboxer)))
    (set! *type-table* (cons i *type-table*))
    i))

;; predefined types

(make-type "pair"    'pair?        "ScmObj"       "SCM_PAIRP"   #f)
(make-type "list"    'list?        "ScmObj"       "SCM_LISTP"   #f)
(make-type "vector"  'vector?      "ScmVector*"   "SCM_VECTORP" "SCM_VECTOR")
(make-type "string"  'string?      "ScmString*"   "SCM_STRINGP" "SCM_STRING")
(make-type "symbol"  'symbol?      "ScmSymbol*"   "SCM_SYMBOLP" "SCM_SYMBOL")
(make-type "keyword" 'keyword?     "ScmKeyword*"  "SCM_KEYWORDP" "SCM_KEYWORD")
(make-type "identifier" 'identifier? "ScmIdentifier*" "SCM_IDENTIFIERP" "SCM_IDENTIFIER")
(make-type "small integer" 'small-integer? "int" "SCM_INTP"    "SCM_INT_VALUE")
;; TODO: bignum!
(make-type "exact integer" 'exact? "int"          "SCM_EXACTP"  "Scm_GetInteger")
(make-type "number"    'number?    "ScmObj"       "SCM_NUMBERP" #f)
(make-type "character" 'char?      "ScmChar"      "SCM_CHARP" "SCM_CHAR_VALUE")
(make-type "char-set"  'char-set?  "ScmCharSet*"  "SCM_CHARSETP" "SCM_CHARSET")
(make-type "port"        'port?        "ScmPort*" "SCM_PORTP"  "SCM_PORT")
(make-type "input port"  'input-port?  "ScmPort*" "SCM_IPORTP" "SCM_PORT")
(make-type "output port" 'output-port? "ScmPort*" "SCM_OPORTP" "SCM_PORT")

(make-type "procedure" 'procedure? "ScmProcedure*" "SCM_PROCEDUREP" "SCM_PROCEDURE")
(make-type "closure"   'closure?   "ScmClosure*"   "SCM_CLOSUREP"   "SCM_CLOSURE")
(make-type "hash table" 'hash-table? "ScmHashTable*" "SCM_HASHTABLEP" "SCM_HASHTABLE")
(make-type "class"     'class?     "ScmClass*"     "SCM_CLASSP" "SCM_CLASS")
(make-type "module"    'module?    "ScmModule*"    "SCM_MODULEP" "SCM_MODULE")

;; default
(define *scm-type*
  (make-type "scheme object" #f     "ScmObj"       #f           #f))

(define (predicate->type pred)
  (let loop ((types *type-table*))
    (cond ((null? types) (error "unknown predicate to assert: ~s" pred))
          ((eq? (predicate-of (car types)) pred) (car types))
          (else (loop (cdr types))))))

;; process type definition in stub file
(define (process-define-type form)
  (unless (= (length form) 6)
    (error "malformed define-type: ~s" form))
  (apply make-type (cdr form)))

;;--------------------------------------------------------------------
;; C structure
;;

;; (define-c-struct <sys-hostent> "struct hostent"
;;   ((h-name      :c-type "char*")
;;    (h-aliases   :c-type "char**")
;;    (h-addrtype  :c-type "int")
;;    (h-length    :c-type "int")
;;    (h-addr-list :c-type "char**"))

(define-class <c-type-mapping> ()
  ((c-type-name :init-keyword :c-name  :getter c-name-of)
   (boxer       :init-keyword :boxer   :getter boxer-of)
   (unboxer     :init-keyword :unboxer :getter unboxer-of)
   (mappings    :allocation :class :init-value '())))

(define-method initialize ((self <c-type-mapping>) initargs)
  (next-method)
  (set! (mappings-of self) (cons self (mappings-of self))))

(define (make-c-type-mapping c-type-name boxer unboxer)
  (make <c-type-mapping>
    :c-type-name c-type-name
    :boxer boxer
    :unboxer unboxer))

(define-class <c-slot> ()
  ((name   :init-keyword :name :getter name-of)
   (c-name :init-keyword :name :getter c-name-of)
   (type   :init-keyword :name :getter type-of)
   (c-type :init-keyword :type :getter c-type-of)
   (getter :init-keyword :getter :getter getter-of)
   (setter :init-keyword :setter :setter setter-of)))

(define-class <c-struct> ()
  ((name    :init-keyword :name :getter name-of)
   (c-name  :init-keyword :c-name :getter c-name-of)
   (slots   :init-keyword :slots :getter slots-of)))

(define (make-c-struct name c-name slots . options)
  (apply make <cstruct>
         :nanem name
         :c-name c-name
         :slots (map make-c-slot slots)
         options))


;;--------------------------------------------------------------------
;; Symbol definition
;;

(define (process-define-symbol form)
  (unless (and (<= 3 (length form) 4)
               (symbol? (cadr form))
               (string? (caddr form)))
    (error "malformed define-symbol: ~s" form))
  (let* ((scheme-name (cadr form))
         (c-name (caddr form))
         (value  (cdddr form))
         (scheme-name-len (string-length (symbol->string scheme-name))))
    (println "static ScmString ~a_NAME = { {SCM_CLASS_STRING}, 0, 1, ~a, ~a, \"~a\" };"
             c-name scheme-name-len scheme-name-len scheme-name)
    (println "static ScmObj ~a;" c-name)
    (newline)
    (set! *symbols* (cons (cdr form) *symbols*))
    ))

;;--------------------------------------------------------------------
;; Cclass definition
;;

;; NOT OPERATIONAL YET
(define (process-define-cclass form)
  (unless (and (> (length form) 4)
               (symbol? (cadr form))
               (list? (caddr form))
               (list? (cadddr form)))
    (error "malformed define-cclass: ~s" form))
  (let* ((scheme-class (cadr form))
         (super (caddr form))
         (slots (cadddr form))
         (c-class (get-keyword :c-name (cddddr form) #f))
         (c-class-sym (string-append c-class "_SYM"))
         (scheme-name-len (string-length (symbol->string scheme-class))))
    (unless c-class (error "C-class name unspecified: ~s" form))
    (case (length super)
      ((0) (set! super '<top>))
      ((1) (set! super (car suprt)))
      (else (error "built-in class can't use multiple inheritance: ~s" form)))
    ;; TODO: check slot vailidity
    (make-cclass scheme-class c-class super slots)
    (newline))
  )

;;--------------------------------------------------------------------
;; Cproc definition
;;

(define (process-define-cproc form)
  (unless (and (>= (length form) 4)
               (symbol? (cadr form))
               (list? (caddr form)))
    (error "malformed define-cproc: ~s" form))
  (let ((cproc (make-cproc (cadr form))))
    (set! (c-name-of cproc)
          (get-c-name *file-prefix* (scheme-name-of cproc)))
    (process-args cproc (caddr form))
    (process-body cproc (cdddr form))
    (set! *cprocs* (cons cproc *cprocs*))
    (emit-definition cproc)
    (emit-inliner cproc)
    (emit-record cproc)))

(define (process-args cproc argspec)
  (define (push-mandatory-arg! arg)
    (set! (num-reqargs-of cproc) (+ (num-reqargs-of cproc) 1))
    (push-arg! cproc (list arg :category :required)))
  (define (push-optional-arg! arg default)
    (set! (num-optargs-of cproc) (+ (num-optargs-of cproc) 1))
    (push-arg! cproc (list arg :category :optional :default default)))
  (define (push-keyword-arg! arg default)
    (set! (num-optargs-of cproc) (+ (num-optargs-of cproc) 1))
    (set! (keyword-args-of cproc) (cons arg (keyword-args-of cproc)))
    (push-arg! cproc (list arg :category :keyword :default default)))
  (define (push-rest-arg! arg)
    (set! (have-rest-arg? cproc) #t)
    (push-arg! cproc (list arg :category :rest)))
  
  (let loop ((spec argspec)
             (state 'initial))
    (if (null? spec)
        cproc
        (let ((arg (car spec))
              (next (cdr spec)))
          (case state
            ((initial)
             (cond ((eq? arg '&optional)  (loop next 'optional))
                   ((eq? arg '&rest)      (loop next 'rest))
                   ((eq? arg '&keyword)   (loop next 'keyword))
                   ((symbol? arg) (push-mandatory-arg! arg)
                                  (loop next state))
                   (else (error "bad argument in argspec: ~s" arg))))
            ((optional)
             (cond ((eq? arg '&optional)  (error "extra &optional parameter"))
                   ((eq? arg '&keyword)
                    (error "&keyword and &optional can't be used together"))
                   ((eq? arg '&rest)      (loop next 'rest))
                   ((symbol? arg) (push-optional-arg! arg *unbound*)
                                  (loop next state))
                   ((and (list? arg)
                         (= (length arg) 2))
                    (push-optional-arg! (car arg) (cadr arg))
                    (loop next state))
                   (else (error "bad argument in argspec: ~s" arg))))
            ((keyword)
             (cond ((eq? arg '&keyword)  (error "extra &keyword parameter"))
                   ((eq? arg '&optional)
                    (error "&keyword and &optional can't be used together"))
                   ((eq? arg '&rest)      (loop next 'rest))
                   ((symbol? arg) (push-keyword-arg! arg *unbound*)
                                  (loop next state))
                   ((and (list? arg)
                         (= (length arg) 2))
                    (push-keyword-arg! (car arg) (cadr arg))
                    (loop next state))
                   (else (error "bad argument in argspec: ~s" arg))))
            ((rest)
             (cond ((have-rest-arg? cproc)
                    (error "too many &rest args"))
                   ((symbol? arg)
                    (push-rest-arg! arg) (loop next state))
                   (else (error "bad argument in argspec: ~s" arg))))))
        ))
  )

(define (process-body cproc body)
  (let loop ((body body))
    (if (null? body)
        (set! (stmts-of cproc) (reverse (stmts-of cproc)))
        (let ((form (car body))
              (next (cdr body)))
          (cond ((string? form) (push-stmt! cproc form) (loop next))
                ((not (pair? form)) (error "bad form in body: ~s" form))
                ((eq? (car form) 'assert)
                 (process-assert cproc (cadr form))
                 (loop next))
                ((eq? (car form) 'inliner)
                 (unless (pair? (cdr form))
                   (error "bad `inliner' spec: ~s" form))
                 (if (and (pair? (cadr form))
                          (eq? (caadr form) 'proc))
                     (if (not (string? (cadadr form)))
                         (error "inliner procedure name must be a string: ~s"
                                form)
                         (set! (inliner-of cproc) (cadadr form)))
                     (set! (inline-insn-of cproc) (cadr form)))
                 (loop next))
                (else
                 (error "unknown body form: ~s" form)))))))

(define (process-assert cproc form)
  (let* ((op  (car form))
         (arg (cadr form)))
    (unless (get-arg cproc arg) (error "assertion for unknown arg: ~s" form))
    (arg-attr-set! cproc arg :type (predicate->type op))))

;;; emit code

(define (emit-definition cproc)
  (println "static ScmObj ~a(ScmObj *SCM_FP, int SCM_ARGCNT, void *data_)"
           (c-name-of cproc))
  (println "{")
  ;; argument decl
  (for-each emit-arg-decl (reverse (args-of cproc)))
  (when (> (num-optargs-of cproc) 0)
    (println "  ScmObj SCM_OPTARGS = SCM_ARGREF(SCM_ARGCNT-1);"))
  (println "  SCM_ENTER_SUBR(\"~a\");" (scheme-name-of cproc))
  ;; argument count check (for optargs)
  (when (and (> (num-optargs-of cproc) 0)
             (null? (keyword-args-of cproc))
             (not (have-rest-arg? cproc)))
    (println "  if (Scm_Length(SCM_OPTARGS) > ~a)" (num-optargs-of cproc))
    (println "    Scm_Error(\"too many arguments: up to ~s is expected, %d given.\", Scm_Length(SCM_OPTARGS));"
             (num-optargs-of cproc)))
  ;; argument assertions & unbox op.
  (for-each emit-arg-unbox (reverse (args-of cproc)))
  ;; body
  (println "  {")
  (for-each (lambda (stmt) (println stmt)) (reverse (stmts-of cproc)))
  (println "  }")
  (println "}")
  (newline)
  )

(define (emit-arg-decl arg)
  (let* ((attrs (cdr arg))
         (type  (get-keyword :type attrs *scm-type*))
         (cname (get-keyword :c-name attrs))
         (sname (get-keyword :s-name attrs)))
    (println "  ScmObj ~a;" sname)
    (println "  ~a ~a;" (c-type-of type) cname)))

(define (emit-arg-unbox arg)
  (let* ((attrs (cdr arg))
         (category (get-keyword :category attrs))
         (type  (get-keyword :type attrs *scm-type*))
         (cname (get-keyword :c-name attrs))
         (sname (get-keyword :s-name attrs))
         (count (get-keyword :count attrs))
         (tname (name-of type))
         (pred  (c-predicate-of type))
         (unbox (unboxer-of type)))
    (case category
      ((:required)
       (println "  ~a = SCM_ARGREF(~a);" sname count))
      ((:optional)
       (println "  if (SCM_NULLP(SCM_OPTARGS)) ~a = ~a;"
                sname
                (scheme-constant->c-constant
                 (get-keyword :default attrs)))
       (println "  else {")
       (println "    ~a = SCM_CAR(SCM_OPTARGS);" sname)
       (println "    SCM_OPTARGS = SCM_CDR(SCM_OPTARGS);")
       (println "  }"))
      ((:keyword)
       (println "  ~a = Scm_GetKeyword(SCM_MAKE_KEYWORD(\"~a\"), SCM_OPTARGS, ~a);"
                sname (car arg)
                (scheme-constant->c-constant
                 (get-keyword :default attrs))))
      ((:rest)
       (println "  ~a = SCM_ARGREF(SCM_ARGCNT-1);" sname)))
    (when pred
      (println "  if (!~a(~a)) Scm_Error(\"~a required, but got %S\", ~a);"
               pred sname tname sname))
    (if unbox
        (println "  ~a = ~a(~a);" cname unbox sname)
        (println "  ~a = ~a;" cname sname))))

(define (scheme-constant->c-constant value)
  (cond ((boolean? value) (if value "SCM_TRUE" "SCM_FALSE"))
        ((null? value)    "SCM_NIL")
        ((char? value)
         (format #f "SCM_MAKE_CHAR(~a) /* #\\~a */"
                 (char->integer value) value))
        ((integer? value)
         (format #f "Scm_MakeInteger(~a)" value))
        ((string? value)
         (format #f "SCM_MAKE_STR(~s)" value))
        ((eq? value *unbound*)
         "SCM_UNBOUND")
        ((equal? value '(current-input-port))
         (format #f "SCM_OBJ(SCM_CURIN)"))
        ((equal? value '(current-output-port))
         (format #f "SCM_OBJ(SCM_CUROUT)"))
        ((equal? value '(current-error-port))
         (format #f "SCM_OBJ(SCM_CURERR)"))
        (else
         (error "Scheme constant ~s can't be used" value))))

(define (emit-inliner cproc)
  (let* ((insn (inline-insn-of cproc)))
    (when insn
      (let ((inliner (string-append (c-name-of cproc) "_inline"))
            (name (scheme-name-of cproc))
            (req  (num-reqargs-of cproc))
            (opt  (num-optargs-of cproc))
            )
        (set! (inliner-of cproc) inliner)
        (emit-inliner-header cproc)
        (cond ((string? insn)
               (println "  SCM_APPEND1(code, tail, ~a);"
                        (if (or (have-rest-arg? cproc) (> opt 0))
                            (format #f "SCM_VM_INSN1(~a, nargs)" insn)
                            (format #f "SCM_VM_INSN(~a)" insn)))
               (println "  return code;"))
              ((and (pair? insn) (eq? (car insn) 'case-nargs))
               (for-each (lambda (clause)
                           (let ((nargs (car clause))
                                 (insn  (cadr clause)))
                             (if (eq? nargs 'else)
                                 (print "else ")
                                 (print "if (nargs == ~a) " nargs))
                             (println "{")
                             (if insn
                                 (println "  SCM_APPEND1(code, tail, SCM_VM_INSN(~a)); return code;" insn)
                                 (println "  return SCM_FALSE;"))
                             (println "}")))
                         (cdr insn))))
        (println "}")
        ))
    ))

(define (emit-inliner-header cproc)
  (let ((inliner (inliner-of cproc))
        (name (scheme-name-of cproc))
        (req  (num-reqargs-of cproc))
        (opt  (num-optargs-of cproc))
        )
    (println "static ScmObj ~a(ScmSubr *subr, ScmObj form, ScmObj env, int ctx)" inliner)
    (println "{")
    (println "  ScmObj cp = SCM_CDR(form);")
    (println "  ScmObj code = SCM_NIL, tail = SCM_NIL;")
    (println "  int nargs = Scm_Length(cp);")
    (cond ((have-rest-arg? cproc)
           (println "  if (nargs < ~a)" req)
           (println "     Scm_Error(\"~s requires at least ~s arg(s)\");" name req)
           )
          ((> opt 0)
           (println "  if (nargs < ~a || nargs > ~a)" req (+ req opt))
           (println "     Scm_Error(\"~s requires at least ~s arg(s), and at most ~s arg(s)\");" name req (+ req opt))
           )
          (else
           (println "  if (nargs != ~a)" req)
           (println "     Scm_Error(\"~s requires exactly ~s arg(s)\");" name req)
           ))
    (println "  SCM_FOR_EACH(cp, cp) {")
    (println "    SCM_APPEND(code, tail, Scm_Compile(SCM_CAR(cp), env, SCM_COMPILE_NORMAL));")
    (println "    if (SCM_PAIRP(SCM_CDR(cp))) {")
    (println "      SCM_APPEND1(code, tail, SCM_VM_INSN(SCM_VM_PUSH));")
    (println "    }")
    (println "  }")
    ))

(define (emit-record cproc)
  (let* ((scm-func-name (symbol->string (scheme-name-of cproc)))
         (c-func-name (c-name-of cproc)))
    (println "static ScmString ~a_NAME = { { SCM_CLASS_STRING }, 0, 1, ~a, ~a, \"~a\" };"
             c-func-name
             (string-length scm-func-name)
             (string-length scm-func-name)
             scm-func-name)
    (println "static ScmSubr ~a_STUB = {" c-func-name)
    (println "  {{SCM_CLASS_PROCEDURE},")
    (println "  ~a, ~a, SCM_PROC_SUBR,"
             (num-reqargs-of cproc)
             (if (or (have-rest-arg? cproc) (> (num-optargs-of cproc) 0)) 1 0))
    (println "  SCM_OBJ(&~a_NAME)}," c-func-name)
    (println "  ~a," c-func-name)
    (println "  ~a, " (or (inliner-of cproc) "NULL"))
    (println "  NULL")
    (println "};")
    (newline)))

(define (emit-initializer name)
  (println "void Scm_Init_~a(ScmModule *module)" name)
  (println "{")
  (for-each (lambda (cproc)
              (println "  SCM_DEFINE(module, ~s, SCM_OBJ(&~a_STUB));"
                       (symbol->string (scheme-name-of cproc))
                       (c-name-of cproc)))
            (reverse *cprocs*))
  (for-each (lambda (symdef)
              (println "  ~a = Scm_Intern(&~a_NAME);"
                       (cadr symdef) (cadr symdef))
              (unless (null? (cddr symdef))
                (println "  Scm_Define(module, SCM_SYMBOL(~a), SCM_OBJ(~a));"
                         (cadr symdef) (caddr symdef))))
            (reverse *symbols*))
  (println "}")
  )

;; aux util functions

(define (get-c-name prefix scheme-name)
  (with-output-to-string
    (lambda ()
      (display (ensure-string prefix))
      (with-input-from-string (ensure-string scheme-name)
        (lambda ()
          (let loop ((c (read-char)))
            (unless (eof-object? c)
              (case c
                ((#\-) (let ((d (read-char)))
                         (cond ((eof-object? d)
                                (display #\_))
                               ((eqv? d #\>)
                                (display "_TO") (loop (read-char)))
                               (else
                                (display #\_) (loop d)))))
                ((#\?) (display #\P) (loop (read-char)))
                ((#\!) (display #\X) (loop (read-char)))
                ((#\<) (display "_LT") (loop (read-char)))
                ((#\>) (display "_GT") (loop (read-char)))
                ((#\* #\> #\@ #\$ #\% #\^ #\& #\* #\+ #\=
                  #\: #\. #\/ #\~)
                 (display #\_)
                 (display (number->string (char->integer c) 16))
                 (loop (read-char)))
                (else (display (char-downcase c)) (loop (read-char)))
                ))))
        )
      )
    )
  )

;;; main loop ===========================================================

(unless (and (= (length *argv*) 1)
             (> (string-length (car *argv*)) 5))
  (println "Usage: genstub FILE.stub")
  (exit 1))

(let* ((file (car *argv*))
       (base (sys-basename file))
       (filelen (string-length file))
       (baselen (string-length base))
       (prefix (substring base 0 (- baselen 5)))
       (outfile (string-append (substring file 0 (- filelen 5)) ".c")))
  (unless (file-exists? file)
    (println "Couldn't open ~a" file)
    (exit 1))
  (set! *file-prefix* (string-append (get-c-name "" prefix) "_"))
  (with-output-to-file outfile
    (lambda ()
      (println "/* Generated by genstub.  Do not edit. */")
      (println "/* source: ~a */" file)
      (println "#include <gauche.h>")
      (newline)
      (with-input-from-file file
        (lambda ()
          (let loop ((form (read)))
            (unless (eof-object? form)
              (cond ((string? form) (println form))
                    ((not (pair? form))
                     (error "bad form: ~s" form))
                    ((eq? (car form) 'define-cproc)
                     (process-define-cproc form))
                    ((eq? (car form) 'define-symbol)
                     (process-define-symbol form))
                    ((eq? (car form) 'define-type)
                     (process-define-type form))
                    ((eq? (car form) 'define-cclass)
                     (process-define-cclass form))
                    (else (error "bad form: ~s" form)))
              (loop (read))))))
      (emit-initializer (get-c-name "" prefix))
      ))
  )

;; Local variables:
;; mode: scheme
;; end:
