;;;
;;; syslib.stub - system interface functions
;;;  
;;;   Copyright (c) 2000-2006 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: syslib.stub,v 1.122 2007-01-14 09:49:15 shirok Exp $
;;;

;; System interface functions.   Mostly I followed POSIX.1, but included
;; some non-posix functions which are important for programming on Unix.

"#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <locale.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <math.h>
#ifndef __MINGW32__
#include <sys/wait.h>
#include <grp.h>
#include <pwd.h>
#else  /* __MINGW32__ */
#include <windows.h>
#endif /* __MINGW32__ */
#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif
#if HAVE_CRYPT_H
#include <crypt.h>
#endif
"

;;---------------------------------------------------------------------
;; dirent.h - read directory
;;   we don't have correspoinding functions, but provide these:

(define-cproc sys-readdir (pathname::<string>)
  (call "Scm_ReadDirectory"))

(define-cproc sys-glob (pattern::<string>)
  (call "Scm_GlobDirectory"))

;; Bonus

(define-cproc sys-normalize-pathname (pathname::<string>
                                      &keyword (absolute #f)
                                               (expand #f)
                                               (canonicalize #f))
  "  int flags = 0;
  if (!SCM_FALSEP(absolute)) flags |= SCM_PATH_ABSOLUTE;
  if (!SCM_FALSEP(expand))   flags |= SCM_PATH_EXPAND;
  if (!SCM_FALSEP(canonicalize)) flags |= SCM_PATH_CANONICALIZE;
  SCM_RETURN(Scm_NormalizePathname(pathname, flags));")

(define-cproc sys-basename (pathname::<string>)
  (call "Scm_BaseName"))

(define-cproc sys-dirname (pathname::<string>)
  (call "Scm_DirName"))

;;---------------------------------------------------------------------
;; errno.h - error numbers

;; We won't (and can't) cover every possible errnos, including system
;; specific ones.  The following list is taken from Linux asm/errno.h.

(define-enum-conditionally E2BIG)
(define-enum-conditionally EACCES)
(define-enum-conditionally EADDRINUSE)
(define-enum-conditionally EADDRNOTAVAIL)
(define-enum-conditionally EADV)
(define-enum-conditionally EAFNOSUPPORT)
(define-enum-conditionally EAGAIN)
(define-enum-conditionally EALREADY)
(define-enum-conditionally EBADE)
(define-enum-conditionally EBADF)
(define-enum-conditionally EBADFD)
(define-enum-conditionally EBADMSG)
(define-enum-conditionally EBADR)
(define-enum-conditionally EBADRQC)
(define-enum-conditionally EBADSLT)
(define-enum-conditionally EBFONT)
(define-enum-conditionally EBUSY)
(define-enum-conditionally ECANCELED)
(define-enum-conditionally ECHILD)
(define-enum-conditionally ECHRNG)
(define-enum-conditionally ECOMM)
(define-enum-conditionally ECONNABORTED)
(define-enum-conditionally ECONNREFUSED)
(define-enum-conditionally ECONNRESET)
(define-enum-conditionally EDEADLK)
(define-enum-conditionally EDEADLOCK)
(define-enum-conditionally EDESTADDRREQ)
(define-enum-conditionally EDOM)
(define-enum-conditionally EDOTDOT)
(define-enum-conditionally EDQUOT)
(define-enum-conditionally EEXIST)
(define-enum-conditionally EFAULT)
(define-enum-conditionally EFBIG)
(define-enum-conditionally EHOSTDOWN)
(define-enum-conditionally EHOSTUNREACH)
(define-enum-conditionally EIDRM)
(define-enum-conditionally EILSEQ)
(define-enum-conditionally EINPROGRESS)
(define-enum-conditionally EINTR)
(define-enum-conditionally EINVAL)
(define-enum-conditionally EIO)
(define-enum-conditionally EISCONN)
(define-enum-conditionally EISDIR)
(define-enum-conditionally EISNAM)
(define-enum-conditionally EKEYEXPIRED)
(define-enum-conditionally EKEYREJECTED)
(define-enum-conditionally EKEYREVOKED)
(define-enum-conditionally EL2HLT)
(define-enum-conditionally EL2NSYNC)
(define-enum-conditionally EL3HLT)
(define-enum-conditionally EL3RST)
(define-enum-conditionally ELIBACC)
(define-enum-conditionally ELIBBAD)
(define-enum-conditionally ELIBEXEC)
(define-enum-conditionally ELIBMAX)
(define-enum-conditionally ELIBSCN)
(define-enum-conditionally ELNRNG)
(define-enum-conditionally ELOOP)
(define-enum-conditionally EMEDIUMTYPE)
(define-enum-conditionally EMFILE)
(define-enum-conditionally EMLINK)
(define-enum-conditionally EMSGSIZE)
(define-enum-conditionally EMULTIHOP)
(define-enum-conditionally ENAMETOOLONG)
(define-enum-conditionally ENAVAIL)
(define-enum-conditionally ENETDOWN)
(define-enum-conditionally ENETRESET)
(define-enum-conditionally ENETUNREACH)
(define-enum-conditionally ENFILE)
(define-enum-conditionally ENOANO)
(define-enum-conditionally ENOBUFS)
(define-enum-conditionally ENOCSI)
(define-enum-conditionally ENODATA)
(define-enum-conditionally ENODEV)
(define-enum-conditionally ENOENT)
(define-enum-conditionally ENOEXEC)
(define-enum-conditionally ENOKEY)
(define-enum-conditionally ENOLCK)
(define-enum-conditionally ENOLINK)
(define-enum-conditionally ENOMEDIUM)
(define-enum-conditionally ENOMEM)
(define-enum-conditionally ENOMSG)
(define-enum-conditionally ENONET)
(define-enum-conditionally ENOPKG)
(define-enum-conditionally ENOPROTOOPT)
(define-enum-conditionally ENOSPC)
(define-enum-conditionally ENOSR)
(define-enum-conditionally ENOSTR)
(define-enum-conditionally ENOSYS)
(define-enum-conditionally ENOTBLK)
(define-enum-conditionally ENOTCONN)
(define-enum-conditionally ENOTDIR)
(define-enum-conditionally ENOTEMPTY)
(define-enum-conditionally ENOTNAM)
(define-enum-conditionally ENOTSOCK)
(define-enum-conditionally ENOTTY)
(define-enum-conditionally ENOTUNIQ)
(define-enum-conditionally ENXIO)
(define-enum-conditionally EOPNOTSUPP)
(define-enum-conditionally EOVERFLOW)
(define-enum-conditionally EPERM)
(define-enum-conditionally EPFNOSUPPORT)
(define-enum-conditionally EPIPE)
(define-enum-conditionally EPROTO)
(define-enum-conditionally EPROTONOSUPPORT)
(define-enum-conditionally EPROTOTYPE)
(define-enum-conditionally ERANGE)
(define-enum-conditionally EREMCHG)
(define-enum-conditionally EREMOTE)
(define-enum-conditionally EREMOTEIO)
(define-enum-conditionally ERESTART)
(define-enum-conditionally EROFS)
(define-enum-conditionally ESHUTDOWN)
(define-enum-conditionally ESOCKTNOSUPPORT)
(define-enum-conditionally ESPIPE)
(define-enum-conditionally ESRCH)
(define-enum-conditionally ESRMNT)
(define-enum-conditionally ESTALE)
(define-enum-conditionally ESTRPIPE)
(define-enum-conditionally ETIME)
(define-enum-conditionally ETIMEDOUT)
(define-enum-conditionally ETOOMANYREFS)
(define-enum-conditionally ETXTBSY)
(define-enum-conditionally EUCLEAN)
(define-enum-conditionally EUNATCH)
(define-enum-conditionally EUSERS)
(define-enum-conditionally EWOULDBLOCK)
(define-enum-conditionally EXDEV)
(define-enum-conditionally EXFULL)

;;---------------------------------------------------------------------
;; grp.h - groups

(define-type <sys-group> "ScmSysGroup*")

(define-cproc sys-getgrgid (gid::<int>)
  (call "Scm_GetGroupById"))
(define-cproc sys-getgrnam (name::<string>)
  (call "Scm_GetGroupByName"))

;; faster functions; bypassing creation of group object
(define-cproc sys-gid->group-name (gid::<int>)
  "  struct group *g = getgrgid(gid);
  if (g == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(SCM_MAKE_STR_COPYING(g->gr_name));")
(define-cproc sys-group-name->gid (name::<string>)
  "  struct group *g = getgrnam(Scm_GetStringConst(name));
  if (g == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(Scm_MakeInteger(g->gr_gid));")

;;---------------------------------------------------------------------
;; locale.h

(define-enum LC_ALL)
(define-enum LC_COLLATE)
(define-enum LC_CTYPE)
(define-enum LC_MONETARY)
(define-enum LC_NUMERIC)
(define-enum LC_TIME)

(define-cproc sys-setlocale (category::<fixnum> locale::<const-cstring>)
  (call <const-cstring>? "setlocale"))

;;---------------------------------------------------------------------
;; math.h

;;---------------------------------------------------------------------
;; pwd.h - passwords

(define-type <sys-passwd> "ScmSysPasswd*")

(define-cproc sys-getpwuid (uid::<int>)
  (call "Scm_GetPasswdById"))
(define-cproc sys-getpwnam (name::<string>)
  (call "Scm_GetPasswdByName"))

;; faster functions; bypassing creation of passwd object
(define-cproc sys-uid->user-name (uid::<int>)
  "  struct passwd *p = getpwuid(uid);
  if (p == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(SCM_MAKE_STR_COPYING(p->pw_name));")
(define-cproc sys-user-name->uid (name::<string>)
  "  struct passwd *p = getpwnam(Scm_GetStringConst(name));
  if (p == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(Scm_MakeInteger(p->pw_uid));")

;;---------------------------------------------------------------------
;; setjmp.h

;;  No equivalent functions --- use call/cc

;;---------------------------------------------------------------------
;; signal.h

(define-type <sys-sigset> "ScmSysSigset*")

(define-cproc sys-sigset-add! (set::<sys-sigset> &rest sigs)
  (expr "Scm_SysSigsetOp(set, sigs, FALSE)"))

(define-cproc sys-sigset-delete! (set::<sys-sigset> &rest sigs)
  (expr "Scm_SysSigsetOp(set, sigs, TRUE)"))

(define-cproc sys-sigset-fill! (set::<sys-sigset>)
  (expr "Scm_SysSigsetFill(set, FALSE)"))

(define-cproc sys-sigset-empty! (set::<sys-sigset>)
  (expr "Scm_SysSigsetFill(set, TRUE)"))

(define-cproc sys-signal-name (sig::<fixnum>)
  (call "Scm_SignalName"))

(define-cproc sys-kill (pid::<int> sig::<fixnum>)
  (body <void>
        "int r; SCM_SYSCALL(r, kill(pid, sig));"
        "if (r < 0) Scm_SysError(\"kill failed\");"))

(define-cproc set-signal-handler! (sig proc &optional (mask::<sys-sigset>? #f))
  (call "Scm_SetSignalHandler"))

(define-cproc get-signal-handler (sig::<fixnum>)
  (call "Scm_GetSignalHandler"))

(define-cproc get-signal-handler-mask (sig::<fixnum>)
  (call "Scm_GetSignalHandlerMask"))

(define-cproc get-signal-handlers ()
  (call "Scm_GetSignalHandlers"))

(define-cproc set-signal-pending-limit (limit::<fixnum>)
  (call <void> "Scm_SetSignalPendingLimit"))

(define-cproc get-signal-pending-limit ()
  (call <int> "Scm_GetSignalPendingLimit"))

(define-enum SIG_SETMASK)
(define-enum SIG_BLOCK)
(define-enum SIG_UNBLOCK)

(define-cproc sys-sigmask (how::<fixnum> mask::<sys-sigset>?)
  (call "Scm_SysSigmask"))

(define-cproc sys-sigsuspend (mask::<sys-sigset>)
  (call "Scm_SigSuspend"))

(if "defined HAVE_SIGWAIT"
(define-cproc sys-sigwait (mask::<sys-sigset>)
  (body <int>
        "int v;"
        ;; sigwait never returns EINTR, so we don't need SCM_SYSCALL.
        "v = sigwait(&mask->set, &SCM_RESULT);"
        "if (v != 0) {"
        "  errno = v;"
        "  Scm_SysError(\"sigwait failed\");"
        "}"))
)

;(define-cproc %with-signal-handlers (handlers thunk)
;  (assert (procedure? thunk))
;  "SCM_RETURN(Scm_VMWithSignalHandlers(handlers, thunk));")

;; raise should be handled by sys-kill

;;---------------------------------------------------------------------
;; stdio.h

(define-cproc sys-remove (filename::<const-cstring>)
  "  int r;
  SCM_SYSCALL(r, remove(filename));
  if (r < 0) Scm_SysError(\"removing %s failed\", filename);
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-rename (oldname::<const-cstring> newname::<const-cstring>)
  "  int r;
#if defined(__MINGW32__)
  /* Windows doesn't allow renaming to the existing file, so we unlink
     it first.  This breaks the atomicity of rename operation.
     We don't check and raise an error here, since the error will be
     caught by rename() call. */
  chmod(newname, 0666);
  unlink(newname);
#endif /* __MINGW32__ */
  SCM_SYSCALL(r, rename(oldname, newname));
  if (r < 0) Scm_SysError(\"renaming %s to %s failed\", oldname, newname);
  SCM_RETURN(SCM_TRUE);")

;; NB: Alghough tmpnam() is in POSIX, its use is discouraged because of
;; potential security risk.  We mimic it's behavior by mkstemp() if possible.
(define-cproc sys-tmpnam ()
  "
#ifdef HAVE_MKSTEMP
  char nam[] = \"/tmp/fileXXXXXX\";
  int fd;
  SCM_SYSCALL(fd, mkstemp(nam));
  if (fd < 0) Scm_SysError(\"mkstemp failed\");
  close(fd);
  unlink(nam);
  SCM_RETURN(SCM_MAKE_STR_COPYING(nam));
#else
  char *s = tmpnam(NULL);
  SCM_RETURN(SCM_MAKE_STR_COPYING(s));
#endif")

(define-cproc sys-mkstemp (template::<string>)
  (call "Scm_SysMkstemp"))

;; tmpfile

;;---------------------------------------------------------------------
;; stdlib.h

(define-cproc sys-exit (code::<fixnum>)
  (call <void> "_exit"))

(define-cproc sys-getenv (name::<const-cstring>)
  (call <const-cstring>? "getenv"))

;; Note: the return value of system() is not portable.
(define-cproc sys-system (command::<const-cstring>)
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, system(command));"))

(define-cproc sys-random ()
  "#if defined(HAVE_RANDOM) && defined(HAVE_SRANDOM)
  SCM_RETURN(Scm_MakeInteger(random()));
#elif defined(LRAND48) && defined(SRAND48)
  SCM_RETURN(Scm_MakeInteger(lrand48()));
#else
  /* fallback - we don't want to use rand(), for it is not very good RNG.
     replace it when we have time. */
  SCM_RETURN(Scm_MakeInteger(rand()));
#endif")

(define-cproc sys-srandom (seed)
  "  if (!SCM_EXACTP(seed)) Scm_Error(\"exact integer required: %S\", seed);
#if defined(HAVE_RANDOM) && defined(HAVE_SRANDOM)
  srandom(Scm_GetUInteger(seed));
#elif defined(LRAND48) && defined(SRAND48)
  srand48(Scm_GetUInteger(seed));
#else
  /* fallback - we don't want to use rand(), for it is not very good RNG.
     replace it when we have time. */
  srand(Scm_GetUInteger(seed));
#endif
  SCM_RETURN(SCM_UNDEFINED);")

(define-constant RAND_MAX (c "Scm_MakeIntegerFromUI(RAND_MAX)"))

;;---------------------------------------------------------------------
;; string.h

;; TODO: for thread safety, we should use strerror_r when available.
;; unfortunately there are conflicting versions of strerror_r among
;; various systems.
(define-cproc sys-strerror (errno::<int>)
  (call <const-cstring> "strerror"))

;;---------------------------------------------------------------------
;; sys/stat.h

(define-type <sys-stat> "ScmSysStat*")

(define-cproc sys-stat (path::<const-cstring>)
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int r;
  SCM_SYSCALL(r, stat(path, &s->statrec));
  if (r < 0) Scm_SysError(\"stat failed for %s\", path);
  SCM_RETURN(SCM_OBJ(s));")

(if "!defined(__MINGW32__)"
(define-cproc sys-lstat (path::<const-cstring>)
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int r;
  SCM_SYSCALL(r, lstat(path, &s->statrec));
  if (r < 0) Scm_SysError(\"lstat failed for %s\", path);
  SCM_RETURN(SCM_OBJ(s));")
)

(define-cproc sys-fstat (port-or-fd)
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int fd = Scm_GetPortFd(port_or_fd, FALSE), r;
  if (fd < 0) SCM_RETURN(SCM_FALSE);
  SCM_SYSCALL(r, fstat(fd, &s->statrec));
  if (r < 0) Scm_SysError(\"fstat failed for %d\", fd);
  SCM_RETURN(SCM_OBJ(s));")

;;---------------------------------------------------------------------
;; sys/wait.h

(if "!defined(__MINGW32__)" (begin

;; returns pid and status 
(define-cproc sys-wait ()
  (body (<int> <int>)
        "int status;  pid_t r;"
        "SCM_SYSCALL(r, wait(&status));"
        "if (r < 0) Scm_SysError(\"wait() failed\");"
        "SCM_RESULT0 = r; SCM_RESULT1 = status;"))

(define-cproc sys-waitpid (pid::<int> &keyword (nohang #f) (untraced #f))
  (body (<int> <int>)
        "  int status, options = 0;  pid_t r;"
        "if (!SCM_FALSEP(nohang))   options |= WNOHANG;"
        "if (!SCM_FALSEP(untraced)) options |= WUNTRACED;"
        "SCM_SYSCALL(r, waitpid(pid, &status, options));"
        "if (r < 0) Scm_SysError(\"waitpid() failed\");"
        "SCM_RESULT0 = r; SCM_RESULT1 = status;"))

;; status interpretation
(define-cproc sys-wait-exited? (status::<int>)
  (call <boolean> "WIFEXITED"))

(define-cproc sys-wait-exit-status (status::<int>)
  (call <int> "WEXITSTATUS"))

(define-cproc sys-wait-signaled? (status::<int>)
  (call <boolean> "WIFSIGNALED"))

(define-cproc sys-wait-termsig (status::<int>)
  (call <int> "WTERMSIG"))

(define-cproc sys-wait-stopped? (status::<int>)
  (call <boolean> "WIFSTOPPED"))

(define-cproc sys-wait-stopsig (status::<int>)
  (call <int> "WSTOPSIG"))

)) ;; !defined(__MINGW32__)

;;---------------------------------------------------------------------
;; time.h

(define-type <time> "ScmTime*")

(define-type <sys-tm> "ScmSysTm*")

(define-cproc sys-time ()
  (expr "Scm_MakeSysTime(time(NULL))"))

(define-cproc sys-gettimeofday ()
  (body (<ulong> <ulong>)
        "Scm_GetTimeOfDay(&SCM_RESULT0, &SCM_RESULT1);"))

(define-cproc current-time ()           ;SRFI-18, SRFI-19, SRFI-21
  (call "Scm_CurrentTime"))

(define-cproc time? (obj)               ;SRFI-18, SRFI-19, SRFI-21
  (call <boolean> "SCM_TIMEP"))

(define-cproc time->seconds (t::<time>) ;SRFI-18
  (call "Scm_TimeToSeconds"))

(define-cproc seconds->time (t::<real>) ;SRFI-18
  (call "Scm_RealSecondsToTime"))

(define-cproc sys-asctime (tm::<sys-tm>)
  (expr "SCM_MAKE_STR_COPYING(asctime(&SCM_SYS_TM_TM(tm)))"))

(define-cproc sys-ctime (time)
  (body <const-cstring>
        "time_t tim = Scm_GetSysTime(time);"
        "SCM_RESULT = ctime(&tim);"))

(define-cproc sys-difftime (time1 time0)
  (expr <double> "difftime(Scm_GetSysTime(time1), Scm_GetSysTime(time0))"))

(define-cproc sys-strftime (format::<const-cstring> tm::<sys-tm>)
  (body <const-cstring>
        "char tmpbuf[256];"
        "strftime(tmpbuf, sizeof(tmpbuf), format, &SCM_SYS_TM_TM(tm));"
        "SCM_RESULT = tmpbuf;"))

(define-cproc sys-gmtime (time)
  (body "time_t tim = Scm_GetSysTime(time);"
        "SCM_RESULT = Scm_MakeSysTm(gmtime(&tim));"))

(define-cproc sys-localtime (time)
  (body "time_t tim = Scm_GetSysTime(time);"
        "SCM_RESULT = Scm_MakeSysTm(localtime(&tim));"))

(define-cproc sys-mktime (tm::<sys-tm>)
  (expr "Scm_MakeSysTime(mktime(&SCM_SYS_TM_TM(tm)))"))

;;---------------------------------------------------------------------
;; unistd.h - miscellaneous functions

(define-enum R_OK)
(define-enum W_OK)
(define-enum X_OK)
(define-enum F_OK)

(define-cproc sys-access (pathname::<const-cstring> amode::<int>)
  (body <boolean>
        "int r;"
        "if (Scm_IsSugid()) {
           Scm_Error(\"cannot use sys-access in suid/sgid program.\");"
        "}"
        "SCM_SYSCALL(r, access(pathname, amode));"
        "SCM_RESULT = (r == 0);"))

(define-cproc sys-chdir (pathname::<const-cstring>)
  (body "int r; SCM_SYSCALL(r, chdir(pathname));"
        "if (r < 0) Scm_SysError(\"chdir failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-chmod (pathname::<const-cstring> mode::<int>)
  (body "int r; SCM_SYSCALL(r, chmod(pathname, mode));"
        "if (r < 0) Scm_SysError(\"chmod failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-fchmod (port-or-fd mode::<int>)
  (body "int fd = Scm_GetPortFd(port_or_fd, TRUE), r;"
        "SCM_SYSCALL(r, fchmod(fd, mode));"
        "if (r < 0) Scm_SysError(\"fchmod failed\");"
        "SCM_RESULT = SCM_TRUE;"))

;; NB: we force GC just befor fork().  It appeares necessary on some
;; platform to synchronize page dirty bit information, so that incremental
;; GC works properly.
(define-cproc sys-fork ()
  (body <int>
        "pid_t pid;"
        "GC_gcollect();"
        "SCM_SYSCALL(pid, fork());"
        "if (pid < 0) Scm_SysError(\"fork failed\");"
        "SCM_RESULT = pid;"))

;; NB: the signature of old version was (command args &optional iomap).
;; The new version is (command args &keyword iomap sigmask).
;; For transitional stage, we accept both.
(define-keyword iomap "key_iomap")
(define-keyword sigmask "key_sigmask")

"static void get_exec_args(ScmObj rest, ScmObj *iomap, ScmSysSigset **sigmask)"
"{"
"  ScmObj s_sigmask = SCM_NIL;"
"  *iomap = SCM_NIL; *sigmask = NULL;"
"  if (SCM_PAIRP(rest) && SCM_NULLP(SCM_CDR(rest))) {"
"    /* OLD SIGNATURE */"
"    *iomap = SCM_CAR(rest);"
"  } else {"
"    *iomap = Scm_GetKeyword(key_iomap, rest, SCM_NIL);"
"    s_sigmask = Scm_GetKeyword(key_sigmask, rest, SCM_FALSE);"
"    if (SCM_SYS_SIGSET_P(s_sigmask)) {"
"      *sigmask = SCM_SYS_SIGSET(s_sigmask);"
"    } else if (!SCM_FALSEP(s_sigmask)) {"
"      Scm_Error(\"<sys-sigset> or #f required, but got %S\", s_sigmask);"
"    }"
"  }"
"}"

(define-cproc sys-exec (command::<string>
                        args::<list>
                        &rest rest)
  (body <void>
        "ScmObj iomap = SCM_NIL;"
        "ScmSysSigset *sigmask = NULL;"
        "get_exec_args(rest, &iomap, &sigmask);"
        "Scm_SysExec(command, args, iomap, sigmask, 0);"))

(define-cproc sys-fork-and-exec (command::<string>
                                 args::<list>
                                 &rest rest)
  (body "ScmObj iomap = SCM_NIL;"
        "ScmSysSigset *sigmask = NULL;"
        "get_exec_args(rest, &iomap, &sigmask);"
        "SCM_RESULT = Scm_SysExec(command, args, iomap, sigmask, SCM_EXEC_WITH_FORK);"))

(define-cproc sys-getcwd ()
  (body <const-cstring>
        "#define GETCWD_PATH_MAX 1024  /* TODO: needs to be configured */"
        "char p[GETCWD_PATH_MAX];"
        "if (getcwd(p, GETCWD_PATH_MAX-1) == NULL) {"
        "  Scm_SysError(\"getcwd failed\");"
        "}"
        "SCM_RESULT = p;"))

(define-cproc sys-getegid () (call <int> "getegid"))
(define-cproc sys-getgid ()  (call <int> "getgid"))
(define-cproc sys-geteuid () (call <int> "geteuid"))
(define-cproc sys-getuid ()  (call <int> "getuid"))

(define-cproc sys-getpid ()  (call <int> "getpid"))
(define-cproc sys-getppid () (call <int> "getppid"))

(define-cproc sys-link (existing::<const-cstring> newpath::<const-cstring>)
  (body "int r; SCM_SYSCALL(r, link(existing, newpath));"
        "if (r < 0) Scm_SysError(\"link failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-pause ()
  ;; We can't simply use pause().  If a signal is delivered after the last
  ;; Scm_SigCheck and before the call of pause(), the signal will just sit
  ;; in a queue and pause() may not return.
  (call "Scm_Pause"))

(define-cproc sys-alarm (seconds::<fixnum>)
  (body <int> "SCM_SYSCALL(SCM_RESULT, alarm(seconds));"))

;; returns a list of two ports
(define-cproc sys-pipe (&keyword (name "(pipe)") (buffering #f) (buffered? #f))
  (body (<top> <top>)
        "int fds[2], r, bufmode;"
        "SCM_SYSCALL(r, pipe(fds));"
        "if (r < 0) Scm_SysError(\"pipe failed\");"
        "if (SCM_TRUEP(bufferedP)) {"
        "  bufmode = SCM_PORT_BUFFER_FULL; /* for backward compatibility */"
        "} else {"
        "  bufmode = Scm_BufferingMode(buffering, -1, SCM_PORT_BUFFER_LINE);"
        "}"
        "SCM_RESULT0 = Scm_MakePortWithFd(name, SCM_PORT_INPUT, fds[0], bufmode, TRUE);"
        "SCM_RESULT1 = Scm_MakePortWithFd(name, SCM_PORT_OUTPUT, fds[1], bufmode, TRUE);"))

;; close integer file descriptor.  should only be used for
;; low-level file descriptor handling, and you know what you're doing.
;; closing a file descriptor that is still used by Scheme port would
;; result a disaster.
(define-cproc sys-close (fd::<int>)
  (body "int r;"
        "SCM_SYSCALL(r, close(fd));"
        "if (r < 0) Scm_SysError(\"close failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-mkdir (pathname::<const-cstring> mode::<int>)
  (body "int r;"
        "#ifndef __MINGW32__"
        "SCM_SYSCALL(r, mkdir(pathname, mode));"
        "#else"
        "SCM_SYSCALL(r, mkdir(pathname));"
        "#endif /*__MINGW32__*/"
        "if (r < 0) Scm_SysError(\"mkdir failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-rmdir (pathname::<const-cstring>)
  (body "int r; SCM_SYSCALL(r, rmdir(pathname));"
        "if (r < 0) Scm_SysError(\"rmdir failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-umask (mode::<fixnum>)
  (call <int> "umask"))

(define-cproc sys-sleep (seconds::<fixnum>)
  (body <int>
        "#if defined(__MINGW32__)"
        "  Sleep(seconds*1000); SCM_RESULT=0;"
        "#else"
        "  SCM_RESULT = sleep(seconds);"
        "#endif"))

(if "defined(HAVE_NANOSLEEP)"
    (define-cproc sys-nanosleep (nanoseconds)
      "struct timespec spec, rem;
       if (SCM_TIMEP(nanoseconds)) {
           spec.tv_sec = SCM_TIME(nanoseconds)->sec;
           spec.tv_nsec = SCM_TIME(nanoseconds)->nsec;
       } else if (!SCM_REALP(nanoseconds)) {
           Scm_Error(\"bad timeout spec: <time> object or real number is required, but got %S\", nanoseconds);
       } else {
           double v = Scm_GetDouble(nanoseconds);
           if (v < 0) Scm_Error(\"bad timeout spec: positive number required, but got %S\", nanoseconds);
           spec.tv_sec = (unsigned long)floor(v/1.0e9);
           spec.tv_nsec = (unsigned long)fmod(v, 1.0e9);
           while (spec.tv_nsec >= 1000000000) {
               spec.tv_nsec -= 1000000000;
               spec.tv_sec += 1;
           }
       }
       rem.tv_sec = rem.tv_nsec = 0;
       nanosleep(&spec, &rem);
       if (rem.tv_sec == 0 && rem.tv_nsec == 0) SCM_RETURN(SCM_FALSE);
       else SCM_RETURN(Scm_MakeTime(SCM_FALSE, rem.tv_sec, rem.tv_nsec));"))

(define-cproc sys-unlink (pathname::<const-cstring>)
  (body "int r; SCM_SYSCALL(r, unlink(pathname));"
        "if (r < 0) {"
        "  if (errno == ENOENT) { SCM_RETURN(SCM_FALSE); }"
        "  else Scm_SysError(\"unlink failed\");"
        "}"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-isatty (port_or_fd)
  (body <boolean>
        "int fd = Scm_GetPortFd(port_or_fd, FALSE);"
        "SCM_RESULT = (fd >= 0 && isatty(fd));"))
  
(define-cproc sys-ttyname (port_or_fd)
  (body <const-cstring>?
        "int fd = Scm_GetPortFd(port_or_fd, FALSE);"
        "if (fd < 0) SCM_RESULT = NULL;"
        "else SCM_RESULT = ttyname(fd);"))

(define-cproc sys-truncate (path::<const-cstring> length::<integer>)
  (body "int r; SCM_SYSCALL(r, truncate(path, Scm_IntegerToOffset(length)));"
        "if (r < 0) Scm_SysError(\"truncate failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-ftruncate (port_or_fd length::<integer>)
  (body "int r; int fd = Scm_GetPortFd(port_or_fd, TRUE);"
        "SCM_SYSCALL(r, ftruncate(fd, Scm_IntegerToOffset(length)));"
        "if (r < 0) Scm_SysError(\"ftruncate failed\");"
        "SCM_RESULT = SCM_TRUE;"))

;; NB. Linux needs _XOPEN_SOURCE defined before unistd.h to get crypt()
;; prototype.  However, it screws up something else.  Just for now I
;; cast the return value of crypt() to avoid it...such a kludge...
(if "defined(HAVE_CRYPT)"
(define-cproc sys-crypt (key::<const-cstring> salt::<const-cstring>)
  (expr <const-cstring> "(const char *)crypt(key, salt)"))
)

;; not supported yet:
;;  fpathconf lseek pathconf read sysconf write

;;---------------------------------------------------------------------
;; symbolic link

(if "defined(HAVE_SYMLINK)"
(define-cproc sys-symlink (existing::<const-cstring> newpath::<const-cstring>)
  "
#ifdef HAVE_SYMLINK
  int r;
  SCM_SYSCALL(r, symlink(existing, newpath));
  if (r < 0) Scm_SysError(\"link failed\");
  SCM_RETURN(SCM_TRUE);
#else
  Scm_Error(\"the system doesn't support symbolic links\");
  SCM_RETURN(SCM_FALSE);
#endif
")
)

(if "defined(HAVE_READLINK)"
(define-cproc sys-readlink (path::<const-cstring>)
  "#define READLINK_PATH_MAX 1024  /* TODO: needs to be configured */
  char buf[READLINK_PATH_MAX];
  int n;
  SCM_SYSCALL(n, readlink(path, buf, READLINK_PATH_MAX));
  if (n < 0) Scm_SysError(\"readlink failed\");
  if (n == READLINK_PATH_MAX) Scm_Error(\"readlink result too long\");
  return Scm_MakeString(buf, n, -1, SCM_STRING_COPYING);")
)

;;---------------------------------------------------------------------
;; select

(define-type <sys-fdset> "ScmSysFdset*")

(if "defined(HAVE_SELECT)" (begin
(define-cproc sys-fdset-ref (fdset::<sys-fdset> pf)
  (body <boolean>
        "int fd = Scm_GetPortFd(pf, FALSE);"
        "if (fd < 0) SCM_RESULT = TRUE;"
        "else SCM_RESULT = FD_ISSET(fd, &fdset->fdset);")
  (setter sys-fdset-set!))
  
(define-cproc sys-fdset-set! (fdset::<sys-fdset> pf flag::<boolean>)
  "int fd = Scm_GetPortFd(pf, FALSE);
  if (fd >= 0) {
    if (flag) {
      FD_SET(fd, &fdset->fdset);
      if (fdset->maxfd < fd) fdset->maxfd = fd;
    } else {
      FD_CLR(fd, &fdset->fdset);
      if (fdset->maxfd == fd) {
        int i;
        for (i=fdset->maxfd-1; i>=0; i--) {
          if (FD_ISSET(i, &fdset->fdset)) break;
        }
        fdset->maxfd = i;
      }
    }
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc sys-fdset-max-fd (fdset::<sys-fdset>)
  (expr <int> "fdset->maxfd"))

(define-cproc sys-select (rfds wfds efds &optional (timeout #f))
  (call "Scm_SysSelect"))

(define-cproc sys-select! (rfds wfds efds &optional (timeout #f))
  (call "Scm_SysSelectX"))

)) ;; if defined(HAVE_SELECT)

;; Local variables:
;; mode: scheme
;; end:
