;;;
;;; intlib.stub - internal built-ins
;;;  
;;;   Copyright (c) 2000-2010  Shiro Kawai  <shiro@acm.org>
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  

;; This file defines subrs that are used by Gauche internal routines
;; (such as the compiler).  They are interned in gauche.internal module.
;; The API in this module is still fluid.  Do not count on them.


(declcode
 (.include <gauche/class.h>
           <gauche/code.h>
           <gauche/vminsn.h>
           <gauche/macro.h>
           <gauche/prof.h>
           <gauche/builtin-syms.h>))

(define-type <gloc> "ScmGloc*" "GLOC"
  "SCM_GLOCP" "SCM_GLOC" "SCM_OBJ")

;;
;; Pair attributes
;;
;;  Pair attributes are almost exclusively used to attach source-code
;;  information to s-exprs.

(define-cproc pair-attributes (pair::<pair>) Scm_PairAttr)

(define-cproc pair-attribute-get (pair::<pair> key :optional fallback)
  (result (Scm_PairAttrGet (SCM_PAIR pair) key fallback)))

(define-cproc pair-attribute-set! (pair::<pair> key value)
  (result (Scm_PairAttrSet (SCM_PAIR pair) key value)))

(define-cproc extended-pair? (obj) ::<boolean> SCM_EXTENDED_PAIR_P)
(define-cproc extended-cons (car cdr) Scm_ExtendedCons)
(define-cproc extended-list (elt :rest more) Scm_ExtendedCons)

;;
;; Static configuration
;;
(define-cproc cond-features () Scm_GetFeatures)

;;
;; Syntactic closure
;;

(define-cproc make-syntactic-closure (env literals expr)
  Scm_MakeSyntacticClosure)

;;
;; Identifiers
;;
;;   Identifiers shouldn't be seen by programmers except they are
;;   really aware of working with Gauche internals.  However, for
;;   historical reasons, identifiers leak out to the Scheme world
;;   in the expanded form of the macro.  Hence we leave identifer?
;;   and identifier->symbol in extlib.stub.

(define-cproc make-identifier (name::<symbol> mod::<module> env::<list>)
  Scm_MakeIdentifier)

;;
;; Symbol table
;;

;; Returns GLOC object or #f
(define-cproc find-binding (mod::<module> name::<symbol>
                            stay-in-module::<boolean>)
  ::<gloc>?
  (result (Scm_FindBinding mod name
                           (?: stay_in_module SCM_BINDING_STAY_IN_MODULE 0))))

;; This small piece of code encapsulates the common procedure in
;; pass1/variable to find whether the variable reference is a constant
;; or not.
(define-cproc find-const-binding (id::<identifier>)
  (let* ([g::ScmGloc* (Scm_FindBinding (-> id module) (-> id name) 0)])
    (cond [(or (not g)
               (not (SCM_GLOC_CONST_P g))
               (SCM_VM_COMPILER_FLAG_IS_SET (Scm_VM)
                                            SCM_COMPILE_NOINLINE_CONSTS))
           (result SCM_FALSE)]
          [else
           (result (SCM_GLOC_GET g))])))

(define-cproc %insert-binding (mod::<module> name::<symbol> value
                               :optional (flags '()))
  (let* ([z::int 0])
    (unless (SCM_FALSEP (Scm_Memq 'const flags))
      (logior= z SCM_BINDING_CONST))
    (unless (SCM_FALSEP (Scm_Memq 'inlinable flags))
      (logior= z SCM_BINDING_INLINABLE))
    (set! SCM_RESULT (SCM_OBJ (Scm_MakeBinding mod name value z)))))

(define-cproc %hide-binding (mod::<module> name::<symbol>) ::<void>
  Scm_HideBinding)

(define-cproc %alias-binding (target::<module> tname::<symbol>
                              origin::<module> oname::<symbol>) ::<boolean>
  Scm_AliasBinding)

(define-cproc %make-wrapper-module (origin::<module> prefix)
  Scm__MakeWrapperModule)

(define-cproc %export-symbols (mod::<module> names) Scm_ExportSymbols)

(define-cproc %import-module (mod::<module> imported
                                            :optional (prefix #f)
                                                      (flags::<ulong> 0))
  Scm_ImportModule)

(define-cproc %import-modules (mod::<module> mods) ;deprecated
  Scm_ImportModules)

(define-cproc gloc-bound? (gloc::<gloc>) ::<boolean>
  (result (not (SCM_UNBOUNDP (SCM_GLOC_GET gloc)))))
(define-cproc gloc-ref (gloc::<gloc> :optional fallback)
  (let* ([v::ScmObj (SCM_GLOC_GET gloc)])
    (if (SCM_UNBOUNDP v)
      (if (SCM_UNBOUNDP fallback)
        (Scm_Error "gloc %S doesn't have a value" (SCM_OBJ gloc))
        (result fallback))
      (result v))))
(define-cproc gloc-set! (gloc::<gloc> value) SCM_GLOC_SET)
(define-cproc gloc-const? (gloc::<gloc>) ::<boolean> Scm_GlocConstP)
(define-cproc gloc-inlinable? (gloc::<gloc>) ::<boolean> Scm_GlocInlinableP)

;;
;; Compiler interface
;;

;; GLOBAL-CALL-TYPE
;;
;;   This is an aux call to dispatch the function call with global variable
;;   reference in its first position (in pass1/global-call).  It checks
;;   up the binding of global identifier, and returns two values.
;;
;;   The first value is #f if this global call would be a simple call.
;;   Otherwise, the first value is a bound value of the global variable,
;;   and the second value is one of the symbols 'macro, 'syntax or 'inline.
;;
;;   We write this in C because it is in critical path of the compiler.
;;
;;   {Experimental}
;;   If RECORD_DEPENDED_MODULES is defined, this proc also records
;;   modules from which macro/syntax identifiers come.  It will be used
;;   in test-module to detect unnecessarily 'use'd modules.  For normal
;;   procedure we can scan identifier/glocs embedded in the VM code
;;   vector, but for the case of macros/syntaxes/inlined procedures
;;   the original identifier is lost during expansion, so we need to
;;   record it at compile time.
;;   Although global-call-type is in critical path, my benchmark showed
;;   little impact from this addition.
;;   I still don't feel "right" about having this hack here, though.
;;   Just keep it for now, for the record.

(if "defined(RECORD_DEPENDED_MODULES)"
  (begin
    "static ScmModule *stdmods[3];"

    (initcode
     "stdmods[0] = Scm_NullModule();"
     "stdmods[1] = Scm_SchemeModule();"
     "stdmods[2] = Scm_GaucheModule();")))

(define-cproc global-call-type (id cenv) ::(<top> <top>)
  (let* ([mod::ScmModule* (-> (SCM_IDENTIFIER id) module)]
         [gloc::ScmGloc* (Scm_FindBinding mod (-> (SCM_IDENTIFIER id) name) 0)]
         )
    (set! SCM_RESULT0 '#f SCM_RESULT1 '#f)
    (when gloc
      (let* ([gval (SCM_GLOC_GET gloc)])
        (cond [(SCM_MACROP gval)
               (set! SCM_RESULT0 gval SCM_RESULT1 'macro)]
              [(SCM_SYNTAXP gval)
               (set! SCM_RESULT0 gval SCM_RESULT1 'syntax)]
              [(and (SCM_PROCEDUREP gval)
                    (SCM_PROCEDURE_INLINER gval) ; inliner may be NULL
                    (not (SCM_FALSEP (SCM_PROCEDURE_INLINER gval)))
                    ;; Remainder: Enable the following check after 0.9.1 release.
                    ;; This check is required to suppress inadvertent
                    ;; inlining of some special constructs such as case-lambda.
                    ;; However, 0.9's runtime does not have 'inlinable' bindings,
                    ;; thus enabling this prevents some built-in procedures
                    ;; from being inlined.
                    ;;(Scm_GlocInlinableP gloc)
                    (not (SCM_VM_COMPILER_FLAG_IS_SET
                          (Scm_VM) SCM_COMPILE_NOINLINE_GLOBALS)))
               (set! SCM_RESULT0 gval SCM_RESULT1 'inline)]
              [else (goto normal)])
        (.if "defined(RECORD_DEPENDED_MODULES)"
             (begin
               (dotimes [i 3]
                 (when (SCM_EQ mod (aref stdmods i)) (goto normal)))
               (let* ([curmod (SCM_VECTOR_ELEMENT cenv 0)])
                 (SCM_ASSERT (SCM_MODULEP curmod))
                 (when (SCM_FALSEP
                        (Scm_Memq (SCM_OBJ mod)
                                  (-> (SCM_MODULE curmod) depended)))
                   (set! (-> (SCM_MODULE curmod) depended)
                         (Scm_Cons (SCM_OBJ mod)
                                   (-> (SCM_MODULE curmod) depended)))))))
        ))
    (label normal)
    ))

(define-cproc macro? (obj) ::<boolean> SCM_MACROP)

(define-cproc make-toplevel-closure (code::<compiled-code>)
  (result (Scm_MakeClosure (SCM_OBJ code) NULL)))

(define-cproc make-macro-transformer (name::<symbol> proc::<procedure>)
  Scm_MakeMacroTransformerOld)

(define-cproc compile-syntax-rules (name literals rules mod env)
  Scm_CompileSyntaxRules)

(define-type <macro> "ScmMacro*" "macro"
  "SCM_MACROP" "SCM_MACRO" "SCM_OBJ")

(define-cproc call-macro-expander (mac::<macro> expr env)
  Scm_CallMacroExpander)

(define-cproc make-syntax (name::<symbol> proc)
  Scm_MakeSyntax)

(define-cproc call-syntax-handler (syn program cenv)
  (SCM_ASSERT (SCM_SYNTAXP syn))
  (result (Scm_VMApply2 (-> (SCM_SYNTAX syn) handler) program cenv)))

(define-cproc syntax-handler (syn)
  (SCM_ASSERT (SCM_SYNTAXP syn))
  (result (-> (SCM_SYNTAX syn) handler)))

(define-cproc %internal-macro-expand (form env once::<boolean>)
  Scm_VMMacroExpand)

(define-cproc %procedure-inliner (proc::<procedure>)
  (setter (proc::<procedure> inliner) ::<void>
          (set! (-> proc inliner) inliner))
  (result (?: (-> proc inliner) (-> proc inliner) '#f)))

(define-cproc %mark-binding-inlinable! (mod::<module> name::<symbol>) ::<void>
  (let* ([g::ScmGloc* (Scm_FindBinding mod name 0)])
    (unless g
      (Scm_Error "[internal] %mark-binding-inlinable!: no such binding for %S \
                  in %S" (SCM_OBJ name) (SCM_OBJ mod)))
    (Scm_GlocMark g SCM_BINDING_INLINABLE)))

;;
;; Compiled code builder interface
;;

(define-cproc make-compiled-code-builder (reqargs::<uint16> optargs::<uint16>
                                          name parent intform)
  Scm_MakeCompiledCodeBuilder)

;; CompiledCodeEmit is performance critical.  To reduce the overhead of
;;  argument passing, we prepare variations for specific code patterns.
(define-cproc compiled-code-emit0!
  (cc::<compiled-code> code::<int>) ::<void>
  (Scm_CompiledCodeEmit cc code 0 0 '#f '#f))

(define-cproc compiled-code-emit0o!
  (cc::<compiled-code> code::<int> operand) ::<void>
  (Scm_CompiledCodeEmit cc code 0 0 operand '#f))

(define-cproc compiled-code-emit0i!
  (cc::<compiled-code> code::<int> info) ::<void>
  (Scm_CompiledCodeEmit cc code 0 0 '#f info))

(define-cproc compiled-code-emit0oi!
  (cc::<compiled-code> code::<int> operand info) ::<void>
  (Scm_CompiledCodeEmit cc code 0 0 operand info))

(define-cproc compiled-code-emit1!
  (cc::<compiled-code> code::<int> arg0::<int>) ::<void>
  (Scm_CompiledCodeEmit cc code arg0 0 '#f '#f))

(define-cproc compiled-code-emit1o!
  (cc::<compiled-code> code::<int> arg0::<int> operand) ::<void>
  (Scm_CompiledCodeEmit cc code arg0 0 operand '#f))

(define-cproc compiled-code-emit1i!
  (cc::<compiled-code> code::<int> arg0::<int> info) ::<void>
  (Scm_CompiledCodeEmit cc code arg0 0 '#f info))

(define-cproc compiled-code-emit1oi!
  (cc::<compiled-code> code::<int> arg0::<int> operand info) ::<void>
  (Scm_CompiledCodeEmit cc code arg0 0 operand info))

(define-cproc compiled-code-emit2!
  (cc::<compiled-code> code::<int> arg0::<int> arg1::<int>) ::<void>
  (Scm_CompiledCodeEmit cc code arg0 arg1 '#f '#f))

(define-cproc compiled-code-emit2o!
  (cc::<compiled-code> code::<int> arg0::<int> arg1::<int> operand) ::<void>
  (Scm_CompiledCodeEmit cc code arg0 arg1 operand '#f))

(define-cproc compiled-code-emit2i!
  (cc::<compiled-code> code::<int> arg0::<int> arg1::<int> info) ::<void>
  (Scm_CompiledCodeEmit cc code arg0 arg1 '#f info))

(define-cproc compiled-code-emit2oi!
  (cc::<compiled-code> code::<int> arg0::<int> arg1::<int> operand info)::<void>
  (Scm_CompiledCodeEmit cc code arg0 arg1 operand info))

(define-cproc compiled-code-new-label (cc::<compiled-code>)
  Scm_CompiledCodeNewLabel)

(define-cproc compiled-code-set-label! (cc::<compiled-code> label)
  ::<void> Scm_CompiledCodeSetLabel)

(define-cproc compiled-code-finish-builder (cc::<compiled-code>
                                            maxstack::<int>)
  ::<void> Scm_CompiledCodeFinishBuilder)

;; standard
(define-constant ENV_HEADER_SIZE  (c "SCM_MAKE_INT(ENV_SIZE(0))"))
(define-constant CONT_FRAME_SIZE (c "SCM_MAKE_INT(CONT_FRAME_SIZE)"))

;;
;; VM inspection and interface
;;

(define-cproc vm-dump-code (code::<compiled-code>) ::<void>
  Scm_CompiledCodeDump)
(define-cproc vm-code->list (code::<compiled-code>)
  Scm_CompiledCodeToList)
(define-cproc vm-insn-build (insn) ::<ulong>
  (result (cast u_long (Scm_VMInsnBuild insn))))
(define-cproc vm-insn-code->name (opcode::<uint>)
  (result (SCM_INTERN (Scm_VMInsnName opcode))))
(define-cproc vm-insn-name->code (insn-name) ::<int>
  Scm_VMInsnNameToCode)

;; Eval situation flag (for eval-when constrcut)
(define-cproc vm-eval-situation (:optional val) ::<int>
  (let* ([vm::ScmVM* (Scm_VM)])
    (cond [(SCM_UNBOUNDP val) (result (-> vm evalSituation))]
          [else
           (unless (SCM_INTP val) (SCM_TYPE_ERROR val "integer"))
           (let* ([prev::int (-> vm evalSituation)])
             (set! (-> vm evalSituation) (SCM_INT_VALUE val))
             (result prev))])))

(define-enum SCM_VM_EXECUTING)
(define-enum SCM_VM_LOADING)
(define-enum SCM_VM_COMPILING)

;; Compiler flags
(define-cproc vm-compiler-flag-is-set? (flag::<uint>) ::<boolean>
  (result (SCM_VM_COMPILER_FLAG_IS_SET (Scm_VM) flag)))
(define-cproc vm-compiler-flag-set! (flag::<uint>) ::<void>
  (SCM_VM_COMPILER_FLAG_SET (Scm_VM) flag))
(define-cproc vm-compiler-flag-clear! (flag::<uint>) ::<void>
  (SCM_VM_COMPILER_FLAG_CLEAR (Scm_VM) flag))

(define-cproc vm-compiler-flag-noinline-locals? () ::<boolean>
  (result (SCM_VM_COMPILER_FLAG_IS_SET (Scm_VM) SCM_COMPILE_NOINLINE_LOCALS)))
(define-cproc vm-compiler-flag-no-pass2-post? () ::<boolean>
  (result (SCM_VM_COMPILER_FLAG_IS_SET (Scm_VM) SCM_COMPILE_NO_PASS2POST)))

(define-enum SCM_COMPILE_NOINLINE_GLOBALS)
(define-enum SCM_COMPILE_NOINLINE_LOCALS)
(define-enum SCM_COMPILE_NOINLINE_CONSTS)
(define-enum SCM_COMPILE_NOSOURCE)
(define-enum SCM_COMPILE_SHOWRESULT)
(define-enum SCM_COMPILE_NOCOMBINE)
(define-enum SCM_COMPILE_NO_PASS2POST)

;; Set/get VM's current module info. (temporary)
(define-cproc vm-current-module () (result (SCM_OBJ (-> (Scm_VM) module))))
(define-cproc vm-set-current-module (mod::<module>) ::<void>
  (set! (-> (Scm_VM) module) mod))

;; for partial continuation
(define-cproc %call/pc (proc) (result (Scm_VMCallPC proc)))

(define-cproc gc-print-static-roots () ::<void> Scm_PrintStaticRoots)

;;
;; Profiler internal API
;;
(define-cproc profiler-raw-result () Scm_ProfilerRawResult)

;;
;; Compiler internal procedures
;;
;; These procedures are originally implemented in Scheme, but moved
;; here for efficiency.
;; Some procedures depend on the structure defined in compile.scm,
;; and need to be adjusted if the structure is changed.
;; In future, precomp should be extended so that these routines can
;; be written in compile.scm as "inlined C" code.

;; %imax - max for unsigned integer only, unsafe.
(define-cproc %imax (x y)
  (if (> (SCM_WORD x) (SCM_WORD y)) (result x) (result y)))

;; (%map1c proc lis c) = (map (cut proc <> c) lis)
(define-cfn map1c_cc (result data::void**) :static
  (let* ([proc (SCM_OBJ (aref data 0))]
         [r    (SCM_OBJ (aref data 1))]
         [lis  (SCM_OBJ (aref data 2))]
         [c    (SCM_OBJ (aref data 3))])
    (cond [(SCM_NULLP lis) (return (Scm_ReverseX (Scm_Cons result r)))]
          [else
           (set! (aref data 1) (Scm_Cons result r)
                 (aref data 2) (SCM_CDR lis))
           (Scm_VMPushCC map1c_cc data 4)
           (return (Scm_VMApply2 proc (SCM_CAR lis) c))])))

(define-cproc %map1c (proc lis c)
  (let* ([data::(.array void* [4])])
    (cond [(SCM_NULLP lis) (result SCM_NIL)]
          [else
           (set! (aref data 0) proc
                 (aref data 1) SCM_NIL
                 (aref data 2) (SCM_CDR lis)
                 (aref data 3) c)
           (Scm_VMPushCC map1c_cc data 4)
           (result (Scm_VMApply2 proc (SCM_CAR lis) c))])))

;; (%map1cc proc lis c1 c2) = (map (cut proc <> c1 c2) lis)
(define-cfn map1cc-cc (result (data :: void**)) :static
  (let* ([proc (SCM_OBJ (aref data 0))]
         [r    (SCM_OBJ (aref data 1))]
         [lis  (SCM_OBJ (aref data 2))]
         [c1   (SCM_OBJ (aref data 3))]
         [c2   (SCM_OBJ (aref data 4))])
    (cond [(SCM_NULLP lis) (return (Scm_ReverseX (Scm_Cons result r)))]
          [else
           (set! (aref data 1) (Scm_Cons result r)
                 (aref data 2) (SCM_CDR lis))
           (Scm_VMPushCC map1cc-cc data 5)
           (return (Scm_VMApply3 proc (SCM_CAR lis) c1 c2))])))

(define-cproc %map1cc (proc lis c1 c2)
  (if (SCM_NULLP lis)
    (result SCM_NIL)
    (let* ([data::(.array void* [5])])
      (set! (aref data 0) proc
            (aref data 1) SCM_NIL
            (aref data 2) (SCM_CDR lis)
            (aref data 3) c1
            (aref data 4) c2)
      (Scm_VMPushCC map1cc-cc data 5)
      (result (Scm_VMApply3 proc (SCM_CAR lis) c1 c2)))))

;; (%map-cons lis1 lis2) = (map cons lis1 lis2)
(define-cproc %map-cons (lis1 lis2)
  (let* ([h SCM_NIL] [t SCM_NIL])
    (while (and (SCM_PAIRP lis1) (SCM_PAIRP lis2))
      (SCM_APPEND1 h t (Scm_Cons (SCM_CAR lis1) (SCM_CAR lis2)))
      (set! lis1 (SCM_CDR lis1) lis2 (SCM_CDR lis2)))
    (result h)))

;;
;; Tester procedures
;;   These are not meant to be used in the actual Scheme code.  They're
;;   here to test particular C APIs which wouldn't be called from normal
;;   Scheme programs.

(define-cproc %apply-rec0 (p)            Scm_ApplyRec0)
(define-cproc %apply-rec1 (p a)          Scm_ApplyRec1)
(define-cproc %apply-rec2 (p a b)        Scm_ApplyRec2)
(define-cproc %apply-rec3 (p a b c)      Scm_ApplyRec3)
(define-cproc %apply-rec4 (p a b c d)    Scm_ApplyRec4)
(define-cproc %apply-rec  (p :rest args) Scm_ApplyRec)

;; To add autocurrying flag
(define-cproc %procedure-currying-set! (p::<procedure> f::<boolean>) ::<void>
  (set! (SCM_PROCEDURE_CURRYING p) f))

;; Support procedure for case-lambda
;; Dispatch-vector maps # of required arguments to the procedure body.
;; The last entry of dispatch vector is to cover more arguments; it should
;; be #f if no cases take arbitrary number of arguments.
;; Examples:
;;  (case-lambda [() a] [(x) (b)] [(x y) c] [(x y . z) d])
;;  =>
;;  #( (lambda () a)              min-reqargs == 0
;;     (lambda (x) b)
;;     (lambda (x y) c)
;;     (lambda (x y . z) d) )
;;
;;  (case-lambda [() a] [(x) (b)] [(x y) c])
;;  =>
;;  #( (lambda () a)              min-reqargs == 0
;;     (lambda (x) b)
;;     (lambda (x y) c)
;;     #f )
;;
;;  (case-lambda [(x y) a] [(x y z) b] [(x y z . w) c]
;;  =>
;;  #( (lambda (x y) a)           min-reqargs == 2
;;     (lambda (x y z) b)
;;     (lambda (x y z . w) c))
;;
;;  (case-lambda [(x y) a] [(x . y) b]
;;  =>
;;  #( (lambda (x . y) c)         min-reqargs == 1
;;     (lambda (x y) a)  
;;     (lambda (x . y) c))
;;
;; In the last example, 2 argument case matches the first procedure
;; first, so 

"typedef struct case_lambda_packet_rec {
    ScmVector *dispatch_vector;
    int max_optargs;
    int min_reqargs;
 } case_lambda_packet;"

(define-cfn case-lambda-dispatch (args::ScmObj* nargs::int data::void*):static
  (let* ([d::case_lambda_packet* (cast case_lambda_packet* data)]
         [rarg (aref args (- nargs 1))])
    (SCM_ASSERT (> nargs (-> d min_reqargs)))
    (SCM_ASSERT (<= nargs (+ (-> d min_reqargs) (-> d max_optargs) 1)))
    ;; NB: Since this is variable-arg subr, rarg is always a list.
    ;; If nargs <= d->max_optargs + d->min_reqargs, rargs should always
    ;; be '().  See vmcall.c for how the arguments are folded.
    (let* ([p (SCM_VECTOR_ELEMENT (-> d dispatch_vector)
                                  (- nargs (-> d min_reqargs) 1))])
      (when (SCM_FALSEP p)
        (Scm_Error "wrong number of arguments to case lambda: %S"
                   (Scm_ArrayToListWithTail args (- nargs 1)
                                            (aref args (- nargs 1)))))
      (if (SCM_NULLP rarg)
        (case (- nargs 1)
          [(0) (return (Scm_VMApply0 p))]
          [(1) (return (Scm_VMApply1 p (aref args 0)))]
          [(2) (return (Scm_VMApply2 p (aref args 0) (aref args 1)))]
          [(3) (return (Scm_VMApply3 p (aref args 0) (aref args 1)
                                     (aref args 2)))]
          [(4) (return (Scm_VMApply4 p (aref args 0) (aref args 1)
                                     (aref args 2) (aref args 3)))]
          [else (return (Scm_VMApply p (Scm_ArrayToList args (- nargs 1))))])
        (return
         (Scm_VMApply p (Scm_ArrayToListWithTail args (- nargs 1) rarg))))
      )))

;; NB: We keep dispatch-vector in the procedure info, so that disasm
;; and other inspection routines can find it.  The structure of
;; the procedure info here is tentative; it may be changed later.
;; Routines that depends on this info must be aware of that.
(define-cproc make-case-lambda-dispatcher (dispatch-vector::<vector>
                                           min-reqargs::<int>)
  (let* ([max-optargs::int (SCM_VECTOR_SIZE dispatch-vector)]
         [packet::case_lambda_packet* (SCM_NEW case_lambda_packet)])
    (set! (-> packet min_reqargs) min-reqargs
          (-> packet max_optargs) max-optargs
          (-> packet dispatch_vector) dispatch-vector)
    (result (Scm_MakeSubr case_lambda_dispatch packet
                          min_reqargs max_optargs
                          (SCM_LIST3 'case-lambda-dispatcher
                                     (SCM_MAKE_INT min-reqargs)
                                     (SCM_OBJ dispatch-vector))))))

;; Local variables:
;; mode: scheme
;; end:
