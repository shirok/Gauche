;;;
;;; intlib.stub - internal built-ins
;;;  
;;;   Copyright (c) 2000-2007  Shiro Kawai  <shiro@acm.org>
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: intlib.stub,v 1.28 2007-08-16 11:29:50 shirok Exp $
;;;

;; This file defines subrs that are used by Gauche internal routines
;; (such as the compiler).  They are interned in gauche.internal module.
;; The API in this module is still fluid.  Do not count on them.


"
#include <gauche/class.h>
#include <gauche/code.h>
#include <gauche/vminsn.h>
#include <gauche/macro.h>
#include <gauche/prof.h>
#include <gauche/builtin-syms.h>
#include <gauche/memory.h> /* for GC_print_static_roots */
"

(define-type <gloc> "ScmGloc*" "GLOC"
  "SCM_GLOCP" "SCM_GLOC" "SCM_OBJ")

;;
;; Pair attributes
;;
;;  Pair attributes are almost exclusively used to attach source-code
;;  information to s-exprs.

(define-cproc pair-attributes (pair::<pair>)
  (call "Scm_PairAttr"))

(define-cproc pair-attribute-get (pair::<pair> key &optional fallback)
  (expr (Scm_PairAttrGet (SCM_PAIR pair) key fallback)))

(define-cproc pair-attribute-set! (pair::<pair> key value)
  (expr (Scm_PairAttrSet (SCM_PAIR pair) key value)))

(define-cproc extended-pair? (obj)
  (call <boolean> "SCM_EXTENDED_PAIR_P"))

(define-cproc extended-cons (car cdr)
  (call "Scm_ExtendedCons"))

(define-cproc extended-list (elt &rest more)
  (call "Scm_ExtendedCons"))

;;
;; Static configuration
;;
(define-cproc cond-features ()
  (call "Scm_GetFeatures"))

;;
;; Syntactic closure
;;

(define-cproc make-syntactic-closure (env literals expr)
  (call "Scm_MakeSyntacticClosure"))

;;
;; Identifiers
;;
;;   Identifiers shouldn't be seen by programmers except they are
;;   really aware of working with Gauche internals.  However, for
;;   historical reasons, identifiers leak out to the Scheme world
;;   in the expanded form of the macro.  Hence we leave identifer?
;;   and identifier->symbol in extlib.stub.

(define-cproc make-identifier (name::<symbol> mod::<module> env::<list>)
  (call "Scm_MakeIdentifier"))

;;
;; Symbol table
;;

;; Returns GLOC object or #f
(define-cproc find-binding (mod::<module> name::<symbol>
                            stay-in-module::<boolean>)
  (expr <gloc>?
        (Scm_FindBinding mod name
                         (?: stay_in_module SCM_BINDING_STAY_IN_MODULE 0))))

;; This small piece of code encapsulates the common procedure in
;; pass1/variable to find whether the variable reference is a constant
;; or not.
(define-cproc find-const-binding (id::<identifier>)
  (body <top>
        (let* ((g :: ScmGloc* (Scm_FindBinding (-> id module) (-> id name) 0)))
          (cond ((or (not g)
                     (not (SCM_GLOC_CONST_P g))
                     (SCM_VM_COMPILER_FLAG_IS_SET (Scm_VM) SCM_COMPILE_NOINLINE_CONSTS))
                 (result SCM_FALSE))
                (else
                 (result (SCM_GLOC_GET g)))))))

(define-cproc %insert-binding (mod::<module> name::<symbol> value)
  (call "Scm_Define"))

(define-cproc %export-symbols (mod::<module> names)
  (call "Scm_ExportSymbols"))

(define-cproc %import-modules (mod::<module> mods)
  (call "Scm_ImportModules"))

(define-cproc gloc-ref (gloc::<gloc>)
  (call "SCM_GLOC_GET"))

(define-cproc gloc-set! (gloc::<gloc> value)
  (call "SCM_GLOC_SET"))

(define-cproc gloc-const? (gloc::<gloc>)
  (call <boolean> "SCM_GLOC_CONST_P"))

;;
;; Compiler interface
;;

;; GLOBAL-CALL-TYPE
;;
;;   This is an aux call to dispatch the function call with global variable
;;   reference in its first position (in pass1/global-call).  It checks
;;   up the binding of global identifier, and returns two values.
;;
;;   The first value is #f if this global call would be a simple call.
;;   Otherwise, the first value is a bound value of the global variable,
;;   and the second value is one of the symbols 'macro, 'syntax or 'inline.
;;
;;   We write this in C because it is in critical path of the compiler.
;;
;;   {Experimental}
;;   If RECORD_DEPENDED_MODULES is defined, this proc also records
;;   modules from which macro/syntax identifiers come.  It will be used
;;   in test-module to detect unnecessarily 'use'd modules.  For normal
;;   procedure we can scan identifier/glocs embedded in the VM code
;;   vector, but for the case of macros/syntaxes/inlined procedures
;;   the original identifier is lost during expansion, so we need to
;;   record it at compile time.
;;   Although global-call-type is in critical path, my benchmark showed
;;   little impact from this addition.
;;   I still don't feel "right" about having this hack here, though.
;;   Just keep it for now, for the record.

(if "defined(RECORD_DEPENDED_MODULES)"
  (begin
    "static ScmModule *stdmods[3];"

    (initcode
     "stdmods[0] = Scm_NullModule();"
     "stdmods[1] = Scm_SchemeModule();"
     "stdmods[2] = Scm_GaucheModule();")))

(define-cproc global-call-type (id cenv)
  (body
   (<top> <top>)
   "ScmModule *mod = SCM_IDENTIFIER(id)->module;"
   "ScmGloc *gloc = Scm_FindBinding(mod, SCM_IDENTIFIER(id)->name, 0);"
   "ScmObj gval;"
   "SCM_RESULT0 = SCM_RESULT1 = SCM_FALSE;"
   "if (gloc) {"
   "  gval = SCM_GLOC_GET(gloc);"
   "  if (SCM_MACROP(gval)) {"
   "    SCM_RESULT0 = gval; SCM_RESULT1 = SCM_SYM_MACRO;"
   "  } else if (SCM_SYNTAXP(gval)) {"
   "    SCM_RESULT0 = gval; SCM_RESULT1 = SCM_SYM_SYNTAX;"
   "  } else if (SCM_PROCEDUREP(gval)"
   "             && SCM_PROCEDURE_INLINER(gval)"
   "             && !SCM_FALSEP(SCM_PROCEDURE_INLINER(gval))"
   "             && !SCM_VM_COMPILER_FLAG_IS_SET(Scm_VM(), "
   "                                             SCM_COMPILE_NOINLINE_GLOBALS)) {"
   "    SCM_RESULT0 = gval; SCM_RESULT1 = SCM_SYM_INLINE;"
   "  } else {"
   "    goto normal;"
   "  }"
   "#if defined(RECORD_DEPENDED_MODULES)"
   "  for (i=0; i<3; i++) {"
   "    if (SCM_EQ(mod, stdmods[i])) goto normal;"
   "  }"
   "  curmod = SCM_VECTOR_ELEMENT(cenv, 0);"
   "  SCM_ASSERT(SCM_MODULEP(curmod));"
   "  if (SCM_FALSEP(Scm_Memq(SCM_OBJ(mod), SCM_MODULE(curmod)->depended))) {"
   "     SCM_MODULE(curmod)->depended = Scm_Cons(SCM_OBJ(mod), SCM_MODULE(curmod)->depended);"
   "  }"
   "#endif /*RECORD_DEPENDED_MODULES*/"
   "}"
   "normal:;"))

(define-cproc macro? (obj)
  (call <boolean> "SCM_MACROP"))

(define-cproc make-toplevel-closure (code::<compiled-code>)
  (expr "Scm_MakeClosure(SCM_OBJ(code), NULL)"))

(define-cproc make-macro-transformer (name::<symbol> proc::<procedure>)
  (call "Scm_MakeMacroTransformerOld"))

(define-cproc compile-syntax-rules (name literals rules mod env)
  (call "Scm_CompileSyntaxRules"))

(define-type <macro> "ScmMacro*" "macro"
  "SCM_MACROP" "SCM_MACRO" "SCM_OBJ")

(define-cproc call-macro-expander (mac::<macro> expr env)
  (call "Scm_CallMacroExpander"))

(define-cproc make-syntax (name::<symbol> proc)
  (call "Scm_MakeSyntax"))

(define-cproc call-syntax-handler (syn program cenv)
  (code "SCM_ASSERT(SCM_SYNTAXP(syn));")
  (expr "Scm_VMApply2(SCM_SYNTAX(syn)->handler, program, cenv)"))

(define-cproc syntax-handler (syn)
  (body "SCM_ASSERT(SCM_SYNTAXP(syn));"
        "SCM_RESULT = SCM_SYNTAX(syn)->handler;"))

(define-cproc %internal-macro-expand (form env once::<boolean>)
  (call "Scm_VMMacroExpand"))

(define-cproc %procedure-inliner (proc::<procedure>)
  (setter (proc::<procedure> inliner)
          (body <void> "proc->inliner = inliner;"))
  (body "if (proc->inliner) SCM_RESULT = proc->inliner;"
        "else               SCM_RESULT = SCM_FALSE;"))

;;
;; Compiled code builder interface
;;

(define-cproc make-compiled-code-builder (reqargs::<uint16> optargs::<uint16>
                                          name parent intform)
  (call "Scm_MakeCompiledCodeBuilder"))

;; CompiledCodeEmit is performance critical.  To reduce the overhead of
;;  argument passing, we prepare variations for specific code patterns.
(define-cproc compiled-code-emit0! (cc::<compiled-code>
                                    code::<int>)
  (body <void> "Scm_CompiledCodeEmit(cc, code, 0, 0, SCM_FALSE, SCM_FALSE);"))

(define-cproc compiled-code-emit0o! (cc::<compiled-code>
                                     code::<int> operand)
  (body <void> "Scm_CompiledCodeEmit(cc, code, 0, 0, operand, SCM_FALSE);"))

(define-cproc compiled-code-emit0i! (cc::<compiled-code>
                                     code::<int> info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, 0, 0, SCM_FALSE, info);"))

(define-cproc compiled-code-emit0oi! (cc::<compiled-code>
                                      code::<int> operand info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, 0, 0, operand, info);"))

(define-cproc compiled-code-emit1! (cc::<compiled-code>
                                    code::<int> arg0::<int>)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, 0, SCM_FALSE, SCM_FALSE);"))

(define-cproc compiled-code-emit1o! (cc::<compiled-code>
                                     code::<int> arg0::<int> operand)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, 0, operand, SCM_FALSE);"))

(define-cproc compiled-code-emit1i! (cc::<compiled-code>
                                     code::<int> arg0::<int> info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, 0, SCM_FALSE, info);"))

(define-cproc compiled-code-emit1oi! (cc::<compiled-code>
                                      code::<int> arg0::<int> operand info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, 0, operand, info);"))

(define-cproc compiled-code-emit2! (cc::<compiled-code>
                                    code::<int> arg0::<int> arg1::<int>)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, arg1, SCM_FALSE, SCM_FALSE);"))

(define-cproc compiled-code-emit2o! (cc::<compiled-code>
                                     code::<int> arg0::<int> arg1::<int>
                                     operand)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, arg1, operand, SCM_FALSE);"))

(define-cproc compiled-code-emit2i! (cc::<compiled-code>
                                     code::<int> arg0::<int> arg1::<int>
                                     info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, arg1, SCM_FALSE, info);"))

(define-cproc compiled-code-emit2oi! (cc::<compiled-code>
                                      code::<int> arg0::<int> arg1::<int>
                                      operand info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, arg1, operand, info);"))


(define-cproc compiled-code-new-label (cc::<compiled-code>)
  (call "Scm_CompiledCodeNewLabel"))

(define-cproc compiled-code-set-label! (cc::<compiled-code> label)
  (call <void> "Scm_CompiledCodeSetLabel"))

(define-cproc compiled-code-finish-builder (cc::<compiled-code>
                                            maxstack::<int>)
  (call <void> "Scm_CompiledCodeFinishBuilder"))

;; standard
(define-constant ENV_HEADER_SIZE  (c "SCM_MAKE_INT(ENV_SIZE(0))"))
(define-constant CONT_FRAME_SIZE (c "SCM_MAKE_INT(CONT_FRAME_SIZE)"))

;;
;; VM inspection and interface
;;

(define-cproc vm-dump-code (code::<compiled-code>)
  (call <void> "Scm_CompiledCodeDump"))
(define-cproc vm-code->list (code::<compiled-code>)
  (call "Scm_CompiledCodeToList"))
(define-cproc vm-insn-build (insn)
  (call <ulong> "Scm_VMInsnBuild"))

;; Eval situation flag (for eval-when constrcut)
(define-cproc vm-eval-situation (&optional val)
  (body <int>
        "int prev;"
        "ScmVM *vm = Scm_VM();"
        "if (SCM_UNBOUNDP(val)) {"
        "  SCM_RESULT = vm->evalSituation;"
        "} else {"
        "  if (!SCM_INTP(val)) Scm_Error(\"integer required, but got %S\", val);"
        "  prev = vm->evalSituation;"
        "  vm->evalSituation = SCM_INT_VALUE(val);"
        "  SCM_RESULT = prev;"
        "}"))

(define-enum SCM_VM_EXECUTING)
(define-enum SCM_VM_LOADING)
(define-enum SCM_VM_COMPILING)

;; Compiler flags
(define-cproc vm-compiler-flag-is-set? (flag::<uint>)
  (expr <boolean>
        "SCM_VM_COMPILER_FLAG_IS_SET(Scm_VM(), flag)"))
(define-cproc vm-compiler-flag-set! (flag::<uint>)
  (body <void>
        "SCM_VM_COMPILER_FLAG_SET(Scm_VM(), flag);"))
(define-cproc vm-compiler-flag-clear! (flag::<uint>)
  (body <void>
        "SCM_VM_COMPILER_FLAG_CLEAR(Scm_VM(), flag);"))

(define-cproc vm-compiler-flag-noinline-locals? ()
  (expr <boolean>
        "SCM_VM_COMPILER_FLAG_IS_SET(Scm_VM(), SCM_COMPILE_NOINLINE_LOCALS)"))

(define-enum SCM_COMPILE_NOINLINE_GLOBALS)
(define-enum SCM_COMPILE_NOINLINE_LOCALS)
(define-enum SCM_COMPILE_NOINLINE_CONSTS)
(define-enum SCM_COMPILE_NOSOURCE)
(define-enum SCM_COMPILE_SHOWRESULT)
(define-enum SCM_COMPILE_NOCOMBINE)

;; Set/get VM's current module info. (temporary)
(define-cproc vm-current-module ()
  (expr "SCM_OBJ(Scm_VM()->module)"))
(define-cproc vm-set-current-module (mod::<module>)
  (body <void>
        "Scm_VM()->module = mod;"))

(define-cproc gc-print-static-roots ()
  (call <void> "GC_print_static_roots"))

;;
;; Profiler internal API
;;
(define-cproc profiler-raw-result () (call "Scm_ProfilerRawResult"))

;;
;; Compiler internal procedures
;;
;; These procedures are originally implemented in Scheme, but moved
;; here for efficiency.
;; Some procedures depend on the structure defined in compile.scm,
;; and need to be adjusted if the structure is changed.
;; In future, gencomp should be extended so that these routines can
;; be written in compile.scm as "inlined C" code.

;; Lookup variable reference in the compiler environment in Pass 1.
;; This depends on the Cenv structure.
;;
;;   cenv-lookup :: Cenv, Name, LookupAs -> Var
;;        where Var = Lvar | Identifier | Macro
;;
;;   LookupAs ::
;;      LEXICAL(0) - lookup only lexical bindings
;;    | SYNTAX(1)  - lookup lexical and syntactic bindings
;;    | PATTERN(2) - lookup lexical, syntactic and pattern bindings
;;
;;   PERFORMANCE KLUDGE:
;;     - We assume the frame structure is well-formed, so skip some tests.
;;     - We assume 'lookupAs' and the car of each frame are small non-negative
;;       integers, so we directly compare them without unboxing them.
;;
(define-cproc cenv-lookup (cenv name lookup-as)
  " ScmObj frames, fp, vp;
    int name_identifier = SCM_IDENTIFIERP(name);
    SCM_ASSERT(SCM_VECTORP(cenv));
    frames = SCM_VECTOR_ELEMENT(cenv, 1);
    SCM_FOR_EACH(fp, frames) {
        if (name_identifier && SCM_IDENTIFIER(name)->env == fp) {
            /* strip identifier if we're in the same env (kludge). */
            name = SCM_OBJ(SCM_IDENTIFIER(name)->name);
        }
        if (SCM_CAAR(fp) > lookup_as) continue; /* see PERFORMANCE KLUDGE above */
        /* We inline assq here to squeeze performance. */
        SCM_FOR_EACH(vp, SCM_CDAR(fp)) {
            if (SCM_EQ(name, SCM_CAAR(vp))) return SCM_CDAR(vp);
        }
    }
    if (SCM_SYMBOLP(name)) {
        ScmObj mod = SCM_VECTOR_ELEMENT(cenv, 0);
        SCM_ASSERT(SCM_MODULEP(mod));
        return Scm_MakeIdentifier(SCM_SYMBOL(name), SCM_MODULE(mod), SCM_NIL);
    } else {
        SCM_ASSERT(SCM_IDENTIFIERP(name));
        return name;
    }
  ")

;; Check if Cenv is toplevel or not.  Depends on the structure of Cenv.
;;
;; (define (cenv-toplevel? cenv)
;;   (not (any (lambda (frame) (eqv? (car frame) LEXICAL))
;;             (cenv-frames cenv))))
;;
(define-cproc cenv-toplevel? (cenv)
  "ScmObj fp;
  SCM_ASSERT(SCM_VECTORP(cenv));
  SCM_FOR_EACH(fp, SCM_VECTOR_ELEMENT(cenv, 1)) {
    if (SCM_CAAR(fp) == SCM_MAKE_INT(0)) return SCM_FALSE;
  }
  return SCM_TRUE;")

;; Lookup local variable from the runtime envirnoment Renv.
;; Called in Pass3.
;;
;;   renv-lookup : [[Lvar]], Lvar -> Int, Int
;;
;; Returns depth and offset of local variable frame.
;;  Note that this routine is agnostic about the structure of Lvar.

(define-cproc renv-lookup (renv lvar)
  " ScmObj fp, lp;
    int depth = 0;
    SCM_FOR_EACH(fp, renv) {
        int count = 1;
        SCM_FOR_EACH(lp, SCM_CAR(fp)) {
            if (SCM_EQ(SCM_CAR(lp), lvar)) {
                return Scm_Values2(SCM_MAKE_INT(depth),
                                   SCM_MAKE_INT(Scm_Length(SCM_CAR(fp))-count));
            }
            count++;
        }
        depth++;
    }
    Scm_Error(\"[internal error] stray local variable:\", lvar);
    SCM_RETURN(SCM_UNDEFINED); /* dummy */
  ")

;; Specialized routines handling Lvar structure.
(define-symbol lvar "sym_lvar")

"#define LVAR_OFFSET_TAG        0
#define LVAR_OFFSET_NAME        1
#define LVAR_OFFSET_INITVAL     2
#define LVAR_OFFSET_REF_COUNT   3
#define LVAR_OFFSET_SET_COUNT   4
#define LVAR_SIZE               5
"

;; Specialized routine for (map (lambda (name) (make-lvar name)) objs)
(define-cproc %map-make-lvar (names)
  "ScmObj h = SCM_NIL, t = SCM_NIL;
   SCM_FOR_EACH(names, names) {
     ScmObj v = Scm_MakeVector(LVAR_SIZE, SCM_MAKE_INT(0));
     SCM_VECTOR_ELEMENT(v, LVAR_OFFSET_TAG) = sym_lvar;
     SCM_VECTOR_ELEMENT(v, LVAR_OFFSET_NAME) = SCM_CAR(names);
     SCM_VECTOR_ELEMENT(v, LVAR_OFFSET_INITVAL) = SCM_UNDEFINED;
     SCM_APPEND1(h, t, v);
   }
   SCM_RETURN(h);")

(define-cproc lvar-ref++! (lvar)
  "int i;
  SCM_ASSERT(SCM_VECTORP(lvar));
  i = SCM_INT_VALUE(SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_REF_COUNT));
  SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_REF_COUNT) = SCM_MAKE_INT(i+1);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc lvar-ref--! (lvar)
  "int i;
  SCM_ASSERT(SCM_VECTORP(lvar));
  i = SCM_INT_VALUE(SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_REF_COUNT));
  SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_REF_COUNT) = SCM_MAKE_INT(i-1);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc lvar-set++! (lvar)
  "int i;
  SCM_ASSERT(SCM_VECTORP(lvar));
  i = SCM_INT_VALUE(SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_SET_COUNT));
  SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_SET_COUNT) = SCM_MAKE_INT(i+1);
  SCM_RETURN(SCM_UNDEFINED);")

;; %imax - max for unsigned integer only, unsafe.
(define-cproc %imax (x y)
  "if (SCM_WORD(x) > SCM_WORD(y)) SCM_RETURN(x);
   else SCM_RETURN(y);")

;; (%map1c proc lis c) = (map (cut proc <> c) lis)
"static ScmObj map1c_cc(ScmObj result, void *data[])
 {
   ScmObj proc = SCM_OBJ(data[0]);
   ScmObj r = SCM_OBJ(data[1]);
   ScmObj lis = SCM_OBJ(data[2]);
   ScmObj c = SCM_OBJ(data[3]);
   if (SCM_NULLP(lis)) {
     SCM_RETURN(Scm_ReverseX(Scm_Cons(result, r)));
   } else {
     data[1] = Scm_Cons(result, r);
     data[2] = SCM_CDR(lis);
     Scm_VMPushCC(map1c_cc, data, 4);
     SCM_RETURN(Scm_VMApply2(proc, SCM_CAR(lis), c));
   }
 }"

(define-cproc %map1c (proc lis c)
  (body
   "void *data[4];"
   "if (SCM_NULLP(lis)) { SCM_RESULT = SCM_NIL; }"
   "else { "
   "  data[0] = proc;"
   "  data[1] = SCM_NIL;"
   "  data[2] = SCM_CDR(lis);"
   "  data[3] = c;"
   "  Scm_VMPushCC(map1c_cc, data, 4);"
   "  SCM_RETURN(Scm_VMApply2(proc, SCM_CAR(lis), c));"
   "}"))

;; (%map1cc proc lis c1 c2) = (map (cut proc <> c1 c2) lis)
"static ScmObj map1cc_cc(ScmObj result, void *data[])
 {
   ScmObj proc = SCM_OBJ(data[0]);
   ScmObj r = SCM_OBJ(data[1]);
   ScmObj lis = SCM_OBJ(data[2]);
   ScmObj c1 = SCM_OBJ(data[3]);
   ScmObj c2 = SCM_OBJ(data[4]);
   if (SCM_NULLP(lis)) {
     SCM_RETURN(Scm_ReverseX(Scm_Cons(result, r)));
   } else {
     data[1] = Scm_Cons(result, r);
     data[2] = SCM_CDR(lis);
     Scm_VMPushCC(map1cc_cc, data, 5);
     SCM_RETURN(Scm_VMApply3(proc, SCM_CAR(lis), c1, c2));
   }
 }"

(define-cproc %map1cc (proc lis c1 c2)
  "void *data[5];
  if (SCM_NULLP(lis)) SCM_RETURN(SCM_NIL);
  data[0] = proc;
  data[1] = SCM_NIL;
  data[2] = SCM_CDR(lis);
  data[3] = c1;
  data[4] = c2;
  Scm_VMPushCC(map1cc_cc, data, 5);
  SCM_RETURN(Scm_VMApply3(proc, SCM_CAR(lis), c1, c2));")


;; (%map-cons lis1 lis2) = (map cons lis1 lis2)
(define-cproc %map-cons (lis1 lis2)
  "ScmObj h = SCM_NIL, t = SCM_NIL;
  while (SCM_PAIRP(lis1) && SCM_PAIRP(lis2)) {
    SCM_APPEND1(h, t, Scm_Cons(SCM_CAR(lis1), SCM_CAR(lis2)));
    lis1 = SCM_CDR(lis1);
    lis2 = SCM_CDR(lis2);
  }
  SCM_RETURN(h);")

;; Local variables:
;; mode: scheme
;; end:
