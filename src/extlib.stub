;;;
;;; extlib.stub - extra built-ins
;;;  
;;;   Copyright (c) 2000-2006 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: extlib.stub,v 1.268 2006-11-30 23:55:01 shirok Exp $
;;;

"
#include <fcntl.h>
#include <gauche/arch.h>
#include <gauche/class.h>
#include <gauche/vminsn.h>
#include <gauche/regexp.h>
#include <gauche/bignum.h>
"

;;
;; Macros
;;

(define-cproc macroexpand (form)
  (expr "Scm_VMMacroExpand(form, SCM_NIL, FALSE)"))
(define-cproc macroexpand-1 (form)
  (expr "Scm_VMMacroExpand(form, SCM_NIL, TRUE)"))

;;
;; 6.1  Equivalence predicates
;;

;; to pass the cmpmode argument
(define-symbol eq?    "sym_eq")
(define-symbol eqv?   "sym_eqv")
(define-symbol equal? "sym_equal")

(define-symbol string=? "sym_string_eq") ; used for make-hash-table

"static int getcmpmode(ScmObj opt)
 { if (SCM_UNBOUNDP(opt) || opt == sym_equal) return SCM_CMP_EQUAL;
   if (opt == sym_eq) return SCM_CMP_EQ;
   if (opt == sym_eqv) return SCM_CMP_EQV;
   Scm_Error(\"unrecognized compare mode: %S\", opt);
   return 0; /* dummy */ }"

(define-cproc compare (x y) (call <fixnum> "Scm_Compare"))

;;
;; 6.2  Numbers
;;

(define-cproc ash (num cnt::<fixnum>) (call "Scm_Ash"))

(define-cproc lognot (x) (call "Scm_LogNot"))
(define-cproc logand (x y &rest args)
  "  ScmObj cp, r = Scm_LogAnd(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogAnd(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")
(define-cproc logior (x y &rest args)
  "  ScmObj cp, r = Scm_LogIor(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogIor(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")
(define-cproc logxor (x y &rest args)
  "  ScmObj cp, r = Scm_LogXor(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogXor(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")

(define-cproc fixnum? (x) (call <boolean> "SCM_INTP"))
(define-cproc bignum? (x) (call <boolean> "SCM_BIGNUMP"))
(define-cproc flonum? (x) (call <boolean> "SCM_FLONUMP"))

;; As of 0.8.8 we support exact rational numbers.  Some existing
;; code may count on exact integer division to be coerced to flonum
;; if it isn't produce a whole number, and such programs start
;; running very slowly on 0.8.8 by introducing unintentional exact
;; rational arithmetic.
;;
;; For the smooth transition, we provide the original behavior as
;; inexact-/.  If the program uses compat.no-rational, '/' is overridden
;; by inexact-/ and the old code behaves the same.
(define-cproc inexact-/ (arg1 &rest args)
  (body "ScmObj p;"
        "if (SCM_NULLP(args)) return Scm_ReciprocalInexact(arg1);"
        "SCM_FOR_EACH(p, args) {"
        "  arg1 = Scm_DivInexact(arg1, SCM_CAR(p));"
        "}"
        "SCM_RESULT = arg1;"))

(define-cproc clamp (x &optional (min #f) (max #f))
  " ScmObj r = x;  int maybe_exact = FALSE;
  if (SCM_EXACTP(x)) maybe_exact = TRUE;
  else if (!SCM_FLONUMP(x)) {
    Scm_Error(\"real number required for x, but got %S\", x);
  }
  if (SCM_EXACTP(min)) {
    if (Scm_NumCmp(x, min) < 0) r = min;
  } else if (SCM_FLONUMP(min)) {
    maybe_exact = FALSE;
    if (Scm_NumCmp(x, min) < 0) r = min;
  } else if (!SCM_FALSEP(min)) {
    Scm_Error(\"real number or #f required for min, but got %S\", min);
  }
  if (SCM_EXACTP(max)) {
    if (Scm_NumCmp(x, max) > 0) r = max;
  } else if (SCM_FLONUMP(max)) {
     maybe_exact = FALSE;
    if (Scm_NumCmp(x, max) > 0) r = max;
  } else if (!SCM_FALSEP(max)) {
    Scm_Error(\"real number or #f required for max, but got %S\", max);
  }
  if (!maybe_exact && SCM_EXACTP(r)) SCM_RETURN(Scm_ExactToInexact(r));
  else SCM_RETURN(r);")

(define-cproc decode-float (num)        ;from ChezScheme
  "if (SCM_FLONUMP(num)) {
     int exp, sign;
     ScmObj f = Scm_DecodeFlonum(SCM_FLONUM_VALUE(num), &exp, &sign);
     ScmObj v = Scm_MakeVector(3, SCM_FALSE);
     SCM_VECTOR_ELEMENT(v, 0) = f;
     SCM_VECTOR_ELEMENT(v, 1) = Scm_MakeInteger(exp);
     SCM_VECTOR_ELEMENT(v, 2) = Scm_MakeInteger(sign);
     SCM_RETURN(v);
  } else if (SCM_INTP(num)) {
     ScmObj v = Scm_MakeVector(3, SCM_FALSE);
     SCM_VECTOR_ELEMENT(v, 0) = Scm_Abs(num);
     SCM_VECTOR_ELEMENT(v, 1) = Scm_MakeInteger(0);
     SCM_VECTOR_ELEMENT(v, 2) = Scm_MakeInteger(Scm_Sign(num));
     SCM_RETURN(v);
  } else {
     Scm_Error(\"real number required, but got %S\", num);
     SCM_RETURN(SCM_UNDEFINED);
  }")

;; just for debug...
(if "SCM_DEBUG_HELPER"
(define-cproc %bignum-dump (obj)
  "  if (SCM_BIGNUMP(obj)) Scm_DumpBignum(SCM_BIGNUM(obj), SCM_CUROUT);
  SCM_RETURN(SCM_UNDEFINED);")
)

(define-cproc min&max (arg0 &rest args)
  "ScmObj min, max;
   Scm_MinMax(arg0, args, &min, &max);
   SCM_RETURN(Scm_Values2(min, max));")

(define-cproc quotient&remainder (n1 n2)
  "ScmObj q, r;
   q = Scm_Quotient(n1, n2, &r);
   SCM_RETURN(Scm_Values2(q, r));")

;;
;; 6.3.1  Booleans
;;

;; a convenient coercer
(define-cproc boolean (obj)
  (call <boolean> "!SCM_FALSEP"))

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc proper-list? (obj)        ; SRFI-1
  (call <boolean> "SCM_PROPER_LIST_P"))

(define-cproc dotted-list? (obj)        ; SRFI-1
  (call <boolean> "SCM_DOTTED_LIST_P"))

(define-cproc circular-list? (obj)      ; SRFI-1
  (call <boolean> "SCM_CIRCULAR_LIST_P"))

(define-cproc make-list (len::<fixnum> &optional (fill #f)) ; SRFI-1
  (call "Scm_MakeList"))

(define-cproc acons (caa cda cd)
  (call "Scm_Acons"))

(define-cproc last-pair (list)          ; SRFI-1
  (call "Scm_LastPair"))

(define-cproc list-copy (list)          ; SRFI-1
  (call "Scm_CopyList"))

(define-cproc list* (&rest args)
  (inliner LIST-STAR)
  "  ScmObj head = SCM_NIL, tail = SCM_NIL, cp;
  if (SCM_PAIRP(args)) {
    SCM_FOR_EACH(cp, args) {
      if (!SCM_PAIRP(SCM_CDR(cp))) {
        if (SCM_NULLP(head)) head = SCM_CAR(cp);
        else SCM_SET_CDR(tail, SCM_CAR(cp));
        break;
      }
      SCM_APPEND1(head, tail, SCM_CAR(cp));
    }
  }
  SCM_RETURN(head);")

(define-cproc %delete (obj list::<list> &optional cmpmode)
  (expr "Scm_Delete(obj, list, getcmpmode(cmpmode))"))

(define-cproc %delete! (obj list::<list> &optional cmpmode)
  (expr "Scm_DeleteX(obj, list, getcmpmode(cmpmode))"))

(define-cproc %delete-duplicates (list::<list> &optional cmpmode)
  (expr "Scm_DeleteDuplicates(list, getcmpmode(cmpmode))"))

(define-cproc %delete-duplicates! (list::<list> &optional cmpmode)
  (expr "Scm_DeleteDuplicatesX(list, getcmpmode(cmpmode))"))

(define-cproc %alist-delete (elt list::<list> &optional cmpmode)
  (expr "Scm_AssocDelete(elt, list, getcmpmode(cmpmode))"))

(define-cproc %alist-delete! (elt list::<list> &optional cmpmode)
  (expr "Scm_AssocDeleteX(elt, list, getcmpmode(cmpmode))"))

(define-cproc append! (&rest list)
  "  ScmObj cp, h = SCM_NIL, t = SCM_NIL;
  SCM_FOR_EACH(cp, list) {
    /* allow non-list argument at the last position */
    if (!SCM_PAIRP(SCM_CAR(cp)) && SCM_NULLP(SCM_CDR(cp))) {
      if (SCM_NULLP(h)) return SCM_CAR(cp);
      else { SCM_SET_CDR(t, SCM_CAR(cp)); return h; }
    }
    SCM_APPEND(h, t, SCM_CAR(cp));
  }
  SCM_RETURN(h);")

(define-cproc reverse! (list)
  (call "Scm_ReverseX"))

;; Scheme version of 'sort' handles the case when comparison function
;; is given.
(define-cproc %sort (seq)
  "if (SCM_VECTORP(seq)) {
    ScmObj r = Scm_VectorCopy(SCM_VECTOR(seq), 0, -1, SCM_UNDEFINED);
    Scm_SortArray(SCM_VECTOR_ELEMENTS(r), SCM_VECTOR_SIZE(r), SCM_FALSE);
    SCM_RETURN(r);
  } else if (Scm_Length(seq) >= 0) {
    SCM_RETURN(Scm_SortList(seq, SCM_FALSE));
  } else {
    Scm_Error(\"proper list or vector required, but got %S\", seq);
    SCM_RETURN(SCM_UNDEFINED);
  }")

(define-cproc %sort! (seq)
  "if (SCM_VECTORP(seq)) {
    Scm_SortArray(SCM_VECTOR_ELEMENTS(seq), SCM_VECTOR_SIZE(seq), SCM_FALSE);
    SCM_RETURN(seq);
  } else if (Scm_Length(seq) >= 0) {
    SCM_RETURN(Scm_SortListX(seq, SCM_FALSE));
  } else {
    Scm_Error(\"proper list or vector required, but got %S\", seq);
    SCM_RETURN(SCM_UNDEFINED);
  }")

(define-cproc monotonic-merge (start sequences::<list>)
  (call "Scm_MonotonicMerge"))

;;
;; 6.3.3  Symbols
;;

(define-cproc gensym (&optional prefix)
  "  ScmString *p = NULL;
  if (prefix != SCM_UNBOUND) {
    if (!SCM_STRINGP(prefix))
      Scm_Error(\"string expected, but got %S\", prefix);
    p = SCM_STRING(prefix);
  }
  SCM_RETURN(Scm_Gensym(p));")

;; keywords
(define-cproc keyword? (obj) (call <boolean> "SCM_KEYWORDP"))

(define-cproc make-keyword (name)
  "   ScmString *sname = NULL;
  if (SCM_STRINGP(name)) sname = SCM_STRING(name);
  else if (SCM_SYMBOLP(name)) sname = SCM_SYMBOL_NAME(name);
  else Scm_Error(\"string or symbol required, but got %S\", name);
  SCM_RETURN(Scm_MakeKeyword(sname));")

(define-cproc get-keyword (key list &optional fallback)
  (call "Scm_GetKeyword"))

(define-cproc delete-keyword (key list)
  (call "Scm_DeleteKeyword"))

(define-cproc delete-keyword! (key list)
  (call "Scm_DeleteKeywordX"))

(define-cproc keyword->string (key::<keyword>)
  (expr "SCM_OBJ(SCM_KEYWORD_NAME(key))"))

;; identifiers
(define-cproc identifier? (obj)
  (inliner IDENTIFIERP)
  (call <boolean> "SCM_IDENTIFIERP"))

(define-cproc identifier->symbol (obj::<identifier>)
  (expr "SCM_OBJ(SCM_IDENTIFIER(obj)->name)"))

;;
;; 6.3.4  Characters
;;

(define-cproc digit->integer (ch::<char> &optional (radix::<fixnum> 10))
  (body "int r;"
        "if (radix < 2 && radix > 36)"
        "  Scm_Error(\"radix must be between 2 and 36, but got %d\", radix);"
        "r = Scm_DigitToInt(ch, radix);"
        "SCM_RESULT = (r >= 0 ? SCM_MAKE_INT(r) : SCM_FALSE);"))

(define-cproc integer->digit (n::<fixnum> &optional (radix::<fixnum> 10))
  (body "ScmChar r;"
        "if (radix < 2 || radix > 36)"
        "  Scm_Error(\"radix must be between 2 and 36, but got %d\", radix);"
        "r = Scm_IntToDigit(n, radix);"
        "return (r == SCM_CHAR_INVALID? SCM_FALSE : SCM_MAKE_CHAR(r));"))

(define-cproc ucs->char (n::<int>)
  "ScmChar ch = Scm_UcsToChar(n);
  if (ch == SCM_CHAR_INVALID) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(SCM_MAKE_CHAR(ch));")

(define-cproc char->ucs (c::<char>)
  "int ucs = Scm_CharToUcs(c);
  if (ucs < 0) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(Scm_MakeInteger(ucs));")

(define-cproc gauche-character-encoding ()
  (call "Scm_CharEncodingName"))

(define-cproc supported-character-encodings ()
  (expr "Scm_CStringArrayToList(Scm_SupportedCharacterEncodings(), -1, 0)"))

(define-cproc supported-character-encoding? (encoding::<const-cstring>)
  (call <boolean> "Scm_SupportedCharacterEncodingP"))

;; character sets (SRFI-14)
;;   not all of srfi-14 functions are defined in C.  you need to load
;;   srfi-14.scm to get a full set of functions.

(define-constant *char-code-max* (c "Scm_MakeInteger(SCM_CHAR_MAX)"))

(define-cproc char-set? (obj) (call <boolean> "SCM_CHARSETP"))

"static void char_set_add(ScmCharSet *cs, ScmObj chars)
 {  ScmObj cp; ScmChar ch;
  SCM_FOR_EACH(cp, chars) {
    if (!SCM_CHARP(SCM_CAR(cp)))
      Scm_Error(\"character required, but got %S\", SCM_CAR(cp));
    ch = SCM_CHAR_VALUE(SCM_CAR(cp));
    Scm_CharSetAddRange(cs, ch, ch);
  }
 }"

(define-cproc %char-set-equal? (x::<char-set> y::<char-set>)
  (call <boolean> "Scm_CharSetEq"))

(define-cproc %char-set<=? (x::<char-set> y::<char-set>)
  (call <boolean> "Scm_CharSetLE"))

(define-cproc char-set (&rest chars)
  "  ScmCharSet *cs = SCM_CHARSET(Scm_MakeEmptyCharSet());
  char_set_add(cs, chars);
  SCM_RETURN(SCM_OBJ(cs));")

(define-cproc char-set-copy (cs::<char-set>)
  (call "Scm_CopyCharSet"))

(define-cproc %char-set-add-chars! (cs::<char-set> chars::<list>)
  "  char_set_add(cs, chars); SCM_RETURN(SCM_OBJ(cs));")

(define-cproc %char-set-add-range! (cs::<char-set> from to)
  "  long fromc = -1, toc = -1;
  if (SCM_EXACTP(from)) fromc = Scm_GetInteger(from);
  else if (SCM_CHARP(from)) fromc = SCM_CHAR_VALUE(from);
  if (fromc < 0) Scm_Error(\"character or positive integer required, but got %S\", from);
  if (fromc > SCM_CHAR_MAX) Scm_Error(\"argument out of range: %S\", from);
  if (SCM_EXACTP(to)) toc = Scm_GetInteger(to);
  else if (SCM_CHARP(to)) toc = SCM_CHAR_VALUE(to);
  if (toc < 0) Scm_Error(\"character or positive integer required, but got %S\", to);
  if (toc > SCM_CHAR_MAX) Scm_Error(\"argument out of range: %S\", to);
  SCM_RETURN(Scm_CharSetAddRange(cs, (ScmChar)fromc, (ScmChar)toc));")

(define-cproc %char-set-add! (dst::<char-set> src::<char-set>)
  (call "Scm_CharSetAdd"))

(define-cproc char-set-contains? (cs::<char-set> ch::<char>)
  (call <boolean> "Scm_CharSetContains"))

(define-cproc %char-set-complement! (cs::<char-set>)
  (call "Scm_CharSetComplement"))

(define-cproc %char-set-ranges (cs::<char-set>)
  (call "Scm_CharSetRanges"))

(define-cproc %char-set-predefined (num::<fixnum>)
  (call "Scm_GetStandardCharSet"))

;; for debug
(if "SCM_DEBUG_HELPER"
(define-cproc %char-set-dump (cs::<char-set>)
  (body <void> "Scm_CharSetDump(cs, SCM_CUROUT);"))
)

;;
;; 6.3.5 Strings
;;

(define-cproc string-incomplete? (obj)    ;gauche specific
  (expr <boolean> "SCM_STRINGP(obj)&&SCM_STRING_INCOMPLETE_P(obj)"))
(define-cproc string-immutable? (obj)   ;gauche specific
  (expr <boolean> "SCM_STRINGP(obj)&&SCM_STRING_IMMUTABLE_P(obj)"))

;; obsoleted
;(define-cproc string-complete->incomplete! (str::<string>)
;  (call "Scm_StringCompleteToIncompleteX"))

;; DEPRECATED, only kept for backward compatibility.
;; We allocate a new string and swap the body, in order to avoid MT-hazard.
;; (So it is _not_ allocation-free, and we no longer have reason to keep
;; this procedure.)
(define-cproc string-incomplete->complete! (str::<string>)
  (body "ScmObj s = Scm_StringIncompleteToComplete(str, SCM_ILLEGAL_CHAR_REJECT, SCM_CHAR(0));"
        "if (!SCM_FALSEP(s)) str->body = SCM_STRING_BODY(s);"
        "SCM_RESULT = s;"))

(define-cproc string-complete->incomplete (str::<string>)
  (call "Scm_StringCompleteToIncomplete"))

(define-keyword omit "key_omit")

(define-cproc string-incomplete->complete (str::<string>
                                           &optional (handling #f))
  (body "int h = 0; ScmChar sub = SCM_CHAR(0);"
        "if (SCM_EQ(handling, key_omit)) {"
        "  h = SCM_ILLEGAL_CHAR_OMIT;"
        "} else if (SCM_FALSEP(handling)) {"
        "  h = SCM_ILLEGAL_CHAR_REJECT;"
        "} else if (SCM_CHARP(handling)) {"
        "  h = SCM_ILLEGAL_CHAR_REPLACE;"
        "  sub = SCM_CHAR_VALUE(handling);"
        "}"
        "SCM_RESULT = Scm_StringIncompleteToComplete(str, h, sub);"))

(define-cproc string-size (str::<string>)
  (expr <fixnum> "SCM_STRING_BODY_SIZE(SCM_STRING_BODY(str))"))

(define-cproc make-byte-string (size::<fixnum> &optional (byte::<fixnum> 0))
  (body "char *s;"
        "if (size < 0) Scm_Error(\"size out of bound: %d\", size);"
        "s = SCM_NEW_ATOMIC2(char *, size);"
        "memset(s, byte, size);"
        "SCM_RESULT = Scm_MakeString(s, size, size, SCM_STRING_INCOMPLETE);"))

(define-cproc string-byte-ref (str::<string> k::<fixnum> &optional fallback)
  (body "int r = Scm_StringByteRef(str, k, SCM_UNBOUNDP(fallback));"
        "SCM_RESULT = (r<0)? fallback : SCM_MAKE_INT(r);"))

(define-cproc string-byte-set! (str::<string> k::<fixnum> b::<fixnum>)
  (call "Scm_StringByteSet"))

(define-cproc string-substitute! (target::<string> start::<fixnum> str::<string>)
  "  ScmObj r = Scm_StringSubstitute(target, start, str);
  if (!SCM_STRINGP(r)) Scm_Error(\"argument out of range: (%d %S)\", start, str);
  SCM_RETURN(r);")

(define-cproc %maybe-substring (str::<string> &optional start end)
  (call "Scm_MaybeSubstring"))

(define-symbol infix "sym_infix")
(define-symbol strict-infix "sym_strict_infix")
(define-symbol suffix "sym_suffix")
(define-symbol prefix "sym_prefix")

(define-cproc string-join (strs::<list>
                           &optional (delim::<string> " ") grammer)
  "  int gm = 0;
  if (SCM_UNBOUNDP(grammer) || SCM_UNDEFINEDP(grammer) || grammer == sym_infix)
    gm = SCM_STRING_JOIN_INFIX;
  else if (grammer == sym_strict_infix)
    gm = SCM_STRING_JOIN_STRICT_INFIX;
  else if (grammer == sym_suffix)
    gm = SCM_STRING_JOIN_SUFFIX;
  else if (grammer == sym_prefix)
    gm = SCM_STRING_JOIN_PREFIX;
  else Scm_Error(\"invalid grammer specification: %S\", grammer);
  SCM_RETURN(Scm_StringJoin(strs, delim, gm));")

(define-cproc %hash-string (str::<string> bound) ; for SRFI-13
  "  unsigned long modulo = 0;
  if (SCM_UNDEFINEDP(bound)) modulo = SCM_SMALL_INT_MAX;
  else if (SCM_INTP(bound)) modulo = SCM_INT_VALUE(bound);
  else if (SCM_BIGNUMP(bound)) modulo = Scm_BignumToUI(SCM_BIGNUM(bound), SCM_CLAMP_BOTH, NULL);
  if (modulo == 0) Scm_Error(\"argument out of domain: %S\", bound);
  SCM_RETURN(Scm_MakeInteger(Scm_HashString(str, modulo)));")

;; see lib/gauche/string for generic string-split
(define-cproc %string-split-by-char (s::<string> ch::<char>)
  (call "Scm_StringSplitByChar"))

;; primitive scanner
(define-symbol index   "sym_index")
(define-symbol before  "sym_before")
(define-symbol after   "sym_after")
(define-symbol before* "sym_before2")
(define-symbol after*  "sym_after2")
(define-symbol both    "sym_both")

(define-cproc string-scan (s1::<string> s2 &optional (mode (c "sym_index")))
  "  int retmode = 0;
  if (mode == sym_index)         retmode = SCM_STRING_SCAN_INDEX;
  else if (mode == sym_before)   retmode = SCM_STRING_SCAN_BEFORE;
  else if (mode == sym_after)    retmode = SCM_STRING_SCAN_AFTER;
  else if (mode == sym_before2)  retmode = SCM_STRING_SCAN_BEFORE2;
  else if (mode == sym_after2)   retmode = SCM_STRING_SCAN_AFTER2;
  else if (mode == sym_both)     retmode = SCM_STRING_SCAN_BOTH;
  else {
    Scm_Error(\"bad value in mode argumet: %S, must be one of 'index, 'before, 'after, 'before*, 'after* or 'both.\", mode);
  }
  if (SCM_STRINGP(s2)) {
     SCM_RETURN(Scm_StringScan(s1, SCM_STRING(s2), retmode));
  } else if (SCM_CHARP(s2)) {
     SCM_RETURN(Scm_StringScanChar(s1, SCM_CHAR_VALUE(s2), retmode));
  } else {
     Scm_Error(\"bad type of argument for s2: %S, must be either string or character\", s2);
     SCM_RETURN(SCM_UNDEFINED); /* dummy */
  }")
  

;; string pointer
(define-type <string-pointer> "ScmStringPointer*" "string pointer"
  "SCM_STRING_POINTERP" "SCM_STRING_POINTER")

(define-cproc make-string-pointer (str::<string>
                                   &optional (index::<fixnum> 0)
                                             (start::<fixnum> 0)
                                             (end::<fixnum> -1))
  (call "Scm_MakeStringPointer"))
(define-cproc string-pointer? (obj)
  (call <boolean> "SCM_STRING_POINTERP"))

(define-cproc string-pointer-ref (sp::<string-pointer>)
  (call "Scm_StringPointerRef"))
(define-cproc string-pointer-next! (sp::<string-pointer>)
  (call "Scm_StringPointerNext"))
(define-cproc string-pointer-prev! (sp::<string-pointer>)
  (call "Scm_StringPointerPrev"))
(define-cproc string-pointer-set! (sp::<string-pointer> index::<fixnum>)
  (call "Scm_StringPointerSet"))
(define-cproc string-pointer-substring (sp::<string-pointer>
                                        &keyword (after #f))
  (expr "Scm_StringPointerSubstring(sp, !SCM_FALSEP(after))"))
(define-cproc string-pointer-index (sp::<string-pointer>)
  (expr <int> "sp->index"))
(define-cproc string-pointer-copy (sp::<string-pointer>)
  (call "Scm_StringPointerCopy"))
(define-cproc string-pointer-byte-index (sp::<string-pointer>)
  (expr <int> "sp->current - sp->start"))

(if "SCM_DEBUG_HELPER"
    (define-cproc %string-pointer-dump (sp::<string-pointer>)
      (call <void> "Scm_StringPointerDump"))
    )

;; Regexp
(define-cproc regexp? (obj)    (call <boolean> "SCM_REGEXPP"))
(define-cproc regmatch? (obj)  (call <boolean> "SCM_REGMATCHP"))

(define-cproc string->regexp (str::<string> &keyword (case-fold #f))
  (body "int flags = SCM_BOOL_VALUE(case_fold)? SCM_REGEXP_CASE_FOLD : 0;"
        "SCM_RESULT = Scm_RegComp(str, flags);"))
(define-cproc regexp->string (regexp::<regexp>)
  (expr "regexp->pattern?SCM_OBJ(regexp->pattern):SCM_FALSE"))
(define-cproc regexp-case-fold? (regexp::<regexp>)
  (expr <boolean> "regexp->flags&SCM_REGEXP_CASE_FOLD"))

(define-cproc regexp-parse (str::<string> &keyword (case-fold #f))
  (body "int flags = SCM_BOOL_VALUE(case_fold)? SCM_REGEXP_CASE_FOLD : 0;"
        "SCM_RESULT = Scm_RegComp(str, flags|SCM_REGEXP_PARSE_ONLY);"))
(define-cproc regexp-compile (ast)
  (call "Scm_RegCompFromAST"))
(define-cproc regexp-optimize (ast)
  (call "Scm_RegOptimizeAST"))

(define-cproc rxmatch (regexp str::<string>)
  "  ScmRegexp *rx = NULL;
  if (SCM_STRINGP(regexp)) rx = SCM_REGEXP(Scm_RegComp(SCM_STRING(regexp), 0));
  else if (SCM_REGEXPP(regexp)) rx = SCM_REGEXP(regexp);
  else Scm_Error(\"regexp required, but got %S\", regexp);
  SCM_RETURN(Scm_RegExec(rx, str));")

(define-cproc rxmatch-substring (match &optional (obj 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchSubstr(SCM_REGMATCH(match), obj));")

(define-cproc rxmatch-start (match &optional (obj 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchStart(SCM_REGMATCH(match), obj));")

(define-cproc rxmatch-end (match &optional (obj 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchEnd(SCM_REGMATCH(match), obj));")

(define-cproc rxmatch-before (match &optional (obj 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchBefore(SCM_REGMATCH(match), obj));")

(define-cproc rxmatch-after (match &optional (obj 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchAfter(SCM_REGMATCH(match), obj));")

(define-cproc rxmatch-num-matches (match)
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_MAKE_INT(0));
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(SCM_MAKE_INT(SCM_REGMATCH(match)->numMatches));")

;; for debug
(if "SCM_DEBUG_HELPER"
(define-cproc %regexp-dump (rx::<regexp>)
  (call <void> "Scm_RegDump"))
)

(if "SCM_DEBUG_HELPER"
(define-cproc %regmatch-dump (rm::<regmatch>)
  (call <void> "Scm_RegMatchDump"))
)

;;
;; 6.3.6  Vectors
;;

(define-cproc vector-copy (v::<vector>
                           &optional
                           (start::<fixnum> 0) (end::<fixnum> -1) fill)
  (call "Scm_VectorCopy"))

;; weak vector
(define-cproc make-weak-vector (size::<fixnum>)
  (call "Scm_MakeWeakVector"))

(define-cproc weak-vector-length (wv::<weak-vector>)
  (expr <int> "wv->size"))

(define-cproc weak-vector-ref (wv::<weak-vector> index::<fixnum>
                               &optional fallback)
  (call "Scm_WeakVectorRef"))
  
(define-cproc weak-vector-set! (wv::<weak-vector> index::<fixnum> val)
  (call "Scm_WeakVectorSet"))

;;
;; 6.4  Control Features
;;

(define-cproc setter (proc) ;SRFI-17
  (inliner SETTER)
  (call "Scm_Setter")
  (setter (proc::<procedure> setter::<procedure>)
          (body <void> "Scm_SetterSet(proc, setter, FALSE);")))

(define-cproc has-setter? (proc)
  (call <boolean> "Scm_HasSetter"))

(define-cproc identity (val)            ;sometimes useful
  (expr "val"))

(define-cproc promise? (obj)
  (expr <boolean> "SCM_XTYPEP(obj, SCM_CLASS_PROMISE)"))

(define-cproc eager (obj)               ;srfi-45
  (expr "Scm_MakePromise(TRUE, obj)"))

(define-cproc promise-kind (p::<promise>)
  (expr "p->kind")
  (setter (p::<promise> obj)
          (body <void> "p->kind = obj;")))

;;
;; 6.6.1  Ports
;;

;; open-input-file and open-output-file are defined in Scheme.
;; these are core procedures

;; valid keywords for open-*-file options
(define-keyword error "key_error")
(define-keyword create "key_create")
(define-keyword append "key_append")
(define-keyword supersede "key_supersede")
(define-keyword overwrite "key_overwrite")
(define-keyword character "key_character")
(define-keyword binary "key_binary")

(define-cproc %open-input-file (path::<string>
                                &keyword
                                (if-does-not-exist (c "key_error"))
                                (buffering #f)
                                (element-type (c "key_character"))
                                )
  "  ScmObj o; int ignerr = FALSE, bufmode;
  if (SCM_FALSEP(if_does_not_exist)) ignerr = TRUE;
  else if (!SCM_EQ(if_does_not_exist, key_error)) {
    Scm_Error(\"argument for :if-does-not-exist must be either :error or #f, but got %S\", if_does_not_exist);
  }
  bufmode = Scm_BufferingMode(buffering, SCM_PORT_INPUT, SCM_PORT_BUFFER_FULL);
  o = Scm_OpenFilePort(Scm_GetStringConst(path), O_RDONLY, bufmode, 0);
  if (o == SCM_FALSE && !ignerr) {
     Scm_Error(\"couldn't open input file: %S\", path_scm);
  }
  SCM_RETURN(o);")

(define-cproc %open-output-file (path::<string>
                                 &keyword
                                 (if-exists (c "key_supersede"))
                                 (if-does-not-exist (c "key_create"))
                                 (mode::<fixnum> #o666)
                                 (buffering #f)
                                 (element-type (c "key_character"))
                                 )
  "  ScmObj o;
  int ignerr = FALSE, bufmode, flags = O_WRONLY;

  if (SCM_EQ(if_exists, key_append)) flags |= O_APPEND;
  else if (SCM_EQ(if_exists, key_error)) {
    flags |= O_EXCL;
    if (SCM_EQ(if_does_not_exist, key_error)) {
      Scm_Error(\"bad flag combination: :if-exists and :if-does-not-exist can't be :error the same time.\");
    }
  }
  else if (SCM_EQ(if_exists, key_supersede)) flags |= O_TRUNC;
  else if (SCM_EQ(if_exists, key_overwrite)) /*no need to add flags*/;
  else if (SCM_FALSEP(if_exists)) { flags |= O_EXCL; ignerr = TRUE; }
  else {
    Scm_Error(\"argument for :if-exists must be either :supersede, :overwrite, :append, :error or #f, but got %S\", if_exists);
  }

  if (SCM_EQ(if_does_not_exist, key_create)) flags |= O_CREAT;
  else if (SCM_FALSEP(if_does_not_exist)) ignerr = TRUE;
  else if (!SCM_EQ(if_does_not_exist, key_error)) {
    Scm_Error(\"argument for :if-does-not-exist must be either :error, :create or #f, but got %S\", if_does_not_exist);
  }

  bufmode = Scm_BufferingMode(buffering, SCM_PORT_OUTPUT, SCM_PORT_BUFFER_FULL);
  o = Scm_OpenFilePort(Scm_GetStringConst(path), flags, bufmode, mode);
  if (!ignerr && o == SCM_FALSE) {
     Scm_Error(\"couldn't open output file: %S\", path_scm);
  }
  SCM_RETURN(o);")

;; String port (srfi-6)
(define-cproc open-input-string (string::<string>
                                 &keyword (private?::<boolean> #f))
  (call "Scm_MakeInputStringPort"))

(define-cproc open-output-string (&keyword (private?::<boolean> #f))
  (call "Scm_MakeOutputStringPort"))

(define-cproc get-output-string (oport::<output-port>) ;SRFI-6
  (call "Scm_GetOutputString"))

(define-cproc get-remaining-input-string (iport::<input-port>)
  (call "Scm_GetRemainingInputString"))

(define-cproc open-coding-aware-port (iport::<input-port>)
  (call "Scm_MakeCodingAwarePort"))

;; Buffered port
;; NB: the interface may be changed soon!!
"static void bufport_closer(ScmPort *p)
 {
    if (SCM_PORT_DIR(p) == SCM_PORT_OUTPUT) {
       ScmObj scmflusher = SCM_OBJ(p->src.buf.data);
       int siz = (int)(p->src.buf.current - p->src.buf.buffer);
       if (siz > 0) Scm_ApplyRec(scmflusher, SCM_LIST1(Scm_MakeString(p->src.buf.buffer, siz, siz, SCM_STRING_INCOMPLETE|SCM_STRING_COPYING)));
       Scm_ApplyRec(scmflusher, SCM_LIST1(SCM_FALSE));
    }
 }"

"static int bufport_filler(ScmPort *p, int cnt)
 {
    ScmObj scmfiller, r;  int siz;
    const ScmStringBody *b;
    scmfiller = SCM_OBJ(p->src.buf.data);
    /* no need to use VMApply; we're in the C callback */
    r = Scm_ApplyRec(scmfiller, SCM_LIST1(Scm_MakeInteger(cnt)));
    if (SCM_EOFP(r) || SCM_FALSEP(r)) {
       return 0;
    } else if (!SCM_STRINGP(r)) {
       Scm_Error(\"buffered port callback procedure returned non-string: %S\", r);
    }
    b = SCM_STRING_BODY(r);
    siz = SCM_STRING_BODY_SIZE(b);
    if (siz > cnt) siz = cnt; /* for safety */
    memcpy(p->src.buf.end, SCM_STRING_BODY_START(b), siz);
    return SCM_STRING_BODY_SIZE(b);
 }"

(define-cproc open-input-buffered-port (filler::<procedure>
                                        buffer-size::<fixnum>)
  "  ScmPortBuffer bufrec;
  bufrec.size = buffer_size;
  bufrec.buffer = NULL;
  bufrec.mode = SCM_PORT_BUFFER_FULL;
  bufrec.filler = bufport_filler;
  bufrec.flusher = NULL;
  bufrec.closer = bufport_closer;
  bufrec.ready = NULL;
  bufrec.filenum = NULL;
  bufrec.data = (void*)filler;
  SCM_RETURN(Scm_MakeBufferedPort(SCM_CLASS_PORT, SCM_FALSE, SCM_PORT_INPUT, TRUE, &bufrec));
  ")

"static int bufport_flusher(ScmPort *p, int cnt, int forcep)
 {
     ScmObj scmflusher, s;
     scmflusher = SCM_OBJ(p->src.buf.data);
     s = Scm_MakeString(p->src.buf.buffer, cnt, cnt, SCM_STRING_INCOMPLETE|SCM_STRING_COPYING);
     Scm_ApplyRec(scmflusher, SCM_LIST1(s));
     return cnt;
 }"

(define-cproc open-output-buffered-port (flusher::<procedure>
                                         buffer-size::<fixnum>)
  "  ScmPortBuffer bufrec;
  bufrec.size = buffer_size;
  bufrec.buffer = NULL;
  bufrec.mode = SCM_PORT_BUFFER_FULL;
  bufrec.filler = NULL;
  bufrec.flusher = bufport_flusher;
  bufrec.closer = bufport_closer;
  bufrec.ready = NULL;
  bufrec.filenum = NULL;
  bufrec.data = (void*)flusher;
  SCM_RETURN(Scm_MakeBufferedPort(SCM_CLASS_PORT, SCM_FALSE, SCM_PORT_OUTPUT, TRUE, &bufrec));
  ")

(define-cproc flush (&optional (oport::<output-port> (current-output-port)))
  (call <void> "Scm_Flush"))

(define-cproc flush-all-ports ()
  (body <void> "Scm_FlushAllPorts(FALSE);"))

(define-cproc port-closed? (obj::<port>)
  (call <boolean> "SCM_PORT_CLOSED_P"))

(define-cproc current-error-port ()     ;gauche extention
  (inliner CURERR)
  (expr "SCM_OBJ(SCM_CURERR)"))

(define-cproc standard-input-port ()
  (call "Scm_Stdin"))

(define-cproc standard-output-port ()
  (call "Scm_Stdout"))

(define-cproc standard-error-port ()
  (call "Scm_Stderr"))

(define-cproc with-input-from-port (port::<input-port> thunk)
  (expr "Scm_WithPort(&port, thunk, SCM_PORT_CURIN, FALSE)"))

(define-cproc with-output-to-port (port::<output-port> thunk)
  (expr "Scm_WithPort(&port, thunk, SCM_PORT_CUROUT, FALSE)"))

(define-cproc with-error-to-port (port::<output-port> thunk)
  (expr "Scm_WithPort(&port, thunk, SCM_PORT_CURERR, FALSE)"))

(define-cproc with-ports (iport::<input-port>?
                          oport::<output-port>?
                          eport::<output-port>?
                          thunk)
  (body "ScmPort *p[3]; int flags = 0, cnt = 0;"
        "if (iport) { p[cnt++] = iport; flags |= SCM_PORT_CURIN; }"
        "if (oport) { p[cnt++] = oport; flags |= SCM_PORT_CUROUT; }"
        "if (eport) { p[cnt++] = eport; flags |= SCM_PORT_CURERR; }"
        "SCM_RESULT = Scm_WithPort(p, thunk, flags, FALSE);"))

(define-cproc port-name (port::<port>)
  (call "Scm_PortName"))

(define-cproc port-current-line (port::<port>)
  (call <fixnum> "Scm_PortLine"))

(define-cproc port-file-number (port::<port>)
  "  int i = Scm_PortFileNo(port);
  SCM_RETURN((i < 0)? SCM_FALSE : Scm_MakeInteger(i));")

(define-enum SEEK_SET)
(define-enum SEEK_CUR)
(define-enum SEEK_END)

(define-cproc port-seek (port::<port> offset::<integer>
                         &optional (whence::<fixnum> (c "SCM_MAKE_INT(SEEK_SET)")))
  (call "Scm_PortSeek"))

(define-symbol file "sym_file")
(define-symbol string "sym_string")
(define-symbol proc "sym_proc")
(define-cproc port-type (port::<port>)
  "ScmObj type = SCM_FALSE;
   switch (SCM_PORT_TYPE(port)) {
     case SCM_PORT_FILE: type = sym_file; break;
     case SCM_PORT_PROC: type = sym_proc; break;
     case SCM_PORT_OSTR:;
     case SCM_PORT_ISTR: type = sym_string; break;
   }
   SCM_RETURN(type);")

(define-cproc port-buffering (port::<port>)
  (call "Scm_GetBufferingMode")
  (setter (port::<port> mode)
    "if (SCM_PORT_TYPE(port) != SCM_PORT_FILE) {
       Scm_Error(\"can't set buffering mode to non-buffered port: %S\", port);
     }
     port->src.buf.mode = Scm_BufferingMode(mode, port->direction, -1);
     SCM_RETURN(SCM_UNDEFINED);")
  )

;; Open port from fd
(define-cproc open-input-fd-port (fd::<fixnum>
                                  &keyword (buffering #f)
                                           (owner?::<boolean> #f)
                                           (name #f))
  "int bufmode = Scm_BufferingMode(buffering, SCM_PORT_INPUT, SCM_PORT_BUFFER_FULL);
   if (fd < 0) Scm_Error(\"bad file descriptor: %d\", fd);
   return Scm_MakePortWithFd(name, SCM_PORT_INPUT, fd, bufmode, ownerP);")

(define-cproc open-output-fd-port (fd::<fixnum>
                                   &keyword (buffering #f)
                                            (owner?::<boolean> #f)
                                            (name #f))
  "int bufmode = Scm_BufferingMode(buffering, SCM_PORT_OUTPUT, SCM_PORT_BUFFER_FULL);
   if (fd < 0) Scm_Error(\"bad file descriptor: %d\", fd);
   return Scm_MakePortWithFd(name, SCM_PORT_OUTPUT, fd, bufmode, ownerP);")

;; Unsafe port operations
(define-cproc with-port-locking (port::<port> proc)
  (call "Scm_VMWithPortLocking"))

(define-cproc port->byte-string (port::<input-port>)
  ;; TODO: use chunked I/O if appropriate
  " int b; ScmPort *out = SCM_PORT(Scm_MakeOutputStringPort(TRUE));
  for (;;) {
    SCM_GETB(b, port);
    if (b == EOF) break;
    Scm_PutbUnsafe(b, out);
  }
  SCM_RETURN(Scm_GetOutputString(out));")

;;
;; 6.6.2  Input
;;

(define-cproc byte-ready? (port::<input-port>)
  (call <boolean> "Scm_ByteReady"))

(define-cproc read-byte (&optional (port::<input-port> (current-input-port)))
  "  int b; SCM_GETB(b, port);
  SCM_RETURN((b < 0)? SCM_EOF : SCM_MAKE_INT(b));")

(define-cproc peek-byte (&optional (port::<input-port> (current-input-port)))
  "  int b = Scm_Peekb(port);
  SCM_RETURN((b < 0)? SCM_EOF : SCM_MAKE_INT(b));")

(define-cproc read-line (&optional (port::<input-port> (current-input-port))
                                   (allowbytestr #f))
  "ScmObj r = Scm_ReadLine(port);
  if (SCM_FALSEP(allowbytestr)&&SCM_STRINGP(r)&&SCM_STRING_INCOMPLETE_P(r)) {
    Scm_ReadError(port, \"read-line: encountered illegal byte sequence: %S\", r);
  }
  SCM_RETURN(r);")

(define-cproc read-block (bytes::<fixnum>
                          &optional (port::<input-port> (current-input-port)))
  "  char *buf; int nread;
  if (bytes < 0) Scm_Error(\"bytes must be non-negative integer: %d\", bytes);
  if (bytes == 0) SCM_RETURN(Scm_MakeString(\"\", 0, 0, 0));
  buf = SCM_NEW_ATOMIC2(char*, bytes+1);
  nread = Scm_Getz(buf, bytes, port);
  if (nread <= 0) {
    SCM_RETURN(SCM_EOF);
  } else {
    SCM_ASSERT(nread <= bytes);
    buf[nread] = '\\0';
    SCM_RETURN(Scm_MakeString(buf, nread, nread, SCM_STRING_INCOMPLETE));
  }")

(define-cproc read-list (closer::<char>
                         &optional (port (current-input-port)))
  "SCM_RETURN(Scm_ReadList(port, closer));")

(define-cproc define-reader-ctor (symbol proc &optional (finisher #f))
  (call "Scm_DefineReaderCtor"))

(define-type <read-reference> "ScmReadReference*" "read reference"
  "SCM_READ_REFERENCE_P" "SCM_READ_REFERENCE" "")

(define-cproc read-reference? (obj)
  (call <boolean> "SCM_READ_REFERENCE_P"))

(define-cproc read-reference-has-value? (ref::<read-reference>)
  (expr <boolean> "!SCM_UNBOUNDP(ref->value)"))

(define-cproc read-reference-value (ref::<read-reference>)
  "if (SCM_UNBOUNDP(ref->value))
    Scm_Error(\"read reference hasn't been resolved\");
  SCM_RETURN(ref->value);")

;;
;; 6.6.3  Output
;;

(define-cproc write-byte (byte::<fixnum>
                          &optional (port::<output-port> (current-output-port)))
  "  if (byte < 0 || byte > 255) Scm_Error(\"argument out of range: %d\", byte);
  SCM_PUTB(byte, port);
  SCM_RETURN(SCM_MAKE_INT(1));")

(define-cproc write-limited (obj limit::<fixnum>
                             &optional (port (current-output-port)))
  "  int n = Scm_WriteLimited(obj, port, SCM_WRITE_WRITE, limit);
  SCM_RETURN(SCM_MAKE_INT(n));")

(define-cproc write* (obj &optional (port (current-output-port)))
  "  int n = Scm_WriteCircular(obj, port, SCM_WRITE_WRITE, 0);
  SCM_RETURN(SCM_MAKE_INT(n));")

;;
;; 6.6.4  System Interface
;;

(define-cproc %add-load-path (path::<string> &optional (afterp #f))
  "  const char *cpath = Scm_GetStringConst(path);
  SCM_RETURN(Scm_AddLoadPath(cpath, !SCM_FALSEP(afterp)));")

(define-cproc dynamic-load (file::<string>
                            &keyword (init-function #f)
                                     (export-symbols #f))
  (expr "Scm_DynLoad(file, init_function, !SCM_FALSEP(export_symbols))"))

(define-cproc %require (feature)  (call "Scm_Require"))
(define-cproc provide (feature)   (call "Scm_Provide"))
(define-cproc provided? (feature) (call <boolean> "Scm_ProvidedP"))

;(define-cproc %make-autoload (sym::<symbol> path::<string>
;                              &optional import-from)
;  "ScmSymbol *from = SCM_SYMBOLP(import_from)? SCM_SYMBOL(import_from) : NULL;
;   SCM_RETURN(Scm_MakeAutoload(sym, path, from));")

(define-cproc %autoload (mod::<module> file-or-module entries)
  (call <void> "Scm_DefineAutoload"))

(define-cproc undefined ()
  (inliner CONSTU)
  "SCM_RETURN(SCM_UNDEFINED);")

(define-cproc undefined? (obj)    (call <boolean> "SCM_UNDEFINEDP"))

(define-cproc warn (fmt::<string> &rest args)
  (call <void> "Scm_FWarn"))

;;
;; Hashtable
;;

(define-cproc eq-hash (obj)
  (call <ulong> "Scm_EqHash"))

(define-cproc eqv-hash (obj)
  (call <ulong> "Scm_EqvHash"))

(define-cproc hash (obj)
  (call <ulong> "Scm_Hash"))

"static int get_hash_proc(ScmSymbol *type) {
  if (SCM_EQ(SCM_OBJ(type), sym_eq))             return SCM_HASH_EQ;
  else if (SCM_EQ(SCM_OBJ(type), sym_eqv))       return SCM_HASH_EQV;
  else if (SCM_EQ(SCM_OBJ(type), sym_equal))     return SCM_HASH_EQUAL;
  else if (SCM_EQ(SCM_OBJ(type), sym_string_eq)) return SCM_HASH_STRING;
  else {
    Scm_Error(\"unsupported hash type: %S\", type);
    return 0; /* dummy */
  }
 }"

(define-cproc make-hash-table (&optional (type::<symbol> (c "sym_eq")))
  "SCM_RETURN(Scm_MakeHashTableSimple(get_hash_proc(type), 0));")

(define-cproc hash-table? (obj)
  (call <boolean> "SCM_HASH_TABLE_P"))

(define-cproc hash-table-type (hash::<hash-table>)
  "switch (hash->type) {
   case SCM_HASH_EQ:      SCM_RETURN(sym_eq);
   case SCM_HASH_EQV:     SCM_RETURN(sym_eqv);
   case SCM_HASH_EQUAL:   SCM_RETURN(sym_equal);
   case SCM_HASH_STRING:  SCM_RETURN(sym_string_eq);
   default: SCM_RETURN(SCM_FALSE);  /* TODO: need to think over */
  }")

(define-cproc hash-table-num-entries (hash::<hash-table>)
  (expr <int> "hash->numEntries"))

(define-cproc hash-table-get (hash::<hash-table> key &optional defval)
  "  ScmHashEntry *e = Scm_HashTableGet(hash, key);
  if (!e || e->value == SCM_UNBOUND) {
    if (defval != SCM_UNBOUND) SCM_RETURN(defval);
    else Scm_Error(\"hash table doesn't have an entry for key %S\", key);
  }
  SCM_RETURN(e->value);")

(define-cproc hash-table-put! (hash::<hash-table> key value)
  (call <void> "Scm_HashTablePut"))

;; this is hash-table-remove! in STk.  I use `delete' for
;; it's consistent with SRFI-1 and dbm-delete!.
(define-cproc hash-table-delete! (hash::<hash-table> key)
  (expr <boolean> "Scm_HashTableDelete(hash, key) != NULL"))

(define-cproc hash-table-exists? (hash::<hash-table> key)
  (expr <boolean> "Scm_HashTableGet(hash, key) != NULL"))

"static ScmObj hash_table_update_cc(ScmObj result, void **data)
 {
   ScmHashEntry *e = (ScmHashEntry*)data[0];
   e->value = result;
   SCM_RETURN(result);
 }"

(define-cproc hash-table-update! (hash::<hash-table> key proc &optional defval)
  (body "ScmHashEntry *e;"
        "void *data[1];"
        "if (SCM_UNBOUNDP(defval)) {"
        "  e = Scm_HashTableGet(hash, key);"
        "  if (!e) Scm_Error(\"hash table doesn't have an entry for key %S\", key);"
        "} else {"
        "  e = Scm_HashTableAdd(hash, key, defval);"
        "}"
        "data[0] = (void*)e;"
        "Scm_VMPushCC(hash_table_update_cc, data, 1);"
        "SCM_RESULT = Scm_VMApply1(proc, e->value);"))

(define-cproc hash-table-push! (hash::<hash-table> key value)
  "ScmHashEntry *e = Scm_HashTableAdd(hash, key, SCM_UNBOUND);
  if (SCM_UNBOUNDP(e->value)) e->value = SCM_LIST1(value);
  else                        e->value = Scm_Cons(value, e->value);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc hash-table-pop! (hash::<hash-table> key &optional fallback)
  "ScmHashEntry *e = Scm_HashTableGet(hash, key); ScmObj r;
  if (e == NULL) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"hash table doesn't have an entry for key %S\", key);
    }
    r = fallback;
  } else if (!SCM_PAIRP(e->value)) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"hash table value for key %S is not a pair: %S\", key, e->value);
    }
    r = fallback;
  } else {
    r = SCM_CAR(e->value); e->value = SCM_CDR(e->value);
  }
  SCM_RETURN(r);")

"static ScmObj hash_table_iter(ScmObj *args, int nargs, void *data)
 {
   ScmHashIter *iter = (ScmHashIter*)data;
   ScmHashEntry *e = Scm_HashIterNext(iter);
   ScmObj eofval = args[0];
   if (e == NULL) SCM_RETURN(Scm_Values2(eofval, eofval));
   else SCM_RETURN(Scm_Values2(e->key, e->value));
 }"

(define-cproc %hash-table-iter (hash::<hash-table>)
  "ScmHashIter *iter = SCM_NEW(ScmHashIter);
  Scm_HashIterInit(hash, iter);
  SCM_RETURN(Scm_MakeSubr(hash_table_iter, iter, 1, 0, SCM_MAKE_STR(\"hash-table-iterator\")));")

(define-cproc hash-table-keys (hash::<hash-table>)
  (call "Scm_HashTableKeys"))

(define-cproc hash-table-values (hash::<hash-table>)
  (call "Scm_HashTableValues"))

(define-cproc hash-table-stat (hash::<hash-table>)
  (call "Scm_HashTableStat"))

;;
;; Modules
;;

(define-cproc module? (obj) (call <boolean> "SCM_MODULEP"))

(define-cproc module-name (mod::<module>)
  (expr "SCM_OBJ(SCM_MODULE(mod)->name)"))

(define-cproc module-parents (mod::<module>)
  (expr "mod->parents"))

(define-cproc module-precedence-list (mod::<module>)
  (expr "mod->mpl"))

(define-cproc module-imports (mod::<module>)
  (expr "mod->imported"))

(define-cproc module-exports (mod::<module>)
  (expr "mod->exported"))

(define-cproc module-table (mod::<module>)
  (expr "SCM_OBJ(mod->table)"))

(define-cproc find-module (name::<symbol>)
  (expr <module>? "Scm_FindModule(name, SCM_FIND_MODULE_QUIET)"))

(define-cproc all-modules ()
  (call "Scm_AllModules"))

(define-keyword error "key_error") ; this is also in stdlib.stub.  should I
                                   ; consolidate these?
(define-cproc make-module (name
                           &keyword (if-exists (c "key_error")))
  "int error_if_exists = TRUE;
  if (SCM_EQ(if_exists, key_error)) {
    error_if_exists = TRUE;
  } else if (SCM_FALSEP(if_exists)) {
    error_if_exists = FALSE;
  } else {
    Scm_Error(\"argument for :if-exists must be either :error or #f, but got %S\", if_exists);
  }
  if (!SCM_FALSEP(name) && !SCM_SYMBOLP(name)) {
    Scm_Error(\"module name must be a symbol or #f, but got %S\", name);
  }
  SCM_RETURN(Scm_MakeModule((SCM_FALSEP(name)?NULL:SCM_SYMBOL(name)),
                            error_if_exists));")

(define-cproc module-name->path (name)
  (body "ScmSymbol *s = NULL;"
        "if (SCM_SYMBOLP(name)) s = SCM_SYMBOL(name);"
        "else if (SCM_IDENTIFIERP(name)) s = SCM_IDENTIFIER(name)->name;"
        "else Scm_Error(\"symbol or identifier required, but got %S\", name);"
        "SCM_RESULT = Scm_ModuleNameToPath(s);"))

(define-cproc path->module-name (path::<string>)
  (call "Scm_PathToModuleName"))

(define-cproc %export-all (module::<module>)
  (call "Scm_ExportAll"))

(define-cproc %extend-module (module::<module> supers::<list>)
  (call "Scm_ExtendModule"))

"static ScmModule *get_module_from_mod_or_name(ScmObj mod_or_name)
 {
   if (SCM_MODULEP(mod_or_name)) return SCM_MODULE(mod_or_name);
   else if (SCM_SYMBOLP(mod_or_name)) {
     return Scm_FindModule(SCM_SYMBOL(mod_or_name), 0);
   } else if (SCM_FALSEP(mod_or_name)) {
     return SCM_CURRENT_MODULE();
   } else {
     Scm_Error(\"module or symbol required, but got: %S\", mod_or_name);
     return NULL;
   }
 }
"

(define-cproc global-variable-bound? (mod-or-name name::<symbol>)
  (body <boolean>
        "ScmModule *module = get_module_from_mod_or_name(mod_or_name);"
        "SCM_RESULT = (Scm_SymbolValue(module, name) != SCM_UNBOUND);"))

(define-cproc global-variable-ref (mod_or_name name::<symbol>
                                               &optional
                                               fallback
                                               (stay-in-module::<boolean> #f))
  (body "ScmModule *module = get_module_from_mod_or_name(mod_or_name);"
        "int flags = (stay_in_module? SCM_BINDING_STAY_IN_MODULE : 0);"
        "ScmObj r = Scm_GlobalVariableRef(module, name, flags);"
        "SCM_RESULT = fallback;"
        "if (r != SCM_UNBOUND) SCM_RESULT = r;"
        "else if (fallback == SCM_UNBOUND) {"
        "  Scm_Error(\"global variable %S is not bound in module %S\", name, module);"
        "}"))

;;
;; Gauche extentions
;;

;; Utility procedure

(define-cproc %format (port::<output-port> fmt::<string>
                       args shared::<boolean>)
  (call <void> "Scm_Format"))

(define-cproc exit (&optional (code::<fixnum> 0))
  (call <void> "Scm_Exit"))

;;
;; External view of VM.
;;

(define-cclass <thread> "ScmVM" "Scm_VMClass"
  ()
  ((name)
   (specific)
   )
  (printer
   "ScmVM *vm = SCM_VM(obj);
    const char *state;
    switch (vm->state) {
    case SCM_VM_NEW:        state = \"new\"; break;
    case SCM_VM_RUNNABLE:   state = \"runnable\"; break;
    case SCM_VM_BLOCKED:    state = \"blocked\"; break;
    case SCM_VM_TERMINATED: state = \"terminated\"; break;
    default: state = \"(unknown state)\";
    }
    Scm_Printf(port, \"#<thread %S %s %p>\", vm->name, state, vm);")
  )

(define-cproc vm-dump (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  Scm_VMDump(SCM_VM(vm));
  SCM_RETURN(SCM_UNDEFINED); ")

(define-cproc vm-get-stack-trace (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  SCM_RETURN(Scm_VMGetStack(SCM_VM(vm)));")

(define-cproc vm-get-stack-trace-lite (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  SCM_RETURN(Scm_VMGetStackLite(SCM_VM(vm)));")

(define-cproc vm-set-default-exception-handler (vm handler)
  "  if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  if (!SCM_FALSEP(handler) && !SCM_PROCEDUREP(handler)) {
    Scm_Error(\"a procedure or #f required, but got %S\", handler);
  }
  SCM_VM(vm)->defaultEscapeHandler = handler;
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc current-load-history ()
  (expr "Scm_VM()->load_history"))
(define-cproc current-load-next ()
  (expr "Scm_VM()->load_next"))
(define-cproc current-load-port ()
  (expr "Scm_VM()->load_port"))

;; parameter
(define-cproc %vm-make-parameter-slot ()
  "int newid, num;
   num = Scm_MakeParameterSlot(Scm_VM(), &newid);
   SCM_RETURN(Scm_Values2(SCM_MAKE_INT(num), SCM_MAKE_INT(newid)));")
(define-cproc %vm-parameter-ref (index::<int> id::<int>)
  (expr "Scm_ParameterRef(Scm_VM(), index, id)"))
(define-cproc %vm-parameter-set! (index::<int> id::<int> value)
  (expr "Scm_ParameterSet(Scm_VM(), index, id, value)"))

;;
;; Inspecting feature
;;

;; Obtain info about gauche itself
(define-cproc gauche-version ()
  (expr "SCM_MAKE_STR(GAUCHE_VERSION)"))
(define-cproc gauche-architecture ()
  (expr "SCM_MAKE_STR(GAUCHE_ARCH)"))
(define-cproc gauche-library-directory ()
  (call "Scm_LibraryDirectory"))
(define-cproc gauche-architecture-directory ()
  (call "Scm_ArchitectureDirectory"))
(define-cproc gauche-site-library-directory ()
  (call "Scm_SiteLibraryDirectory"))
(define-cproc gauche-site-architecture-directory ()
  (call "Scm_SiteArchitectureDirectory"))
(define-cproc gauche-dso-suffix ()
  (expr "SCM_MAKE_STR(SHLIB_SO_SUFFIX)"))

;; Other thread stuff is in ext/threads/thrlib.stub
(define-cproc current-thread ()
  (expr "SCM_OBJ(Scm_VM())"))

(define-cproc unwrap-syntax (form)
  (call "Scm_UnwrapSyntax"))

;; foreign pointer
(define-cproc foreign-pointer-attributes (fp::<foreign-pointer>)
  (call "Scm_ForeignPointerAttr"))

(define-cproc foreign-pointer-attribute-get (fp::<foreign-pointer>
                                             key &optional fallback)
  (call "Scm_ForeignPointerAttrGet"))

(define-cproc foreign-pointer-attribute-set (fp::<foreign-pointer>
                                             key value)
  (call "Scm_ForeignPointerAttrSet"))

;;
;; Profiling
;;

;; GC stuff
(define-cproc gc () (call <void> "GC_gcollect"))

(define-keyword total-heap-size "key_total_heap_size")
(define-keyword free-bytes      "key_free_bytes")
(define-keyword bytes-since-gc  "key_bytes_since_gc")
(define-keyword total-bytes     "key_total_bytes")

(define-cproc gc-stat ()
  "  ScmObj h = SCM_NIL, t = SCM_NIL;
  SCM_APPEND(h, t, SCM_LIST2(key_total_heap_size,
                             Scm_MakeIntegerFromUI(GC_get_heap_size())));
  SCM_APPEND(h, t, SCM_LIST2(key_free_bytes,
                             Scm_MakeIntegerFromUI(GC_get_free_bytes())));
  SCM_APPEND(h, t, SCM_LIST2(key_bytes_since_gc,
                             Scm_MakeIntegerFromUI(GC_get_bytes_since_gc())));
  SCM_APPEND(h, t, SCM_LIST2(key_total_bytes,
                             Scm_MakeIntegerFromUI(GC_get_total_bytes())));
  SCM_RETURN(h);")

;; Profiler public API
(define-cproc profiler-start () (call <void> "Scm_ProfilerStart"))
(define-cproc profiler-stop  () (call <int>  "Scm_ProfilerStop"))
(define-cproc profiler-reset () (call <void> "Scm_ProfilerReset"))

;; Misc.  WARNING: API may change
(define-cproc subr? (obj)
  (call <boolean> "SCM_SUBRP"))
(define-cproc closure? (obj)
  (call <boolean> "SCM_CLOSUREP"))
(define-cproc toplevel-closure? (obj)
  (expr <boolean> "SCM_CLOSUREP(obj) && SCM_CLOSURE(obj)->env == NULL"))

(define-cproc closure-code (clo::<closure>)
  (expr "clo->code"))

(define-cproc procedure-info (proc::<procedure>)
  (expr "SCM_PROCEDURE_INFO(proc)"))


;; Local variables:
;; mode: scheme
;; end:
