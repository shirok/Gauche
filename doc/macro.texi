@node Macros, Core library, Core syntax, Top
@chapter Macros
@c NODE マクロ

@c EN
Macro of Lisp-family language is very different feature from
ones of other languages, such as C preprocessor macros.
It allows you to extend the original language syntax.
You can use macros to change Gauche syntax
so that you can run a Scheme program written to other Scheme
implementations, and you can even design your own mini-language
to solve your problem easily.
@c JP
Lisp系言語のマクロは、他の言語に見られるマクロ(例えばCプリプロセッサマクロ)とは
大きく異なります。Lispのマクロは元の言語の構文を拡張する手段なのです。
例えば、Gaucheの構文を若干変えることで他のScheme実装用に書かれたSchemeプログラムを
走らせたり、あるいは自分の問題解決に適した「ミニ言語」をデザインすることさえできます。
@c COMMON

@c EN
Gauche supports hygienic macros, which allows to write safe macros
by avoiding name collisions.  If you know traditional Lisp macros
but new to hygienic macros, they might seem confusing at first.
We have an introductory section (@ref{Why hygienic?}) for those who
are not familiar with hygienic macros; if you know what they are,
you can skip the section.
@c JP
Gaucheは、名前の衝突を避ける安全なマクロを簡単に書ける、「衛生的な(hygienic)」
マクロをサポートします。これは、従来のLispマクロは知っていても衛生的なマクロを
初めて見る人には、やや難解に見えるかもしれません。
衛生的マクロに馴染みが無い読者向けに、紹介の節を用意しました(@ref{Why hygienic?})。
既に衛生的マクロを知っている読者はその節は読み飛ばして構いません。
@c COMMON

@menu
* Why hygienic?::
* Hygienic macros::
* Traditional macros::
* Macro expansion::
* Macro utilities::
@end menu

@node Why hygienic?, Hygienic macros, Macros, Macros
@section Why hygienic?
@c NODE なぜ衛生的マクロか

@c EN
Lisp macro is a programmatic transformation of source code.
A @emph{macro transformer} is a procedure that takes a subtree of
source code, and returns a reconstructed tree of source code.
@c JP
Lispのマクロは、ソースコードをプログラムによって変換するものです。
@emph{マクロ変換器(macro transformer)}が、ソースコードの部分木を受け取り、
加工したソースコードの部分木を返します。
@c COMMON

@c EN
The traditional Lisp macros take the input source code as
an S-expression, and returns the output as another S-expression.
Gauche supports that type of macro, too, with @code{define-macro} form.
Here's the simple definition of @code{when} with the traditional macro.
@c JP
伝統的なLispマクロでは、入力となるソースコードも、出力されるコードも、単なるS式でした。
Gaucheはそのタイプのマクロも@code{define-macro}形式でサポートしています。
例えば、@code{when}は伝統的マクロで次のとおり書けます。
@c COMMON

@example
(define-macro (when test . body)
  `(if ,test (begin ,@@body)))
@end example

@c EN
For example,
if the macro is used as @code{(when (zero? x) (print "zero") 'zero)},
the above macro transformer rewrites it to
@code{(if (zero? x) (begin (print "zero") 'zero))}.  So far, so good.
@c JP
このマクロが@code{(when (zero? x) (print "zero") 'zero)}のように使われたとすれば、
上記の変換器はそれを@code{(if (zero? x) (begin (print "zero") 'zero))}と
書き換えます。一見問題なさそうですね。
@c COMMON

@c EN
But what if the @code{when} macro is used in an environment
where the names @code{begin} or @code{if} is bound to nonstandard values?
@c JP
けれども、@code{begin}や@code{if}が通常とは違う意味で束縛されている環境で
@code{when}が使われたらどうなるでしょう。
@c COMMON

@example
(let ([begin list])
  (when (zero? x) (print "zero") 'zero))
@end example

@c EN
The expanded result would be as follows:
@c JP
展開結果は次の通りになります。
@c COMMON

@example
(let ([begin list])
  (if (zero? x) (begin (print "zero") 'zero)))
@end example

@c EN
This obviously won't work as the macro writer intended, since
@code{begin} in the expanded code refers to the locally bound name.
@c JP
これでは意図した通りには動きません。展開された結果の中の@code{begin}が
ローカル変数と解釈されてしまいます。
@c COMMON

@c EN
This is a form of @emph{variable capture}.  Note that, when Lisp
people talk about variable capture of macros, it often means
another form of capture, where the temporary variables inserted
by a macro would unintentionally capture the variables passed to
the macro.   That kind of variable capture can be avoided easily
by naming the temporary variables something that never conflict,
using @code{gensym}.
@c JP
これは@emph{変数捕捉}の一形態です。Lispのマクロによる変数捕捉というと、
別の形態、すなわちマクロにより導入される一時変数がマクロに渡された式内の
変数を意図せずに捕捉してしまうことが話題に上ることが多いのですが、
そちらは@code{gensym}を使って一時変数を決して衝突しない名前にすることで
簡単に回避できます。
@c COMMON

@c EN
On the other hand, the kind of variable capture in the above example
can't be avoided by @code{gensym}, because @code{(let ([begin list]) ...)}
part isn't under macro writer's control.  As a macro writer, you can
do nothing to prevent the conflict, just hoping the
macro user won't do such a thing.  Sure, rebinding @code{begin} is
a crazy idea that nobody perhaps wants to do, but it can happen on
@emph{any} global variable, even the ones you define for your library.
@c JP
しかし上の例のような変数捕捉は@code{gensym}では回避できません。外側の
@code{(let ([begin list]) ...)}の部分はマクロを書く人には制御できない
からです。マクロ作成者が、この衝突を避けるために出来ることは何もありません。
せいぜい、マクロ使用者がそんな使い方をしないように祈るだけです。
もちろん、@code{begin}を再束縛するなんて誰もやろうとは思わないかもしれませんが、
同様の衝突はあなたのライブラリが提供するものも含めあらゆるグローバル変数について
起こり得るのです。
@c COMMON

@c EN
Various Lisp dialects have tried to address this issue in different
ways.  Common Lisp somewhat relies on the common sense of the
programmer---you can use separate packages to reduce the chance
of accidental conflict but can't prevent the user from binding
the name in the same package.
(The Common Lisp spec says it is undefined if you locally rebind
names of CL standard symbols; but it doesn't prevent you from locally
rebinding symbols that are provided by user libraries.)
@c JP
異なるLisp方言はそれぞれ異なる方法でこの問題に対処してきました。
Common Lispは、ある意味プログラマの常識に頼ります。マクロ作成者は
ライブラリのパッケージを分けることで、偶然名前が衝突してしまう危険性を
減らせますが、マクロ使用者が同じパッケージの名前を再束縛することを防げるわけではありません。
(Common Lispの仕様ではCL標準のシンボルをローカルに再束縛した場合の
動作は未定義とされていますが、ユーザが提供するライブラリについては
何も決められていません。)
@c COMMON

@c EN
Clojure introduced a way to directly refer to the toplevel variables
by a namespace prefix, so it can bypass whatever local bindings of
the same name (also, it has a sophisticated quasiquote form that
automatically renames free variables to refer to the toplevel ones).
It works, as far as there are no local macros.  With
local macros, you need a way to distinguish different local bindings
of the same name, as we see in the later examples.  Clojure's way
can only distinguish between local and toplevel bindings.
It's ok for Clojure which doesn't have local macros,
but in Scheme, we prefer uniform and orthogonal axioms---if functions
can be defined locally with lexical scope, why not macros?
@c JP
Clojureは、名前空間プレフィクスによって直接トップレベル変数を参照する方法を
導入したので、同名のローカル変数束縛をバイパスして意図するトップレベル変数を確実に
参照できます (また、Clojureのquasiquoteは高機能で、自由変数を自動的に
プレフィクスつきのトップレベル変数へと変換してくれます。)
この方法はローカルマクロが存在しない限りはうまくいきます。
ローカルマクロがあると、後の例で見るように、複数の同名のローカル変数束縛を
区別する必要が出てきます。Clojureの方法はローカル変数束縛とトップレベル変数束縛を
区別できるだけです。Clojureにはローカルマクロが無いのでそれでよいのですが、
Schemeは一様で直交する定理を重視するので、レキシカルスコープを持つローカル関数があるなら、
レキシカルスコープを持つローカルマクロもやっぱり欲しいわけです。
@c COMMON

@c EN
Let's look at the local macro with lexical scope.  For the sake of
explanation, suppose we have
@emph{hypothetical} local macro binding form, @code{let-macro},
that binds a local identifiers to a macro transformer.
(We don't actually have @code{let-macro}; what we have is
@code{let-syntax} and @code{letrec-syntax}, which have slightly
different way to call macro transformers.  But here @code{let-macro} may
be easier to understand as it is similar to @code{define-macro}.)
@c JP
レキシカルスコープを持つローカルマクロを見てみましょう。説明のために、
ローカルなマクロ束縛を書ける@code{let-macro}という形式があると仮定します。
(実際には@code{let-macro}形式はありません。マクロ変換器の指定方法が
やや異なる@code{let-syntax}と@code{letrec-syntax}という形式があります。
ただ、ここでは@code{define-macro}と似たような形で例を示す方がわかりやすいので、
そのような@code{let-macro}があるものとして説明します。)
@c COMMON

@example
(let ([f (^x (* x x))])
  (let-macro ([m (^[expr1 expr2] `(+ (f ,expr1) (f ,expr2)))])
    (let ([f (^x (+ x x))])
      (m 3 4))))    ; [1]
@end example

@c EN
The local identifier @var{m} is bound to a macro transformer
that takes two expressions, and returns an S-expression.
So, the @code{(m 3 4)} form [1] would be expanded into
@code{(+ (f 3) (f 4))}.  Let's rewrite the above expression
with the expanded form.  (After expansion, we no longer
need @code{let-macro} form, so we don't include it.)
@c JP
ローカルな識別子@var{m}は、二つの式を引数として取り、S式を返すマクロ変換器に
束縛されます。従って、[1]の@code{(m 3 4)}は
@code{(+ (f 3) (f 4))}へと展開されます。上の式を展開結果を使って
書き直してみます (展開後は@code{let-macro}フォームはもはや必要ないので
展開結果には含めていません)。
@c COMMON

@example
(let ([f (^x (* x x))])
  (let ([f (^x (+ x x))])
    (+ (f 3) (f 4))))  ; [2]
@end example

@c EN
Now, the question.  Which binding @code{f} in the expanded form [2]
should refer?  If we literally interpret the expansion,
it would refer to the inner binding @code{(^x (+ x x))}.
However, following the Scheme's scoping principle, the outer
code should be fully understood regardless of innter code:
@c JP
さてここで問題です。展開結果に現れた[2]のフォーム内の@code{f}は、どちらの
@code{f}を参照すべきでしょう。上の式を文字通り解釈するなら、
より内側にある@code{(^x (+ x x))}への束縛となります。
けれども、Schemeのスコープ規則にしたがえば、
外側のコードは、内側にどんなコードが来るかに関わらず意味が決まって欲しいわけです。
@c COMMON

@example
(let ([f (^x (* x x))])
  (let-macro ([m (^[expr1 expr2] `(+ (f ,expr1) (f ,expr2)))])
@c EN
    ;; The code here isn't expected to accidentally alter
    ;; the behavior defined outside.
@c JP
    ;; ここに書かれたコードがうっかり外側のコードに影響を与えてしまう
    ;; のは避けたい。
@c COMMON
    ))
@end example

@c EN
The macro writer may not know the inner @code{let} shadows
the binding of @code{f} (the inner forms may be @code{include}d,
or may be changed by other person who didn't fully realize
the macro expansion needs to refer outer @code{f}).
@c JP
マクロ作成者は内側の@code{let}が@code{f}をシャドウしてしまうことを
知らないかもしれません(内側のフォームは他のコードを@code{include}している
かもしれませんし、また他の人が、ローカルマクロが外側の@code{f}を参照することに
気づかずに内側のコードを変更してしまうかもしれません。)
@c COMMON

@c EN
To ensure the local macro to work regardless of what's placed
inside @code{let-macro}, we need a sure way to refer the outer
@code{f} in the result of macro expansion.  The basic idea is
to ``mark''
the names inserted by the macro transformer @code{m}---which are
@code{f} and @code{+}---so that we can distinguish two @code{f}'s.
@c JP
@code{let-macro}の中に置かれるコードが何であれローカルマクロが動作するためには、
マクロの展開結果から「外側の@code{f}」を確実に参照する方法が必要です。
基本的なアイディアは、
マクロ変換器@code{m}により挿入される名前(@code{f}と@code{+})に
「印」をつけて、二つの@code{f}を区別するというものです。
@c COMMON

@c EN
For example, if we would rewrite the entire form and @emph{renames}
corresponding local identifiers as follows:
@c JP
例えば、フォーム全体を書き直して、対応するローカル変数がユニークな名前を持つように
@emph{リネーム}したらどうでしょう:
@c COMMON

@example
(let ([f_1 (^x (* x x))])
  (let-macro ([m (^[expr1 expr2] `(+ (f_1 ,expr1) (f_1 ,expr2)))])
    (let ([f_2 (^x (+ x x))])
      (m 3 4))))
@end example

@c EN
Then the naive expansion would correctly preserve scopes; that is,
expansion of @code{m} refers @code{f_1}, which wouldn't conflict
with inner name @code{f_2}:
@c JP
こうしておけばナイーブな展開でもスコープが正しく保たれます。つまり、
@code{m}の展開結果に現れる@code{f_1}は内側の@code{f_2}と衝突しません。
@c COMMON

@example
(let ([f_1 (^x (* x x))])
  (let ([f_2 (^x (+ x x))])
    (+ (f_1 3) (f_1 4))))
@end example

@c EN
(You may notice that this is similar to lambda calculus treating
lexical bindings with higher order functions.)
@c JP
(ラムダ計算において、レキシカルスコープを保ったまま高階関数を扱う際に
似たようなリネーム戦略を見たことがあるかもしれません)
@c COMMON

@c EN
The above example deal with avoiding @code{f} referred from the
macro @emph{definition} (which is, in fact, @code{f_1}) from being
shadowed
by the binding of @code{f} at the macro @emph{use} (which is @code{f_2}).
@c JP
上の例ではマクロの@emph{定義時}に現れる@code{f}(リネーム後は@code{f_1})が
マクロの@emph{使用時}に現れる@code{f} (リネーム後は@code{f_2}) によって
シャドウされることを避ける話でした。
@c COMMON

@c EN
Another type of variable capture (the one most often talked about,
and can be avoided by @code{gensym})
is that a variable in macro use site is shadowed by the binding introduced
by a macro definition.  We can apply the same renaming strategy to
avoid that type of capture, too.  Let's see the following example:
@c JP
一方、もう一つのタイプの変数捕捉 (より頻繁に話題に上る、@code{gensym}で回避できる捕捉) 
は、マクロ使用時の変数がマクロ定義時に導入される束縛によりシャドウされてしまう
という問題です。これについても、同じリネーム戦略が使えます。
次の例を見てみましょう。
@c COMMON

@example
(let ([f (^x (* x x))])
  (let-macro ([m (^[expr1] `(let ([f (^x (+ x x))]) (f ,expr1)))])
    (m (f 3))))
@end example

@c EN
The local macro inserts binding of @code{f} into the expansion.  
The macro use @code{(m (f 3))} also contains a reference to @code{f},
which should be the outer @code{f},
since the macro use is lexically outside of the @code{let} inserted
by the macro.
@c JP
ローカルマクロは@code{f}の束縛を導入しています。
一方、マクロの使用時@code{(m (f 3))}に、@code{f}への参照が含まれています。
後者の@code{f}は外側の@code{f}を指すべきです。なぜならマクロを使っている
フォームは字句上、マクロ定義の@code{let}の外側にあるからです。
@c COMMON

@c EN
We could rename @code{f}'s according to its lexical scope:
@c JP
@code{f}をレキシカルスコープによってリネームすれば次のようになるでしょう。
@c COMMON

@example
(let ([f_1 (^x (* x x))])
  (let-macro ([m (^[expr1] `(let ([f_2 (^x (+ x x))]) (f_2 ,expr1)))])
    (m (f_1 3))))
@end example

@c EN
Then expansion unambiguously distinguish two @code{f}'s.
@c JP
これだと展開しても二つの@code{f}はきちんと区別されます。
@c COMMON

@example
(let ([f_1 (^x (* x x))])
  (let ([f_2 (^x (+ x x))])
    (f_2 (f_1 3))))
@end example

@c EN
This is, in principle, what hygienic macro is about (well, almost).
In reality, we don't rename everything in batch.
One caveat is in the latter example---we statically renamed
@code{f} to @code{f_2}, but it is possible that the macro
recursively calls itself, and we have to distinguish @code{f}'s 
introduced in every individual expansion of @code{m}.
So macro expansion and renaming should work together.
@c JP
以上が、衛生的マクロの原理です (まあ、だいたいは)。
ただし、実際の実装では、すべてを一気にリネームすることはありません。
後者の例のようなケースで注意すべき点があります。後者の例では静的に
@code{f}を@code{f_2}にリネームしましたが、より複雑な場合にマクロ展開器が
再帰的に自分を呼ぶことがあり、その場合にはマクロの展開ごとに挿入される@code{f}を
別のものとして扱う必要があります。
従って、マクロの展開とリネームは協調して動作しなければなりません。
@c COMMON

@c EN
There are multiple strategies to implement it, and the
Scheme standard doesn't want to bind implementations to single
specific strategy.  The standard only states the properties
the macro system should satisfy, in two concise sentences:
@c JP
それを実装する戦略はいくつか考えられます。そして、Scheme標準は実装を
どれかひとつの戦略に縛ってしまうことを良しとしません。
結果的に、標準はマクロシステムが満たすべき性質を、二つの簡潔な
文で示すに止まります：
@c COMMON

@quotation
@c EN
If a macro transformer inserts a binding for an
identifier (variable or keyword), the identifier will in effect be
renamed throughout its scope to avoid conflicts with
other identifiers.
@c JP
マクロ展開器が識別子(変数かキーワード)の束縛を挿入した場合、
識別子はそのスコープ内で実効的にリネームされ、
他の識別子との衝突を避けられる。
@c COMMON

@c EN
If a macro transformer inserts a free reference to an
identifier, the reference refers to the binding that was
visible where the transformer was specified,
regardless of any local bindings that surround the use of the macro.
@c JP
マクロ展開器が識別子の自由参照を挿入した場合、その識別子は展開器が定義された場所から
見える束縛を参照し、マクロが使われる場所を囲むローカル束縛には影響されない。
@c COMMON
@end quotation

@c EN
Just from reading this,
it may not be obvious @emph{how} to realize those properties, and
the existing hygienic macro mechanisms (e.g. @code{syntax-rules}) hide
the ``how'' part.  That's probably one of the reason some people
feel hygienic macros are difficult to grasp.  It's like
continuations---its description is concise but at first
you have no idea how it works; then, through experience,
you become familiarized yourself to it, and then you reread
the original description and understand it says exactly what it is.
@c JP
これを読んだだけでは、これらの性質を@emph{いかにして}実現するかは
すぐにはわからないかもしれません。そして既存の衛生的マクロ(@code{syntax-rules}など)は
この@emph{いかにして}の部分を隠しています。それが、
衛生的マクロをとっつきにくく思う理由の一つかもしれません。
これはある意味、継続に似ています。継続の仕様はごく簡潔に述べられていて、
最初に読んだときにはどう動くかさっぱりわからないかもしれません。
しかし経験を積んで使うのに慣れた後でもう一度元の説明を読むと、
必要十分なことが書いてあるとわかるのです。
@c COMMON

@c EN
This introduction may not answer @emph{how} the hygienic macro
realizes those properties, but I hope it showed @emph{what} it does
and @emph{why} it is needed.  In the following chapters we introduce
a couple of hygienic macro mechanisms Gauche supports, with examples,
so that you can familiarize yourself to the concept.
@c JP
この節では@emph{いかにして}衛生的マクロがこれらの性質を
実現しているかについての詳細には触れませんでしたが、
衛生的マクロが@emph{何を}して、@emph{何のために}必要かについて
ある程度示せたのではないかと思います。
以降の節では、Gaucheがサポートする衛生的マクロシステムについて
例を交え紹介してゆきます。
@c COMMON


@node Hygienic macros, Traditional macros, Why hygienic?, Macros
@section Hygienic macros
@c NODE 衛生的マクロ

@c EN
@subheading Macro bindings
@c JP
@subheading マクロ束縛
@c COMMON

@c EN
The following forms establish bindings of @var{name} and
a macro transformer created by @var{transformer-spec}.  The
binding introduced by these forms shadows
a binding of @var{name} established in outer scope, if there's any.
@c JP
以下のフォームは@var{transformer-spec}で作られるマクロ変換器と
@var{name}の束縛を作ります。外側のスコープに@var{name}の束縛があれば、
それはシャドウされます。
@c COMMON

@c EN
For toplevel bindings, it will shadow bindings of @var{name} imported
or inherited from other modules (@pxref{Modules}).
(Note: This toplevel shadowing behavior is Gauche's extension;
in R7RS, you shouldn't redefine imported bindings, so the portable
code should avoid it.)
@c JP
トップレベル束縛の場合、@var{name}に他のモジュールからインポートされたり
継承されている束縛があれば、それをシャドウすることになります
(@ref{Modules}参照)。
(註:モジュール内でのトップレベル束縛がインポートした束縛をシャドウするのは
Gaucheの拡張です。R7RSではインポートした束縛の再定義はしてはいけないことに
なっているので、ポータブルなコードでは避けて下さい)。
@c COMMON

@c EN
The effect is undefined if you bind the same name more than once
in the same scope.
@c JP
同じスコープで同じ名前を複数回束縛した場合の動作は未定義です。
@c COMMON

@c EN
The @var{transformer-spec} can be either one of @code{syntax-rules}
form, @code{er-macro-transformer} form, or another macro keyword
or syntactic keyword.  We'll explain them later.
@c JP
@var{transformer-spec}は@code{syntax-rules}フォーム、
@code{er-macro-transformer}フォーム、あるいは他のマクロキーワードか
構文キーワードです。これについては後述します。
@c COMMON

@defspec define-syntax name transformer-spec
[R7RS base]
@c EN
If this form appears in toplevel, it binds toplevel @var{name} to
a macro transformer defined by @var{transformer-spec}.

If this form appears in the @emph{declaration} part of
body of @code{lambda} (internal define-syntax), @code{let} and
other similar forms, it binds @var{name} locally within that body.
Internal @code{define-syntax}es are converted to @code{letrec-syntax},
just like internal @code{define}s are converted to @code{letrec*}.
@c JP
トップレベルで使われた場合、このフォームはトップレベルの@var{name}を
@var{transformer-spec}で定義されるマクロ変換器に束縛します。

@code{lambda}、@code{let}等の本体の宣言部分に使われた場合 (内部define-syntax)、
その本体内のスコープで@var{name}を束縛します。
内部defineが@code{letrec*}に変換されるのと同じように、
内部define-syntaxは@code{letrec-syntax}へと変換されます。
@c COMMON
@end defspec

@defspec let-syntax ((name transformer-spec) @dots{}) body
@defspecx letrec-syntax ((name transformer-spec) @dots{}) body
[R7RS base]
@c EN
Defines local macros.  Each @var{name} is bound to a macro
transformer as specified by the corresponding @var{transformer-spec},
then @code{body} is expanded.  With @code{let-syntax},
@var{transformer-spec} is evaluated with the scope
surrounding @code{let-syntax}, while with @code{letrec-syntax}
the bindings of @var{name}s are included in the scope where
@var{transformer-spec} is evaluated.  Thus @code{letrec-syntax}
allows mutually recursive macros.
@c JP
ローカルマクロを定義します。各@var{name}が
対応する@var{transformer-spec}で定義されるマクロ変換器へと束縛された
環境を作り@var{body}を評価します。
@code{let-synta}では、@var{transformer-spec}は@code{let-syntax}を
囲むスコープ内で@var{transformer-spec}を評価するのに対し、
@code{letrec-syntax}では@var{name}の束縛がなされた環境で
@var{transformer-spec}を評価します。つまり@code{letrec-syntax}は
相互再帰的なマクロを定義できます。
@c COMMON
@end defspec

@subheading Transformer specs

@c EN
The @var{trasformer-spec} is a special expression that evaluates
to a macro transformer.  It is evaluated in a different phase
than the other expressions, since macro transformers must be
executed during compiling.  So there are some restrictions.

At this moment, only one of the following expressions are allowed:
@c JP
@var{transformer-spec}は、マクロ展開器へと評価される特別な式です。
マクロ変換器はコンパイル時に実行されるため、他の式とは異なった段階で評価されます。
そのためにいくらか制限があります。

現在のところ、以下の上げる式しか許されていません。
@c COMMON

@enumerate
@item
@c EN
A @code{syntax-rules} form.   This is called ``high-level'' macro,
for it uses pattern matching entirely, which is basically a
different declarative language from Scheme, thus putting the
complication of the phasing and hygiene issues completely under the hood.
Some kind of macros are easier to write in @code{syntax-rules}.
@xref{Syntax-rules macro transformer}, for further description.
@c JP
@code{syntax-rules}フォーム。これは「高レベル」マクロと呼ばれ、
パターンマッチングのみによってマクロを定義します。
これはSchemeとは異なる一種の宣言的言語で、
マクロの段階や衛生の問題をボンネットの下に隠してしまいます。
ある種のマクロは@code{syntax-rules}でより簡単に書けます。
詳しくは@ref{Syntax-rules macro transformer}を参照してください。
@c COMMON

@item
@c EN
An @code{er-macro-transformer} form.  This employs @emph{explicit-renaming}
(ER) macro, where you can use arbitrary Scheme code to transform
the program, with required renaming to keep hygienity.  The legacy
Lisp macro can also be written with ER macro if you don't use
renaming.  @xref{Explicit-renaming macro transformer}, for the details.
@c JP
@code{er-macro-transfomer}フォーム。
これは@emph{explicit renaming}(ER)マクロを定義します。
ERマクロでは、必要な衛生を保ちながら、任意のSchemeコードを使って変換を書けます。
伝統的なLispのマクロは、ERマクロでリネームを使わない特別な場合と考えられます。
詳しくは@ref{Explicit-renaming macro transformer}を参照してください。
@c COMMON

@item
@c EN
Macro or syntax keyword.  This is Gauche's extension, and can be
used to define alias of existing macro or syntax keyword.
@c JP
マクロキーワードか構文キーワード。これはGauche独自の拡張で、
既存のマクロキーワードや構文キーワードの別名を定義するものです。
@c COMMON
@example
(define-syntax si if)
(define écrivez write)

(si (< 2 3) (écrivez "oui"))
@end example
@end enumerate



@menu
* Syntax-rules macro transformer::
* Explicit-renaming macro transformer::
@end menu

@node Syntax-rules macro transformer, Explicit-renaming macro transformer, Hygienic macros, Hygienic macros
@subsection Syntax-rules macro transformer
@c NODe Syntax-rulesマクロ変換器

@defspec syntax-rules (literal @dots{}) clause clause2 @dots{}
@defspecx syntax-rules ellipsis (literal @dots{}) clause clause2 @dots{}
[R7RS base]
@c EN
This form creates a macro transformer by pattern matching.

Each @var{clause} has the following form:
@c JP
パターンマッチングによるマクロ変換器を作ります。

各@var{clause}は次の形式です。
@c COMMON

@example
(@var{pattern} @var{template})
@end example

@c EN
A @var{pattern} denotes a pattern to be matched to the macro call.
It is an S-expression that matches if the macro call has the same
structure, except that symbols in @var{pattern} can match a whole subtree
of the input; the matched symbol is called a @emph{pattern variable},
and can be referenced in the @var{template}.
@c JP
@var{pattern}はマクロ呼び出しにマッチすべきパターンを記述します。
パターンはS式で、マクロ呼び出しの式と同じ構造を持っている場合にマッチします。
但し、パターン中のシンボルは@emph{パターン変数}と呼ばれ、
マクロ呼び出し式の対応する任意の部分木とマッチし、
@var{template}の中でマッチした部分木を参照するのに使えます。
@c COMMON

@c EN
For example, if a pattern is @code{(_ "foo" (a b))}, it can match the
macro call @code{(x "foo" (1 2))}, or @code{(x "foo" (1 (2 3)))}, but does
not match @code{(x "bar" (1 2))}, @code{(x "foo" (1))} or
@code{(x "foo" (1 2) 3)}.  You can also match repeating structure or
literal symbols; we'll discuss it fully later.
@c JP
例えば、パターンが@code{(_ "foo" (a b))}であったとすると、それは
@code{(x "foo" (1 2))}や@code{(x "foo" (1 (2 3)))}といったマクロ呼び出しとマッチしますが、
@code{(x "bar" (1 2))}、@code{(x "foo" (1))}、@code{(x "foo" (1 2) 3)}とは
マッチしません。
さらに、後で説明するように、繰り返しのある構造やリテラルシンボルとマッチするような記述も可能です。
@c COMMON

@c EN
Clauses are examined in order to see if the macro call form matches
its pattern.  If matching pattern is found, the corresponding @var{template}
replaces the macro call form.  A pattern variable in the template is
replaced with the subtree of input that is bound to the pattern variable.
@c JP
@var{clause}は順番に、そのパターンにマクロ呼び出しとマッチするかが検査されます。
マッチするパターンが見つかれば、対応する@var{template}でマクロ呼び出しの式が
置き換えられます。@var{template}中のパターン変数は、
マクロ呼び出し式のその変数にマッチした部分木で置き換えられます。
@c COMMON

@c EN
Here's a definition of @code{when} macro in @ref{Why hygienic?},
using @code{syntax-rules}:
@c JP
これは@ref{Why hygienic?}で例に出した@code{when}マクロを
@code{syntax-rules}で書いたものです:
@c COMMON

@example
(define-syntax when
  (syntax-rules ()
    [(_ test body ...) (if test (begin body ...))]))
@end example

@c EN
The pattern is @code{(_ test body ...)}, and the template is
@code{(if test (begin body ...))}.
The ellipsis @code{...} is a symbol; we're not omitting code here.
It denotes that the previous pattern (@code{body}) may
repeat zero or more times.
@c JP
パターンが@code{(_ test body ...)}で、
テンプレートが@code{(if test (begin body ...))}です。
@code{...} (エリプシス) は、記述を省略しているわけではなく、
ピリオド3つからなる名前を持つシンボルです。
これは直前のパターン(@code{body})がゼロ個以上繰り替えされるということを示します。
@c COMMON

@c EN
So, if the @code{when} macro is called as
@code{(when (zero? x) (print "huh?") (print "we got zero!"))},
the macro expander first check if the input matches the pattern.
@c JP
@code{when}マクロが
@code{(when (zero? x) (print "huh?") (print "we got zero!"))}
という形で呼び出されたとしまそう。
マクロ展開器はまず、この入力がパターンとマッチするかどうかを調べます。
@c COMMON

@itemize @bullet
@item
@c EN
The @var{test} in pattern matches the input @code{(zero? x)}.
@c JP
パターン中の@var{test}は入力の@code{(zero? x)}とマッチ。
@c COMMON
@item
@c EN
The @var{body} in pattern matches the input @code{(print "huh?")} 
@emph{and} @code{(print "we got zero!")}.
@c JP
パターン中の@var{body}は入力の@code{(print "huh?")}および@code{(print "we got zero!")}とマッチ
@c COMMON
@end itemize

@c EN
The matching of @var{body} is a bit tricky; as a pattern variable,
you may think that @var{body} works like an array variable, each element
holds each match---and you can use them in similarly
repeating substructures in template.
Let's see the template, now that the input fully matched the pattern.
@c JP
@var{body}とのマッチングはちょっとややこしいです。
パターン変数@var{body}は配列のようなものだと考えても良いでしょう。
配列の各要素がマッチする入力の部分木を保持します。
その値は、テンプレート中の似たような繰り返し部分構造の中で使うことができます。
ここまでで入力がパターンにマッチしたので、テンプレートの方を見てみましょう。
@c COMMON

@itemize @bullet
@item
@c EN
In the template, @code{if} and @code{begin} are not pattern variable,
since they are not appeared in the pattern.
So they are inserted as identifiers---that is, hygienic symbols effectively
renamed to make sure to refer to the global @code{if} and @code{begin},
and will be unaffected by the macro use environment.
@c JP
テンプレート中の@code{if}と@code{begin}はパターン中に現れていないので
パターン変数ではありません。従って、識別子として出力に挿入されます。
ここで、識別子@code{if}や@code{begin}はこのマクロのスコープから見えるグローバルな
@code{if}や@code{begin}を常に参照できるように、衛生的に扱われます。
マクロが使われた場所で@code{if}や@code{begin}がシャドウされていたとしても影響を受けません。
@c COMMON
@item
@c EN
The @var{test} in the template is a pattern variable, so it is replaced
for the matched value, @code{(zero? x)}.
@c JP
テンプレート中の@var{test}はパターン変数なので、マッチした値である@code{(zero? x)}へと
置き換えられます。
@c COMMON
@item
@c EN
The @var{body} is also a pattern variable.  The important point is
that it is also followed by ellipsis.  So we repeat @var{body} as many
times as the number of matched values.
The first value, @code{(print "huh?")}, and the second value,
@code{(print "we got zero!")}, are expanded here.
@c JP
@var{body}もパターン変数です。重要な点はここでも@var{body}の後にエリプシスがあることで、
@var{body}はパターン変数にマッチした値のぶんだけ繰り返されます。
最初のマッチした値である@code{(print "huh?")}と、次の
@code{(print "we got zero!")}とがここに展開されます。
@c COMMON
@item
@c EN
Hence, we get
@code{(if (zero? x) (begin (print "huh?") (print "we got zero!")))}
as the result of expansion.  (With the note that @code{if} and @code{begin}
refers to the identifiers visible from the macro definition environment.)
@c JP
以上から、最終的な展開結果として
@code{(if (zero? x) (begin (print "huh?") (print "we got zero!")))}
が得られます (このうち、@code{if}と@code{begin}は
マクロ定義環境から見える識別子を指すようになっています)。
@c COMMON
@end itemize

@c EN
The expansion of ellipses is quite powerful.  In the template,
the ellipses don't need to follow the sequence-valued pattern variable
immediately; the variable can be in a substructure, as long as the
substructure itself is followed by an ellipsis.
See the following example:
@c JP
エリプシスを使った展開はかなり強力です。
テンプレート中で、エリプシスは複数の値を持つパターン変数の直後にある必要はありません。
そういった変数を中に含む部分構造をエリプシスで繰り返すことも可能です。
次の例を見てください。
@c COMMON

@example
(define show
  (syntax-rules ()
    [(_ expr ...)
     (begin 
       (begin (write 'expr) (display "=") (write expr) (newline)) 
       ...)]))
@end example

@c EN
If you call this macro as follows:
@c JP
このマクロを次のように呼ぶと:
@c COMMON

@example
(show (+ 1 2) (/ 3 4))
@end example

@c EN
It is expanded to the following form, modulo hygienity:
@c JP
以下のとおりに展開されます (シンボルの衛生性は保たれているとします)。
@c COMMON

@example
(begin
  (begin (write '(+ 1 2)) (display "=") (write (+ 1 2)) (newline))
  (begin (write '(/ 3 4)) (display "=") (write (/ 3 4)) (newline)))
@end example

@c EN
So you'll get this output.
@c JP
これを実行すれば、以下の出力が得られるでしょう。
@c COMMON

@example
(+ 1 2)=3
(/ 3 4)=3/4
@end example

@c EN
You can also match with a repetition of substructures in the pattern.
The following example is a simplified @code{let} that expands to
@code{lambda}:
@c JP
また、パターン中の部分構造を繰り返しマッチするのにも使えます。
次の例は@code{let}を@code{lambda}に展開する、簡略化した例です:
@c COMMON

@example
(define-syntax my-let
  (syntax-rules ()
    [(_ ((var init) ...) body ...)
     ((lambda (var ...) body ...) init ...)]))
@end example

@c EN
If you call it as @code{(my-let ((a expr1) (b expr2)) foo)},
then @var{var} is matched to @code{a} and @code{b},
while @var{init} is matched to @code{expr1} and @code{expr2}, respectively.
They can be used separately in the template.
@c JP
このマクロを@code{(my-let ((a expr1) (b expr2)) foo)}のように呼び出すと、
@var{var}は@code{a}および@code{b}に、
@var{init}は@code{expr1}および@code{expr2}にそれぞれマッチします。
@var{var}と@var{init}はテンプレート中でばらばらに使うことができます。
@c COMMON

@c EN
Suppose ``level'' of a pattern variable
means the number of nested ellipses that designate repetition of the pattern
variable.
A subtemplate can be followed as many ellipses as the maximum level of
pattern variables in the subtemplate.
In the following example, the level of pattern variable @code{a} is 1
(it is repeated by the last ellipsis in the pattern),
while the level of @code{b} is 2 (repeated by the last two ellipses),
and the level of @code{c} is 3 (repeated by all the ellipses).
@c JP
パターン変数の繰り返しを示すエリプシスの入れ子の数を、
そのパターン変数のレベルと呼ぶことにします。
サブテンプレートは、その中に含まれるパターン変数のレベルの最大値と同じだけの
エリプシスの入れ子に中になければなりません。
次の例では、パターン変数@code{a}のレベルは1 (最後のエリプシスによって繰り返される)、
@code{b}は2 (後ろの2つのエリプシスで繰り返される)、
@code{c}は3 (全てのエリプシスで繰り返される) です。
@c COMMON

@example
(define-syntax ellipsis-test
  (syntax-rules ()
    [(_ (a (b c ...) ...) ...)
     '((a ...)
       (((a b) ...) ...)
       ((((a b c) ...) ...) ...))]))
@end example

@c EN
In this case, the subtemplate @code{a} must be repeated by one level
of ellipsis, @code{(a b)} must be repeated by two,
and @code{(a b c)} must be repeated by three.
@c JP
したがって、サブテンプレート @code{a} は1重、
サブテンプレート @code{(a b)}は2重、
@code{(a b c)}は3重のエリプシスで繰り返されることになります。
@c COMMON

@example
(ellipsis-test (1 (2 3 4) (5 6)) (7 (8 9 10 11)))
 @result{} ((1 7)
    (((1 2) (1 5)) ((7 8)))
    ((((1 2 3) (1 2 4)) ((1 5 6))) (((7 8 9) (7 8 10) (7 8 11)))))
@end example

@c EN
In the template, more than one ellipsis directly follow a subtemplate,
splicing the leaves into the surrounding list:
@c JP
また、サブテンプレートの後ろには複数のエリプシスを直接置くことができ、
繰り返しの「葉」の部分がそこにスプライスされます。
@c COMMON

@example
(define-syntax my-append
  (syntax-rules ()
    [(_ (a ...) ...)
     '(a ... ...)]))

(my-append (1 2 3) (4) (5 6))
  @result{} (1 2 3 4 5 6)

(define-syntax my-append2
  (syntax-rules ()
    [(_ ((a ...) ...) ...)
     '(a ... ... ...)]))

(my-append2 ((1 2) (3 4)) ((5) (6 7 8)))
  @result{} (1 2 3 4 5 6 7 8)
@end example

@c EN
Note: Allowing multiple ellipses to directly follow a subtemplate,
and a pattern variable in a subtemplate to be enclosed within more
than the variable's level of nesting of ellipses, are extention to
R7RS, and defined in SRFI-149.  In the above examples, 
@code{ellipsis-test}, @code{my-append} and @code{my-append2} are
outside of R7RS.
@c JP
註：サブテンプレートの直後に複数のエリプシスを置くこと、
及びパターン変数をそのレベルよりもエリプシスのネストが深いテンプレート中に置けることは、
R7RSに対する拡張で、SRFI-149で定義されています。上記の例では、
@code{ellipsis-test}、@code{my-append}、@code{my-append2}が
R7RSの範囲外になります。
@c COMMON

@end defspec

@node Explicit-renaming macro transformer,  , Syntax-rules macro transformer, Hygienic macros
@subsection Explicit-renaming macro transformer
@c NODE Explcit-renamingマクロ変換器

@defspec er-macro-transformer procedure-expr
@c EN
Creates a macro transformer from the given @var{procedure-expr}.
The created macro transformer has to be bound to the syntactic keyword
by @code{define-syntax}, @code{let-syntax} or @code{letrec-syntax}.
Other use of macro transformers is undefined.

The @var{procedure-expr} must evaluate to a procedure that takes
three arguments; @var{form}, @var{rename} and @var{id=?}.

The @var{form} argument receives the S-expression of
the macro call.  The @var{procedure-expr} must return an
S-expression as the result of macro expansion.  This part is pretty much
like the traditional lisp macro.  In fact, if you ignore @var{rename}
and @var{id=?}, the semantics is the same as the traditional
(unhygienic) macro.  See the following example
(Note the use of @code{match}; it is a good
tool to decompose macro input):
@c JP
@var{procedure-expr}からマクロ変換器を作ります。
作られたマクロ変換器は、@code{define-syntax}、@code{let-syntax}、
@code{letrec-syntax}により構文キーワードに束縛されなければなりません。
マクロ変換器の他の用途は定義されていません。

@var{procedure-expr}は3つの引数、@var{form}、@var{rename}、@var{id=?}を
取る手続きへと評価される式です。

@var{form}引数には、マクロ呼び出しのS式そのものが渡されます。
@var{procedure-expr}はマクロ展開の結果をS式として返します。
この点は、伝統的なマクロとよく似ています。実のところ、
@var{rename}と@var{id=?}を無視すれば、セマンティクスは伝統的な(非衛生な)マクロと
同じになります。次の例を見てください
(この例では@code{match}を使っています。マクロの入力を分解するのにも
手軽なツールです。)
@c COMMON

@example
(use util.match)

;; Unhygienic 'when-not' macro
(define-syntax when-not
  (er-macro-transformer
    (^[form rename id=?]
      (match form
        [(_ test expr1 expr ...)
         `(if (not ,test) (begin ,expr1 ,@@expr))]
        [_ (error "malformed when-not:" form)]))))

(macroexpand '(when-not (foo) (print "a") 'boo))
  @result{} (if (not (foo)) (begin (print "a") 'boo))
@end example

@c EN
This is ok as long as you know you don't need hygiene---e.g. when
you only use this macro locally in your code, knowning all the
macro call site won't contain name conflicts.  However, if you
provide your @code{when-not} macro for general use,
you have to protect namespace pollution around the macro use.
For example, you want to make sure your macro work even if it is
used as follows:
@c JP
衛生を気にする必要がない場合は、これでも十分です。
例えばマクロを自分で書いたコードの中だけで使い、
すべてのマクロ呼び出しを把握していて名前の衝突が起きないことを知っている場合です。
けれども、この@code{when-not}マクロを広く使えるようにするなら、
マクロの使われる場所での名前の衝突からの防御が必要です。
たとえば、次のとおり呼び出されたとしてもちゃんと動くようにしたい場合です。
@c COMMON

@example
(let ((not values))
  (when-not #t (print "This shouldn't be printed")))
@end example

@c EN
The @var{rename} argument passed to @var{procedure-expr} is
a procedure that takes a symbol (or, to be precise, a symbol or
an identifier) and @emph{effectively renames} it to a unique 
identifier that keeps identity within the macro definition environment and
won't be affected in the macro use environment.
@c JP
@var{procedure-expr}に渡される@var{rename}引数は、
シンボル(正確には、シンボルか識別子)を取り、それをマクロ定義時の環境を保持する
ユニークな識別子へと@emph{実質的にリネームする}手続きです。
リネームされた識別子はマクロ使用時の環境には影響を受けません。
@c COMMON

@c EN
As a rule of thumb, you have to pass
@emph{all new identifiers you insert into macro output} to the
@var{rename} procedure to keep hygiene.  In our @code{when-not} macro,
we insert @code{if}, @code{not} and @code{begin} into the macro output,
so our hygienic macro would look like this:
@c JP
大雑把なルールとして、マクロの出力に挿入する識別子はすべて@var{rename}を通すことを
徹底すれば、衛生は保たれます。@code{when-not}マクロの例では、
マクロの出力に@code{if}、@code{not}、@code{begin}を挿入していますから、
衛生的なバージョンは次のとおり書けます。
@c COMMON

@example
(define-syntax when-not
  (er-macro-transformer
    (^[form rename id=?]
      (match form
        [(_ test expr1 expr ...)
         `(,(rename 'if) (,(rename 'not) ,test)
            (,(rename 'begin) ,expr1 ,@@expr))]
        [_ (error "malformed when-not:" form)]))))
@end example

@c EN
This is cumbersome and makes it hard to read the macro, so Gauche
provides an auxiliary macro @code{quasirename}, which works like
@code{quasiquote} but renaming identifiers in the form.  See the
entry of @code{quasirename} below for the details.  You can write
the hygienic @code{when-not} as follows:
@c JP
でもこれは面倒ですし読みづらいですね。そこでGaucheでは、
補助マクロ@code{quasirename}を用意しています。これは@code{quasiquote}のように
動作しますが、フォーム中の識別子をリネームしてゆきます。詳しくは後述の
@code{quasirename}のエントリを参照してください。@code{quasirename}を使うと
衛生的な@code{when-not}はこうなります:
@c COMMON

@example
(define-syntax when-not
  (er-macro-transformer
    (^[form rename id=?]
      (match form
        [(_ test expr1 expr ...)
         (quasirename rename
           (if (not ,test) (begin ,expr1 ,@@expr)))]
        [_ (error "malformed when-not:" form)]))))
@end example

@c EN
You can intentionally break hyginene by inserting a symbol
without renaming.  The following code implements
@emph{anaphoric} @code{when}, meaning the result of the
test expression is available in the @var{expr1} @var{exprs} @dots{}
with the name @code{it}.  Since the binding of the identifier @code{it}
does not exist in the macro use site, but rather injected into
the macro use site by the macro expander, it is unhygienic.
@c JP
シンボルをリネームせずに挿入すれば、意図的に衛生を破ることができます。
次のコードは@emph{アナフォリック(前方照応的)な}@code{when}を定義しています。
つまり、テスト式の結果が、@var{expr1} @var{exprs} @dots{} から@code{it}という
変数で参照できるということです。
@code{it}の束縛はマクロ呼び出し箇所には無かったもので、
マクロ展開器により挿入されるので、これは非衛生マクロになります。
@c COMMON

@example
(define-syntax awhen
  (er-macro-transformer
    (^[form rename id=?]
      (match form
        [(_ test expr1 expr ...)
         `(,(rename 'let1) it ,test     ; 'it' is not renamed
             (,(rename 'begin) ,expr1 ,@@expr))]))))
@end example

@c EN
If you use @code{quasirename}, you can write @code{,'it} to prevent
@code{it} from being renamed:
@c JP
@code{quasirename}を使う場合、@code{it}がリネームされないようにするには
@code{,'it}と書きます。
@c COMMON

@example
(define-syntax awhen
  (er-macro-transformer
    (^[form rename id=?]
      (match form
        [(_ test expr1 expr ...)
         (quasirename rename
           (let1 ,'it ,test
             (begin ,expr1 ,@@expr)))]))))
@end example

@c EN
Here's an example:
@c JP
使用例を見てみましょう。
@c COMMON

@example
(awhen (find odd? '(0 2 8 7 4))
  (print "Found odd number:" it))
 @result{} @r{prints} Found odd number:7
@end example

@c EN
Finally, the @var{id=?} argument to the @var{procedure-expr} is
a procedure that takes two arguments, and returns @code{#t} iff
both are identifiers and either both are referring to the same binding
or both are free.  It can be used to compare literal syntactic keyword
(e.g. @code{else} in @code{cond} and @code{case} forms) hygienically.

The following @code{if=>} macro behaves like @code{if}, except that
it accepts @code{(if=> test => procedure)} syntax,
in which @code{procedure} is called with the value of @code{test}
if it is not false (similar to @code{(cond [test => procedure])} syntax).
The symbol @code{=>} must match hygienically,
that is, it must refer to the same binding as in the macro definition.
@c JP
最後に、@var{procedure-expr}の@var{id=?}引数はふたつの引数を取り、
それらがともに識別子であって、しかも同じ束縛を参照するか束縛されていないか、という
場合に限り@code{#t}を返します。
これはリテラル構文キーワード(@code{cond}や@code{case}フォームの@code{else}等)
を比較するのに使えます。

下の@code{if=>}マクロは@code{if}と同じように動作しますが、
@code{(if=> test => procedure)}のように呼ばれた場合、
@code{(cond [test => procedure])}構文と同じように、
@code{test}が真の値を返した際には結果を引数にして@code{procedure}を呼び出します。
シンボル@code{=>}は衛生的に比較されます。つまり、マクロ定義時と同じ束縛を
参照している場合にのみ有効となります。
@c COMMON

@example
(define-syntax if=>
  (er-macro-transformer
    (^[form rename id=?]
      (match form
        [(_ test a b)
         (if (id=? (rename '=>) a)
           (quasirename rename
             (let ((t ,test))
               (if t (,b t))))
           (quasirename rename
             (if ,test ,a ,b)))]))))
@end example

@c EN
The call @code{(rename '=>)} returns an identifier that captures
the binding of @code{=>} in the macro definition, and using
@code{id=?} with the thing passed to the macro argument
checks if both refer to the same binding.
@c JP
@code{(rename '=>)}とすることで、マクロ定義時における@code{=>}の束縛を
参照する識別子を手に入れ、@code{id=?}でそれをマクロ引数から渡された式と
比較しています。
@c COMMON

@example
(if=> 3 => list)  @result{} (3)
(if=> #f => list) @result{} #<undef>

@c EN
;; If the second argument isn't =>, if=> behaves like ordinary if:
@c JP
;; 第二引数が=>でなければ、if=>は通常のifと同じ:
@c COMMON
(if=> #t 1 2)     @result{} 1

@c EN
;; The binding of => in macro use environment differs from
;; the macro definition environment, so this if=> behaves like
;; ordinary if, instead of recognizing literal =>.
@c JP
;; 下の例ではマクロ呼び出しでの=>の束縛がマクロ使用時の束縛と違っているため、
;; => はリテラルと認識されず、if=> は通常のifとして振る舞う。
@c COMMON
(let ((=> 'oof)) (if=> 3 => list)) @result{} oof
@end example
@end defspec

@defmac quasirename renamer form
@c EN
It works like quasiquote, except that the symbols and identifiers
that appear in the ``literal'' portion of @var{form} (i.e. outside
of @code{unquote} and @code{unquote-splicing}) are replaced
by the result of applying @var{rename} on themselves.
@c JP
@var{form}中の「リテラル」な部分 (@code{unquote}や@code{unquote-splicing}の外側)
に現れるシンボルや識別子が@var{rename}によってリネームされることを除いて、
準クオートのように動作します。
@c COMMON

@c EN
For example, a form:
@example
(quasirename r (a ,b c "d"))
@end example
would be equivalent to write:
@example
(list (r 'a) b (r 'c) "d")
@end example
@c JP
例えば次のフォームは:
@example
(quasirename r (a ,b c "d"))
@end example
次のとおり書くのと同じです:
@example
(list (r 'a) b (r 'c) "d")
@end example
@c COMMON

@c EN
This is not specifically tied to macros; the @var{renamer} can
be any procedure that takes one symbol or identifier argument:
@c JP
この手続きはマクロ専用というわけではありません。
@var{renamer}はシンボルか識別子を取る手続きであれば何でも構いません。
@c COMMON

@example
(quasirename (^[x] (symbol-append 'x: x)) (+ a ,(+ 1 2) 5))
  @result{} (x:+ x:a 3 5)
@end example

@c EN
However, it comes pretty handy to construct the result form
in ER macros.  Compare the following two:
@c JP
ただ、ERマクロを書く際にとても便利なのは確かです。次の2つを比べてみてください。
@c COMMON

@example
(use util.match)

;; using quasirename
(define-syntax swap
  (er-macro-transformer
    (^[f r c]
      (match f
        [(_ a b) (quasirename r
                   (let ((tmp ,a))
                     (set! ,a ,b)
                     (set! ,b tmp)))]))))

;; not using quasirename
(define-syntax swap
  (er-macro-transformer
    (^[f r c]
      (match f
        [(_ a b) `((r'let) (((r'tmp) ,a))
                     ((r'set!) ,a ,b)
                     ((r'set!) ,b (r'tmp)))]))))
@end example
@end defmac


@node Traditional macros, Macro expansion, Hygienic macros, Macros
@section Traditional macros
@c NODE 伝統的なマクロ

@defspec define-macro name procedure
@defspecx define-macro (name . formals) body @dots{}
@c EN
Defines @var{name} to be a global macro whose transformer is @var{procedure}.
The second form is a shorthand notation of the following form:
@c JP
変換子が @var{procedure} である大域マクロ @var{name} を定義します。
2番目のフォームは、以下のフォームの簡易記法です。
@c COMMON
@example
(define-macro name (lambda formals body @dots{}))
@end example

@c EN
When a form @code{(name @var{arg} @dots{})} is seen by the compiler,
it calls @var{procedure} with @var{arg} @dots{}.  When @var{procedure}
returns, the compiler inserts the returned form in place of the original
form, and compile it again.
@c JP
コンパイラが @code{(name @var{arg} @dots{})} というフォームを見つけると、
@var{arg} @dots{} を引数として @var{procedure} を呼び出します。
@var{procedure} が戻ると、コンパイラは元のフォームの場所に返されたフォームを
挿入し、再度それをコンパイルします。
@c COMMON
@end defspec

@node Macro expansion, Macro utilities, Traditional macros, Macros
@section Macro expansion
@c NODE マクロの展開

@defun macroexpand form
@defunx macroexpand-1 form
@c EN
If @var{form} is a list and its first element is a variable
globally bound to a macro, @code{macroexpand-1}
invokes its macro transformer and
returns the expanded form.  Otherwise, returns @var{form} as is.

@code{macroexpand} repeats @code{macroexpand-1} until the
@var{form} can't be expanded.

These procedures can be used to expand globally defined macros.
@c JP
@var{form} がリストで、その最初の要素が大域的にマクロに束縛された
変数であるならば、@code{macroexpand-1}はそのマクロ変換子を実行し、
展開されたフォームを返します。そうでなければ、@var{form} をそのまま
返します。

@code{macroexpand} は、@var{form} が展開できなくなるまで
@code{macroexpand-1} を繰り返します。

これらの手続きは、大域的に定義されたマクロを展開するために使うことが
できます。
@c COMMON
@end defun

@defun macroexpand-all form
@c EN
Fully expand macros inside @var{form}.  The result only contains
function calls and Gauche's built-in syntax.
The @var{form} is assumed to be a toplevel form within the current module.
(@xref{Module semantics}, for the concept of the current module.
It can be tricky, for sometimes the current module differ
between compile-time and run-time.)
@c JP
@var{form}中にあるマクロを全て展開します。結果の中に残るのは、
関数呼び出しとGaucheの組み込み構文だけになります。
@var{form}は現在のモジュール中のトップレベルにあるものと解釈されます
(現在のモジュールについては@ref{Module semantics}を参照してください。
この概念はちょっとややこしいです。コンパイル時と実行時で
現在のモジュールが異なる場合があるからです。)
@c COMMON

@c EN
Any local variables introduced in @var{form} is renamed to avoid collision.
Since each local variable has unique name, all @code{let} forms become
@code{letrec} forms (we can safely replace @code{let} with @code{letrec}
if no bindings introduced by @code{let} shadows outer bindings.)
@c JP
@var{form}中で導入されるローカル変数は全て、衝突を避けるためにリネームされます。
ローカル変数が全て固有の名前を持つようになるので、@code{let}フォームはすべて
@code{letrec}で表されます(@code{let}による束縛が他の束縛をシャドウしないと
わかっていれば、@code{let}を@code{letrec}に置き換えても意味は変わりません)。
@c COMMON

@c EN
NB: If a macro in @var{form} inserts a reference to a global variable
which belongs to other module, the information is lost in the current
implementation.  There are a few ways to address this issue; we may
leave such reference as an identifier object, convert it to
@code{with-module} form, or introduce a special syntax to represent
such case.  It's undecided currently, so do not rely too much on
the current behavior.  For the time being, it's best to use this
feature only for interactive macro testing.
@c JP
注意: もし@var{form}内で呼ばれているマクロが、他のモジュール中にあるグローバル
変数への参照を挿入した場合、現在の実装ではその情報は失われてしまいます。
いくつか、その問題を修正する方法は考えられるのですが(例えば他のモジュール中に
グローバル変数参照は識別子オブジェクトのまま残しておくとか、
@code{with-module}フォームに変換するとか、
そういったケースのための特殊構文を導入するとか)、今のところどうするか
決まっていません。なので、現在のふるまいにあまり依存しないようにしてください。
今のところ、この手続きは、マクロの展開結果をインタラクティブに確かめる用途に
限って使うのが安全です。
@c COMMON

@example
(macroexpand-all
 '(letrec-syntax
      [(when-not (syntax-rules ()
                   [(_ test . body) (if test #f (begin . body))]))]
    (let ([if list])
      (define x (expt foo))
      (let1 x 3
        (when-not (bar) (if x))))))
 @result{} (letrec ((if.0 list)) 
     (letrec ((x.1 (expt foo)))
       (letrec ((x.2 '3)) 
        (if (bar) '#f (if.0 x.2)))))
@end example
@end defun


@defspec %macroexpand form
@defspecx %macroexpand-1 form
@end defspec

@node Macro utilities,  , Macro expansion, Macros
@section Macro utilities
@c NODE マクロユーティリティ

@defmac syntax-error msg arg @dots{}
@defmacx syntax-errorf fmt arg @dots{}
@c EN
Signal an error.  They are same as
@code{error} and @code{errorf} (@pxref{Signaling exceptions}),
except that the error is signaled at macro-expansion time
(i.e. compile time) rather than run time.

They are useful to tell the user the wrong usage of macro in
the comprehensive way, instead of the cryptic error from the macro
transformer.   Because of the purpose, @var{arg} @dots{} are first
passed to @code{unwrap-syntax} described below, to strip off
the internal syntactic binding informations.
@c JP
これらは@code{error}と@code{errorf} (@ref{Signaling exceptions}参照) と
ほぼ同じですが、実行時ではなくマクロ展開時(すなわち、コンパイル時)に
エラーを通知するところが異なります。

これらの手続きは、マクロの誤った使い方を、
マクロ展開ルーチンの出す複雑なエラーではなく、
分かりやすい方法でユーザーに通知するのに使えます。
そのため、@var{arg} @dots{}はまず下に述べる@code{unwrap-syntax}に渡されて
内部の構文的束縛情報を取り除いた後でこれらの手続きに渡されます。
@c COMMON

@example
(define-syntax my-macro
  (syntax-rules ()
    ((_ a b)   (foo2 a b))
    ((_ a b c) (foo3 a b c))
    ((_ . ?)
     (syntax-error "malformed my-macro" (my-macro . ?)))))

(my-macro 1 2 3 4)
  @result{} @r{error: "malformed my-macro: (my-macro 1 2 3 4)"}
@end example
@end defmac

@defun unwrap-syntax form
@c EN
Removes internal syntactic information from @var{form}.
In order to implement a hygienic macro, macro transformer replaces
symbols in the macro form for identifiers, which captures the
syntactic environment where they are defined.  Although it is
necessary information for the compiler, it is rather confusing
for users if it appears in the messages.  This function
replaces occurrences of identifiers in @var{form} to the original
symbols.
@c JP
@var{form}の内部的な構文情報を取り除きます。
衛生マクロの実装のために、マクロ拡張ルーチンはマクロ内のシンボルを
識別子(identifier)に置き換えます。識別子はそれが現れる構文的環境を
捕捉します。それはコンパイラに取っては必要な情報ですが、
エラーメッセージに現れるとユーザーを混乱させるもとにもなります。
そこで、この手続きでは@var{form}中の識別子をもとのシンボルに
置換しなおします。
@c COMMON
@end defun

@c Local variables:
@c mode: texinfo
@c coding: utf-8
@c end:
