@node Library modules - R7RS integration, Library modules - SRFIs, Library modules - Gauche extensions, Top
@chapter Library modules - R7RS integration
@c NODE ライブラリモジュール - R7RS統合

@c EN
Gauche predates R7RS, and for the convenience, Gauche makes quite a few
procedures as built-in (@pxref{Core library}).  Although the set of
Gauche's core features are mostly superset of R7RS, some functions
and syntaxes have different names and/or interface from R7RS.

R7RS fully-compatible syntaxes and functions are available
in the set of modules described in this chapter.  Since R7RS
programs and libraries needs to follow a specific format
(@code{import} declaration or @code{define-library} form),
generally there's no ambiguity in whether you're looking at R7RS code
or Gauche-specific code.  Also, it is totally transparent to load
R7RS library into Gauche-specific code or vice versa.
However, you need to be aware of which ``world'' you're in when
you code.
@c JP
GaucheはR7RS以前からあり、使い勝手のために非常に多くの組み込み手続きを
持っています(@ref{Core library}参照)。そのほとんどはR7RSのスーパーセットと
なっていますが、いくつかの手続きや構文は違う名前であったり、
違うインタフェースを取っていたりします。

R7RSと完全に互換な構文と関数は、本章で説明されるモジュール群によって提供されます。
R7RSプログラムとライブラリは特定の形式で書かれるので
(@code{import}宣言で始まるか、もしくは@code{define-library}フォーム)、
通常はR7RSのコードを見ているのかGauche特有のコードを見ているのかははっきり区別できます。
また、Gauche特有のコードからR7RSライブラリをロードすることも、その逆も、
全く透過的にできます。
但し、コードを書く時には、どちらの「世界」にいるのかを意識する必要があります。
@c COMMON

@menu
* Traveling between two worlds back and forth::  
* Three forms of import::       
* R7RS library form::           
* R7RS base library::           
* R7RS case-lambda::            
* R7RS char library::           
* R7RS complex numbers::        
* R7RS cxr accessors::          
* R7RS eval::                   
* R7RS file library::           
* R7RS inexact numbers::        
* R7RS lazy evaluation::        
* R7RS load::                   
* R7RS process context::        
* R7RS read::                   
* R7RS repl::                   
* R7RS time::                   
* R7RS write::                  
* R5RS compatibility::          
@end menu

@node Traveling between two worlds back and forth, Three forms of import, Library modules - R7RS integration, Library modules - R7RS integration
@section Traveling between two worlds back and forth
@c NODE 二つの世界を往き来する

@c EN
When you start Gauche, either in REPL or as a script, you're in
@code{user} module, which @emph{inherits} @code{gauche} module.
Likewise, when you read a library, the initial module inherits
@code{gauche} module (until you call @code{select-module}).
That's why you can access all the built-in procedures of Gauche
without saying @code{(use something)}.  (@xref{Module inheritance}, for
the details about inheriting modules).
@c JP
Gaucheを起動した直後は、それがREPLであってもスクリプトファイルの実行であっても、
トップレベルは@code{user}モジュールになっています。@code{user}モジュールは
@code{gauche}モジュールを@emph{継承}しています。
また、ライブラリを読み込む際にも、(@code{select-module}が呼ばれるまでは)
トップレベルは@code{gauche}を継承したモジュールになっています。
これが、@code{(use something)}等といちいち書かないでも
Gaucheの組み込み手続きを使える理由です。
(モジュールの継承については@ref{Module inheritance}を参照してください)。
@c COMMON

@c EN
On the other hand, R7RS requires to be explicit about which namespaces
you'll be using, by @code{import} form, e.g. @code{(import (scheme base))}.
Besides, R7RS library must be explicitly enclosed by @code{define-library} form.
Before the first @code{import} form of a program, or outside of
@code{define-library}, is beyond R7RS world---the standard defines
nothings about it.
@c JP
一方、R7RSでは@code{import}フォームによってどの名前空間を利用するか明示することが
求められています(例: @code{(import (scheme base))})。
また、R7RSライブラリはそれぞれ@code{define-library}フォームで囲う必要があります。
プログラムの最初の@code{import}より前、あるいはライブラリの@code{define-library}の
外側は、R7RSの世界の外であり、標準では何も規定していません。
@c COMMON

@c EN
These facts let Gauche to set up appropriate ``world'',
and you can use R7RS code and traditional Gauche code transparently.
@c JP
Gaucheはこれを利用して、適切な「世界」を設定し、R7RSコードと既存のGaucheコードを
透過的に混ぜるられるようにしています。
@c COMMON

@c EN
NB: As explained in @ref{Three forms of import},
R7RS @code{import} is rather different from Gauche
@code{import}, so we note the former @code{r7rs#import} and the latter
@code{gauche#import} in this section for clarity.  When you write code
don't use prefixes @code{r7rs#} and @code{gauche#}; just write @code{import}.
@c JP
註：@ref{Three forms of import}で説明しますが、
R7RSの@code{import}はGaucheの@code{import}と異なります。この節では
区別が必要な時は前者を@code{r7rs#import}、後者を@code{gauche#import}と
表記しますが、実際のコードでは@code{r7rs#}や@code{gauche#}といったプレフィクスを
つけずに、単に@code{import}と書いてください。
@c COMMON

@c EN
@subheading Loading R7RS libraries
@c JP
@subheading R7RSライブラリをロードする
@c COMMON

@c EN
The @code{define-library} form is defined as a macro in @code{gauche} module;
it sets up R7RS environment before evaluating its contents.
So, when you load an R7RS library (either from Gauche code via @code{use}
form, or from R7RS code via @code{r7rs#import} form),
Gauche starts loading the file in @code{gauche} module, but immediately
see @code{define-library} form, and the rest is handled in R7RS
environment.
@c JP
@code{define-library}フォーム自身は、@code{gauche}モジュール内のマクロとして
定義されていて、R7RS環境を設定してその中身を評価するコードに展開されます。
(Gaucheコードから@code{use}を使うか、
R7RSコードから@code{r7rs#import}フォームを使うかして)R7RSライブラリをロードすると、
Gaucheはファイルの評価を@code{gauche}モジュール内で始めますが、すぐに
@code{define-library}フォームに当たるので、その中身はR7RS環境で処理されることになります。
@c COMMON

@c EN
Suppose you have an R7RS library @code{(mylib foo)} with the following code:
@c JP
以下のコードを持つ、R7RSライブラリ@code{(mylib foo)}があるとしましょう。
@c COMMON

@example
(define-library (mylib foo)
  (import (scheme base))
  (export snoc)
  (begin
    (define (snoc x y) (cons y x))))
@end example

@c EN
It should be saved as @file{mylib/foo.scm} in one of the directories in
@code{*load-path*}.
@c JP
このファイルは@code{*load-path*}にあるディレクトリのどれかの下に、
@file{mylib/foo.scm}という名前で保存されなければなりません。
@c COMMON

@c EN
From R7RS code, this library can be loaded by @code{r7rs#import}:
@c JP
R7RSコードからは、このライブラリは@code{r7rs#import}フォームでロードできます。
@c COMMON

@example
(import (mylib foo))

(snoc 1 2) @result{} (2 . 1)
@end example

@c EN
To use this library from Gauche code, concatenate elements of library
names by @code{.} to get a module name, and @code{use} it:
@c JP
Gaucheコードからこのライブラリを使うには、ライブラリ名の各要素を@code{.}で
つなげたものをモジュール名として、@code{use}します。
@c COMMON

@example
(use mylib.foo)

(snoc 1 2) @result{} (2 . 1)
@end example

@c EN
@subheading Loading Gauche libraries
@c JP
@subheading Gaucheライブラリのロード
@c COMMON

@c EN
To use Gauche library @code{foo.bar} from R7RS code,
split the module name by @code{.} to make a list for the name
of the library.  For example, @code{gauche.lazy} module can be
used from R7RS as follows:
@c JP
Gaucheライブラリの@code{foo.bar}をR7RSコードから使うには、
モジュール名を@code{.}で区切った名前のリストをライブラリ名として使います。
例えば@code{gauche.lazy}モジュールは次のとおりR7RSから使えます。
@c COMMON

@example
(import (gauche lazy))
@end example

@c EN
For SRFI modules, R7RS implementations have a convention to
name it as @code{(srfi n)}, and Gauche follows it.  
The following code loads srfi-1 and srfi-13 from R7RS code:
@c JP
SRFIモジュールについては、R7RSでは慣習的に@code{(srfi n)}という
名前を使うので、Gaucheもそれに合わせています。R7RSコードから
srfi-1とsrfi-13を使うには、次のようにします。
@c COMMON

@example
(import (srfi 1) (srfi 13))
@end example

@c EN
(It's not that Gauche treat @code{srfi} name specially; installation
of Gauche includes adapter libraries such as @file{srfi/1.scm}.)
@c JP
(これが動くのは、Gaucheが@code{srfi}という名前を特別扱いしているのではなく、
Gaucheをインストールした時に@code{srfi/1.scm}等のアダプタライブラリが作られているからです)
@c COMMON

@c EN
A tip: To use Gauche's built-in features (the bindings that are
available by default in Gauche code) from R7RS code, import
@code{(gauche base)} library (@pxref{Importing gauche built-ins}):
@c JP
ヒント: Gaucheの組み込みの機能 (Gaucheコードでは最初から使える束縛) を
R7RSコードから使いたい場合は、@code{(gauche base)}ライブラリをimportしてください
(@ref{Importing gauche built-ins}参照)。
@c COMMON

@example
(import (gauche base))

filter @result{} #<closure filter>
@end example

@c EN
@subheading Running R7RS scripts
@c JP
@subheading R7RSスクリプトの実行
@c COMMON

@c EN
R7RS scripts always begin with @code{import} form.  However, @code{r7rs#import}
has a different syntax and semantics 
from @code{gauche#import}---so we employ a trick.
@c JP
R7RSスクリプトは必ず@code{import}フォームで始まります。
しかし、@code{r7rs#import}は@code{gauche#import}と文法や意味が異なります。
そこで、ちょっとしたトリックを使っています。
@c COMMON

@c EN
When @code{gosh} is started, it loads the given script file
in @code{user} module.  We have a separate @code{user#import} macro, which
examines its arguments and if it is R7RS import syntax, switch to the
@code{r7rs.user} module and run the @code{r7rs#import}.  Otherwise, it
runs @code{gauche#import}.  @xref{Three forms of import}, for the details.
@c JP
@code{gosh}がスクリプトファイルを読み込むのは@code{user}モジュールです。
そこには@code{user#import}というマクロが用意してあり、
そのマクロは引数を調べて、それがR7RSのimportの構文であれば
@code{r7rs.user}モジュールに切り替えて@code{r7rs#import}を実行し、
そうでなければ@code{gauche#import}を実行します。
詳しくは@ref{Three forms of import}を参照してください。
@c COMMON

@c EN
An example of R7RS script:
@c JP
R7RSスクリプトの例です:
@c COMMON

@example
(import (scheme base) (scheme write))
(display "Hello, world!\n")
@end example

@c EN
If you're already familiar with Gauche scripts, keep in mind that
R7RS program doesn't treat @code{main} procedure specially; it
just evaluates toplevel forms from top to bottom.  So the following
script doesn't output anything:
@c JP
Gaucheスクリプトを見慣れている人は、R7RSプログラムが@code{main}手続きを
特別扱いしないことに気をつけてください。R7RSプログラムは、トップレベルフォームを
順に評価してゆくだけです。したがって次のスクリプトは何も表示しません:
@c COMMON

@example
(import (scheme base) (scheme write))
(define (main args)
  (display "Hello, world!\n")
  0)
@end example

@c EN
To access the command-line arguments in R7RS scripts, use
@code{command-line} in @code{(scheme process-context)} library
(@pxref{R7RS process context}, also @pxref{Command-line arguments}).
@c JP
R7RSスクリプトからコマンドライン引数を利用するには、
@code{(scheme process-context)}ライブラリの@code{command-line}を使います
(@ref{R7RS process context} および @ref{Command-line arguments}参照)。
@c COMMON

@c EN
@subheading Using R7RS REPL
@c JP
@subheading R7RS REPLを使う
@c COMMON

@c EN
When @code{gosh} is invoked with @code{-r7} option and no script file is
given, it enters an R7RS REPL mode.  For the convenience, the following
modules (``libraries'', in R7RS term) are pre-loaded.
@c JP
@code{gosh}が@code{-r7}オプションつきで起動され、スクリプトファイルが
与えられていなかった場合は、R7RS REPLモードになります。
使いやすいように、以下のモジュール (R7RS用語では「ライブラリ」)は
自動的にロードされます。
@c COMMON

@example
(scheme base) (scheme case-lambda) (scheme char)
(scheme complex) (scheme cxr) (scheme eval)
(scheme file) (scheme inexact) (scheme lazy)
(scheme load) (scheme process-context) (scheme read)
(scheme repl) (scheme time) (scheme write)
@end example

@c EN
Besides, the history variables @code{*1}, @code{*2}, @code{*3},
@code{*1+}, @code{*2+}, @code{*3+}, @code{*e} and @code{*history}
are available (@xref{Working in REPL}, for the details of history variables).
@c JP
さらに、ヒストリ変数@code{*1}、@code{*2}、@code{*3}、
@code{*1+}、@code{*2+}、@code{*3+}、@code{*e} および
@code{*history}も使えます (ヒストリ変数の詳細については@ref{Working in REPL}参照)。
@c COMMON

@c EN
You can know you're in R7RS REPL by looking at the prompt, where
@code{gosh} shows the current module (@code{r7rs.user}):
@c JP
R7RS REPLにいることはプロンプトを見ればわかります。
現在のモジュールが@code{r7rs.user}となっているからです。
@c COMMON

@example
gosh[r7rs.user]> 
@end example

@c EN
To switch Gauche REPL from R7RS REPL, import @code{(gauche base)} and
select @code{user} module using @code{select-module}:
@c JP
R7RS REPLからGauche REPLにスイッチするには、@code{(gauche base)}を
インポートして@code{select-module}を使って@code{user}モジュールを選びます。
@c COMMON

@example
gosh[r7rs.user]> (import (gauche base))
#<undef>
gosh[r7rs.user]> (select-module user)
#<undef>
gosh> 
@end example

@c EN
(You can @code{(select-module gauche)} but that's usually not what you
want to do---changing @code{gauche} module can have unwanted side effects.)
@c JP
(@code{(select-module gauche)}とする手もありますが、おすすめはしません。
@code{gauche}モジュールの中を変えると思いがけない副作用が生じるかもしれませんから。)
@c COMMON

@c EN
When you're working on R7RS code in file and load it into R7RS REPL
(for example, if you're using Emacs Scheme mode, C-c C-l does the job),
make sure the file is in proper shape as R7RS; that is, the file
must start with appropriate @code{import} declarations, or 
the file contains @code{define-library} form(s).  If you load
file without those forms, it is loaded into Gauche's @code{user} module
no matter what your REPL's current module is,
and the definitions won't be visible from @code{r7rs.user} module
by default.
@c JP
R7RSコードをファイルに書きだし、R7RS REPLにそのファイルをロードしてインタラクティブに
開発を進めている場合 (例えばEmacsのSchemeモードなら、C-c C-lでファイルがロードできます)、
そのファイルがR7RSとして正しい形式になっていることを確認してください。
つまり、ファイルは@code{import}宣言で始まるか、@code{define-library}形式
から構成されるものでなければなりません。それ以外の、単にSchemeコードが並べて
書いてあるだけのファイルをロードした場合、
それはREPLでの現在のモジュールが何であるかにかかわらずGaucheの@code{user}モジュールに
読み込まれるので、@code{r7rs.user}モジュールからはデフォルトでは見えません。
@c COMMON

@c EN
@subheading Switching from Gauche REPL
@c JP
@subheading Gauche REPLからのスイッチ
@c COMMON

@c EN
By default, @code{gosh} enters Gauche REPL when no script file is given.
@xref{Working in REPL}, for detailed explanation of using REPL.
@c JP
デフォルトでは、@code{gosh}はスクリプトファイルが与えられなければGaucheのREPLに
入ります。REPLの説明は@ref{Working in REPL}を参照してください。
@c COMMON

@c EN
To switch Gauche REPL to R7RS REPL, simply use r7rs-style import;
@code{user#import} knows you want R7RS and make a switch.
@c JP
Gauche REPLからR7RS REPLにスイッチするには、
単にr7rsスタイルのimportを使うだけです。@code{user#import}は
あなたが欲しいのがR7RSであることを察知して環境を切り替えます。
@c COMMON

@example
gosh> (import (scheme base))
#<undef>
gosh[r7rs.user]> 
@end example

@c EN
If you don't start @code{gosh} with @code{-r7} option, however,
only the libraries you given to @code{user#import} are loaded at
this moment.
@c JP
ただし、@code{gosh}を@code{-r7}オプションつきで起動していなければ、
この時点でロードされているのは@code{user#import}で指定したライブラリだけです。
@c COMMON

@c EN
If you want to switch the ``vanilla'' r7rs environment, that is, even
not loading @code{(scheme base)}, then you can use @code{r7rs}
module and directly select @code{r7rs.user}:
@c JP
もし、「すっぴん」のR7RS環境、つまり@code{(scheme base)}でさえロードされていない
環境へと切り替えたければ、@code{r7rs}モジュールをuseして
直接@code{r7rs.user}モジュールを選択します。
@c COMMON

@example
gosh> (use r7rs)
#<undef>
gosh> (select-module r7rs.user)
#<undef>
gosh[r7rs.user]> 
@end example

@c EN
If you do this, the only
bindings visible initially are @code{import} and @code{define-library};
even @code{define} is undefined!
You have to manually do @code{(import (scheme base))} etc. to start
writing Scheme in this environment.
@c JP
こうして切り替えた場合、使えるフォームは@code{import}と@code{define-library}
だけです (@code{define}でさえ定義されていません!)
この環境でSchemeを書くには、まず @code{(import (scheme base))} 等として
束縛をインポートする必要があります。
@c COMMON


@node Three forms of import, R7RS library form, Traveling between two worlds back and forth, Library modules - R7RS integration
@section Three import forms
@c NODE 3つのimport形式

@c EN
Gauche's module system design is inherited from STk, and we've been
used @code{import} for purely name-space level operation; that is,
it assumes the module you import from already exists in memory.  
Loading a file that defines the module (if necessary) is
done by separate primitives, @code{require}.  In most cases one file
defines one module, and using that module means @code{require} it then
@code{import} it (it's so common that Gauche has a macro for it---@code{use}).
However, separating those two sometimes comes handy when you need
some nontrivial hacks.  @xref{Using modules}, for the details of
Gauche's @code{import}.
@c JP
Gaucheのモジュールシステム設計はSTkを継承していて、
@code{import}は純粋に名前空間の操作として使われています。
つまり、既にメモり上に存在するモジュールをインポートするということです。
そのモジュールが定義されているファイルを、(必要なら)ロードするという
操作は別のプリミティブ@code{require}により実現されます。
典型的には、ひとつのファイルがひとつのモジュールを定義していて、
そのモジュールを使うにはまずファイルを@code{require}し、
次にモジュールを@code{import}するということになります
(これはGaucheでは頻繁に出てくるので、@code{use}というマクロが定義されているくらいです)。
ファイルのロードとモジュールのインポートが分かれていることは、
たまに変わったハックが必要とされる時に役に立ちます。
Gaucheの@code{import}については@ref{Using modules}を参照してください。
@c COMMON

@c EN
R7RS leaves out the relation between modules (libraries) and files
in order to give implementation freedom.  If necessary, its @code{import}
must load a file implicitly and transparently.  So R7RS's @code{import}
is semantically Gauche's @code{use}.
@c JP
R7RSは実装に選択の余地を与えるため、モジュール(ライブラリ)とファイルの関係は
敢えて規定していません。R7RSの@code{import}は、
必要ならば暗黙のうちに、透過的にファイルをロードすることが期待されています。
つまり、R7RSの@code{import}はGaucheの@code{use}と意味的に同じと考えられます。
@c COMMON

@defspec import import-spec @dots{}
[R7RS]
@c EN
Imports libraries specified by @var{import-spec}s.  What R7RS calls
libraries are what Gauche calls modules; they're the same thing.
@c JP
@var{import-spec}で指定されるライブラリをインポートします。
R7RSでいうライブラリは、Gaucheがモジュールと呼んできたものです。両者は同じものです。
@c COMMON

@c EN
R7RS libraries are named by a list of symbols or integers, 
e.g. @code{(scheme base)} or @code{(srfi 1)}.
It is translated to Gauche's module name by joining the symbols
by periods; so, R7RS @code{(scheme base)} is Gauche's @code{scheme.base}.
Conversely, Gauche's @code{data.queue} is available as
@code{(data queue)} in R7RS.  To use those two libraries,
R7RS program needs this form at the beginning.
@c JP
R7RSライブラリの名前はシンボルか整数のリストで表されます。
例: @code{(scheme base)}、@code{(srfi 1)}。
この名前は、ピリオドを挟んでシンボル名をつなげることで、Gaucheのモジュール名へと
変換されます。つまり、R7RSの@code{(scheme base)}はGaucheからは@code{scheme.base}
モジュールとして扱えます。逆にGaucheの@code{data.queue}モジュールは
R7RSからは@code{(data queue)}ライブラリとして扱えます。
R7RSプログラムからこれら二つのライブラリを使うには、プログラムの最初に
次のように記します。
@c COMMON

@example
(import (scheme base) 
        (data queue))
@end example

@c EN
It works just like Gauche's @code{use} forms; that is, if the named
module doesn't exist in the current process, it loads the file; then
the module's exported bindings become visible from the current module.
@c JP
これはGaucheで@code{use}フォームを使うのと同じです。つまり、もし
その名前を持つモジュールが現在のプロセス内に無ければまずファイルをロードし、
それからモジュールがexportしている束縛を現在のモジュールから見えるようにします。
@c COMMON

@example
(use scheme.base)
(use data.queue)
@end example

@c EN
(You may wonder what if R7RS library uses symbols with periods in them.
Frankly, we haven't decided yet.   It'll likely be that we use some
escaping mechanism; for the time being you'd want to stick with
alphanumeric characters and hyphens as possible.)
@c JP
(勘の良い読者な、R7RSのライブラリがピリオドを中に含むシンボルを名前に使っていたら
どうなるのか疑問に思ったことでしょう。正直なところ、まだどうするか決めていません。
多分、何らかのエスケープ機構を用意することになると思いますが、
今のところ、できる限りモジュール名にはアルファベット、数字、ハイフンだけを
使うようにしておいて下さい。)
@c COMMON

@c EN
Just like Gauche's @code{use}, you can select which symbols to be
imported (or not imported), rename specific symbols, or add
prefix to all imported symbols.  The formal syntax
of R7RS import syntax is as follows:
@c JP
R7RSの@code{import}フォームは、
Gaucheの@code{use}と同様、どのシンボルをimportするか/しないかを指定したり、
名前を変えてimportしたりプレフィクスを付加することができます。
R7RSの@code{import}の正式な構文は次の通りです。
@c COMMON

@smallexample
<import declaration> : (import <import-set> <import-set> ...)

<import-set> : <library-name>
  | (only <import-set> <identifier> <identifier> ...)
  | (except <import-set> <identifier> <identifier> ...)
  | (prefix <import-set> <identifier>)
  | (rename <import-set>
            (<identifier> <identifier>)
            (<identifier> <identifier>) ...)

<library-name> : (<identifier-or-base-10-integer>
                  <identifier-or-base-10-integer> ...)
@end smallexample
@end defspec


@node R7RS library form, R7RS base library, Three forms of import, Library modules - R7RS integration
@section R7RS library form
@c NODE R7RSライブラリ形式

@defmac define-library library-name library-decl @dots{}
[R7RS]
Defines a library @var{library-name}, which is a list of 
symbols or base-10 integer:

@smallexample
<library-name> : (<identifier-or-base-10-integer>
                  <identifier-or-base-10-integer> ...)
@end smallexample

Library declarations can be export declarations, import declarations,
@code{begin}-list of Scheme code,
include forms, or @code{cond-expand} forms.

@smallexample
<library-decl> : (export <export-spec> @dots{})
               | <import declaration>
               | (begin <command-or-definition> @dots{})
               | (include <string> <string2> @dots{})
               | (include-ci <string> <string2> @dots{})
               | (include-library-declarations 
                        <string> <string2> @dots{})
               | (cond-expand <cond-expand-clause>
                              <cond-expand-clause2> @dots{})
               | (cond-expand <cond-expand-clause>
                              <cond-expand-clause2> @dots{}
                              (else <library-decl> @dots{}))
@end smallexample

The @code{export} declaration is the same Gauche's @code{export}
form; @pxref{Using modules}.

The @code{import} declaration is R7RS's @code{import} form,
described in @ref{Three forms of import}.

The @code{include} and @code{include-ci} forms are the same as Gauche's;
@pxref{Inclusions}.

The @code{cond-expand} form is also the same as Gauche's;
@pxref{Feature conditional}.
@end defmac


@node R7RS base library, R7RS case-lambda, R7RS library form, Library modules - R7RS integration
@section @code{scheme.base} - R7RS base library
@c NODE R7RS基本ライブラリ, @code{scheme.base} - R7RS基本ライブラリ

@deftp {Module} scheme.base
@mdindex scheme.base
Exports bindings of R7RS @code{(scheme base)} library.  From R7RS programs,
those bindings are available by @code{(import (scheme base))}.
@end deftp

@subheading Bindings common to Gauche's built-ins

The following syntaxes and procedures are the same as Gauche's
builtins:

@table @asis
@item Primitive expression types
@example
quote if include include-ci lambda
@end example
@item Derived expression types
@example
cond case and or when unless cond-expand let let* letrec letrec*
let-values let*-values begin do make-parameter parameterize
guard quasiquote unquote unquote-splicing case-lambda
@end example
@item Macros
@example
let-synatx letrec-syntax syntax-rules syntax-error define-syntax
@end example
@item Variable definitions
@example
define define-values
@end example
@item Record type definitions
@example
define-record-type
@end example
@item Equivalence predicates
@example
eqv? eq? equal?
@end example
@item Numbers
@example
number? complex? real? rational? integer? exact? exact-integer?
= < > <= >= zero? positive? negative? odd? even? max min + * - / abs
floor/ floor-quotient floor-remainder
truncate/ truncate-quotient truncate-remainder
quotient modulo remainder gcd lcm numerator denominator
floor ceiling truncate round rationalize square exact-integer-sqrt
expt inexact exact number->string string->number
@end example
@item Booleans
@example
not boolean? boolean=?
@end example
@item Pairs and lists
@example
pair? cons car cdr set-car! set-cdr! caar cadr cdar cddr null? list?
make-list list length append reverse list-tail list-ref list-set!
memq memv member assq assv assoc list-copy
@end example
@item Symbols
@example
symbol? symbol=? symbol->string string->symbol
@end example
@item Characters
@example
char? char=? char<? char>? char<=? char>=? char->integer integer->char
@end example
@item Strings
@example
string? make-string string string-length string-ref string-set!
string=? string<? string>? string<=? string>=? substring string-append
string->list list->string string-copy string-copy! string-fill!
@end example
@item Vectors
@example
vector? make-vector vector vector-length vector-ref vector-set!
vector->list list->vector vector->string string->vector
vector-copy vector-copy! vector-append vector-fill!
@end example
@item Control features
@example
procedure? apply map call-with-current-continuation call/cc 
values call-with-values dynamic-wind
@end example
@item Exception
@example
raise error
@end example
@item Environments and evaluation
@example
scheme-report-environment null-environment
@end example
@item Input and output
@example
input-port? output-port? port? current-input-port current-output-port
current-error-port close-port close-input-port close-output-port
open-input-string open-output-string get-output-string
read-char peek-char read-line eof-object? eof-object char-ready?
newline write-char
@end example
@end table

@subheading Bytevector utilities

@defun bytevector n @dots{}
@defunx bytevector? obj
@defunx make-bytevector size :optional byte
@defunx bytevector-length bv
@defunx bytevector-u8-ref bv index
@defunx bytevector-u8-set! bv index byte
@defunx bytevector-copy bv :optional start end
@defunx bytevector-copy! to at from :optional start end
@defunx bytevector-append bv @dots{}
[R7RS]
R7RS's bytevector is Gauche's u8vector.

These are equivalent to @code{gauche.uvector}'s
@code{u8vector}, @code{u8vector?},
@code{make-u8vector}, @code{u8vector-length}, @code{u8vector-ref},
@code{u8vector-set!}, @code{u8vector-copy}, @code{u8vector-copy!}, and
@code{u8vector-append}, respectively.  (@pxref{Uniform vectors}).
@end defun

These two procedures are the same as the ones in @code{gauche.unicode}
module (@pxref{Unicode transfer encodings}):

@example
utf8->string string->utf8
@end example

@subheading Control features

@defun string-map proc str @dots{}
@defunx string-for-each proc str @dots{}
[R7RS]
These take different arguments from 
@code{string-map} and @code{string-for-each} in SRFI-13
(@pxref{SRFI-13 String mapping}), so provided only in @code{scheme.base} module
to avoid confusion.
@end defun

@defun raise-continuable obj
[R7RS]
At this moment, this is defined as an alias of @code{raise},
for Gauche's @code{raise} returns unless @var{obj} is not a
@code{<serious-condition>}.
@end defun

@defun error-object? exc
[R7RS]
Defined as @code{(condition-has-type? exc <error>))}
@end defun

@defun error-object-message exc
[R7RS]
Returns the message portion of @var{exc} if it has one,
or an empty string otherwise.
@end defun

@defun error-object-irritants exc
[R7RS]
@end defun

@defun read-error? exc
[R7RS]
Defined as @code{(condition-has-type? e <read-error>))}.
@end defun

@defun file-error? exc
[R7RS]
At this moment, Gauche doesn't have distinct @code{<file-error>} condition,
but most file errors are thrown as one of @code{<system-error>}s.
This procedure checks error code of @code{<system-error>} and
returns @code{#t} if the error is likely to be related to the filesystem.
@end defun

@subsection Input and output

@defun textual-port? port
@defunx binary-port? port
[R7RS]
Gauche's port can handle both, so these are equivalent to @code{port?}.
@end defun

@defun input-port-open? port
@defunx output-port-open? port
[R7RS]
@end defun

@defun open-input-bytevector bv
@defunx open-output-bytevector
@defunx get-output-bytevector port
[R7RS]
@end defun

@defun read-u8 :optional iport
@defunx peek-u8 :optional iport
@defunx u8-ready? :optional iport
[R7RS]
These are aliases to @code{read-byte}, @code{peek-byte} and @code{byte-ready?},
respectively.
@end defun

@defun read-bytevector size :optional iport
[R7RS]
Equivalent to @code{(read-uvector <u8vector> size iport)}. 
@xref{Uvector block I/O}.
@end defun

@defun read-bytevector! bv :optional iport start end
[R7RS]
An alias to @code{read-uvector!}.  @xref{Uvector block I/O}.
@end defun

@defun write-string string :optional oport start end
[R7RS]
@end defun

@defun write-u8
[R7RS]
An alias to @code{write-byte}.
@end defun

@defun write-bytevector bv :optional oport start end
[R7RS]
Equivalent to @code{write-uvector}.  @xref{Uvector block I/O}.
@end defun

@defun flush-output-port :optional oport
[R7RS]
An alias to @code{flush}.
@end defun

@defun features
[R7RS]
Returns a list of symbols of supported feature identifiers,
recognized by @code{cond-expand} (@pxref{Feature conditional}).
@end defun


@node R7RS case-lambda, R7RS char library, R7RS base library, Library modules - R7RS integration
@section @code{scheme.case-lambda} - R7RS case-lambda
@c NODE R7RS case-lambda, @code{scheme.case-lambda} - R7RS case-lambda

@deftp {Module} scheme.case-lambda
@mdindex scheme.case-lambda
Exports bindings of R7RS @code{(scheme case-lambda)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme case-lambda))}.

The only binding exported from this module is @code{case-lambda},
and it is the same as Gauche's built-in @code{case-lambda};
@pxref{Making Procedures} for the details.
@end deftp


@node R7RS char library, R7RS complex numbers, R7RS case-lambda, Library modules - R7RS integration
@section @code{scheme.char} - R7RS char library
@c NODE R7RS文字ライブラリ, @code{scheme.char} - R7RS文字ライブラリ

@deftp {Module} scheme.char
@mdindex scheme.char
Exports bindings of R7RS @code{(scheme char)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme char))}.
@end deftp

The following procedures are the same as Gauche's builtin procedures;
@pxref{Characters}.

@example
char-alphabetic? char-ci<=? char-ci<?  char-ci=? char-ci>=? char-ci>?
char-downcase char-foldcase char-lower-case? char-numeric?
char-upcase char-upper-case?  char-whitespace?
@end example

The following procedures are the same as the ones provided
in @code{gauche.unicode} module (@pxref{Full string case conversion}).
They use full case folding by Unicode standard (e.g. taking into
account of German eszett).

@example
string-ci<=? string-ci<?  string-ci=? string-ci>=?  string-ci>?
string-downcase string-foldcase string-upcase
@end example

@defun digit-value c
[R7RS]
If @var{c} is a character with @code{Nd} general category---that is,
if it represents a decimal digit---this procedure returns the value
the character represents.  Otherwise it returns @code{#f}.

@example
(digit-value #\3) @result{} 3

(digit-value #\z) @result{} #f
@end example

Note that Unicode defines about two dozen sets of digit characters.

@example
(digit-value #\x11068) @result{} 2
@end example

Gauche's built-in procedure @code{digit->integer} has more general
interface (@pxref{Characters}).

@example
(digit-value c) @equiv{} (digit->integer c 10 #t)
@end example
@end defun

@node R7RS complex numbers, R7RS cxr accessors, R7RS char library, Library modules - R7RS integration
@section @code{scheme.complex} - R7RS complex numbers
@c NODE R7RS複素数, @code{scheme.compex} - R7RS複素数

@deftp {Module} scheme.complex
@mdindex scheme.complex
Exports bindings of R7RS @code{(scheme complex)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme complex))}.

This module provides the following bindings, all of which are 
Gauche built-in (@pxref{Numerical conversions}).

@example
angle imag-part magnitude make-polar make-rectangular real-part
@end example
@end deftp


@node R7RS cxr accessors, R7RS eval, R7RS complex numbers, Library modules - R7RS integration
@section @code{scheme.cxr} - R7RS cxr accessors
@c NODE R7RS cxrアクセサ, @code{scheme.cxr} - R7RS cxrアクセサ

@deftp {Module} scheme.cxr
@mdindex scheme.cxr
Exports bindings of R7RS @code{(scheme cxr)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme cxr))}.

This module provides the following bindings, all of which are 
Gauche built-in (@pxref{List accessors and modifiers}).

@example
caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar caaadr caadar
caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar cdaddr cddaar
cddadr cdddar cddddr
@end example
@end deftp

@node R7RS eval, R7RS file library, R7RS cxr accessors, Library modules - R7RS integration
@section @code{scheme.eval} - R7RS eval
@c NODE R7RS eval, @code{scheme.eval} - R7RS eval

@deftp {Module} scheme.eval
@mdindex scheme.eval
Exports bindings of R7RS @code{(scheme eval)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme eval))}.
@end deftp

@defun eval expr environment
[R7RS]
This is the same as Gauche's built-in @code{eval} (@pxref{Eval and repl}).
@end defun

@defun environment import-list @dots{}
[R7RS]
This is R7RS way to create an environment specifier suitable to pass
to @code{eval}.  In Gauche, an environment specifier is just a
module object.

The argument is the same as what @code{import} takes.
This procedure creates an empty environment (as a fresh anonymous module;
see @code{make-module} in @ref{Module introspection}, for the details).
The following example creates an environment that includes
@code{scheme.base} bindings plus @code{select-module} syntax from Gauche.

@example
(environment
 '(scheme base)
 '(only (gauche base) select-module))
 @result{} #<module #f>  ; an anonymous module
@end example
@end defun


@node R7RS file library, R7RS inexact numbers, R7RS eval, Library modules - R7RS integration
@section @code{scheme.file} - R7RS file library
@c NODE R7RSファイルライブラリ, @code{scheme.file} - R7RSファイルライブラリ

@deftp {Module} scheme.file
@mdindex scheme.file
Exports bindings of R7RS @code{(scheme file)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme file))}.
@end deftp

The following bindings provided in this module are
Gauche built-in (@pxref{File ports}, and @ref{File stats}).

@example
call-with-input-file call-with-output-file
file-exists?
open-input-file open-output-file
with-input-from-file with-output-to-file
@end example

@defun delete-file filename
[R7RS]
This is the same as @code{delete-file} in @code{file.util}.
@end defun

@defun open-binary-input-file filename
@defunx open-binary-output-file filename
[R7RS]
In Gauche, ports are both textual and binary at the same time,
so these R7RS procedures
are just aliases of @code{open-input-file} and @code{open-output-file},
respectively.  @xref{File ports}.
@end defun

@node R7RS inexact numbers, R7RS lazy evaluation, R7RS file library, Library modules - R7RS integration
@section @code{scheme.inexact} - R7RS inexact numbers
@c NODE R7RS不正確数, @code{scheme.inexact} - R7RS不正確数

@deftp {Module} scheme.inexact
@mdindex scheme.inexact
Exports bindings of R7RS @code{(scheme inexact)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme inexact))}.

This module provides the following bindings, all of which are 
Gauche built-in (@pxref{Arithmetics}, and @ref{Numerical predicates}).

@example
acos asin atan cos exp finite? infinite? log nan? sin sqrt tan
@end example
@end deftp

@node R7RS lazy evaluation, R7RS load, R7RS inexact numbers, Library modules - R7RS integration
@section @code{scheme.lazy} - R7RS lazy evaluation
@c NODE R7RS遅延評価, @code{scheme.lazy} - R7RS遅延評価

@deftp {Module} scheme.lazy
@mdindex scheme.lazy
Exports bindings of R7RS @code{(scheme lazy)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme lazy))}.
@end deftp

The following bindings this module provides are Gauche built-ins
(@pxref{Delay force and lazy}).

@example
delay force promise?
@end example

@defspec delay-force promise
[R7RS]
This is the same as @code{lazy}.
@pxref{Delay force and lazy} for the discussion about when this
form should be used.
@end defspec

@defun make-promise obj
[R7RS]
If @var{obj} is a promise, it is returned as is.  Otherwise,
A promise, which yields @var{obj} when forced, is returned.
Because this is a procedure, expression passed as @var{obj} is
eagerly evaluated, so this doesn't have effect on lazy evaluation,
but can be used to ensure you have a promise.

This procedure is important on implementations where
@code{force} only takes a promise, and portable code should
use this procedure to yield a value that can be passed to @code{force}.

If you write Gauche-specific code, however, @code{force} can take
non-promise values, so you don't need this.
@end defun


@node R7RS load, R7RS process context, R7RS lazy evaluation, Library modules - R7RS integration
@section @code{scheme.load} - R7RS load
@c NODE R7RS load, @code{scheme.load} - R7RS load

@deftp {Module} scheme.load
@mdindex scheme.load
Exports bindings of R7RS @code{(scheme load)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme load))}.
@end deftp

@defun load file :optional env
[R7RS]
R7RS @code{load} takes environment as an optional argument,
while Gauche @code{load} takes it as a keyword argument
(among other keyword arguments).  @xref{Loading Scheme file}.

In Gauche, @var{env} is just a module.  In portable code,
you can create a module with desired bindings with R7RS @code{environment}
procedure; @pxref{R7RS eval}.
@end defun


@node R7RS process context, R7RS read, R7RS load, Library modules - R7RS integration
@section @code{scheme.process-context} - R7RS process context
@c NODE R7RSプロセスコンテキスト, @code{scheme.process-context} - R7RSプロセスコンテキスト

@deftp {Module} scheme.process-context
@mdindex scheme.process-context
Exports bindings of R7RS @code{(scheme process-context)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme process-context))}.
@end deftp

The following bindings are the same as Gauche built-ins
(@pxref{Command-line arguments}, and @ref{Program termination}):

@example
command-line exit
@end example

The following bindings are the same as SRFI-98
(@pxref{Accessing environment variables}):

@example
get-environment-variable get-environment-variables
@end example

@defun emergency-exit :optional (obj 0)
[R7RS]
Terminate the program without running any clean-up procedures
(@var{after} thunks of @code{dynamic-wind}).  Internally, 
it calls the @code{_exit(2)} system call directly.
The optional argument is used for the process exit code.

This is almost the same
as Gauche's @code{sys-exit}, except that @code{sys-exit} requires
the exit code object (@pxref{Program termination}).
@end defun

@node R7RS read, R7RS repl, R7RS process context, Library modules - R7RS integration
@section @code{scheme.read} - R7RS read
@c NODE R7RS read, @code{scheme.read} - R7RS read

@deftp {Module} scheme.read
@mdindex scheme.read
Exports bindings of R7RS @code{(scheme read)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme read))}.

The only binding exported from this module is @code{read},
which is the same as Gauche's built-in.  @xref{Reading data}.
@end deftp

@node R7RS repl, R7RS time, R7RS read, Library modules - R7RS integration
@section @code{scheme.repl} - R7RS repl
@c NODE R7RS repl, @code{scheme.repl} - R7RS repl

@deftp {Module} scheme.repl
@mdindex scheme.repl
Exports bindings of R7RS @code{(scheme repl)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme repl))}.

The only binding exported from this module is @code{interaction-environment},
which is the same as Gauche's built-in.  @xref{Eval and repl}.
@end deftp


@node R7RS time, R7RS write, R7RS repl, Library modules - R7RS integration
@section @code{scheme.time} - R7RS time
@c NODE R7RS time, @code{scheme.time} - R7RS time

@deftp {Module} scheme.time
@mdindex scheme.time
Exports bindings of R7RS @code{(scheme time)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme time))}.
@end deftp

@defun current-second
[R7RS]
Returns a real number represents the number of seconds since
the midnight of Jan. 1, 1970 TAI (which is 23:59:52, Dec 31, 1969 UTC, that
is, -8 seconds before Unix Epoch.)  Number of leap seconds were
inserted since then, and as of 2014, UTC is 35 seconds behind TAI.  That means
the number returned is 27 seconds larger than the unix time,
which is returned from @code{sys-time} or @code{sys-gettimeofday}.

The reason that R7RS adopts TAI is that it is monotonic and suitable
to take difference of two timepoints.  The unix time returned by
@code{sys-time} and @code{sys-gettimeofday} are defined in terms of
UTC date and time, so if the interval spans across leap seconds,
it won't reflect the actual number of seconds in the interval.
(The precise definition is given in section 4.15 of 
IEEE Std 1003.1, 2013 Edition, a.k.a Single Unix Specification 4.) 

However, since we don't know yet when the next leap second happen,
the current implementation just uses a fixed amount of offset
from the unix time.

Just be aware the difference, or you'll be surprised if you
pass the return value of @code{current-second} to the UTC time
formatter such as @code{sys-strftime}, or compare it with
the file timestamps which uses the unix time.  You can convert
between TAI and UTC using srfi-19 (@pxref{SRFI-19 Date}).
@end defun

@defun current-jiffy
[R7RS]
Returns an exact integer measuring a real (wallclock) time elapsed
since some point in the past, which does not change while a
process is running.  The time unit is @code{(/ jiffies-per-second)}-th
second.

The absolute value of current jiffies doesn't matter, but
the difference can be used to measure the time interval.
@end defun

@defun jiffies-per-second
Returns a constant to tell how many time units used in @code{current-jiffy}
consists of a second.  Currently this is 10^9 on 64bit architectures
(that is, nanosecond resolution) and 10^4 on 32bit architectures
(100 microseconds resolution).

The resolution for 32bit architectures
is unfortunately rather coarse, but if we make it finer
the current jiffy value easily becomes bignums, taking time
to allocate and operate, beating the purpose of benchmarking.
With the current choice, we have 53,867 seconds before we spill
into bignum.   On 64bit architectures we have enough bits
not to worry about bignums, with nanosecond resolution.

If you want to do more finer benchmarks on 32bit machines,
you need to roll your own with @code{sys-clock-gettime-monotonic} or
@code{sys-gettimeofday}.
@end defun


@node R7RS write, R5RS compatibility, R7RS time, Library modules - R7RS integration
@section @code{scheme.write} - R7RS write
@c NODE R7RS write, @code{scheme.write} - R7RS write

@deftp {Module} scheme.write
@mdindex scheme.write
Exports bindings of R7RS @code{(scheme write)} library.
From R7RS programs,
those bindings are available by @code{(import (scheme write))}.

This module provides the following bindings, all of which are 
Gauche built-in (@pxref{Object output}).

@example
display write write-shared write-simple
@end example
@end deftp

@node R5RS compatibility,  , R7RS write, Library modules - R7RS integration
@section @code{scheme.r5rs} - R5RS compatibility
@c NODE R5RS compatibility, @code{scheme.r5rs} - R5RS互換性

@deftp {Module} scheme.r5rs
@mdindex scheme.r5rs
This module is to provide R5RS environment in R7RS programs.
The following bindings are exported.  Note that @code{lambda}
is @code{scheme#lambda}, without the support of
extended formals (@code{:optional} etc.)
@xref{Making Procedures}, for the details of extended formals.

@example
* + - / < <= = > >= abs acos and angle append apply asin assoc assq
assv atan begin boolean? caaaar caaadr caaar caadar caaddr caadr
caar cadaar cadadr cadar caddar cadddr caddr cadr
call-with-current-continuation call-with-input-file
call-with-output-file call-with-values car case cdaaar cdaadr cdaar
cdadar cdaddr cdadr cdar cddaar cddadr cddar cdddar cddddr cdddr cddr
cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<?
char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case?
char-numeric? char-ready? char-upcase char-upper-case? char-whitespace?
char<=? char<? char=? char>=? char>? char? close-input-port
close-output-port complex? cond cons cos current-input-port
current-output-port define define-syntax delay denominator display
do dynamic-wind eof-object? eq? equal? eqv? eval even? exact->inexact
exact? exp expt floor for-each force gcd if imag-part inexact->exact
inexact? input-port? integer->char integer? interaction-environment
lambda lcm length let let* let-syntax letrec letrec-syntax list
list->string list->vector list-ref list-tail list? load log magnitude
make-polar make-rectangular make-string make-vector map max member
memq memv min modulo negative? newline not null-environment null?
number->string number? numerator odd? open-input-file open-output-file
or output-port? pair? peek-char positive? procedure? quasiquote quote
quotient rational? rationalize read read-char real-part real? remainder
reverse round scheme-report-environment set! set-car! set-cdr! sin
sqrt string string->list string->number string->symbol string-append
string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>?
string-copy string-fill! string-length string-ref string-set!
string<=? string<? string=? string>=? string>? string? substring
symbol->string symbol? tan truncate values vector vector->list
vector-fill! vector-length vector-ref vector-set! vector?
with-input-from-file with-output-to-file write write-char zero?
@end example
@end deftp


@c Local variables:
@c mode: texinfo
@c coding: utf-8
@c end:
