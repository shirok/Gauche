\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@setfilename gauche-ref
@settitle Gauche Reference Manual
@comment %**end of header

@c $Id: gauche-ref.texi,v 1.45 2001-07-25 10:48:23 shirok Exp $

@c module and class index
@defcodeindex md
@defcodeindex cl

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@title Gauche Reference Manual
@subtitle version 0.4.1
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)

@ifnottex
This is a reference manual of Gauche, an R5RS Scheme implementation.
@end ifnottex

@menu
* Introduction::                
* Concepts::                    
* Writing Scheme program using Gauche::  
* Core Syntax::                 
* Macros::                      
* Core library::                
* Object System::               
* Libarary Modules::            
* References::                  
* Function and Syntax Index::   
* Module Index::                
* Class Index::                 
* Variable Index::              
@end menu

@node Introduction, Concepts, Top, Top
@chapter Introduction

This is a programmers' guide and reference manual of
the Gauche Scheme system.
Here I tried to describe Gauche's implementation precisely,
sometimes referring to background design choices.

The target readers are those who already know Scheme and
want to write useful programs in Gauche.
For those who are new to Scheme, it'll be easier to start
from some kind of tutorial.  I'm planning to write one.

This manual only deals with Scheme side of things.  Gauche has
another face, a C interface.   Details of it will be discussed
in a separate document to be written.
Those who wants to use Gauche as an embedded language, or wants
to write an extension, need that volume.

For the Scheme side, I tried to make this manual self-contained
for reader's convenience, i.e. as far as you want to look up
Gauche's features you don't need to refer to other documents, 
For example, description of functions defined in the standard
documents are included in this manual, instead of saying
``see the standard document''.   However, this document is not a verbatim
copy of the standard documents; sometimes I omit detailed
discussions in the standard documents for brevity.
I put pointers to the original documents, so please consult them if you
need to refer to the standards.

If you're reading this document off-line, you may find the most
recent version on the web:
@example
@uref{http://www.shiro.dreamhost.com/scheme/gauche/}.
@end example

@menu
* Overview of Gauche::          
* Notations::                   
* Structure of this document::  
@end menu

@node Overview of Gauche, Notations, Introduction, Introduction
@section Overview of Gauche

Gauche is a script interpreter based on Scheme.
Gauche conforms the language standard
"Revised^5 Report on the Algorithmic Language Scheme"
(@uref{http://www.schemers.org/Documents/Standards/R5RS/HTML/}),
and supports various common libraries defined in SRFIs
(@uref{http://srfi.schemers.org}).

The goal of Gauche is to provide a handy tool for
programmers and system administrators to handle
daily works conveniently and efficiently in the production environment.

There are lots of Scheme implementations available, and each
of them has its design emphasis and weeknesses.  Gauche is
designed with emphasis on the following criteria.

@table @b
@item Quick startup

In the production environment, there are situations that 
you write a ten-line Scheme script which does a simple but useful thing,
and others invoke it from 
from their shell scripts (or Perl, Phthon, Tcl, whatever) very frequently.
You don't want to use a big fat scripting engine that takes half a second
to start up for this kind of scripts, or people start writing their own
libraries in their own favorite languages.
Sharing scripts, not only code, is very important in the practical
situation, and you want to have a reasonably lightweight interpreter
to populate your scripts.

Gauche includes a set of most common features in its executable,
while splits less common stuffs into libraries which are to be loaded
on demand, to make itself start quickly.

@item Modular development

Richness of libraries is one of the criteria on which
people choose scripting language, so you want to include as many
libraries as possible.  You cannot, however, write everything by
your own.   The key to enrich the libraries are the framework to
allow and to encourage people to write reusable, modulalized code.

Gauche has several mechanisms to realize this framework.
The simple and clean module system, a powerful CLOS-like object
syste with a metaobject protocol, and feature based on-demand
file loading system are the elements.
@xref{Module System}, for details.

@item Multibyte strings

We can no longer live happily in ASCII-only or 1-byte-per-character world.
Nowadays you have to exchange text information in various encodings,
some of them have much more characters than 256 (or, in fact, more than 65536).
The practical language implementations are required to handle
multibyte (wide) characters in some way.

Gauche supports multibyte strings natively, providing robust and
consistent support than @i{ad hoc} library-level implementation.
@xref{Multibyte Strings}, for details.

@item System interface

Although Scheme abstracts lots of details of the machine,
sometimes you have to bypass these high-level layers and
go down to the basement to make things work.

Gauche has built-in support of most of POSIX.1 system calls.
Other modules, such as networking module, usually provide
both high-level abstract interface and low-level interface.

@item Powerful I/O

No real application can be written without dealing with I/O.
Scheme neatly abstracts I/O as a port, but defines least operations on it.

Gauche uses a port object as a unified abstraction, providing
utility functions to operate on the underlying I/O system.
@xref{Input and output}, for the basic I/O support.

@end table

On the other hand, Gauche is @emph{not} designed for the following
type of applications:

@table @asis
@item Number cruncher
Gauche is useful for arithmetic operations, since it supports wide
range of numbers like bignums and complex numbers.  However, it is not
designed to do fast calculation.  Use C, Fortran, or whatever you like.

@item Very high performance
Gauche is a script interpreter, and can't be comparable with compiled
programs in execution speed.  Gauche does compiles programs into
intermediate code internally, so it has performance comparable to
similar script interpreters.

@item 
@end table


@node Notations, Structure of this document, Overview of Gauche, Introduction
@section Notations

In this manual, each entry is represented like this:

@deftp {Category} foo arg1 arg2
[spec] Description of foo @dots{}
@end deftp

@var{Category} denotes the category of the entry @b{foo}.
The following category will appear in this manual:

@multitable @columnfractions .4 .6
@item Function
@tab A Scheme function.
@item Special Form
@tab A special form (in the R5RS term, ``syntax'').
@item Macro
@tab A macro.
@item Module
@tab A module
@item Class
@tab A class.
@item Generic Function
@tab A generic function
@item Method
@tab A method
@item Reader Syntax
@tab A lexical syntax that is interpreted by the reader.
@end multitable

For functions, special forms and macros, the entry may followed
by one or more arguments.  In the argument list, the following notations
may appear:

@table @var
@item arg @dots{}
This notation may appear in special forms and macros, and indicates
zero or more arguments.
@item &optional x y z
@itemx &optional (x x-default) (y y-default) z
Indicates it may take up to three optional arguments.
The second form specifies default values.
Note that Gauche doesn't really support Common-Lisp style
@code{&optional} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@item &keyword x y z
@itemx &keyword (x x-default) (y y-default) z
Indicates it may take keyword arguments @var{x}, @var{y} and @var{z.}
Note that Gauche doesn't really support Common-Lisp style
@code{&keyword} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@item &rest args
Indicates it may take rest arguements.
Note that Gauche doesn't really support Common-Lisp style
@code{&rest} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@end table

The description of the entry follows the entry line.
If the specification of the entry comes from some standard or
implementation, its origin is noted in the bracket at the beginning
of the description.  The following origins are noted:

@table @asis
@item [R5RS]
The entry works as specified in ``Revised^5 Report of Algorithmic Language
Scheme.''.
@item [SRFI-@var{n}]
The entry works as specified in SRFI-@var{n}.
@item [POSIX]
The API of the entry reflects the API specified in POSIX.
@end table


@node Structure of this document,  , Notations, Introduction
@section Structure of this document

---To be written---


@c ======================================================================
@node Concepts, Writing Scheme program using Gauche, Introduction, Top
@chapter Concepts

In this chapter I describe a few Gauche's design concepts
that help you to understand how Gauche works.

---This chapter is under construction---

@menu
* Compilation::                 
* Module System::               
* Objects::                     
* Multibyte Strings::           
@end menu

@node Compilation, Module System, Concepts, Concepts
@section Compilation

Gauche is a Scheme interpreter, in the sense that it reads
a Scheme form at a time and evaluates it.   Actually,
Gauche compiles every toplevel form into an intermediate form
before executing.

Built-in sytanxes and macros are recognized and expanded
at the compilation time.  Some built-in procedures are
expanded in-line as far as the compiler can see the global
binding is not altered at the time the form is compiled.

This raises a few problems you should care.

@table @emph
@item load is done at run time.
@code{load} is a procedure in Gauche, therefore evaluated at run time.
If the loaded program defines a macro, which is available for the compiler
after the toplevel form containing @code{load} is evaluated.  So, suppose
@code{foo.scm} defines a macro @code{foo}, and you use the macro
like this:
@example
;; @r{in ``foo.scm''}
(define-syntax foo
  (syntax-rules () (_ arg) (quote arg)))

;; @r{in your program}
(begin (load "foo") (foo (1 2 3)))
  @result{} @r{error, bad procedure: `1'}

(load "foo")
(foo (1 2 3)) @result{} '(1 2 3)
@end example
The @code{(begin (load ...))} form fails,  because the compiler
doesn't know @code{foo} is a special form at the compilation time
and compiles @code{(1 2 3)} as if it is a normal procedure call.
The latter example works, however, since the execution
of the toplevel form @code{(load "foo")} is done before
@code{(foo (1 2 3))} is compiled.

To avoid this kind of subtleties, use @code{require} or @code{use}
to load a program fragments.  Those are recognized by the compiler.

@item require is done at compile time
On the other hand, since @code{require} and @code{use} is recognized
by the compiler, the specified file is loaded even if the form
is in the conditional expression.  Use @code{load} if you need
such behavior.
@end table


@node Module System, Objects, Compilation, Concepts
@section Module System

Gauche adopts a simple module system that allows
modularlized development of large software.

A higher level interface is simple enough from the user's point
of view.   When you want to use the features provided by module
@code{foo}, you just need to say @code{(use foo)} in your code.
This form is a macro and interpreted at compile time.




The @code{use} mechanism is built on top of two independent
mechanisms, namespace separation and file loading mechanism.
Those two can be used separately, although it is much more
convenient when used together.


@node Objects, Multibyte Strings, Module System, Concepts
@section Objects

Gauche has a CLOS-style object system, with metaobject protocol.
For those who are familiar with SmallTalk style object system,
the CLOS-style multimethod may look strange.  I describe several
characteristics of Gauche object system here.
@xref{Object System}, for details.

@table @emph
@item Everything is an object.
In Gauche, everything is an object in the sense that you can
query its class, and various meta information of the object
at run time.

@item Method is dispatched by all of its arguments.
Unlike other object-oriented languages such as C++, Objective-C,
Python, Ruby, etc., in which a method always belong to a single
class, Gauche methods don't 


@end table

@node Multibyte Strings,  , Objects, Concepts
@section Multibyte Strings


@c ======================================================================
@node Writing Scheme program using Gauche, Core Syntax, Concepts, Top
@chapter  Writing Scheme program using Gauche

Gauche can be used either as an independent Scheme interpreter
or as an embedded Scheme library.   The interpreter
which comes with Gauche distribution is a program named @code{gosh}.

@deftp {Program} gosh [options] [scheme-file arg @dots{}]
Gauche's interpreter.   Without @var{scheme-file}, @code{gosh} works
interactively, i.e. it reads a Scheme expression from the standard input,
evaluates it, and prints the result, and repeat that until it reads EOF or
is terminated.

If @var{scheme-file} is specified, @code{gosh} bounds a global varialbe
@code{*argv*} to the list of the remaining command-line arguments,
then loads @var{scheme-file} as a Scheme program.
If the first line of @var{scheme-file} begins with two character
sequence ``@code{#!}'', the entire line is ignored by @code{gosh}.
This is useful to write a Scheme program that works as an executable
script in unix-like systems.  Typical Gauche script has the first
line like these
@example
#!/usr/local/bin/gosh
  @r{or,}
#!/usr/bin/env gosh
@end example
The latter uses a ``shell trampoline'' technique so that the script
works as far as @code{gosh} is in the PATH.

After the file is successfully loaded, @code{gosh} calls a
procedure named `@code{main}' with the list of the remaining
command-line arguments, if it is defined in the user module.
When @code{main} returns, and its value is an integer, @code{gosh}
uses it for exit code of the program.  Otherwise, @code{gosh} exits
with value 0.
This behavior is compatible with
the draft SRFI-22.  Although you can still write the program
main body as toplevel expressions, like shell scripts or Perl scripts,
it is much convenient to use this @code{main} convention, for
you can load the script file interactively to debug.

If the @code{main} procedure is not defined, @code{gosh} exits
after loading @var{script-file}.

The following command line options are recognized by @code{gosh}.
The first command line argument which doesn't begin with `@minus{}'
is recognized as the script file.  If you want to specify a file
that begins with a minus sign, use a dummy option `@code{--}'.
@end deftp

@deftp {Command Option} -I path
Prepends @var{path} to the load path list.
You can specify this option more than once to add multiple paths.
@end deftp

@deftp {Command Option} -q
Makes @code{gosh} not to load the default initialization file.
@end deftp

@deftp {Command Option} -V
Prints the @code{gosh} version and exits.
@end deftp

@deftp {Command Option} -u module
Use @var{module}.  Before starting execution of @var{file} or entering
the read-eval-print loop, the specified module is @var{use}d, i.e.
it is loaded and imported. 
You can specify this option more than once to use multiple modules.
@end deftp

@deftp {Command Option} -f compiler-option
This option controls the compiler behavior.  For now we have
following options available:
@table @asis
@item no-inline
Prohibits the compiler to iniline primitive Scheme procedures.
@end table
@end deftp

@deftp {Command Option} @code{--}
When @code{gosh} sees this option, it stops processing the options
and takes next command line argument as a script file.  It is useful
in case if you have a script file that begins with a minus sign,
although it is not generally recommended.
@end deftp

@defvar *argv*
The program arguments passed to the Scheme script is bound to this
variable.  If @code{gosh} is invoked in an interactive mode, this
variable always contains @code{()}.

STk uses this variable to pass the command line argument as well,
but other Scheme implementations use different ways.  It is better
to define @code{main} procedure and uses its argument to receive
command line arguments, for it is expected to be more portable.
@end defvar

@defvar *program-name*
This variable is bound to the script file name passed to @code{gosh}.
If @code{gosh} is invoked in the interactive mode, this variable
contains the pathname of @code{gosh} itself.

STk uses the same variable to access the program/script name.
Other Scheme implementations use different ways.
@end defvar

Now I show several simple examples below.
First, this script works like @code{cat(1)}, without any command-line
option processing and error handling.

@example
@cartouche
#!/usr/bin/env gosh

(define (main args)   ;@r{entry point}
  (if (null? args)
      (copy-port (current-input-port) (current-output-port))
      (for-each (lambda (file)
                  (call-with-input-file file
                    (lambda (in)
                      (copy-port in (current-output-port)))))
                args))
  0)
@end cartouche
@end example

The following script is a simple grep command.

@example
@cartouche
#!/usr/bin/env gosh

(define (usage)
  (format (current-error-port)
          "Usage: ~a regexp file ...\n" *program-name*)
  (exit 2))

(define (grep rx port)
  (let loop ((line (read-line port)))
    (cond ((eof-object? line))
          ((rxmatch rx line)
           (format #t "~a:~a: ~a\n"
                   (port-name port)
                   (- (port-current-line port) 1)
                   line)
           (loop (read-line port)))
          (else (loop (read-line port))))))

(define (main args)
  (if (null? args)
      (usage)
      (let ((rx (string->regexp (car args))))
        (if (null? (cdr args))
            (grep rx (current-input-port))
            (for-each (lambda (f)
                        (call-with-input-file f
                          (lambda (p) (grep rx p))))
                      (cdr args))))
        0))
@end cartouche
@end example

See also @ref{Parsing command-line options}, for a convenient way to
parse command-line options.


@c ======================================================================
@node Core Syntax, Macros, Writing Scheme program using Gauche, Top
@chapter Core Syntax

@c ----------------------------------------------------------------------
@menu
* Literals::                    
* Making Procedures::           
* Assignments::                 
* Conditionals::                
* Binding constructs::          
* Sequencing::                  
* Iteration::                   
* Quasiquotation::              
* Definitions::                 
* Modules::                     
@end menu

@node Literals, Making Procedures, Core Syntax, Core Syntax
@section Literals

@defspec quote datum
[R5RS] Inserts @var{datum} as a literal value.
@end defspec

@c ----------------------------------------------------------------------
@node Making Procedures, Assignments, Literals, Core Syntax
@section Making Procedures

@defspec lambda formals body @dots{}
[R5RS]
@end defspec


@c ----------------------------------------------------------------------
@node Assignments, Conditionals, Making Procedures, Core Syntax
@section Assignments

@defspec set! symbol expression
@defspecx set! (proc arg @dots{}) expression
[R5RS][SRFI-17] First, @var{expression} is evaluated.
In the first form, the binding of @var{symbol} is modified
so that next reference of @var{symbol} will return
the result of @var{expression}.
If @var{symbol} is not locally bound, the global variable named @var{symbol}
must already exist, or an error is signalled.

The second form is a ``generalized set!'' specified in SRFI-17.
It is a syntactic sugar of the following form.
@example
((setter @var{proc}) @var{arg} @dots{} @var{expression})
@end example
Note the order of the arguments differs from CommonLisp's @code{setf}.

@example
(define x 3)
(set! x (list 1 2))  @result{} @r{undefined}
x                    @result{} (1 2)

(set! (car x) 5)     @result{} @r{undefined}
x                    @result{} (5 2)
@end example
@end defspec

@defun setter proc
[SRFI-17] Returns a setter procedure associated to the procedure @var{proc}.
If no setter is associated to @var{proc}, an error is signalled.

To associate a setter procedure to another procedure, you can use
the setter of @code{setter}, like this:
@example
(set! (setter @var{get}) @var{set})
@end example

A procedure's setter can be ``locked'' to it.  System default setters,
like @code{set-car!} for @code{car}, is locked and can't be set by
the above way.   In order to lock a setter to a user defined procedure,
use @code{getter-with-setter} below.
@end defun

@defun getter-with-setter get set
[SRFI-17] Takes two procedure @var{get} and @var{set}.  Returns a new
procedure which does the same thing as @var{get}, and its setter is
locked to @var{set}.

The intention of this procedure is, according to the SRFI-17 document,
to allow implementations to inline setters efficiently.  Gauche
hasn't implement such optimization yet.
@end defun

@c ----------------------------------------------------------------------
@node Conditionals, Binding constructs, Assignments, Core Syntax
@section Conditionals

@defspec if test consequent alternate
@defspecx if test consequent
[R5RS] @var{Test} is evaluated.  If it yields a true value,
@var{consequent} is evaluated.  Otherwise, @var{alternative} is
evaluated.  If @var{alternative} is not provided, it results undefined value.
@end defspec


@defspec cond clause1 clause2 @dots{}
[R5RS]
@end defspec


@defspec case key clause1 clause2 @dots{}
[R5RS]
@end defspec


@defspec and test @dots{}
[R5RS] 
@end defspec


@defspec or test @dots{}
[R5RS]
@end defspec

@defspec when test body @dots{}
@defspecx unless test body @dots{}
Evaluates @var{test}.  If it yields true value (or false in case of
@code{unless}), @var{body} @dots{} are evaluated sequentially, and
the result of the last evaluation is returned.  Otherwise, undefined
value is returned.
@end defspec

@node Binding constructs, Sequencing, Conditionals, Core Syntax
@section Binding constructs

@defspec let bindings body
[R5RS]
@end defspec

@defspec let* bindings body
[R5RS]
@end defspec

@defspec letrec bindings body
[R5RS]
@end defspec


@defspec receive formals expression body
[SRFI-8]
@end defspec

@node Sequencing, Iteration, Binding constructs, Core Syntax
@section Sequencing


@defspec begin
[R5RS]
@end defspec


@node Iteration, Quasiquotation, Sequencing, Core Syntax
@section Iteration

@defspec do ((variable init step) @dots{}) (test expr @dots{}) body
[R5RS]
@end defspec


@defspec let name bindings body
[R5RS]
@end defspec


@c ----------------------------------------------------------------------
@node Quasiquotation, Definitions, Iteration, Core Syntax
@section Quasiquotation

@defspec quasiquote template
[R5RS]
@end defspec


@c ----------------------------------------------------------------------
@node Definitions, Modules, Quasiquotation, Core Syntax
@section Definitions

@defspec define variable expression
@defspecx define (variable formals) body @dots{}
[R5RS] In the first form, it globally binds a symbol @var{variable}
to the value of @var{expression}, in the current module.
@example
(define x (+ 1 2))
x @result{} 3
(define y (lambda (a) (* a 2)))
(y 8) @result{} 16
@end example

The second form is a syntactic sugar of defining a procedure.
@example
(define (@var{name} . @var{args}) @var{body} @dots{})
  @equiv{} (define @var{name} (lambda @var{args} @var{body} @dots{}))
@end example
@end defspec

@c ----------------------------------------------------------------------
@node Modules,  , Definitions, Core Syntax
@section Modules

Module is an object that maps symbols onto @emph{bindings}.

Unlike CommonLisp's packages, which map names to symbols,
in Gauche symbols are always @code{eq?} if two have the
same name.  However, different bindings can be associated
to the same symbol, that yield different values.




@menu
* Module syntax::               
* Module introspection::        
* Predefined modules::          
@end menu

@node Module syntax, Module introspection, Modules, Modules
@subsection Module syntax

@defspec define-module name body @dots{}
If a module named @var{name} does not exist, create one.
Then compiles and evaluates @var{body} sequentially in the module.
@end defspec

@defspec select-module name
Makes a module named @var{name} as the current module.
It is an error if no module named @var{name} exists.

If @code{select-module} is used in the Scheme file, its effect is
limited inside the file, i.e. even if you load/require a file that uses
@code{select-module} internallly, the current module of requirer is
not affected.
@end defspec

@defspec with-module name body @dots{}
Compiles and evaluates @var{body} sequentially in the module
named @var{name}.  If no moudle named @var{name}, an error is signalled.
@end defspec

@defspec export symbol @dots{}
Makes bindings of @var{symbol}s in the current module available
to modules that imports the current module.
@end defspec

@defspec export-all
Makes all bindings in the current module available to modules
that imports it.
@end defspec

@defspec import module-name @dots{}
Makes all exported bindings in the module named @var{module-name}
available in the current module.   The named modules should exist
when the compiler sees this special form.
@end defspec

@defspec current-module
Evaluates to the current module in the compile context.
Note that this is a special form, not a function.
Module in Gauche is statically determined at compile time.
@lisp
(define-module foo
  (export get-current-module)
  (define (get-current-module) (module-name (current-module))))

(define-module bar
  (import foo)
  (get-current-module)) @result{} foo @r{; not bar}
@end lisp
@end defspec

@defmac use name
A convenience macro that combines module imports and on-demand
file loading.  Basically, @code{(use foo)} is equivalent
to the following two forms:
@example
(require "foo")
(import foo)
@end example
That is, it loads the library file named ``@code{foo}'' which
defines a module named @code{foo} init, and then import the module
@code{foo} into the current module.

Although the files and modules are orthogonal concept,
it is practically convenient to separate files by modules.
Gauche doesn't force you to do so, and you can always use
@code{require} and @code{import} separately.  However, all
modules provided with Gauche are arranged so that they can be
used by @code{use} macro.

If a module is too big to fit in one file, you can split them
into several subfiles and one main file.  The main file defines
the module, and either loads, requires, or autoloads subfiles.

If @var{name} contains periods `@code{.}', it is replaced to `@code{/}'
in the file name.to be @code{require}d, for example,
@code{(use foo.bar.baz)} is expanded to:
@example
(require "foo/bar/baz")
(import foo.bar.baz)
@end example
This is not very Scheme-ish way, but nevertheless practical.
(The alternative design is to use a list of symbols to represent
hierarchical file/module configuration, as in Guile.)
@end defmac

@node Module introspection, Predefined modules, Module syntax, Modules
@subsection Module introspection

@deftp {Builtin Class} <module>
@clindex module
A module class.
@end deftp

@defun module? obj
Returns true if @var{obj} is a module.
@end defun

@defun find-module name
Returns a module object whose name is a symbol @var{name}.
If the named module doesn't exist, @code{#f} is returned.
@end defun

@defun all-modules
Returns a list of modules currently known to the system.
@end defun

@defun module-name module
@defunx module-imports module
@defunx module-exports module
@defunx module-table module
Accessors of a module object.  Returns the name of the module (a symbol),
list of imported modules, list of exported symbols, and a hash table
that maps symbols to bindings, of the @var{module} are returned,
respectively.

If the @var{module} exports all symbols, @code{module-exports} returns
@code{#t}.

It is an error to pass a non-module object.
@end defun

@node Predefined modules,  , Module introspection, Modules
@subsection Predefined modules

Several modules are predefined in Gauche.

@deftp {Builtin Module} null
@mdindex null
This module corresponds to the null environment referred in R5RS.
This module contains only syntactic bindings of built-in Gauche
special forms.
@end deftp

@deftp {Builtin Module} scheme
@mdindex scheme
This module contains all the binding of @code{null} module,
and the binding of procedures defined in R5RS.
@end deftp

@deftp {Builtin Module} gauche
@mdindex gauche
This module contains all the bindings of @code{scheme} module,
plus Gauche specific built-in procedures.
@end deftp

@deftp {Builtin Module} user
@mdindex user
This module is the default module the user code is compiled.
all the bindings of @code{gauche} module is imported.
@end deftp

@c ======================================================================
@node Macros, Core library, Core Syntax, Top
@chapter Macros

Gauche supports both R5RS hygienic macros and
traditional macros.

@menu
* Hygienic Macros::             
* Traditional Macros::          
* Macro Expansion::             
@end menu

@node Hygienic Macros, Traditional Macros, Macros, Macros
@section Hygienic Macros

@defspec define-syntax name transformer-spec
[R5RS]
@end defspec

@defspec let-syntax ((name transformer-spec) @dots{}) body
@defspecx letrec-syntax ((name transformer-spec) @dots{}) body
[R5RS]
@end defspec

@defspec syntax-rules literals clause1 clause2 @dots{}
[R5RS]
@end defspec


@node Traditional Macros, Macro Expansion, Hygienic Macros, Macros
@section Traditional Macros

@defspec define-macro (name formals) body @dots{}

@end defspec

@node Macro Expansion,  , Traditional Macros, Macros
@section Macro Expansion

@defspec %macro-expand form
@defspecx %macro-expand1 form
@end defspec


@c ======================================================================
@node Core library, Object System, Macros, Top
@chapter Core library

@c ----------------------------------------------------------------------
@menu
* Equivalence::                 
* Numbers::                     
* Booleans::                    
* Pairs and Lists::             
* Symbols::                     
* Keywords::                    
* Identifiers::                 
* Characters::                  
* Character Set::               
* Strings::                     
* Regular Expression::          
* Vectors::                     
* Hashtables::                  
* Control features::            
* Eval::                        
* Input and output::            
* Loading Programs::            
* Comparison and sorting::      
* System interface::            
@end menu

@node Equivalence, Numbers, Core library, Core library
@section Equivalence

@defun eq? obj1 obj2
[R5RS]
@end defun

@defun eqv? obj1 obj2
[R5RS]
@end defun

@defun equal? obj1 obj2
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Numbers, Booleans, Equivalence, Core library
@section Numbers

@menu
* Number classes::              
* Numerical predicates::        
* Numerical comparison::        
* Arithmetics::                 
* Numericaln conversions::      
* Logical operations::          
@end menu

@node Number classes, Numerical predicates, Numbers, Numbers
@subsection Number classes

@deftp {Builtin Class} <number>
@deftpx {Builtin Class} <complex>
@deftpx {Builtin Class} <real>
@deftpx {Builtin Class} <integer>
@clindex number
@clindex complex
@clindex real
@clindex integer
These classes consist a hierarchy of representation of numbers.
Note that these classes does not exactly corresponds to the
number hierarchy defined in R5RS.  Especially, 
only exact integers are the instances of the @code{<integer>}
class.  That is,
@lisp
(integer? 1) @result{} #t
(is-a? 1 <integer>) @result{} #t

(integer? 1.0) @result{} #t
(is-a? 1.0 <integer>) @result{} #f
@end lisp
@end deftp

@node Numerical predicates, Numerical comparison, Number classes, Numbers
@subsection Numerical predicates

@defun number? obj
@defunx complex? obj
@defunx real? obj
@defunx rational? obj
@defunx integer? obj
[R5RS]
@end defun

@defun exact? obj
@defunx inexact? obj
[R5RS]
@end defun

@defun zero? z
[R5RS]
@end defun

@defun positive? x
@defunx negative? x
[R5RS]
@end defun

@defun odd? n
@defunx even? n
[R5RS]
@end defun

@node Numerical comparison, Arithmetics, Numerical predicates, Numbers
@subsection Numerical comparison

@defun @code{=} z1 z2 z3 @dots{}
@defunx @code{<} x1 x2 x3 @dots{}
@defunx @code{<=} x1 x2 x3 @dots{}
@defunx @code{>} x1 x2 x3 @dots{}
@defunx @code{>=} x1 x2 x3 @dots{}
[R5RS]
@end defun


@defun max x1 x2 @dots{}
@defunx min x1 x2 @dots{}
[R5RS]
@end defun

@node Arithmetics, Numericaln conversions, Numerical comparison, Numbers
@subsection Arithmetics

@defun @code{+} z @dots{}
@defunx @code{*} z @dots{}
[R5RS]
@end defun


@defun @code{-} z1 z2 @dots{}
@defunx @code{/} z1 z2 @dots{}
[R5RS]
@end defun

@defun abs z @dots{}
[R5RS+]
@end defun

@defun quotient n1 n2
@defunx remainder n1 n2
@defunx modulo n1 n2
[R5RS]
@end defun

@defun gcd n @dots{}
@defunx lcm n @dots{}
[R5RS]
@end defun

@defun numerator q
@defunx denominator q
[R5RS]
@end defun


@defun floor x
@defunx ceiling x
@defunx truncate x
@defunx round x
[R5RS]
@end defun


@defun exp z
@defunx log z
@defunx sin z
@defunx cos z
@defunx tan z
@defunx asin z
@defunx acos z
@defunx atan z
@defunx atan x y
[R5RS]
@end defun


@defun sinh z
@defunx cosh z
@defunx tanh z
@defunx asinh z
@defunx acosh z
@defunx atanh z
Hyperbolic trigonometric functions.
@end defun

@defun sqrt z
[R5RS]
@end defun

@defun expt z1 z2
[R5RS]
@end defun

@node Numericaln conversions, Logical operations, Arithmetics, Numbers
@subsection Numerical conversions

@defun make-rectangular x1 x2
@defunx make-polar x1 x2
@defunx real-part z
@defunx imag-part z
@defunx magnitude z
@defunx angle z
[R5RS]
@end defun

@defun exact->inexact z
@defunx inexact->exact z
[R5RS]
@end defun

@defun number->string z [radix]
@defunx string->number string [radix]
[R5RS]
@end defun

@node Logical operations,  , Numericaln conversions, Numbers
@subsection Logical operations

@defun ash n count
Shifts integer @var{n} left with @var{count} bits.
If @var{count} is negative, @code{ash} shifts @var{n} right with
@minus{}@var{count} bits.
Negative @var{n} is interpreted as 2's complement numbers
with 1's continue infinitely on the left side of the number.
@end defun
        
@defun logand n1 n2
@defunx logior n1 n2
@defunx logxor n1 n2
Returns bitwise and, bitwise inclusive or and bitwise exclusive or
of two integers @var{n1} and @var{n2}.
@end defun

@defun lognot n
Returns bitwise not of an integer @var{n}.
@end defun

@node Booleans, Pairs and Lists, Numbers, Core library
@section Booleans

@deftp {Builtin Class} <boolean>
@clindex boolean
A boolean class.  Only @code{#t} and @var{#f} belong to this class.
@end deftp

@defun not obj
[R5RS] Returns @code{#t} if and only if @var{obj} is @code{#t},
and returns @code{#f} otherwise.
@end defun

@defun boolean? obj
[R5RS] Returns @code{#t} if and only if @var{obj} is a boolean
value, and returns @code{#f} otherwise.
@end defun

@c ----------------------------------------------------------------------
@node Pairs and Lists, Symbols, Booleans, Core library
@section Pairs and Lists

@menu
* Pair and null class::         
* List predicates::             
* List constructors::           
* List accessors and modifiers::  
* Other list procedures::       
@end menu

@node Pair and null class, List predicates, Pairs and Lists, Pairs and Lists
@subsection Pair and null class

@deftp {Builtin Class} <list>
@clindex list
An abstract class respresents lists.   A parent class of @code{<null>}
and @code{<pair>}.

Note that a cirular list is also an instance of the @code{<list>} class,
while R5RS procedure @code{list?} returns false on the circular lists.
@lisp
(use srfi-1)
(list? (circular-list 1 2)) @result{} #f
(is-a? (circular-list 1 2) <list>) @result{} #t
@end lisp
@end deftp

@deftp {Builtin Class} <null>
@clindex null
A class of empty list.  @code{()} is the only instance.
@end deftp

@deftp {Builtin Class} <pair>
@clindex pair
A class of pairs.
@end deftp

@node List predicates, List constructors, Pair and null class, Pairs and Lists
@subsection List predicates

@defun pair? obj
[R5RS] Returns @code{#t} if @var{obj} is a pair, @code{#f} otherwise.
@end defun

@defun null? obj
[R5RS] Returns @code{#t} if @var{obj} is an empty list, @code{#f} otherwise.
@end defun

@defun list? obj
[R5RS] Returns @code{#t} if @var{obj} is a proper list, @code{#f} otherwise.
This function returns @code{#f} if @var{obj} is a dotted or circular list.
@end defun

See also @code{proper-list?}, @code{circular-list?} and
@code{dotted-list?} in @ref{SRFI-1 List predicates}.

@node List constructors, List accessors and modifiers, List predicates, Pairs and Lists
@subsection List constructors

@defun cons obj1 obj2
[R5RS] Constructs a pair of @var{obj1} and @var{obj2} and returns it.
@lisp
(cons 'a 'b) @result{} (a . b)
@end lisp
@end defun

@defun acons obj1 obj2 obj3
Returns @code{(cons (cons @var{obj1} @var{obj2}) @var{obj3})}.
Useful to put an entry at the head of an associative list.
@lisp
(acons 'a 'b '((c . d))) @result{} ((a . b) (c . d))
@end lisp
@end defun

@defun make-list len &optional fill
[SRFI-1] Makes a proper list of length @var{len}.  If optional argument
@var{fill} is provided, each element is initialized by it.  Otherwise
each element is undefined.
@lisp
(make-list 5 #t) @result{} (#t #t #t #t #t)
@end lisp
@end defun

@defun list obj @dots{}
[R5RS] Makes a list, whose elements are @var{obj} @dots{}.
@lisp
(list 1 2 3) @result{} (1 2 3)
(list) @result{} ()
@end lisp
@end defun

@defun list* obj1 obj2 @dots{}
Like @code{list}, but the last argument becomes cdr of the last pair.
SRFI-1 defines the same function with the name @var{cons*}.
@lisp
(list* 1 2 3) @result{} (1 2 . 3)
(list* 1) @result{} 1
@end lisp
@end defun

@defun list-copy list
[SRFI-1] Shallow copies @var{list}.  If @var{list} is circular,
this function diverges.
@end defun


@node List accessors and modifiers, Other list procedures, List constructors, Pairs and Lists
@subsection List accessors and modifiers

@defun car pair
@defunx cdr pair
[R5RS] Returns car and cdr of @var{pair}, respectively.
@end defun

@defun set-car! pair obj
@defunx set-cdr! pair obj
[R5RS] Modifies car and cdr of @var{pair}, by @var{obj}, respectively.

Note: @code{(setter car)} @equiv{} @code{set-car!}, and
@code{(setter cdr)} @equiv{} @code{set-cdr!}.
@end defun

@defun caar pair
@defunx cadr pair
@defunx cdar pair
@defunx cddr pair
@defunx caaar pair
@defunx caadr pair
@defunx cadar pair
@defunx caddr pair
@defunx cdaar pair
@defunx cdadr pair
@defunx cddar pair
@defunx cdddr pair
@defunx caaaar pair
@defunx caaadr pair
@defunx caadar pair
@defunx caaddr pair
@defunx cadaar pair
@defunx cadadr pair
@defunx caddar pair
@defunx cadddr pair
@defunx cdaaar pair
@defunx cdaadr pair
@defunx cdadar pair
@defunx cdaddr pair
@defunx cddaar pair
@defunx cddadr pair
@defunx cdddar pair
@defunx cddddr pair
[R5RS] @code{caar} @equiv{} @code{(car (car x))},
@code{cadr} @equiv{} @code{(car (cdr x))}, and so on.

The corresponding setters are also defined.
@example
(let ((x (list 1 2 3 4 5)))
  (set! (caddr x) -1)
  x)
  @result{} (1 2 -1 4 5)
@end example
@end defun

@defun length list
[R5RS] Returns the length of a proper list @var{list}.
If @var{list} is a dotted list, an error is signalled.
If @var{list} is a circular list, this function diverges.

If you want to handle circular lists as well, 
See @code{length+} in @ref{SRFI-1 List miscellaneous routines}.
@end defun

@defun list-tail list k
[R5RS] Returns @var{k}-th cdr of @var{list}.
@var{list} can be a proper, dotted or circular list.
@end defun

@defun list-ref list k
[R5RS] Returns @var{k}-th element of @var{list}.
@var{list} can be a proper, dotted or circular list.
@end defun

@defun last-pair list
[SRFI-1] Returns the last pair of @var{list}.
@var{list} can be a proper or dotted list.
@end defun


@node Other list procedures,  , List accessors and modifiers, Pairs and Lists
@subsection Other list procedures

@defun append list @dots{}
[R5RS]
@end defun

@defun append! list @dots{}
[SRFI-1]
@end defun


@defun reverse list
[R5RS]
@end defun

@defun reverse! list
[SRFI-1]
@end defun


@defun memq obj list
@defunx memv obj list
[R5RS]
@end defun

@defun member obj list [=]
[R5RS+][SRFI-1]
@end defun

@defun assq obj list
@defunx assv obj list
[R5RS]
@end defun

@defun assoc obj list [=]
[R5RS+][SRFI-1]
@end defun


@c ----------------------------------------------------------------------
@node Symbols, Keywords, Pairs and Lists, Core library
@section Symbols

@deftp {Builtin Class} <symbol>
@clindex symbol
A class for symbols.
@end  deftp

@defun symbol? obj
[R5RS] Returns true if and only if @var{obj} is a symbol.
In Gauche, all symbols are @emph{interned}, i.e. two symbols with
the same print name are always @code{eq?}.
@end defun

@defun symbol->string symbol
[R5RS] Returns the name of @var{symbol} in a string.  Returned
string is immutable.
@end defun

@defun string->symbol string
[R5RS] Returns a symbol whose name is @var{string}.
If the named symbol hasn't existed, this function creates one.
@end defun

@defun gensym &optional prefix
@end defun

@c ----------------------------------------------------------------------
@node Keywords, Identifiers, Symbols, Core library
@section Keywords

@deftp {Builtin Class} <keyword>
@clindex keyword
@end  deftp

@defun keyword? obj
@end defun

@defun make-keyword name
@end defun

@defun get-keyword key list [fallback]
@end defun

@c ----------------------------------------------------------------------
@node Identifiers, Characters, Keywords, Core library
@section Identifiers

@deftp {Builtin Class} <identifier>
@clindex identifier
@end  deftp

@defun identifier? obj
@end defun

@defun identifier->symbol identiifer
@end defun


@c ----------------------------------------------------------------------
@node Characters, Character Set, Identifiers, Core library
@section Characters

@deftp {Builtin Class} <char>
@clindex char
@end  deftp

@deftp {Reader Syntax} @code{#\@i{charname}}
[R5RS] Denotes a literal character.

When the reader reads @code{#\}, it fetches a sbusequent character.
If it is one of @code{()[]@{@}" \|;#}, this is a character literal of itself.
Otherwise, the reader reads subsequent characters until it sees
a non word-constituent character.  If only one character is read,
it is the character.  Otherwise, the reader matches the read characters
with predefined character names.  If it doesn't match any, an error
is signalled.
@end deftp

@defun char? obj
[R5RS] Returns @code{#t} if @var{obj} is a character, @code{#f} otherwise.
@end defun

@defun char@code{=}? char1 char2
@defunx char@code{<}? char1 char2
@defunx char@code{<=}? char1 char2
@defunx char@code{>}? char1 char2
@defunx char@code{>=}? char1 char2
[R5RS]
@end defun

@defun char-ci@code{=}? char1 char2
@defunx char-ci@code{<}? char1 char2
@defunx char-ci@code{<=}? char1 char2
@defunx char-ci@code{>}? char1 char2
@defunx char-ci@code{>=}? char1 char2
[R5RS]
@end defun

@defun char-alphabetic? char
@defunx char-numeric? char
@defunx char-whitespace? char
@defunx char-upper-case? char
@defunx char-lower-case? char
[R5RS]
@end defun

@defun char->integer char
@defunx integer->char n
[R5RS]
@end defun

@defun char-upcase char
@defunx char-downcase char
[R5RS]
@end defun

@defun gauche-character-encoding
Returns a symbol designates the native character encoding, selected
at the compile time.
The possible return values are those:
@table @code
@item euc-jp
EUC-JP
@item utf-8
UTF-8
@item sjis
Shift JIS
@item none
No multibyte character support (8-bit fixed-length character).
@end table
@end defun

@defun supported-character-encodings
Returns a list of names of character encoding schemes
that are supported in the native multibyte encoding scheme.
@end defun



@c ----------------------------------------------------------------------
@node Character Set, Strings, Characters, Core library
@section Character Set

@deftp {Builtin Class} <char-set>
@clindex char-set
Character set class.  Character set object represents a set of characters.
Gauche provides built-in support of character set creation and
a predicate that tests whether a character is in the set or not.

Further operations, such as set algebra, is defined in SRFI-14
module (See @ref{Character-set library}).
@end deftp

@deftp {Reader Syntax} @code{#[@i{char-set-spec}]}
@end deftp

@defun char-set? obj
[SRFI-14] Returns true if and only if @var{obj} is a character set object.
@end defun

@defun char-set-contains? char-set char
[SRFI-14] Returns true if and only if a character set object
@var{char-set} contains a character @var{char}.
@end defun

@defun char-set char @dots{}
[SRFI-14] Creates a character set that contains @var{char} @dots{}.
@end defun

@defun char-set-copy char-set
[SRFI-14] Copies a character set @var{char-set}.
@end defun


@c ----------------------------------------------------------------------
@node Strings, Regular Expression, Character Set, Core library
@section Strings

@deftp {Builtin Class} <string>
@clindex string
A string class.   In Gauche, a string can be viewed in two ways:
a sequence of characters, or a sequence of bytes.
@end deftp

R5RS string operations are very minimal.  Gauche supports some
extra built-in operations, and also a rich string library
defined in SRFI-13.   @xref{String library}, for details.

@menu
* String Predicates::           
* String Constructors::         
* String Accessors & Modifiers::  
* String Comparison::           
* String Utilities::            
* String Pointers::             
* Incomplete strings::          
@end menu

@node String Predicates, String Constructors, Strings, Strings
@subsection String Predicates

@defun string? obj
[R5RS] Returns @code{#t} if @var{obj} is a string, @code{#f} otherwise.
@end defun

@defun string-immutable? obj
Returns @code{#t} if @var{obj} is an immutable string, @code{#f} otherwise
@end defun

@defun string-incomplete? obj
Returns @code{#t} if @var{obj} is an incomplete string, @code{#f} otherwise
@end defun

@node String Constructors, String Accessors & Modifiers, String Predicates, Strings
@subsection String Constructors

@defun make-string k &optional char
[R5RS] Returns a string of length @var{k}.  If optional @var{char} is given,
the new string is filled with it.  Otherwise, the string is filled with
a whitespace.  The result string is always complete.

Note that the algorithm to allocate a string by @code{make-string} and
then fills it one character at a time is @emph{extremely} inefficient
in Gauche, and should be avoided.   You can use an output string port
for a string construction.   Even creating a list of characters and
using @code{list->string} is faster than using @code{make-string} and
@code{string-set!}.
@end defun

@defun string char @dots{}
[R5RS] Returns a string consisted by @var{char} @dots{}.
@end defun

@node String Accessors & Modifiers, String Comparison, String Constructors, Strings
@subsection String Accessors & Modifiers

@defun string-length string
[R5RS] Returns a length of (possibly incomplete) string @var{string}.
@end defun

@defun string-size string
Returns a size of (possibly incomplete) @var{string}.
A size of string is a number of bytes @var{string} occupies on memory.
The same string may have different sizes if the native encoding scheme
differs.

For incomplete string, its length and its size always match.
@end defun

@defun string-ref cstring k
[R5RS] Returns @var{k}-th character of a complete string @var{cstring}.
@var{k} must be greater than or equal to zero, and less than
@code{(string-length @var{cstring})}.

It is an error to pass an incomplete string.
@end defun

@defun string-byte-ref string k
Returns @var{k-th} byte of a (possibly incomplete) string @var{string}.
Returned value is an integer in the range between 0 and 255.
@var{k} must be greater than or equal to zero, and less than
@code{(string-size @var{string})}.
@end defun

@defun string-set! string k char
[R5RS] Substitute @var{string}'s @var{k}-th character by @var{char}.
@var{k} must be greater than or equal to zero, and less than
@code{(string-length @var{string})}.
Return value is undefined.

If @var{string} is an incomplete string, integer value of the lower 8 bits
of @var{char} is used to set @var{string}'s @var{k}-th byte.

See the notes in @code{make-string} about performance consideration.
@end defun

@defun string-byte-set! string k byte
Substitute @var{string}'s @var{k}-th byte by integer @var{byte}.
@var{byte} must be in the range between 0 to 255, inclusive.
@var{k} must be greater than or equal to zero, and less than
@code{(string-size @var{string})}.
If @var{string} is a complete string, it is turned to incomplete string
by this operation.
Return value is undefined.
@end defun

@node String Comparison, String Utilities, String Accessors & Modifiers, Strings
@subsection String Comparison

@defun string=? string1 string2
@defunx string-ci=? string1 string2
[R5RS]
@end defun

@defun string@code{<}? string1 string2
@defunx string@code{<=}? string1 string2
@defunx string@code{>}? string1 string2
@defunx string@code{>=}? string1 string2
@defunx string-ci@code{<}? string1 string2
@defunx string-ci@code{<=}? string1 string2
@defunx string-ci@code{>}? string1 string2
@defunx string-ci@code{>=}? string1 string2
[R5RS]
@end defun

@node String Utilities, String Pointers, String Comparison, Strings
@subsection String Utilities

@defun substring string start end
[R5RS]
@end defun

@defun string-append string @dots{}
[R5RS]
@end defun

@defun string->list string &optional start end
@defunx list->string list
[R5RS+][SRFI-13]
@end defun

@defun string-copy string &optional start end
[R5RS+][SRFI-13]
@end defun

@defun string-fill! string char &optional start end
[R5RS+][SRFI-13]
@end defun

@defun string-join strs &optional delim grammer
[SRFI-13]
@end defun

@defun string-split s char
@end defun


@node String Pointers, Incomplete strings, String Utilities, Strings
@subsection String Pointers

@deftp {Builtin Class} <string-pointer>
@clindex string-pointer
String pointer is an object to access string efficiently in sequential
order (either forward or backward).

Higher level string iterators and accessors are constructed on top of 
this primitive.  @xref{String library}, for details.
It is highly recommended to use SRFI-13 functions instead of these
string pointer objects, for portability.
@end deftp

@defun make-string-pointer str &optional index
@end defun

@defun string-pointer? obj
@end defun

@defun string-pointer-next! sp
@defunx string-pointer-prev! sp
@end defun

@defun string-pointer-set! sp index
@end defun

@defun string-pointer-substring sp &keyword (after #f)
@end defun

@defun string-pointer-index sp
@end defun

@node Incomplete strings,  , String Pointers, Strings
@subsection Incomplete strings

@defun string-complete->incomplete str
@end defun

@defun string-incomplete->complete str
@end defun

@c ----------------------------------------------------------------------
@node Regular Expression, Vectors, Strings, Core library
@section Regular Expression

@deftp {Builtin Class} <regexp>
@clindex regexp
@end deftp

@deftp {Builtin Class} <regmatch>
@clindex regmatch
@end deftp

@deftp {Reader Syntax} @code{#/@i{regexp-spec}/}
@end deftp

@defun string->regexp string
@end defun

@defun rxmatch regexp string
@var{Regexp} is a regular expression object.
A string @var{string} is matched by
@var{regexp}.  If it matches, the function returns a @code{<regmatch>}
object.  Otherwise it returns @code{#f}.

This corresponds to scsh's @code{regexp-search}.
@end defun

@defun rxmatch-substring match &optional (i 0)
@defunx rxmatch-start match &optional (i 0)
@defunx rxmatch-end match &optional (i 0)
@var{Match} is a match object returned by @code{rxmatch}.
If @var{i} equals to zero, the functions return
start, end or the substring of entire match, respectively.
With positive integer @var{I}, it returns those of @var{I}-th
submatches.  It is an error to pass other values to @var{I}.

It is allowed to pass @code{#f} to @var{match} for convenience.
The functions return @code{#f} in such case.

These functions correspond to scsh's @code{match:start}, @code{match:end}
and @code{match:substring}.
@end defun

@defun rxmatch-after match &optional (i 0)
@defunx rxmatch-before match &optional (i 0)
@end defun

Seel also @ref{Regular expression utilities}, which defines
useful macros to deal with regular expression matching.

@c ----------------------------------------------------------------------
@node Vectors, Hashtables, Regular Expression, Core library
@section Vectors

@deftp {Builtin Class} <vector>
@clindex vector
@end deftp

@defun vector? obj
[R5RS]
@end defun

@defun make-vector k &optional fill
[R5RS]
@end defun

@defun vector obj @dots{}
[R5RS]
@end defun

@defun vector-length vector
[R5RS]
@end defun

@defun vector-ref vector k
[R5RS]
@end defun

@defun vector-set! vector k obj
[R5RS]
@end defun

@defun vector->list vector
@defunx list->vector list
[R5RS]
@end defun

@defun vector-fill! vector fill
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Hashtables, Control features, Vectors, Core library
@section Hashtables

@deftp {Builtin Class} <hash-table>
@clindex hash-table
@end deftp

@defun make-hash-table args
@end defun

@defun hash-table?
@end defun

@defun hash-table-get hash key &optional default
@end defun

@defun hash-table-put! hash key value
@end defun

@defun hash-table-exists? hash key
@end defun

@defun hash-table-for-each hash proc
@end defun

@defun hash-table-keys hash
@defunx hash-table-values hash
@end defun

@defun hash-table-stat hash
@end defun


@c ----------------------------------------------------------------------
@node Control features, Eval, Hashtables, Core library
@section Control features

@menu
* Procedures::                  
* Continuation and escaping::   
* Errors::                      
* Multiple values::             
* Delayed Evaludation::         
@end menu

@node Procedures, Continuation and escaping, Control features, Control features
@subsection Procedures

@deftp {Builtin Class} <procedure>
@clindex procedure
@end deftp

@defun procedure? obj
[R5RS]
@end defun

@defun apply proc arg1 @dots{} args
[R5RS]
@end defun

@defun map proc list1 list2 @dots{}
[R5RS]
@end defun

@defun for-each proc list1 list2 @dots{}
[R5RS]
@end defun

@node Continuation and escaping, Errors, Procedures, Control features
@subsection Continuation and escaping


@defun call-with-current-continuation proc
@defunx call/cc proc
[R5RS]
@end defun

@defun dynamic-wind before thunk after
[R5RS]
@end defun

@node Errors, Multiple values, Continuation and escaping, Control features
@subsection Errors

@defun error string arg @dots{}
[SRFI-23] Signals an error.  This causes the following actions:
@enumerate
@item
@var{string} is printed by @code{display}, and each @var{arg} is printed
by @code{write}, into the current error port.
@item
If Gauche is running in the interactive mode,
the current stack trace is also displayed (although it is not correct
in the current release).
@item
The current dynamic environment is unwound, i.e.
all the active ``after'' thunk set by @code{dynamic-wind} are
executed.
@item
If Gauche is running in the interactive mode, the control goes
to the toplevel REPL.  If Gauche is running as a script,
the program exits with an exit code 70 (EX_SOFTWARE).
@end enumerate

Currently there's no way to catch the error or change this
behavior.  Error handling mechanism will be provided in 0.4.x, though.
@end defun

@defun errorf fmt-string arg @dots{}
Similar to an error, but the error message is formatted by
@code{format}, i.e. it is equivalent to:
@example
(define (errorf fmt . args)
  (error (apply format #f fmt args)))
@end example
@end defun

@node Multiple values, Delayed Evaludation, Errors, Control features
@subsection Multiple values

@defun values obj @dots{}
[R5RS] Returns @var{obj} @dots{} as multiple values.
Caller can capture multiple values by a built-in syntax
@code{receive} (@ref{Binding constructs}), or the R5Rs procedure
@code{call-with-values} described below.  See also @ref{Let-values}.
@end defun

@defun call-with-values producer consumer
[R5RS]
@end defun


@node Delayed Evaludation,  , Multiple values, Control features
@subsection  Delayed Evaludation

@defspec delay expression
[R5RS]
@end defspec

@defun force promise
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Eval, Input and output, Control features, Core library
@section Eval

@defun eval expr env
[R5RS]
@end defun

@defun null-environment
@defunx interaction-environment
@defunx scheme-report-environment version
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Input and output, Loading Programs, Eval, Core library
@section Input and Output

@menu
* Ports::                       
* Common port operations::      
* File ports::                  
* String ports::                
* Procedural ports::            
* Input::                       
* Output::                      
@end menu

@node Ports, Common port operations, Input and output, Input and output
@subsection Ports

@deftp {Builtin Class} <port>
@clindex port
A port class.   A port is Scheme's way of abstraction of I/O channel.
Gauche extends a port in number of ways so that it can be used
in wide range of applications.

Standard Scheme (R5RS) essentially defines a port as an entity that
you can fetch a character at a time and
look one character ahead from an input port, 
and put a character at a time to an output port.
Other R5RS I/O routines can be built on top of them.

Besides this basics, Gauche's port can handle the following
opertaions.

@table @asis
@item Byte I/O
You can read/write one byte at a time, instead of a character.
Some ports allow you to mix byte I/O and character I/O;
you can set the policy of handling such cases.

@item Block I/O
You can read/write a specified number of byte sequences.
This can be an efficient way of moving block of data,
if the port's underlying implementation supports block I/O
operation (for example, if the underyling port is a unix buffered
stream, this operation uses @code{fread} or @code{fwrite}).

@item Conversion
Some ports can be used to convert a data stream from one format
to another; one of such applications is character code conversion
ports, provided by @code{gauche.charconv} module
(@xref{Character code conversion}, for details).
You can define a procedural ports, in both Scheme and C, 
to implement other functionality.
@end table

@end deftp

@node Common port operations, File ports, Ports, Input and output
@subsection Common port operations

@defun input-port? obj
@defunx output-port? obj
[R5RS] Returns true if @var{obj} is an input port and an output port,
respectively.
@end defun

@defun port-closed? port
Returns true if @var{obj} is a port and it is already closed.
A closed port can't be reopened.
@end defun

@defun current-input-port
@defunx current-output-port
[R5RS] Returns the current input port and the current output port, 
respectively.
@end defun

@defun current-error-port
Returns the current output port.
@end defun

@defun with-input-from-port port thunk
@defunx with-output-to-port port thunk
@defunx with-error-to-port port thunk
@end defun

@defun close-input-port port
@defunx close-output-port port
[R5RS]
@end defun

@defun port-name port
@end defun

@defun port-current-line port
@end defun

@defun port-file-number port
Returns an integer file descriptor, if the @var{port} is associated
to the system file I/O.  Returns @code{#f} otherwise.
@end defun

@defun copy-port src dst &keyword unit
Copies data from an input port @var{src} to an output port @var{dst},
until eof is read from @var{src}.

The keyword argument @var{unit} may be zero, a positive exact integer,
a symbol @code{byte} or a symbol @code{char}, to specify the unit
of copying.  If it is an integer, a buffer of the size
(in case of zero, a system default size) is used to copy,
using block I/O.  Generally it is the fastest if you copy
between normal files.   If @var{unit} is a symbol @code{byte},
the copying is done byte by byte, using C-verson of @code{read-byte}
and @code{write-byte}.  If @var{unit} is a symbol @code{char},
the copying is done character by character, using C-version of
@code{read-char} and @code{write-char}.
@end defun


@node File ports, String ports, Common port operations, Input and output
@subsection File ports

@defun open-input-file filename
@defunx open-output-file filename
[R5RS] Opens a file @var{filename} for input or output, and
returns an input or output port associated with it, respectively.
If @var{filename} can't be opened, an error is signalled.
If @code{open-output-file} is called on an existing file, the
file is truncated.

Note for portability: Some Scheme implementations (e.g. STk) allows
you to specify a command to @var{filename} and reads from, or
writes to, the subprocess standard input/output.  Some other scripting
languages (e.g. Perl) have similar features.  In Gauche,
@code{open-input-file} and @code{open-output-file} strictly operates
on files.  However, you can use ``process ports'' to invoke
other command in a subprocess and to communiate it.
@xref{Process ports}, for details.
@end defun

@defun call-with-input-file string proc
@defunx call-with-output-file string proc
[R5RS]
@end defun

@defun with-input-from-file string thunk
@defunx with-output-to-file string thunk
[R5RS]
@end defun


@node String ports, Procedural ports, File ports, Input and output
@subsection String ports

@defun open-input-string string
[SRFI-6]
@end defun

@defun open-output-string
[SRFI-6]
@end defun

@defun get-output-string
[SRFI-6]
@end defun

@defun call-with-input-string string proc
@end defun

@defun call-with-output-string proc
@end defun

@defun with-input-from-string string thunk
@end defun

@defun with-output-to-string thunk
@end defun


@node Procedural ports, Input, String ports, Input and output
@subsection Procedural ports

The underlying mechanism of procedural ports is very flexible,
but I don't have Scheme interface yet, except the following ones:

@defun open-input-buffered-port filler buffer-size
@defunx open-output-buffered-port flusher buffer-size
These are the Scheme interface to the ``buffered port''.

@code{open-input-buffered-port} creates and returns an input port,
with associated buffer of size @var{buffer-size}.
The data is read from the buffer.
When the port is read and the buffer is empty, a procedure @var{filler}
is called with one argument, the size of required data.
@var{filler} must return a string (either complete or incomplete)
of the specified size.  It is permitted for @var{filler}
to return a string shorter than the size, if not enough data is available.
The behavior is undefined if @var{filler} returns larger string than
specified.  Note that the @var{size} of string matters, not the @var{length}
of string.
If @var{filler} finds that it reached EOF of its data source, it can
return EOF.  Retuning zero size string has the same effect as EOF.
Initially, the buffer is empty, so @var{filler} is always called
at the first attempt of reading from the port.

@code{open-output-buffered-port} creates and returns an output port,
with associated buffer of size @var{buffer-size}.
The data output to the port is accumulated in the buffer.
When the buffer gets full, or @code{flush} is called on the port,
a procedure @var{flusher} is called with an @emph{incomplete} string
to be flushed.   @var{flusher} must return a number of bytes flushed,
which must be the same as the size of the passed string.
The string may shorter than @var{buffer-size}.
When the port is closed, @var{flusher} is called with any data
remaining in the buffer, then it is called again with argument @code{#f},
indicating that the port is closed.
@end defun

@node Input, Output, Procedural ports, Input and output
@subsection Input 

@defun read &optional iport
[R5RS]
@end defun

@defun read-char &optional iport
[R5RS]
@end defun

@defun peek-char &optional iport
[R5RS]
@end defun

@defun read-byte &optional iport
Reads one byte from an input port @var{iport}, and returns an integer
in the range between 0 and 255.
If @var{iport} has already reached EOF, an eof object is returned.
@end defun

@defun read-line &optional iport
Reads one line (a sequence of bytes terminated by a newline character or EOF)
and returns a string.  The terminating newline is not included.
If @var{iport} has already reached EOF, an eof object is returned.
@end defun

@defun read-block nbytes &optional iport
Reads @var{nbytes} bytes from @var{iport}, and returns an incomplete
string consisted by those bytes.  The size of returned string may
shorter than @var{nbytes} when @var{iport} doesn't have enough bytes
to fill.  If @var{iport} has already reached EOF, an eof object is returned.

Note: if you want to write a chunk of bytes (incomplete string) to a port,
use @code{display}.
@end defun

@defun eof-object? obj
[R5RS] Returns true if @var{obj} is an EOF object.
@end defun

@defun char-ready? port
[R5RS] If a character is ready to be read from @var{port}, returns @code{#t}.
@end defun

@defun port->string port
@defunx port->list reader port
@defunx port->string-list port
@defunx port->sexp-list port
Generally useful input procedures.  The API is taken from
scsh and STk.

@code{port->string} reads @var{port}
until EOF and returns the accumulated data as a string.

@code{port->list} applies @var{reader} on @var{port} repeatedly, until
@var{reader} returns an EOF, then returns the list of objects
@var{reader} returned.

@code{(port->string-list port)} @equiv{}
@code{(port->list read-line port)}, and
@code{(port->sexp-list port)} @equiv{}
@code{(port->list read port)}.
@end defun

@node Output,  , Input, Input and output
@subsection Output

@defun write obj &optional port
[R5RS]
@end defun

@defun display obj &optional port
[R5RS]
@end defun

@deffn {Method} write-object (obj <object>) port
You can customize how the object is printed out by this method.
@end deffn

@defun newline &optional port
[R5RS]
@end defun

@defun write-char char &optional port
[R5RS]
@end defun

@defun write-byte byte &optional port
@end defun

@defun write* obj &optional port
@end defun

@defun format port string arg @dots{}
Format @var{arg} @dots{} according to @var{string}.
This function is a subset of CommonLisp's @code{format} function.

@var{port} specifies the destination; if it is an output port, the
formatted result is written to it; if it is @code{#t},
the result is written to the current output port;
if it is @code{#f}, the formatted result is returned as a string.

@var{string} is a string that contains format directives.
A format directive is a character sequence begins with tilda, `@code{~}',
and ends with some specific characters.  A format directive takes
the corresponding @var{arg} and formats it.  The rest of string is
copied to the output as is.

@example
(format #f "the answer is ~s" 42)
  @result{} "the answer is 42"
@end example

The format directive can take one or more @var{parameters}, separated
by comma characters.  A parameter may be an integer or a character;
if it is a character, it should be preceded by a quote character.
Parameter can be omitted, in such case the system default value is
used.  The interpretation of the parameters depends on the 
format directive.

Furthermore, a format directive can take two
additional flags: atmark `@code{@@}' and colon `@code{:}'.  One or
both of them may modify the behavior of the format directive.
Those flags must be placed immediately before the directive
character.

If a character `@code{v}' or `@code{V}' is in the place of the
parameter, the value of the parameter is taken from the format's
argument.  The argument must be either an integer, a character, or
@code{#f} (indicating that the parameter is effectively omitted).

Some examples:

@table @code
@item ~10,2s
A format directive @code{~s}, with two parameters, 10 and 2.
@item ~12,,,'*A
A format directive @code{~a}, with 10 for the first parameter and
a character `@code{*}' for the fourth parameter.  The second and
third parameters are omitted.
@item ~10@@d
A format directive @code{~d}, with 10 for the first parameter and
`@code{@@}' flag.
@item ~v,vx
A format directive @code{~x}, whose first and second parameter will
be taken from the arguments.
@end table

The following is a complete list of the supported format directives.

@table @asis
@item @b{~}@var{mincol},@var{colinc},@var{minpad},@var{padchar}@b{A}
Ascii output.  The corresponding argument is printed by @code{display}.
If an integer @var{mincol} is given, it specifies the minimum number
of characters to be output; if the formatted result is shorter than
@var{mincol}, a whitespace is padded to the right (i.e. the result
is left justified).

The @var{colinc}, @var{minpad} and @var{padchar} parameters
control, if given, further padding.  A character @var{padchar} replaces
the padding character for the whitespace.  If an integer @var{minpad}
is given and greater than 0, at least @var{minpad} padding character
is used, regardless of the resulting width.  If an integer @var{colinc}
is given, the padding character is added (after @var{minpad}) in chunk
of @var{colinc} characters, until the entire width exceeds @var{mincol}.

If atmark-flag is given, the format result is right justified, i.e.
padding is added to the left.

@example
(format #f "|~a|" "oops")
  @result{} "|oops|"
(format #f "|~10a|" "oops")
  @result{} "|      oops|"
(format #f "|~10@@a|" "oops")
  @result{} "|oops      |"
(format #f "|~10,,,'*a|" "oops")
  @result{} "|******oops|"
@end example

@item @b{~}@var{mincol},@var{colinc},@var{minpad},@var{padchar}@b{S}
S-expression output.  The corresponding argument is printed
by @code{write}.  The semantics of parameters and flags are the same
as @code{~A} directive.

@example
(format #f "|~s|" "oops")
  @result{} "|\"oops\"|"
(format #f "|~10s|" "oops")
  @result{} "|    \"oops\"|"
(format #f "|~10@@s|" "oops")
  @result{} "|\"oops\"    |"
(format #f "|~10,,,'*s|" "oops")
  @result{} "|****\"oops\"|"
@end example

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{D}
Decimal output.  The argument is formatted as an decimal integer.
If the argument is not an integer, @code{~A} is used to format it.

If an integer parameter @var{mincol} is given, it specifies minimum
width of the formatted result; if the result is shorter than it,
@var{padchar} is padded on the left (i.e. the result is right
justified).  The default of @var{padchar} is a whitespace.

@example
(format #f "|~d|" 12345)
  @result{} "|12345|"
(format #f "|~10d|" 12345)
  @result{} "|     12345|"
(format #f "|~10,'0d|" 12345)
  @result{} "|0000012345|"
@end example

If atmark-flag is given, the sign `@code{+}' is printed for the
positive argument.

If colon-flag is given, every @var{interval}-th digit of
the result is grouped and @var{commachar} is inserted between them.
The default of @var{commachar} is `@code{,}', and the default of
@var{interval} is 3.

@example
(format #f "|~:d|" 12345)
  @result{} "|12,345|"
(format #f "|~,,'_,4:d|" -12345678)
  @result{} "|-1234_5678|"
@end example

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{B}
Binary output.  The argument is formatted as a binary integer.
The semantics of parameters and flags are the same as
the @code{~D} directive.

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{O}
Octal output.  The argument is formatted as an octal integer.
The semantics of parameters and flags are the same as
the @code{~D} directive.

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{X}
Hexadecimal output.
The argument is formatted as a hexadecimal integer.
The semantics of parameters and flags are the same as
the @code{~D} directive.

@end table

@end defun


@c ----------------------------------------------------------------------
@node Loading Programs, Comparison and sorting, Input and output, Core library
@section Loading Programs

@defun load file &keyword (error-if-not-found #t)
[R5RS+]
@end defun

@defun load-from-port port
@end defun

@defun dynamic-load file &keyword init-function
@end defun

@defspec add-load-path path &optional (afterp #f)
@end defspec

@defspec require feature
@end defspec

@defun provide feature
@end defun

@defun provided? feature
@end defun

@defmac autoload file symbol @dots{}
@end defmac


@c ----------------------------------------------------------------------
@node Comparison and sorting, System interface, Loading Programs, Core library
@section Comparison and sorting

@defun sort list &optional cmfpn
@defunx sort! list &optional cmfpn
Sorts elements in @var{list} in ascending order and returns the sorted
list.  @code{sort!} destructively reuses the cons cells of the original
@var{list}.  The sorting order is specified by @code{cmpfn}, which is
a procedure takes two elements of @var{list}, and returns @code{#t}
if the first argument strictly precedes the second.

@example
(sort '(("Chopin" "Frederic") 
        ("Liszt" "Franz")
        ("Alkan" "Charles-Valentin"))
      (lambda (x y) (string<? (car x) (car y))))
  @result{} (("Alkan" "Charles-Valentin")
             ("Chopin" "Frederic")
             ("Liszt" "Franz"))
@end example

Some builtin objects have natural comparison order, and it is used
if @code{cmpfn} is omitted.
@end defun


@c ----------------------------------------------------------------------
@node System interface,  , Comparison and sorting, Core library
@section System interface

Gauche supports most of POSIX.1 functions and other system functions
popular among Unix variants as built-in procedures.

The procedures with name @code{sys-}@var{name} usually correspond to the
system call @var{name}.  I tried to keep the interface similar
whenever reasonable.  Sometimes Gauche has other routines that
are higher level than system calls, nevertheless I try to
provide lower level routines as well.

@menu
* Program termination::         
* Environment Inquiry::         
* Filesystems::                 
* Unix groups and passwords::   
* Locale::                      
* Signal::                      
* System Inquiry::              
* Time::                        
* Unix process management::     
* I/O multiplexing::            
* Miscellaneous system calls::  
@end menu

@node Program termination, Environment Inquiry, System interface, System interface
@subsection Program termination

@defun exit &optional (code 0)
[POSIX] Terminates the current process with the exit code @var{code}.
This calls @code{exit(2)} and does some cleaning up, like flushing
the opened file buffers.

BUG: This procedure should also unwind the current dynamic environment
created by @code{dynamic-wind}, but it is not implemented yet.
Also, Gauche doesn't have an interface to register cleanup procedure
via @code{atexit()}.
@end defun


@defun sys-exit &optional (code 0)
[POSIX] Terminates the current process with the exit code @var{code}.
This procedure calls @code{_exit(2)} directly.
No cleanup is done.  Unflushed file output is discarded.

You may use this procedure if you find the system is screwed up
and no reasonable clean up can be done.  You should use this function
to terminate a forked process; @ref{Fork and exec} for details.
@end defun

@node Environment Inquiry, Filesystems, Program termination, System interface
@subsection Environment Inquiry

@defun sys-getenv name
[POSIX]
Returns the value of the environment variable @var{name} as a string,
or @code{#f} if the environment variable is not defined.
@end defun

@defun gauche-version
@defunx gauche-architecture
@defunx gauche-library-directory
@defunx gauche-architecture-directory
@defunx gauche-site-library-directory
@defunx gauche-site-architecture-directory
These functions returns a string that tells information about Gauche
interpreter itself.
@end defun

@node Filesystems, Unix groups and passwords, Environment Inquiry, System interface
@subsection Filesystems

@menu
* Directories::                 
* Directory manipulation::      
* Pathnames::                   
* File stats::                  
* Other file operations::       
@end menu

@node Directories, Directory manipulation, Filesystems, Filesystems
@subsubsection Directories

@defun sys-readdir path
@var{path} must be a string that denotes valid pathname of an existing
directory.  This function returns a list of strings of the directory
entries.  The returned list is not sorted.  An error is signalled
if @var{path} doesn't exists or is not a directory.
@end defun

@defun sys-glob pattern
An interface to @code{glob(3)} function.  @var{pattern} is a file pattern
like sh(1): a character `@code{?}' matches any single character, 
`@code{*}' matches zero or more characters, `@code{[abc]}' matches
either `@code{a}', `@code{b}' or `@code{c}'.  If no pathname matches
@var{pattern}, an empty list is returned.

If the undelying platform doesn't have @code{glob()}, this function
signals an error of "feature not supported".
@end defun

@node Directory manipulation, Pathnames, Directories, Filesystems
@subsubsection Directory manipulation

@defun sys-remove filenmae
[POSIX] If @var{filename} is a file, or an empty directory,
it is removed.   An error is signaled if @var{filename} doesn't
exist, or is a non-empty directory.
@end defun

@defun sys-rename old new
[POSIX] Renames a file @var{old} to @var{new}.  The new name
can be in different directory from the old name, but both paths
must be on the same device.
@end defun

@defun sys-tmpnam
[POSIX]
@end defun

@defun sys-link existing new
[POSIX] Creates a hard link named @var{new} to the existing file
@var{existing}.
@end defun

@defun sys-unlink pathname
[POSIX] Removes @var{pathname}.  It can't be a directory.
Returns @code{#t} if it is successfully removed, or
@var{#f} if @var{pathname} doesn't exist.
@end defun

@defun sys-symlink existing new
Creates a symbolic link named @var{new} to the existing file @var{existing}.
If the underlying system doesn't support symbolic links, this function
raises an error ``feature not supported''.
@end defun

@defun sys-mkdir pathname mode
[POSIX] Makes a directory @var{pathname} with mode @var{mode}.
@end defun

@defun sys-rmdir pathname
[POSIX] Removes a directory @var{pathname}.  The directory must 
be empty.
@end defun

@defun sys-umask mode
[POSIX] Sets umask setting to @var{mode}.  Returns previous umask setting.
See @code{man umask} for more details.
@end defun

@node Pathnames, File stats, Directory manipulation, Filesystems
@subsubsection Pathnames

@defun sys-normalize-pathname pathname &keyword absolute expand canonicalize
Converts @var{pathname} according to the way specified by keyword arguments.
@table @code
@item absolute
  If this keyword arugment is given and true, and @var{pathname} is not
  an absolute pathname, it is converted to an absolute pathname by
  appending the current working directory in front of @var{pathname}.
@item expand
  If this keyword argument is given and true, and @var{pathname} begins
  with `@code{~}', it is expanded as follows:
@itemize @bullet
@item
    If @var{pathname} is consisted entirely by ``@code{~}'', or begins
    with ``@code{~/}'', then the character ``@code{~}'' is replaced
    for the pathname of the current user's home directory.
@item
    Otherwise, characters following `@code{~}' until either `@code{/}' or
    the end of @var{pathname} are taken as a user name, and the user's
    home directory is replaced in place of it.  If there's no such
    user, an error is signalled.
@end itemize
@item canonicalize
  Tries to remove pathname components ``@code{.}'' and ``@code{..}''.
  The pathname interpretation is done purely in textural level, i.e.
  it doesn't access filesystem to see the conversion reflects the
  real files.  It may be a problem if there's a symbolic links to
  other directory in the path.
@end table
@end defun

@defun sys-basename pathname
@defunx sys-dirname pathname
@code{sys-basename} returns a basename, that is the last component of
@var{pathname}.  @code{sys-dirname} returns the components of @var{pathname}
but the last one.   If @var{pathname} has a trailing `@code{/}', 
it is simply ignored.
@example
(sys-basename "foo/bar/bar.z") @result{} "bar.z"
(sys-basename "coo.scm") @result{} "coo.scm"
(sys-basename "x/y/") @result{} "y"
(sys-dirname "foo/bar/bar.z") @result{} "foo/bar"
(sys-dirname "coo.scm") @result{} "."
(sys-dirname "x/y/") @result{} "x"
@end example
These functions doesn't check if @var{pathname} really exists.

Some boundary cases:
@example
(sys-basename "") @result{} ""
(sys-dirname "") @result{} "."

(sys-basename "/") @result{} ""
(sys-dirname "/") @result{} "/"
@end example
Note: The above behavior is the same as Perl's @code{basename} and
@code{dirname}.   On some implementations, the command @code{basename}
may return @code{"/"} for the argument @code{"/"}, and
@code{"."} for the argument @code{"."}.
@end defun

@node File stats, Other file operations, Pathnames, Filesystems
@subsubsection File stats

@deftp {Builtin Class} <sys-stat>
@clindex sys-stat
An object that represents @code{struct stat}, attributes of an
entry in the filesystem.
@end deftp

@defun sys-stat path
[POSIX] Returns a @code{<sys-stat>} object of @var{path}.
If @var{path} is a symbolic link, a stat of the file the link points
to is returned.
@end defun

@defun sys-lstat path
Like @code{sys-stat}, but it returns a stat of a symbolic link
if @var{path} is a symbolic link.
@end defun

@defun sys-fstat port-or-fd
[POSIX] @code{port-or-fd} may be a port or a positive exact integer
file descriptor.
Returns a @code{<sys-stat>} object of the underlying file of
@var{port-or-fd}.  If a port is given, and the port is not
associated to a file, @code{#f} is returned.
@end defun

@defun sys-stat->mode stat
@defunx sys-stat->ino stat
@defunx sys-stat->dev stat
@defunx sys-stat->rdev stat
@defunx sys-stat->nlink stat
@defunx sys-stat->size stat
@defunx sys-stat->uid stat
@defunx sys-stat->gid stat
@defunx sys-stat->atime stat
@defunx sys-stat->mtime stat
@defunx sys-stat->ctime stat
Accessors of @code{<sys-stat>} objects.  @code{sys-stat->mode} through
@code{sys-stat->gid} returns an exact integer.  @code{sys-stat->atime}
to @code{sys-stat->ctime} returns a number of seconds since Epoch.
@end defun

@defun sys-stat->file-type stat
@var{stat} is a @code{<sys-stat>} object.  Returns one of the following
symbols, according to the information of the mode word of @var{stat}.
@multitable {aaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item @code{regular} @tab a regular file
@item @code{directory} @tab a directory
@item @code{character} @tab a character device
@item @code{block} @tab a block device
@item @code{fifo} @tab a fifo
@item @code{symlink} @tab a symbolic link
@item @code{socket} @tab a socket
@end multitable
If the file type is none of the above, @code{#f} is returned.
@end defun

@defun sys-access pathname amode
[POSIX]
An interface to @code{access(2)}.
Returns a boolean value of indicating whether @var{pathname} is allowed
in @var{amode}.  @var{amode} can be a combinations (logical or) of
following predefined flags.
@table @code
@item r_ok
Checks whether @var{pathname} is readable by the current user.
@item w_ok
Checks whether @var{pathname} is writable by the current user.
@item x_ok
Checks whether @var{pathname} is executable (or searchable in case
@var{pathname} is a directory) by the current user.
@item f_ok
Checks whether @var{pathname} exists or not, regardless of
the access permissions of @var{pathname}.  (But you need to have
access permissions of the directories containing @var{pathname}).
@end table
An error is signalled if @var{pathname} does not exist, or the permissions
of directories containing @var{pathname} prevents you from cheking
@var{pathname} itself.
@end defun

@node Other file operations,  , File stats, Filesystems
@subsubsection Other file operations

@defun sys-chdir dir
[POSIX]
An interface to @code{chdir(2)}.  Change the process's current
working directory to @var{dir}.   An error is signalled if
@var{dir} doesn't exist, or you don't have enough permission to
access @var{dir}.
@end defun

@defun sys-pipe &keyword (buffered? @code{#t})
[POSIX] Creates a pipe, and returns two ports.
The first returned port is an input port and the second is an output port.
The data put to the output port can be read from the input port.

By default, the returned port is buffered using stdio interface,
i.e. you may want to call @code{flush} for the output port to make sure
the data can be read from the input port.  If the keyword argument
@var{buffered?} is false, however, the ports uses low-level
system calls (@code{read(2)} and @code{write(2)}.

@example
(receive (in out) (sys-pipe)
  (display "abc\n" out)
  (flush out)
  (read-line in)) @result{} "abc"
@end example

Note: the returned value is changed from version 0.3.15, in which
@code{sys-pipe} returned a list of two ports.
@end defun

@defun sys-isatty port-or-fd
[POSIX] @var{port-or-fd} may be a port or an integer file descriptor.
Returns @code{#t} if the port is connected to the console, @code{#f}
otherwise.
@end defun

@defun sys-ttyname port-or-fd
[POSIX] @var{port-or-fd} may be a port or an integer file descriptor.
Returns the name of the terminal connected to the port,
or @code{#f} if the port is not connected to a terminal.
@end defun

@node Unix groups and passwords, Locale, Filesystems, System interface
@subsection Unix groups and passwords

@menu
* Unix Group::                  
* Unix Password::               
* Password encryption::         
@end menu

@node Unix Group, Unix Password, Unix groups and passwords, Unix groups and passwords
@subsubsection Unix Group

@deftp {Builtin Class} <sys-group>
@clindex sys-group
@end deftp

@defun sys-getgrid gid
@defunx sys-getgrnam name
[POSIX]
@end defun

@defun sys-gid->group->name gid
@defunx sys-group-name->gid name
@end defun

@node Unix Password, Password encryption, Unix Group, Unix groups and passwords
@subsubsection Unix Password

@deftp {Builtin Class} <sys-passwd>
@clindex sys-passwd
@end deftp

@defun sys-getpwuid uid
@defunx sys-getpwnam name
[POSIX]
@end defun

@defun sys-uid->user-name uid
@defunx sys-user-name->uid
@end defun


@node Password encryption,  , Unix Password, Unix groups and passwords
@subsubsection Password encryption

@defun sys-crypt key salt
This is the interface to @code{crypt(3)}.   @var{Key} and @var{salt}
must be a string, and an encrypted string is returned.
On systems where @code{crypt(3)} is not available, call to this
function signals an error.
@end defun

@node Locale, Signal, Unix groups and passwords, System interface
@subsection Locale

@defun sys-setlocate category locale
[POSIX]
@end defun


@node Signal, System Inquiry, Locale, System interface
@subsection Signal

@defvar SIGABRT
@defvarx SIGALRM
@defvarx SIGCHLD
@defvarx SIGCONT
@defvarx SIGFPE
@defvarx SIGHUP
@defvarx SIGILL
@defvarx SIGINT
@defvarx SIGKILL
@defvarx SIGPIPE
@defvarx SIGQUIT
@defvarx SIGSEGV
@defvarx SIGSTOP
@defvarx SIGTERM
@defvarx SIGTSTP
@defvarx SIGTTIN
@defvarx SIGTTOU
@defvarx SIGUSR1
@defvarx SIGUSR2
These variables are bound to the corresponding signal numbers.
@end defvar

@defun sys-kill pid sig
[POSIX] Sends a signal @var{sig} to the specified process.  @var{sig}
must be a positive exact integer.  @var{pid} is an exact integer and
specifies the target process(es):
@itemize @bullet
@item
If @var{pid} is positive, it is the target process id.
@item
If @var{pid} is zero, the signal is sent to every process in the process
group of the current process.
@item
If @var{pid} is less than -1, the signal is sent to every process in
the process group @var{-pid}.
@end itemize
@end defun


@node System Inquiry, Time, Signal, System interface
@subsection System Inquiry

@defun sys-uname
[POSIX]
@end defun

@defun sys-getcwd
[POSIX] Returns the current working directory by a string.
If the current working directory couldn't be obtained from the system,
an error is signalled.
@end defun

@defun sys-getgid
@defunx sys-getegid
[POSIX] Returns integer value of real and effective group id of the
current process, respectively.
@end defun

@defun sys-getuid
@defunx sys-geteuid
[POSIX] Returns integer value of real and effective user id of the
current process, respectively.
@end defun

@defun sys-getgroups
[POSIX] Returns a list of integer ids of supplementary groups.
@end defun

@defun sys-getlogin
[POSIX] Returns a string of the name of the user logged in on the
controlling terminal of the current process.
If the system can't determine the information, @code{#f} is returned.
@end defun

@defun sys-getpgrp
[POSIX]
@end defun

@defun sys-getpid
@defunx sys-getppid
[POSIX]
@end defun

@defun sys-times
[POSIX]
@end defun

@node Time, Unix process management, System Inquiry, System interface
@subsection Time

@deftp {Builtin Class} <sys-tm>
@clindex sys-tm
Represents @code{struct tm}.
@end deftp

@defun sys-time
[POSIX] Returns the time since Epoch (00:00:00 UTC, January 1, 1970),
measured in seconds.  It may be a non-integral number, depending on
the architecture.

Note that POSIX's definition of ``seconds since the Epoch'' doesn't
take leap seconds into acount.
@end defun

@defun sys-gmtime time
[POSIX] @var{time} is a number of seconds since Epoch.
This function converts it to @code{<sys-tm>} object, represented in GMT.
@end defun

@defun sys-localtime time
[POSIX] @var{time} is a number of seconds since Epoch.
This function converts it to @code{<sys-tm>} object, represented in the
local time.
@end defun

@defun sys-ctime time
[POSIX]
@end defun

@defun sys-difftime time1 time0
[POSIX]
@end defun

@defun sys-asctime tm
[POSIX]
@end defun

@defun sys-strftime format tm
[POSIX]
@end defun

@defun sys-mktime tm
[POSIX]
@end defun

@defun sys-tm->alist tm
@end defun

@node Unix process management, I/O multiplexing, Time, System interface
@subsection Unix process management

@menu
* Fork and exec::               
* Wait::                        
@end menu

@node Fork and exec, Wait, Unix process management, Unix process management
@subsubsection Fork and exec

@defun sys-system command
[POSIX]
Runs @var{command} in a subprocess.   @var{command} is usually passed
to @code{sh}, so the shell metacharacters are interpreted.

This function returns an integer value @code{system()} returned.
Since POSIX doesn't define what @code{system()} returns, you can't
interpret the returned value in a portable way.
@end defun

@defun sys-fork
[POSIX]
Fork the current process.  Returns 0 if you're in the child process,
and a child process' pid if you're in the parent process.
All the opened file descriptors are shared between the parent and
the child.  See @code{fork(2)} of your system for details.

If the forked process runs some Scheme code and exits instead of
calling @code{sys-exec}, the forked process should call @code{sys-exit} to
terminate itself.  Normal exit call tries to flush the file
buffers, and on some OS it messes up the parent's file buffers.
@end defun

@defun sys-exec command args &optional iomap
[POSIX+]
Execute @var{command} with @var{args}, a list of arguments.
The current process image is replaced by @var{command},
so this function never returns.

All elements of @var{args} must be strings.  The first element of
@var{args} is used as @code{argv[0]}, i.e. the program name.

The optional @var{iomap} argument, when provided, specifies how the
open file descriptors are treated.  It must be the following format:
@example
((@i{to-fd} . @i{from-port-or-fd}) @dots{})
@end example
@i{To-fd} must be an integer,
and @i{from-port-or-fd} must be an integer file descriptor or a port.
Each element of the list makes the file descriptor of @i{from-port-or-fd}
of the current process be mapped to the file descriptr @i{to-fd}
in the executed process.

If @var{iomap} is provided,
any file descriptors other than specified in the iomap list will be closed
before @code{exec()}.  Otherwise, all file descriptors in the current
process remain open.

@example
(sys-exec "ls" '("ls" "-l")) @result{} ;; ls is executed.

(sys-exec "ls" '("ls" "-l") '((1 . 2) (1 . 1)))
   @result{} ;; ls is executed, with its stderr and stdout are mapped to the
              current process's stdout.
@end example

When it encounters an error, most of the time it raises an error condition.
Once the file descriptors are permuted, however, it would be impractical
to handle errors in reasonable way (you don't even know stderr is still
available!), so Gauche simply exits on the error.
@end defun

See also @ref{High Level Process Interface}, which provides
more convenient process handling on top of above primitives.

@node Wait,  , Fork and exec, Unix process management
@subsubsection Wait

@defun sys-wait
[POSIX] Calls system's @code{wait(2)}.  The process suspends its execution
until one of the child terminates.  Returns two exact integer values,
the first one is the child's process id, and the second is a status code.
The status code can be interpreted by the following functions.
@end defun

@defun sys-waitpid pid &keyword nohang untraced
[POSIX] This is an interface to @code{waitpid(3)}, an extended version of
wait.

@var{pid} is an exact integer specifying which child(ren) it's waiting.
If it is a positive integer,
it waits fot that specific child.  If it is zero, it waits for any
member of this process group.  If it is -1, it waits for any child process.
If it is less than -1, it waits for any child process whose process group
id is equal to the absolute value of @var{pid}.

The calling process suspends until one of those child process is terminated,
unless true is specified to the keyword argument @var{nohang}.

If true is specified to the keyword argument @var{untraced},
the status of stopped child process can be also returned.

The return values are two exact integers, the first one is the child
process id, and the second is a status code.  If @var{nohang} is true and
no child process status is available, the first value is zero.
@end defun

@defun sys-wait-exited? status
@defunx sys-wait-exit-status status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-wait} or @code{sys-waitpid}.
@code{sys-wait-exited?} returns @code{#t} if the child process is 
terminated normally.   @code{sys-wait-exit-status} returns the exit
code the child process passed to @code{exit(2)}, or the return value
of @code{main()}.
@end defun

@defun sys-wait-signaled? status
@defunx sys-wait-termsig status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-wait} or @code{sys-waitpid}.
@code{sys-wait-signaled?} returns @code{#t} if the child process
is termintaed by an uncaught signal.
@code{sys-wait-termsig} returns the signal number that terminted the child.
@end defun

@defun sys-wait-stopped? status
@defunx sys-wait-stopsig status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-waitpid}.
@code{sys-wait-stopped?} returns @code{#t} if the child process is
stopped.   This status can be caught only by @code{sys-waitpid} with
true @var{untraced} argument.  @code{sys-wait-stopsig} returns the
signum number that stopped the child.
@end defun

@node I/O multiplexing, Miscellaneous system calls, Unix process management, System interface
@subsection I/O multiplexing

The interface functions for @code{select(2)}.

@deftp {Builtin Class} <sys-fdset>
@clindex sys-fdset
Represents @code{fd_set}, a set of file descriptors.  You can make
an empty file descriptor set by make method:
@example
(make <sys-fdset>)
@end example
@end deftp

@defun sys-fdset-ref fdset port-or-fd
@defunx sys-fdset-set! fdset port-or-fd flag
Gets and sets specific file descritor bit of @var{fdset}.
@var{port-or-fd} may be a port or an integer file descriptor.
If @var{port-or-fd} is a port that doesn't have associated file descriptor,
@code{sys-fdset-ref} returns @code{#f}, and @code{sys-fdset-set!} doesn't
modify @var{fdset}.  @var{flag} must be a boolean value.

You can use generic setter of @code{sys-fdset-ref} as this:
@example
(set! (sys-fdset-ref fdset port-or-fd) flag)
  @equiv{} (sys-fdset-set! fdset port-or-fd flag)
@end example
@end defun

@defun sys-fdset-max-fd fdset
Returns the maximum file descriptor number in @var{fdset}.
@end defun

@defun sys-select readfds writefds exceptfds &optional timeout
@defunx sys-select! readfds writefds exceptfds &optional timeout
Waits for a set of file descriptors to change status.
@var{readfds}, @var{writefds}, and @var{exceptfds} are @code{<fdset>}
objects to represent a set of file descriptors to watch.
File descriptors in @var{readfds} are watched to see if characters
are ready to be read.   File descriptors in @var{writefds} are
watched if writing to them is ok.  File descriptors in @var{exceptfds}
are watched for exceptions.  You can pass @code{#f} to one or more
of those arguments if you don't care about watching the condition.

@var{timeout} specifies maximum time @code{sys-select} waits for
the condition change.  It can be a real number, for number of microseconds,
or a list of two integers, the first is the number of seconds and
the second is the number of microseconds.  If you pass @code{#f},
@code{sys-select} waits indefinitely.

@code{sys-select} returns four values.  The first value is a number
of descriptors it detected status change.  It may be zero if 
timeout expired.  The second, third and fourth values are @code{<fdset>}
object that contains a set of descriptors that changed status
for reading, writing, and exception, respectively.
If you passed @code{#f} to one or more of @var{readfds},
@var{writefds} and @var{exceptfds}, the corresponding return value
is @code{#f}.

@code{sys-select!} variant works the same as @code{sys-select}, except
it modifies the passed @code{<fdset>} arguments.
@code{sys-select} creates new @code{<fdset>} objects and
doesn't modify its arguments.
@end defun


@node Miscellaneous system calls,  , I/O multiplexing, System interface
@subsection Miscellaneous system calls

@defun sys-pause
[POSIX] Suspends the process until it receives a signal whose
action is to either execute a signal-catching function or to terminate
the process.  This function only returns when the signal-catching
function returns.  The returned value is undefined.
@end defun

@defun sys-sleep seconds
[POSIX] Suspends the process until the specified number of seconds elapses,
or the process receives a signal.  Returns zero if it sleeps well,
or the number of unslept seconds if it is woke up by a signal.

To be porable across POSIX implementation, keep @var{seconds} less than
65536.
@end defun

@defun sys-random
@defunx sys-srandom seed
A pseudo random number generator.
@code{sys-random} returns a random number between 0 and a positive
integer @var{rand_max}, inclusive.  This is a straightforward
interface to @code{random(3)}.  If the underlying system doesn't have
@code{random(3)}, @code{lrand48(3)} is used.

@code{sys-srandom} sets the seed of the random number generator.
It uses either @code{srandom(3)} or @code{srand48(3)}, depending on
the system.

The intension of these functions are to provide an off-the-stock handy
random number generator (RNG) for applications that doens't
sensitive to the quality and/or speed of RNG.  For serious statistics
analysis, better RNGs should be used.  Gauche will provide an
extention module of Mersenne Twister RNG soon.
@end defun

@defvar rand_max
Bound to a positive integer that @code{sys-random} may return.
@end defvar

@c ======================================================================
@node Object System, Libarary Modules, Core library, Top
@chapter Object System

@c ----------------------------------------------------------------------
@menu
* General Inquiry::             
* Defining class::              
* Defining methods::            
* Creating Instance::           
* Accessing Instance::          
* Metaobject protocol::         
@end menu

@node General Inquiry, Defining class, Object System, Object System
@section  General Inquiry

@defun class-of obj
Returns a class metaobject of @var{obj}.
@end defun

@defun is-a? obj class
Returns true if @var{obj} is an instance of @var{class} or an instance
of descendants of @var{class}.
@end defun

@c ----------------------------------------------------------------------
@node Defining class, Defining methods, General Inquiry, Object System
@section Defining class

@defmac define-class name supers (slot-spec @dots{}) option @dots{}
@end defmac


@c ----------------------------------------------------------------------
@node Defining methods, Creating Instance, Defining class, Object System
@section Defining methods

@defmac define-generic name
@end defmac

@defmac define-method name specs body
@end defmac

@c ----------------------------------------------------------------------
@node Creating Instance, Accessing Instance, Defining methods, Object System
@section Creating Instance

@deffn {Generic Function} make class arg @dots{}
@end deffn

@deffn {Method} make (class <class>) arg @dots{}
@end deffn

@deffn {Method} make (class <method>)  arg @dots{}
@deffnx {Method} make (class <generic>)  arg @dots{}
@end deffn

@deffn {Method} initialize (class <class>) initargs
@end deffn

@c ----------------------------------------------------------------------
@node Accessing Instance, Metaobject protocol, Creating Instance, Object System
@section Accessing Instance

@defun slot-ref obj slot
@end defun

@defun slot-set! obj slot
@end defun

@defun slot-bound? obj slot
@end defun

@defun slot-exists? slot
@end defun

@deffn {Generic Function} slot-unbound
@end deffn

@deffn {Method} slot-unbound (class <class>) obj slot
@end deffn

@deffn {Generic Function} slot-missing
@end deffn

@deffn {Method} slot-missing (class <class>) obj slot &optional value
@end deffn


@defun class-slot-ref class slot-name
@defunx class-slot-set! class slot-name obj
@end defun

@c ----------------------------------------------------------------------
@node Metaobject protocol,  , Accessing Instance, Object System
@section Metaobject procotol

@menu
* System metaclasses::          
* Class introspection::         
* Class instantiation::         
* Customizing slot access::     
* Method instantiation::        
* Customizing method application::  
@end menu

@node System metaclasses, Class introspection, Metaobject protocol, Metaobject protocol
@subsection System metaclasses

@deftp {Class} <top>
@clindex top
@end deftp

@deftp {Class} <class>
@clindex class
@end deftp

@deftp {Class} <generic>
@clindex generic
@end deftp

@deftp {Class} <method>
@clindex method
@end deftp

@deftp {Class} <object>
@clindex object
@end deftp


@node Class introspection, Class instantiation, System metaclasses, Metaobject protocol
@subsection Class introspection

@menu
* Class metaobject::            
* Slot definition::             
@end menu

@node Class metaobject, Slot definition, Class introspection, Class introspection
@subsubsection Class metaobject

@defun class-name class
@end defun

@defun class-precedence-list class
@end defun

@defun class-direct-supers class
@end defun

@defun class-direct-slots class
@end defun

@defun class-slots
@end defun

@node Slot definition,  , Class metaobject, Class introspection
@subsubsection Slot definition

@defun class-slot-definition class slot-name
@end defun

@defun class-slot-accessor class slot-name
@end defun

@defun slot-definition-name slot-def
@end defun
@defun slot-definition-allocation slot
@end defun

@defun slot-definition-getter slot
@defunx slot-defininion-setter slot
@defunx slot-definition-accessor slot
@end defun

@defun slot-definition-options slot-def
@defunx slot-definition-option slot-def key &optional default
@end defun

@node Class instantiation, Customizing slot access, Class introspection, Metaobject protocol
@subsection Class instantiation

@node Customizing slot access, Method instantiation, Class instantiation, Metaobject protocol
@subsection Customizing slot access

@node Method instantiation, Customizing method application, Customizing slot access, Metaobject protocol
@subsection Method instantiation

@node Customizing method application,  , Method instantiation, Metaobject protocol
@subsection Customizing method application



@c ======================================================================
@node Libarary Modules, References, Object System, Top
@chapter Library Modules

@c ----------------------------------------------------------------------
@menu
* Character code conversion::   
* Networking::                  
* Parsing command-line options::  
* High Level Process Interface::  
* Regular expression utilities::  
* Serializer::                  
* Unit Testing::                
* RFC822 Message parsing::      
* Base64 encoding/decoding::    
* URI parsing and construction::  
* SLIB::                        
* Feature Conditional::         
* List library::                
* And-let*::                    
* Homogeneous Vectors::         
* SRFI String ports::           
* Syntax to receive multiple values::  
* Record types::                
* Let-values::                  
* String library::              
* Character-set library::       
@end menu

@node Character code conversion, Networking, Libarary Modules, Libarary Modules
@section @code{gauche.charconv} - Character Code Conversion

@deftp {Module} gauche.charconv
@mdindex gauche.charconv
This module defines a set of functions that converts character encoding
of the given data stream.

Internally, charconv module uses @code{iconv(3)} character code
conversion library.
The supported character encoding schemes (CES) are limited to what
the underlying @code{iconv} supports.   Unfortunately, there is no
standard way to query supported CES's from the system.  You have to
check the manual of your iconv system (try @code{man iconv}) to find
out what CES's are supported.

A CES is represented by its name as a string (case insignificant).
There may be several aliases defined for a single encoding.
For example, both @code{"EUC-JP"} and @code{"EUCJP"} may work on the EUC-JP
encoding.  The iconv in glibc 2.1 or later recognizes following
names for the typical Japanese CES.

@table @code
@item "EUC-JP", "EUCJP"
EUC-JP
@item "SJIS", "SHIFT-JIS"
Shift JIS
@item "UTF-8"
UTF-8
@item "CSISO2022JP"
ISO-2022-JP
@end table

There are cases that you know the input is encoded in one of
several possible encodings.  The charconv module has a mechanism
to guess the input encoding.  There can be multiple algorithms,
and each algorithm has the name.  Right now, there's only one
algorithm implemented:
@table @code
@item "*JP"
To guess the character encoding from japanese text, among either
ISO-2022-JP, EUC-JP, ShiftJIS or UTF-8.
@end table
@end deftp

You can check whether the specific conversion is supported on
your system or not, by the following function.

@defun ces-conversion-supported? from-ces to-ces
Returns @code{#t} if conversion from the character encoding scheme
(CES) @var{from-ces} to @var{to-ces} is supported in this system.
@end defun

@defun open-input-conversion-port source from-code &keyword to-code buffer-size owner?
Takes an input port @var{source}, which feeds characters
encoded in @var{from-code}, and returns another input port,
from which you can read characters encoded in @var{to-code}.

@var{buffer-size} is used to allocate internal buffer size for
conversion.  The default size is about 1 kilobytes.

If you don't know the @var{source}'s CES, you can specify
CES guessing scheme, such as @code{"*JP"}, in place of @var{from-code}.
The conversion port tries to guess the encoding, by prefetching
the data from @var{source} up to the buffer size.  It signals an error
if the code guessing routine finds no appropriate CES.
If the guessing routine finds ambiguous input, however, it silently
assume one of possible CES's, in favor of the native CES.
Hence it is possible that the guessing is wrong if the buffer
size is too small.  The default size is usually enough for most
text documents, but it may fail if the large text contains mostly ASCII
characters and multibyte characters appear only at the very end of
the document.

By default, @code{open-input-conversion-port} leaves @var{source} open.
If you specify true value to @var{owner?}, the function closes
@var{source} after it reads EOF from the port.

For example, the following code copies a file @code{unknown.txt} to a file
@code{eucjp.txt}, converting unknown japanese CES to EUC-JP.
@example
(call-with-output-file "eucjp.txt"
  (lambda (out)
    (copy-port (open-input-conversion-port
                 (open-input-file "unknown.txt")
                 "*jp"             ;@r{guess code}
                 :to-code "eucjp"
                 :owner? #t)       ;@r{close unknown.txt afterwards}
               out)))
@end example

@end defun

@defun open-output-conversion-port sink to-code &keyword from-code buffer-size owner?
Creates and returns an output port that converts
given characters from @var{from-code} to @var{to-code}
and feed to an output port @var{sink}.
If @var{from-code} is omitted, the native CES is assumed.
You can't specify a character guessing scheme (such as "*JP") to
neither @var{from-code} nor @var{to-code}.

@var{buffer-size} specifies the size of internal conversion buffer.
The characters put to the returned port may stay in the buffer,
until the port is explicity flushed (by @code{flush}) or
the port is closed.

By default, the returned port doesn't closes @var{sink} when
itself is closed.  If a keyword argument @var{owner?} is provided
and true, however, it closes @var{sink} when it is closed.
@end defun

@defun ces-convert string from-code &optional to-code
Convert @var{string}'s character encoding from @var{from-code}
to @var{to-code}, and returns the converted string.
The returned string may be a byte-string if @var{to-code}
is different from the native CES.

@var{from-code} can be a name of character guessing scheme
(e.g. "*JP").  when @var{to-code} is omitted, the native CES is
assumed.
@end defun

@defun ces-guess-from-string string scheme
Guesses the CES of @var{string} by the character guessing scheme
@var{scheme} (e.g. "*JP").  Returns CES name that can be used
by other charconv functions.   It may return @code{#f} if the
guessing scheme finds no possible encoding in @var{string}.
Note that if there may be more than one possible encoding in
@var{string}, the guessing scheme returns one of them,
usually in favor of the native CES.
@end defun

@c ----------------------------------------------------------------------
@node Networking, Parsing command-line options, Character code conversion, Libarary Modules
@section @code{gauche.net} - Networking

@deftp {Module} gauche.net
@mdindex gauche.net
Provides a set of functions necessary for network communications
based on BSD socket interface.

The API is provided in two different levels.  Lower level routines
reflect traditional BSD socket interface, such as @code{bind(2)}.
Higher level routines provides more convenient way to create
typical connection-oriented server/client sockets.

This module also provides APIs to obtain various information
about hostnames, service ports, and protocols.
@end deftp


@menu
* Socket address::              
* High-level functions::        
* Low-level socket interface::  
* Netdb interface::             
@end menu

@node Socket address, High-level functions, Networking, Networking
@subsection Socket address

@deftp {Builtin Class} <sockaddr>
@clindex sockaddr
An abstract base class of socket addresses.  Each socket address family
is implemented as a subclass of this class.

Although socket addresses are built-in classes, you can use
@code{make} method to create an instance of a
specific socket address family.
@end deftp

@deffn {Generic Function} sockaddr-family addr
Returns a symbol that indicates the family of the socket address
@var{addr}.
@end deffn

@deffn {Generic Function} sockaddr-name addr
Returns a string which represents the content of the socket address
@var{addr}.
@end deffn

@deftp {Builtin Class} <sockaddr-in>
@clindex sockaddr-in
AF_INET family socket address.  To create an instance of this class,
use @code{make} method as follows:
@example
(make <sockaddr-in> :host @var{host} :port @var{port})
@end example
@var{host} can be a string, or one of the keywords
@code{:any}, @code{:broadcast}, @code{:none} or @code{:loopback}.
If it is a string, it is either a host name or a dotted IP notation.
Gauche uses @code{gethostbyname(3)} to obtain the actual IP address from
@var{host} parameter.  If it is a keyword @code{:any}, 
or @code{:broadcast}, the address
uses @code{INADDR_ANY}, or @code{INADDR_BROADCAST}
respectively.  The keyword @code{:loopback} is a synonym to the
IPv4 loopback address "127.0.0.1".

@var{port} must be a positive integer indicating the port number.
@end deftp

@deffn {Method} sockaddr-family (addr <sockaddr-in>)
Returns a symbol @code{inet}.
@end deffn

@deffn {Method} sockaddr-name (addr <sockaddr-in>)
Returns a string in the form "@var{a}.@var{b}.@var{c}.@var{d}:@var{port}",
 where "@var{a}.@var{b}.@var{c}.@var{d}" is dotted decimal notion of
the IP address and @var{port} is the port number.
@end deffn

@deftp {Builtin Class} <sockaddr-un>
@clindex sockaddr-un
AF_UNIX family socket address.  To create an instance of this class,
use @code{make} method as follows:
@example
(make <sockaddr-un> :path @var{path})
@end example
@var{path} must be a string specifying pathname of the socket.
@end deftp

@deffn {Method} sockaddr-family (addr <sockaddr-un>)
Returns a symbol @code{unix}.
@end deffn

@deffn {Method} sockaddr-name (addr <sockaddr-un>)
Returns a pathname of the socket address.
@end deffn


@node High-level functions, Low-level socket interface, Socket address, Networking
@subsection High-level functions

@deftp {Builtin Class} <socket>
@clindex socket
Abstracts a socket, a communication endpoint.

For a connection-oriented socket, you can access the communication
channel by two ports associated to the socket, one for input and
another for output.  @code{socket-input-port} and @code{socket-output-port}
returns those ports, respectively.
@end deftp

The following two functions are convenient ways to create
a connection-oriented socket.  Those functions
are to provide an easy methods for typical cases,
but have less control.  If you need more than these functions
provide, use low-level interface.

@defun make-client-socket &optional address-spec @dots{}
Creates and returns a client socket, connected to the address
specified by @var{address-spec} @dots{}.

@table @code
@item (make-client-socket 'unix @var{path})
The client socket is connected to the unix domain server socket
of addreess @var{path}.
@item (make-client-socket 'inet @var{host} @var{port})
The client socket is connected to the inet domain server socket
with hostname @var{host} and port @var{port}.   TCP protocol is
assumed.   @var{host} can be either a dotted decimal notation of
IPv4 address, or a hostname.  @var{port} must be an exact integer.
@item (make-client-socket @var{host} @var{port})
This works the same as above.  This form is for compatibility with STk.
@end table

This function raises an error if it cannot create a socket,
or cannot connect to the specified address.

@example
(make-client-socket 'inet "www.w3.com" 80)
  @result{} ;@r{a socket connected to www.w3.com, port 80}
(make-client-socket "127.0.0.1" 23)
  @result{} ;@r{a socket connected to localhost, port 23}
(make-client-socket 'unix "/tmp/.sock"
  @result{} ;@r{a socket connected to a unix domain socket "/tmp/.sock"}
@end example
@end defun

@defun make-server-socket &optional address-spec @dots{}
Creates and returns a server socket, listening the address
specified by @var{address-spec}.

@table @code
@item (make-server-socket 'unix @var{path})
The socket is bound to a unix domain socket with a name @var{path}.
@item (make-server-socket 'inet @var{port} [:reuse-addr? @var{flag}])
The socket is bound to an inet domain TCP socket, listening
port @var{port}, which is a positive exact integer.
If a keyword argument @var{reuse-addr?} is given and true,
@code{so_reuseaddr} option is set to the socket before bound to
the port.  This allows the process to bind the server socket
immediately after other process releases the port.
@item (make-server-socket @var{port} [:reuse-addr? @var{flag}])
This is a synonym to the above form.  This form is backward-compatible
with STk's @code{make-server-socket}.
@end table

@example
(make-server-socket 'inet 8080)
  @result{} ;@r{a TCP socket listening port 8080}
(make-server-socket 8080)
  @result{} ;@r{a TCP socket listening port 8080}
(make-server-socket 'unix "/tmp/.sock")
  @result{} ;@r{a socket listening unix socket /tmp/.sock}
@end example
@end defun

Several accessors are available on the returned socket object.

@defun socket-address socket
Returns a socket address associated with @var{socket}.
If no address has been associated to the socket, @code{#f} is returned.
@end defun

@defun socket-input-port socket
Returns an input port associated with @var{socket}.
The port can be used to receive information from the remote process
connected to the socket.
@end defun

@defun socket-output-port socket
Returns an output port associated with @var{socket}.
The port can be used to send information to the remote process
connected to the socket.
@end defun

@defun socket-close socket
Closes @var{socket}.  All the ports associated to
@var{socket} are closed as well.   If the socket is connected,
it is shut down before closing.
@end defun

@defun call-with-client-socket socket proc
@var{socket} is a connected client socket.  @var{proc} is called
with two arguments, an input port that reads from the socket
and an output port that writes to the socket.
The socket is closed after @var{proc} returns or @var{proc}
raises an error.
@end defun

This is an example of usage of high-level socket functions,
a very simple www client.

@example
#!/usr/bin/env gosh
(use gauche.regexp)
(use gauche.net)

(define (usage)
  (display "Usage: swget url\n" (current-error-port))
  (exit 1))

;; Returns three values: host, port, and path.
(define (parse-url url)
  (rxmatch-let (rxmatch #/^http:\/\/([-A-Za-z\d.]+)(:(\d+))?(\/.*)?/ url)
      (#f host #f port path)
    (values host port path)))

(define (get url)
  (receive (host port path) (parse-url url)
    (call-with-client-socket
        (make-client-socket 'inet host (string->number (or port "80")))
      (lambda (in out)
        (format out "GET ~a HTTP/1.0\r\n" path)
        (format out "host: ~a\r\n\r\n" host)
        (flush out)
        (copy-port in (current-output-port))))))

(define (main args)
  (if (= (length args) 1)
      (get (car args))
      (usage))
  0)
@end example


@node Low-level socket interface, Netdb interface, High-level functions, Networking
@subsection Low-level socket interface

These functions provide APIs similar to the system calls.
Those who are familiar to programming with socket APIs will
find these functions useful since you can have more detailed control over
the sockets.

@defun make-socket domain type &optional protocol
Returns a socket with specified parameters.
@end defun

@defvar pf_unix
@defvarx pf_inet
These variables are bound to @code{PF_UNIX} and @code{PF_INET}.
@end defvar

@defvar af_unix
@defvarx af_inet
These variables are bound to @code{AF_UNIX} and @code{AF_INET}.
@end defvar

@defvar sock_stream
@defvarx sock_dgram
@defvarx sock_raw
These variables are bound to @code{SOCK_STREAM}, @code{SOCK_DGRAM}
and @code{SOCK_RAW}.
@end defvar

@defun socket-status socket
Returns a internal status of @var{socket}, by one of the following
symbols.
@multitable {aaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item none
@tab The socket is just created.
@item bound
@tab The socket is bound to an address by @code{socket-bind}
@item listening
@tab The socket is listening a connection by @code{socket-listen}
@item connected 
@tab The socket is connected by @code{socket-connect} or @code{socket-accept}.
@item shutdown
@tab The socket is shutdown by @code{socket-shutdown}
@item closed
@tab The socket is closed by @code{socket-close}.
@end multitable
@end defun

@defun socket-bind socket address
Binds @var{socket} to the local network address @var{address}.
It is usually used to associate specific address to the server port.
If binding failed, an error is signalled (most likely the address is
already in use).
@end defun

@defun socket-listen socket backlog
Listens @var{socket}.  The socket must be already bound to some
address.  @var{backlog} specifies maximum number of connection
requests to be queued.
@end defun

@defun socket-accept socket
Accepts a connection request coming to @var{socket}.
Returns a new socket that is connected to the remote entity.
The original @var{socket} keeps waiting for further connections.
If there's no connection requests, this call waits for one to come.

You can use @code{sys-select} to check if there's a pending connection
request.
@end defun

@defun socket-connect socket address
Connects @var{socket} to the remote address @var{address}.
This is the way for a client socket to connect to the remote entity.
@end defun

@defun socket-shutdown socket how
Shuts down connection of @var{socket}.  If @var{how} is 0, the receive
channel of @var{socket} is disallowed.  If @var{how} is 1, the send
channel of @var{socket} is disallowed.  If @var{how} is 2, both
receive and send channels are disallowed.
It is an error to call this function on a non-connected socket.

If you shut down the send channel of the socket, the remote peer
sees EOF from its receive channel.  This is useful if the remote peer
expects EOF before sending something back to you.

Other than this kind of special cases, you don't usually need to
call @code{socket-shutdown} explicitly; @code{socket-close} calls it anyway.
@end defun

Further control over sockets and protocol layers is possible
by getsockopt/setsockopt interface, as described below.

@defun socket-setsockopt socket level option value
@defunx socket-getsockopt socket level option rsize
These are the interface to setsockopt() and getsockopt() calls.
The interface is a bit clumsy, in order to allow full access to
those low-level calls.

@var{socket} must be a non-closed socket object.
@var{level} and @var{option} is an exact integer to specify
the level of protocol stack and the option you want to deal with.
There are several variables pre-bound to system constants listed below.

To set the socket option, you can pass either an exact integer or
a string to @var{value}.  If it is an integer, the value is passed
to setsockopt(2) as C @code{int} value.  If it is a string, the
byte sequence is passed as is.  The required type of value depends on
the option, and Gauche can't know if the value you passed is expected
by setsockopt(2); it is your responsibility to pass the correct values.

To get the socket option, you need to tell the maximum length of expected
result by @var{rsize} parameter, for Gauche doesn't know the amount
of data each option returns.
@code{socket-getsockopt} returns the option value as a byte string.
If you know the option value is an integer, you can pass 0 to @var{rsize};
in that case @code{socket-getsockopt} returns the value as an exact integer.

Note about the name: I tempted to name these function socket-@{set|get@}opt
or socket-@{set|get@}-option,
but I rather took the naming consistency.  Hence duplicated "sock"s.

@end defun

The following predefined variables are provided.
Note that some of them are not available on all platforms.
See manpages @code{socket(7)}, @code{tcp(7)} or @code{ip(7)} of
your system to find out exact specification of those values.

For ``level'' argument:
@defvar sol_socket
@defvarx sol_tcp
@defvarx sol_ip
These variables are bound to @code{SOL_SOCKET}, @code{SOL_TCP} and
@code{SOL_IP}, respectively.
@end defvar

For ``option'' argument:
@defvar so_keepalive
Expects integer value.  If it is not zero, enables sending  of
keep-alive messages on connection-oriented sockets.
@end defvar

@defvar so_oobinline
Expects integer value.  If it is not zero, out-of-band data is
directly placed into the receive data stream.  Oth-A$)B
erwise  out-of-band  data  is  only passed when the
MSG_OOB flag is set during receiving.
@end defvar

@defvar so_reuseaddr
Expects integer value.  If it is not zero, @code{socket-bind}
allows to reuse local addresses, unless an active listening
socket bound to the address.
@end defvar

@defvar so_type
Gets the socket type as an integer (like @code{sock_stream}).
Can be only used with @code{socket-getsockopt}.
@end defvar

@defvar so_broadcast
Expects integer value.  If it is not zero, datagram sockets
are allowed to send/receive broadcast packets.
@end defvar

@defvar so_priority
Expects integer value, specifying the protocol-defined priority
for all packets to be sent on this socket.
@end defvar

@defvar so_error
Gets and clears the pending socket error as an integer.
Can be only used with @code{socket-getsockopt}.
@end defvar

@node Netdb interface,  , Low-level socket interface, Networking
@subsection  Netdb interface

@deftp {Builtin Class} <sys-hostent>
@clindex sys-hostent
A class of objects for network hosts.  Corresponding to
@code{struct hostent}.  The following slots are available read-only.

@defivar {<sys-hostent>} name
The formal name of the host (string).
@end defivar
@defivar {<sys-hostent>} aliases
A list of alias names of the host (list of strings).
@end defivar
@defivar {<sys-hostent>} addresses
A list of addresses (list of strings).  Only ipv4 address is 
supported currently.  Each address is represented by dotted decimal
notation.
@end defivar
@end deftp

@defun sys-gethostbyname name
Looks up a host named @var{name}.
If found, returns a @code{<sys-hostent>} object.
Otherwise, returns @code{#f}.
@example
(let ((host (sys-gethostbyname "www.w3c.org")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'addresses)))
  @result{} ("www.w3.org" ("www.w3c.org") ("18.29.1.34" "18.29.1.35"))
@end example
@end defun

@defun sys-gethostbyaddr addr proto
Looks up a host that has an address @var{addr} of protocol @var{proto}.
@var{addr} is a natural string representation of the address;
for ipv4, it is a dotted decimal notation.  @var{proto} is a
protocol number; only @code{af_inet} is supported currently.
If the host is found, returns a @code{<sys-hostent>} object.
Otherwise, returns @code{#f}.
@example
(let ((host (sys-gethostbyaddr "127.0.0.1" af_inet)))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'addresses))
  @result{} ("localhost" ("localhost.localdomain") ("127.0.0.1"))
@end example
@end defun

@deftp {Builtin Class} <sys-servent>
@clindex sys-servent
An entry of the network service database.  Corresponding to
@code{struct servent}.  The following slots are available read-only.

@defivar {<sys-servent>} name
The formal name of the service (string).
@end defivar
@defivar {<sys-servent>} aliases
A list of alias names of the service (list of strings).
@end defivar
@defivar {<sys-servent>} port
A port number registered for this service (exact integer).
@end defivar
@defivar {<sys-servent>} proto
A protocol name for this service (string).
@end defivar
@end deftp

@defun sys-getservbyname name proto
Looks up the network service database with a service name @var{name} and
a protocol @var{proto}.  Both @var{name} and @var{proto} must be a string.
If a service is found, an instance of @code{<sys-servent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((serv (sys-getservbyname "http" "tcp")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'port)
        (slot-ref host 'proto)))
  @result{} ("http" () 80 "tcp")
@end example
@end defun

@defun sys-getservbyport port proto
Looks up the network service database with a service port @var{port} and
a protocol @var{proto}.  @var{port} must be an exact integer, and
@var{proto} must be a string.
If a service is found, an instance of @code{<sys-servent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((serv (sys-getservbyport 6000 "tcp")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'port)
        (slot-ref host 'proto)))
  @result{} ("x-server" () 6000 "tcp")
@end example
@end defun

@deftp {Builtin Class} <sys-protoent>
@clindex sys-protoent
An entry of the protocol database.   Corresponds to @code{struct protoent}
in C.   The following slots are available read-only.

@defivar {<sys-servent>} name
The formal name of the protocol (string).
@end defivar
@defivar {<sys-servent>} aliases
A list of alias names of the protocol (list of strings).
@end defivar
@defivar {<sys-servent>} proto
A protocol number (exact integer).
@end defivar
@end deftp

@defun sys-getprotobyname name
Looks up the network protocol database with a name @var{name},
which must be a string.
If a protocol is found, an instance of @code{<sys-protoent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((proto (sys-getprotobyname "icmp")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'proto)))
  @result{} ("icmp" ("ICMP") 1)
@end example
@end defun

@defun sys-getprotobynumber number
Looks up the network protoice database with a protocol number @var{number},
which must be an exact integer.
If a protocol is found, an instance of @code{<sys-protoent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((proto (sys-getprotobynumber 17)))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'proto)))
  @result{} ("udp" ("UDP") 17)
@end example
@end defun

@c ----------------------------------------------------------------------
@node Parsing command-line options, High Level Process Interface, Networking, Libarary Modules
@section @code{gauche.parseopt} - Parsing command-line options

@deftp {Module} gauche.parseopt
@mdindex gauche.parseopt
This module defines a convenient way to parse command-line options.
The interface is hinted by Perl, and conveniently handles long-format
options with mutiple option arguments.

Note that you can use the standard @code{getopt} interface by SLIB,
if you prefer.
@end deftp

@defmac parse-options args (option-clause @dots{})
@var{args} is an expression that contains a list of command-line arguments.
This macro scans the command-line options (an argument that begins with
`@code{-}') and processes it as specified in @var{option-clause}s, then
returns the remaining arguments.

Unlike typical @code{getopt} or @code{getopt_long} implementation in C,
@code{parse-options} does not permute the given command-line arguments.
It stops parsing when it encounters a non-option argument (argument without
starting with a minus sign).

If the parser encounters an argument with only two minus signs `@code{--}',
it stops argument parsing and returns a list of arguments after `@code{--}'.

Each @var{option-clause} is consisted by a pair of @var{option-spec}
and its action.

@var{option-spec} is a string that specifies the name of the option and
how the option takes the arguments.  An alphanumeric characters, underscore,
plus and minus sign is allowed for option's names, except that
minus sign can't be the first character, i.e. the valid option name
matches a regexp @code{#/[\w_+][-\w_+]*/}.
If the option takes argument(s), it can be specified by attaching 
equal character and the type of the argument after the name.  The option
can take more than one arguments.

@table @code
@item "@var{name}"
Specifies option @var{name}, that doesn't take any argument.

@item "@var{name}=s"
Option @var{name} takes one argument, and it is passed as a string.

@item "@var{name}=i"
Option @var{name} takes one argument, and it is passed as an exact integer.
If the given argument is not valid string for an exact integer,
an error is signalled.

@item "@var{name}=f"
Option @var{name} takes one argument, and it is passed as a real number.
If the given argument is not valid string for a real number,
an error is signalled.

@item "@var{name}=ss"
Option @var{name} takes two arguments, both string.

@item "@var{name}=iii"
Option @var{name} takes three integer arguments.

@item "@var{name}=sf"
Option @var{name} takes two arguments, the first is a string and the
second is a number.
@end table

In the command line, the option may appear with preceding
single or double minus signs.  The option's argument may be comibined
by the option itself with an equal sign.  For example, all the following
command line arguments match an option spec @code{"prefix=s"}.
@example
-prefix /home/shiro
-prefix=/home/shiro
--prefix /home/shiro
--prefix=/home/shiro
@end example

If a given command-line option matches one of @var{option-spec}, then
the associated action is evaluated.  An action can be one of the
following forms.

@table @code
@item @var{bind-spec} @var{body} @dots{}
@var{bind-spec} is a proper or dotted list of variables like lambda-list.
The option's arguments are bound to @var{bind-spec}, then
then @var{body} @dots{} is evaluated. 

@item => @var{proc}
If a command-line option matches @var{option-spec}, calls a procedure
@var{proc} with a list of the option's arguments.
@end table

Examples:
@example
(parse-options '("-file" "foo")
  (("file=s" (file)
     (format #t "file is ~s\n"))))
 @result{} ;@r{``@code{file is "foo"}'' is printed}

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" (xscale yscale)
     (format #t "scale is ~sx~s\n" xscale yscale)
 @result{} ;@r{``@code{scale is 1.5x2.2}'' is printed}

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" scales
     (format #t "scale is ~s\n" scales))))
 @result{} ;@r{``@code{scale is (1.5 2.2)}'' is printed}

(define (scales x y)
  (format #t "scale is ~sx~s\n" x y))

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" => scales)))
 @result{} ;@r{``@code{scale is 1.5x2.2}'' is printed}
@end example

If a symbol @code{else} is at the position of @var{option-spec},
the clause is selected when no other option clause matches a given
command-line option.  Three ``arguments'' are associated to
the clause; the unmatched option, the rest of arguments, and
a procedure that represents the option parser.

@example
(parse-options args
  (("file=s" => process-file)
   (else (option . _)  (error "unrecognized option:" option))))
@end example

Unlike other clause, the else clause returns to the caller of
@code{parse-options}, without looping further.  In order to
continue looping, you have to call the third argument of the else
clause with the remaining arguments.  This can be used
to implement your own sub-parser.  The following example
just skips unrecognized option, with printing a warning,
and continues parsing:

@example
(parse-options args
  (("file=s" => process-file)
   (else (option args continue)
     (format #t "warning: ignoring unrecognized option: ~a" option)
     (continue args))))
@end example

@end defmac

@defmac make-option-parser (option-clause @dots{})
This is a lower-level interface.  @var{option-clause}s are the
same as @code{parse-options}.  This macro returns a procedure
that can be used later to parse the command line options.

The returned procedure takes one required argument and one
optional argument.  The required argument is a list of strings,
for given command-line arguments.  The optional argument may
be a procedure that takes more than three arguments, and if given,
the procedure is used as if it is the body of @code{else} option clause.
@end defmac

@c ----------------------------------------------------------------------
@node High Level Process Interface, Regular expression utilities, Parsing command-line options, Libarary Modules
@section @code{gauche.process} - High Level Process Interface

@deftp {Module} gauche.process
@mdindex gauche.process
This module provides a higher-level API of Unix process control,
implemented on top of low-level system calls such as @code{sys-fork}
and @code{sys-exec}.  The interface is mostly compatible with
STk's process library.  This module also provides ``process ports'', 
a convenient way to send/receive information to/from subprocesses.

To use this module, say @code{(use gauche.process)}.
@end deftp

@menu
* Process object::              
* Process ports::               
@end menu

@node Process object, Process ports, High Level Process Interface, High Level Process Interface
@subsection Process object

@deftp {Class} <process>
@clindex process
An object to keep the status of a child process.  You can create
the process object by @code{run-process} procedure described below.
@end deftp

@defun run-process command arg @dots{}
Run @var{command} with @var{arg} in a subprocess, and returns a
@code{<process>} object.   @var{command} is searched from the
command search path.

Command line arguments @var{arg}s can include the following keyword
arguments which specify special handling of the child process:
@table @code
@item :input @var{file}
@itemx :output @var{file}
@itemx :error @var{file}
These arguments controls the subprocess' standard i/o.
@var{file} may be either a string or a keyword @code{:pipe}.
If it is a string, the process' standard input, output, or error goes
to the named file.   If it is @code{:pipe}, the process'
corresponding standard i/o is connected to a pipe, 
and the other side of the pipe is available for the calling process.

@item :wait @var{flag}
If @var{flag} is true, @code{run-process} waits until the
subprocess terminates.  Othewise the subprocess runs asynchronously
and @code{run-process} returns immediately, which is the default behavior.
Note that if the subprocess is running asynchronously, it is the
caller's responsibility to call @code{process-wait} at certain
timing to correct its exit status.

@item :fork @var{flag}
If @var{flag} is true, @code{run-process} forks to run
the subprocess, which is the default behavior.  If @var{flag} is
false, @code{run-process} directly calls @code{sys-exec}, so
it never returns.
@end table

@end defun

@defun process? obj
@equiv{} @code{(is-a? @var{obj} <process>)}
@end defun

@deffn {Method} process-pid (process <process>)
Returns the process ID of the subprocess @var{process}.
@end deffn

@deffn {Method} process-command (process <process>)
Returns the command invoked in the subprocess @var{process}.
@end deffn

@deffn {Method} process-input (process <process>)
@deffnx {Method} process-output (process <process>)
@deffnx {Method} process-error (process <process>)
If the process' standard input, output or error is connected to
a pipe, returns another end of the pipe, i.e. @code{process-input}
returns an output port that can feed data to @var{process}' stdin,
@code{process-output} an input port that can read data from
@var{process}' stdout, and @code{process-error} an input port that
can read data from @code{process}' stderr.
If the corresponding i/o is not connected to the pipe,
the function returns @code{#f}.

@example
(let* ((process (run-process "date" :output :pipe))
       (line (read-line (process-output process))))
  (process-wait process)
  line)
 @result{} "Fri Jun 22 22:22:22 HST 2001"
@end example
@end deffn

@defun process-alive? process
Returns true if @var{process} is alive.  Note that Gauche can't
know the subprocess' status until it is explicitly checked by
@code{process-wait}.
@end defun

@defun process-list
Returns a list of active processes.  The process remains active
until its exit status is explicitly collected by @code{process-wait}.
@end defun

@defun process-wait process
Obtains exit status of the subprocess @var{process}.
This suspends execution until @var{process} exits.
@end defun

@defun process-send-signal process signal
Sends a signal @var{signal} to the subprocess @var{process}.
@var{signal} must be an exact integer for signal number.
@xref{Signal}, for predefined variables of signals.
@end defun

@defun process-kill process
@defunx process-stop process
@defunx process-continue process
Sends SIGKILL, SIGSTOP and SIGCONT to @var{process}, respectively.
@end defun

@node Process ports,  , Process object, High Level Process Interface
@subsection Process ports

@defun open-input-process-port command
Runs @var{command} via @code{/bin/sh} asynchronously.
An input port is returned, which is connected to the
stdout of @var{command}.   The stdin and stderr of @var{command}
is redirected from/to @code{/dev/null}.  If you need to get
an error output, you can use shell's redirection.
@example
(define port (open-input-process-port "ls -l Makefile"))
(read-line port)
 @result{} "-rw-r--r--   1 shiro    users        1013 Jun 22 21:09 Makefile"

(open-input-process-port "command 2>&1")
 @result{} ;@r{the port reads both stdout and stderr}

(open-input-process-port "command 2>&1 1>/dev/null")
 @result{} ;@r{the port reads stderr}
@end example
Metacharacters are interpreted by shell.
You have to be careful if you pass the string provided from
the outside world, for it may make a security flaw.

The exit status of subprocess is not automatically collected.
It is the caller's responsibility to issue @code{process-wait},
or the subprocess remains in a zombie state.  If it bothers you,
you can use one of the following functions.
@end defun

@defun call-with-input-process command proc
Runs @var{command} via @code{/bin/sh} and pipes its stdout
to an input port, then call @var{proc} with the port as an argument.
When @var{proc} returns, it collects its exit status,
then returns the result @var{proc} returned.
The cleanup is done even if @var{proc} raises an error.
@example
(call-with-input-process "ls -l *"
  (lambda (p) (read-line p)))
@end example
@end defun

@defun with-input-from-process command thunk
Runs @var{command} via @code{/bin/sh}, and calls @var{thunk}
with its current input port connected to the command's stdout.
The command is terminated and its exit status is collected
when @var{thunk} returns, or it raises an error.
@example
(with-input-from-process "ls -l *" read-line)
@end example
@end defun

@defun open-output-process-port command
Runs @code{command} via @code{/bin/sh}, and returns an output
port which is connected to the stdin of the command.
The stdout and stderr of the command is redirected to @var{/dev/null}.

The exit status of the subprocess is not automatically collected.
The caller should call @code{process-wait} on the subprocess
at appropriate time.
@end defun

@defun call-with-output-process command proc
Runs @code{command} via @code{/bin/sh}, and calls @var{proc} 
with an output port which is conected to the stdin of the command.
The exit status of the command is collected after @var{proc}
returns, or it raises an error.

@example
(call-with-output-process "/usr/sbin/sendmail"
  (lambda (out) (display mail-body out)))
@end example
@end defun

@defun with-output-to-process command thunk
Same as @code{call-with-output-process}, except that the
output port which is connected to the stdin of the command
is set to the current output port while executing @var{thunk}.
@end defun

@defun call-with-process-io command proc
Runs @var{command} via @code{/bin/sh}, and calls @var{proc}
with two arguments; the first argument is an input port which
is connected to the command's stdout, and the second is an output
port connected to the command's stdin.  The error output from
the command is redirected to @code{/dev/null}.

The exit status of the command is collected when @var{proc}
returns or raises an error.
@end defun


@c ----------------------------------------------------------------------
@node Regular expression utilities, Serializer, High Level Process Interface, Libarary Modules
@section @code{gauche.regexp} - Regular expression utilities

@deftp {Module} gauche.regexp
@mdindex gauche.regexp
This module defines some macros useful in regexp match.

The interface is borrowed from scsh, but I changed the name of
macros since scsh's @code{match-cond} can be confusing
(e.g. Bigloo has @code{match-lambda} and @code{match-case} in
pattern match library, that sounds too similar).
@end deftp

In the following macros, @var{match-expr} is an expression
which produces a match object or @code{#f}. Typically
it is a call of @code{rxmatch}, but it can be any expression.

@defmac rxmatch-let match-expr (var @dots{}) form @dots{}

Evaluates @var{match-expr}, and if matched, binds @var{var @dots{}}
to the matched strings, then evaluates @var{form}s.
The first @var{var} receives the entire match, and subsequent
variables receive submatches.  If the number of submatches are
smaller than the number of variables to receive them, the rest
of variables will get @code{#f}.

It is possible to put @code{#f} in variable position, which says
you don't care that match.

@example
(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (time hh mm ss)
  (list time hh mm ss))
 @result{} ("23:59:58" "23" "59" "58")

(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (#f hh mm)
  (list hh mm))
 @result{} ("23" "59")
@end example

This macro corresponds to scsh's @code{let-match}.
@end defmac

@defmac rxmatch-if match-expr (var @dots{}) then-form else-form
Evaluates @var{match-expr}, and if matched, binds @var{var} @dots{}
to the matched strings and evaluate @var{then-form}.
Otherwise evaluates @var{else-form}.
The rule of binding @var{var}s is the same as @code{rxmatch-let}.

@example
(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11:22:33")
    (time)
  (format #f "time is ~a" time)
  "unknown time)
 @result{} "time is 11:22"

(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11-22-33")
    (time)
  (format #f "time is ~a" time)
  "unknown time)
 @result{} "unknown time"
@end example

This macro corresponds to scsh's @code{if-match}.
@end defmac

@defmac rxmatch-cond clause @dots{}
Evaluate condition in @var{clause}s one by one.
If a condition of a clause satisfies, rest portion of the clause
is evaluated and becomes the result of @code{rxmatch-cond}.
@var{Clause} may be one of the following pattern.

@table @code
@item (@var{match-expr} (@var{var} @dots{}) @var{form} @dots{})
Evaluate @var{match-expr}, which may return a regexp match
object or @code{#f}.  If it returns a match object, the matches
are bound to @var{var}s, like @var{rxmatch-let}, and @var{form}s
are evaluated.

@item (test @var{expr} @var{form} @dots{})
Evaluates @var{expr}.  If it yields true, evaluates @var{form}s.

@item (test @var{expr} => @var{proc})
Evaluates @var{expr} and if it is true,
calls @var{proc} with the result of @var{expr} as the only argument.

@item (else @var{form} @dots{})
If this clause exists, it must be the last clause.
If other clauses fail, @var{form}s are evaluated.
@end table

If no @code{else} clause exists, and no other clause matched the
@var{string-expr}, an undefined value is returned.

@example
;; @r{parses several possible date format}
(define (parse-date str)
  (rxmatch-cond
    ((rxmatch #/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ str)
        (#f mm dd yyyy)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ str)
        (#f yyyy mm dd)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^\d+\/\d+\/\d+$/ str)
        (#f)
     (error "ambiguous: ~s" str))
    (else (error "bogus: ~s" str))))

(parse-date "2001/2/3") @result{} (2001 2 3)
(parse-date "12/25/1999") @result{} (1999 12 25)
@end example

This macro corresponds to scsh's @code{match-cond}.
@end defmac

@defmac rxmatch-case string-expr clause @dots{}
@var{String-expr} is evaluated, and @var{clause}s are interpreted
one by one.  A @var{clause} may be one of the following pattern.

@table @code
@item (@var{re} (@var{var} @dots{}) @var{form} @dots{})
@var{Re} must be either a literal string describing a
regexp, or a regexp object.  If it matches with the result
of @var{string-expr}, the match result is bound to @var{var}s
and @var{form}s are evaluated, and @code{rxmatch-case} returns
the result of the last @var{form}.

If @var{re} doesn't match the result of @var{string-expr},
@var{string-expr} yields non-string value, the interpretation proceeds
to the next clause.

@item (test @var{proc} @var{form} @dots{})
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{form}s are evaluated, and
@code{rxmatch-case} returns the result of the last @var{form}.

If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.

@item (test @var{proc} => @var{proc2})
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{proc2} is applied on the result,
and its result is returned as the result of @code{rxmatch-case}.

If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.

@item (else @var{form} @dots{})
This form must appear at the end of @var{clause}s, if any.
If other clauses fail, @var{form}s are evaluated,
and the result of the last @var{form} becomes the result of
@code{rxmatch-case}.
@end table

If no @code{else} clause exists, and no other clause matched the
@var{string-expr}, an undefined value is returned.

The @code{parse-date} example above becomes simpler if you use
@code{rxmatch-case}
@example
(define (parse-date2 str)
  (rxmatch-case str
    (test (lambda (s) (not (string? s))) #f)
    (#/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ (#f mm dd yyyy)
     (map string->number (list yyyy mm dd)))
    (#/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ (#f yyyy mm dd)
     (map string->number (list yyyy mm dd)))
    (#/^\d+\/\d+\/\d+$/                (#f)
     (error "ambiguous: ~s" str))
    (else (error "bogus: ~s" str))))
@end example
@end defmac


@c ----------------------------------------------------------------------
@node Serializer, Unit Testing, Regular expression utilities, Libarary Modules
@section @code{gauche.serializer} - Serializer

@deftp {Module} gauche.serializer
@mdindex gauche.serializer
@end deftp


@c ----------------------------------------------------------------------
@node Unit Testing, RFC822 Message parsing, Serializer, Libarary Modules
@section @code{gauche.test} - Unit Testing

@deftp {Module} gauche.test
@mdindex gauche.test
Defines a set of functions to write test scripts.
A test script will look like this:
@lisp
(use gauche.test)
(test-start "my feature")
(load "my-feature")         ; @r{load your program}
(select-module my-feature)  ; @r{if your program defines a module.}

(test-section "feature group 1")
(test "feature 1-1" EXPECT (lambda () TEST-BODY))
(test "feature 1-2" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-section "feature group 2")
(define test-data ...)
(test "feature 2-1" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-end)
@end lisp

With this convention, you can run test both interactively or
in batch.   To run a test interactively, just load the file
and it reports a result of each test, as well as the summary
of failed test at the end.  To run a test in batch, it is
convenient to redirect the stdout to some file
If stdout is redirected to other than tty, all the verbose logs will go
there, and only a small amount of messages go to stderr.

It is recommended to have a "test" target always in Makefile
of your module/program, so that the user of your program can run a
test easily.  The rule may look like this:

@example
test :
        gosh my-feature-test.scm > test.log
@end example

@end deftp

@defun test name expected thunk &optional =
Calls @var{thunk}, and compares its result with @var{expected}.
The comparison predicate is @var{equal?} by default, but you can
specify your own predicate by the argument @var{=}.
@var{Name} is a name of the test, for logging purpose.
@end defun

@defun test-start module-name
Initializes internal state and prints a log header.
This should be called before any tests.
@var{Module-name} is used only for logging purpose.
@end defun

@defun test-section section-name
Marks beginning of the group of tests.  This is just for logging.
@end defun

@defun test-end
Prints out list of failed tests.
@end defun

@c ----------------------------------------------------------------------
@node RFC822 Message parsing, Base64 encoding/decoding, Unit Testing, Libarary Modules
@section @code{rfc.822} - RFC822 message parsing

@deftp {Module} rfc.822
@mdindex rfc.822
Defines a set of functions that parses and constructs the ``Internet
Message Format'', a text format used to exchange e-mails.
The most recent specification can be found in
@uref{http://www.rfc-editor.org/rfc/rfc2822.txt, RFC2822}.
The format was originally defined in RFC 822, and people still 
call it ``RFC822 format'', hence I named this module.
In the following document, I also refer to the format as ``RFC822 format''.

Say @code{(use rfc.822)} to use this module.
@end deftp

@defun rfc822-header->list iport &optional strict?
Reads RFC822 format message from an input port @var{iport},
until it reaches the end of the message header.
The header fields are unfolded, and broken into a list of the following
format:
@example
((name body) @dots{})
@end example
@var{Name} @dots{} are the field names, and @var{body} @dots{} are
the corresponding field body, both as strings.
Field names are converted to lower-case characters.
Field bodies are not modified, except the folded line is concatenated,
CRLFs removed.
The order of fields are preserved.
@end defun


@c ----------------------------------------------------------------------
@node Base64 encoding/decoding, URI parsing and construction, RFC822 Message parsing, Libarary Modules
@section @code{rfc.base64} - Base64 encoding/decoding

@deftp {Module} rfc.base64
@mdindex rfc.base64
This module defines a few functions to encode/decode Base64 format,
defined in @uref{http://www.rfc-editor.org/rfc/rfc2045.txt, RFC 2045},
section 6.3.
@end deftp

@defun base64-encode
Reads byte stream from the current input port, encodes it in Base64
format and writes the result character stream to the current output port.
The conversion ends when it reads EOF from the current input port.
@end defun

@defun base64-encode-string string
Converts contents of @var{string} to Base64 encoded format.
Input string can be either complete or incomplete string;
it is always interpreted as a byte sequence.
@end defun

@defun base64-decode
Reads character stream from the current input port, decodes it from Base64
format and writes the result byte stream to the current output port.
The conversion ends when it reads EOF or the termination character
(@code{=}).  The characters which does not in legal Base64 encoded character
set are silently ignored.
@end defun

@defun base64-decode-string string
Decodes a Base64 encoded string @var{string} and returns
the result as a string.
The conversion terminates at the end of @var{string} or
the termination character (@code{=}).
The characters which does not in legal Base64 encoded character
set are silently ignored.
@end defun

@c ----------------------------------------------------------------------
@node URI parsing and construction, SLIB, Base64 encoding/decoding, Libarary Modules
@section @code{rfc.uri} - URI parsing and construction

@deftp {Module} rfc.uri
@mdindex rfc.uri
Defines a set of functions to parse Uniform Resource Identifiers,
defined in @uref{http://www.rfc-editor.org/rfc/rfc2396.txt, RFC 2396}.
@end deftp


@c ----------------------------------------------------------------------
@node SLIB, Feature Conditional, URI parsing and construction, Libarary Modules
@section @code{slib} - SLIB interface

@deftp {Module} slib
@mdindex slib
This module is the interface to the Aubrey Jaffer's SLIB.
To use SLIB, say @code{(use slib)}.   SLIB itself is not included
in Gauche distribution.   If you don't have it on your system,
get it from @uref{http://www-swiss.ai.mit.edu/~jaffer/SLIB.html}.

This module redefines @code{require}, shadowing the Gauche's original
@code{require}.  If it gets a symbol as an argument, it works as
SLIB's @code{require}, while if it gets a string, it works as
Gauche's @code{require}.   The same applies to @code{provide} and
@code{provided?}.

All SLIB symbol bindings, loaded by @code{require}, stay in the
module @code{slib}.
@end deftp

@c ----------------------------------------------------------------------
@node Feature Conditional, List library, SLIB, Libarary Modules
@section @code{srfi-0} - Feature Conditional

@deftp {Module} srfi-0
@mdindex srfi-0
@end deftp

@defmac cond-expand (feature-requirement command-or-definition @dots{}) @dots{}
[SRFI-0]
@end defmac

@c ----------------------------------------------------------------------
@node List library, And-let*, Feature Conditional, Libarary Modules
@section @code{srfi-1} - List library

@deftp {Module} srfi-1
@mdindex srfi-1
SRFI-1 is a rich collection of list manipulation library.
It is available by saying @code{(use srfi-1)}.
The implementation is based on Olin Shivers's reference implementation.
I splitted it into number of subfiles that will be autoloaded on demand.

Detailed specificaion of SRFI-1 is available at
@uref{http://srfi.schemers.org/srfi-1/srfi-1.html}.
@end deftp

@menu
* SRFI-1 List constructors::    
* SRFI-1 List predicates::      
* SRFI-1 List selectors::       
* SRFI-1 List miscellaneous routines::  
* SRFI-1 Fold::                 
* SRFI-1 Filterling & partitioning::  
* SRFI-1 Searching::            
* SRFI-1 Deletion::             
* SRFI-1 Association lists::    
* SRFI-1 set operations::       
@end menu

@node SRFI-1 List constructors, SRFI-1 List predicates, List library, List library
@subsection List constructors

@defun xcons cd ca
[SRFI-1] Equivalent to @code{(cons ca cd)}.  Useful to pass to
higher-order procedures.
@end defun

@defun cons* elt1 elt2 @dots{}
[SRFI-1] Like @code{list}, but the last argument provides the tail of
the constructed list.  This is just a synonym of Gauche built-in procedure
@code{list*}.
@example
(cons* 1 2 3 4) @result{} (1 2 3 . 4)
(cons* 1) @result{} 1
@end example
@end defun

@defun list-tabulate n init-proc
[SRFI-1] Constructs an @var{n}-element list, in which
each element is generated by @code{(@var{init-proc} @i{i})}.
@example
(list-tabulate 4 values) @result{} (0 1 2 3)
@end example
@end defun

@defun circular-list elt1 elt2 @dots{}
[SRFI-1] Constructs a circular list of the elements.
@example
(circular-list 'z 'q) @result{} (z q z q z q @dots{})
@end example
@end defun

@defun iota count &optional (start 0) (step 1)
[SRFI-1] Returns a list of numbers, starting from @var{start},
increasing by @var{step}.
@example
(iota 5) @result{} (0 1 2 3 4)
(iota 5 0 -0.1) @result{} (0 -0.1 -0.2 -0.3 -0.4)
@end example
@end defun

@node SRFI-1 List predicates, SRFI-1 List selectors, SRFI-1 List constructors, List library
@subsection List predicates

@defun proper-list? x
[SRFI-1] Returns @code{#t} if x is a proper list.
@end defun

@defun circular-list? x
[SRFI-1] Returns @code{#t} if x is a circular list.
@end defun

@defun dotted-list? x
[SRFI-1] Returns @code{#t} if x is a finite, non-nil-terminated list.
This includes non-pair, non-() values (e.g. symbols, numbers),
which are considered to be dotted lists of length 0.
@end defun

@defun null-list? list
[SRFI-1] Returns @code{#t} if @var{list} is the empty list @code{()},
and @var{#f} if @var{list} is a non-null, proper or circular list.
This procedure signals an error if @var{list} is not a proper
or circular list.
@end defun

@defun not-pair? x
[SRFI-1] @code{(lambda (x) (not (pair? x)))}.

SRFI-1 says: Provided as a procedure as it can be useful as
the termination condition for list-processing procedures that wish to
handle all finite lists, both proper and dotted. 
@end defun

@defun list= elt= list @dots{}
[SRFI-1] Determines list equality by comparing every n-th element
of given lists by the procedure @var{elt=}.

It is an error to apply @code{list=} to anything except proper lists.

The equality procedure must be consistent with @code{eq?}, i.e.
@example
(eq? x y) @result{} (elt= x y).
@end example
@end defun

@node SRFI-1 List selectors, SRFI-1 List miscellaneous routines, SRFI-1 List predicates, List library
@subsection List selectors

@defun  first pair
@defunx second pair
@defunx third pair
@defunx fourth pair
@defunx fifth pair
@defunx sixth pair
@defunx seventh pair
@defunx eighth pair
@defunx ninth pair
@defunx tenth pair
[SRFI-1] Returns n-th element of the (maybe improper) list.
@end defun

@defun car+cdr pair
[SRFI-1] Returns two values, @code{(car pair)} and @code{(cdr pair)}.
@end defun

@defun take x i
@defunx drop x i
[SRFI-1] @code{take} returns the first i elements of list x.
@code{drop} returns all but the first i elements of list x. 
@example
(take '(a b c d e)  2) => (a b)
(drop '(a b c d e)  2) => (c d e)
@end example
@var{x} may be any value:
@example
(take '(1 2 3 . d) 2) => (1 2)
(drop '(1 2 3 . d) 2) => (3 . d)
(drop '(1 2 3 . d) 3) => d
@end example
@code{drop} is exactly equivalent to performing @var{i} cdr operations
on @var{x}.  The returned value shares a common tail with @var{x}.
On the other hand, take always allocates a new list 
for result if the argument is a list of non-zero length.
@end defun

@defun take-right flist i
@defunx drop-right flist i
[SRFI-1] @code{take-right} returns the last @var{i} elements of @var{flist}.
@code{drop-right} returns all but the last @var{i} elements of @var{flist}. 
@example
(take-right '(a b c d e) 2) => (d e)
(drop-right '(a b c d e) 2) => (a b c)
@end example
@var{flist} may be any finite list.
@example
(take-right '(1 2 3 . d) 2) => (2 3 . d)
(drop-right '(1 2 3 . d) 2) => (1)
(take-right '(1 2 3 . d) 0) => d
(drop-right '(1 2 3 . d) 0) => (1 2 3)
@end example
@code{take-right}'s return value always shares a common
tail with @var{flist}.
@code{drop-right} always allocates a new list
if the argument is a list of non-zero length.
@end defun

@defun take! x i
@defunx drop-right! x i
[SRFI-1]  Linear update variants of @var{take} and @var{drop-right}.
Those procedures may destructively modifies @var{x}.

If @var{x} is circular, @code{take!} may return a list
shorter than expected.
@end defun

@defun split-at x i
@defunx split-at! x i
[SRFI-1] @code{split-at} splits the list @var{x} at index @var{i},
returning a list of the first @var{i} elements, and the remaining tail.
@example
(split-at '(a b c d e) 2) @result{} (a b) (c d e)
@end example
@code{split-at!} is the linear-update variant. It may destructively
modifes @var{x} to produce the result. 
@end defun

@defun last pair
[SRFI-1] Returns the last element of the non-empty, finite list @var{pair}.
It is equivalent to @code{(car (last-pair pair))}.
Note that @code{last-pair} is Gauche built-in procedure.
@end defun

@node SRFI-1 List miscellaneous routines, SRFI-1 Fold, SRFI-1 List selectors, List library
@subsection List miscellaneous routines

@defun length+ x
[SRFI-1] If @var{x} is a proper list, returns its length.
Otherwise, returns @code{#f}.
@end defun

@defun concatenate list-of-lists
@defunx concatenate! list-of-lists!
[SRFI-1] Equivalent to @code{(apply append @var{list-of-lists})} and
@code{(apply append! @var{list-of-lists})}, respectively.
@end defun

@defun append-reverse rev-head tail
@defunx append-reverse! rev-head tail
[SRFI-1] @code{append-reverse} returns @code{(append (reverse rev-head) tail)}.
@code{append-reverse!} is the linear-update variant.
@end defun

@defun zip clist1 clist2 @dots{}
[SRFI-1] Equivalent to @code{(map list clist1 clist2 @dots{})}.
If @code{zip} is passed @var{n} lists, it returns a list as long as
the shortest of these lists, each element of which is an @var{n}-element list
comprised of the corresponding elements from the parameter lists. 
@example
(zip '(one two three) 
     '(1 2 3)
     '(odd even odd even odd even odd even))
     @result{} ((one 1 odd) (two 2 even) (three 3 odd))

(zip '(1 2 3)) @result{} ((1) (2) (3))
@end example
At least one of the argument lists must be finite: 
@example
(zip '(3 1 4 1) (circular-list #f #t)) 
     @result{} ((3 #f) (1 #t) (4 #f) (1 #t))
@end example
@end defun

@defun unzip1 list
@defunx unzip2 list
@defunx unzip3 list
@defunx unzip4 list
@defunx unzip5 list
[SRFI-1] @code{unzip1} takes a list of lists, where every list must
contain at least one element, and returns a list containing the
initial element of each such list.
@code{unzip2} takes a list of lists, where every list
must contain at least two elements, and returns two values:
a list of the first elements, and a list of the second
elements. @code{unzip3} does the same for the first
three elements of the lists, and so on.
@example
(unzip2 '((1 one) (2 two) (3 three))) @result{}
   (1 2 3) @r{and}
   (one two three)
@end example
@end defun

@defun count pred clist1 clist2 @dots{}
[SRFI-1] A procedure @var{pred} is applied to the @var{n}-th element
of given lists, from @var{n} is zero to the length of the
the shortest finite list in the given lists,
and the count of times @var{pred} returned true is returned.
@example
(count even? '(3 1 4 1 5 9 2 5 6)) @result{} 3
(count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) @result{} 3
@end example
At least one of the argument lists must be finite: 
@example
(count < '(3 1 4 1) (circular-list 1 10)) @result{} 2
@end example
@end defun

@node SRFI-1 Fold, SRFI-1 Filterling & partitioning, SRFI-1 List miscellaneous routines, List library
@subsection List fold, unfold & map

@defun fold kons knil clist1 clist2 @dots{}
[SRFI-1] The fundamental list iterator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@example
(@var{kons} @var{en} @dots{} (@var{kons} @var{e2} (@var{kons} @var{e1} @var{knil})) @dots{} ) 
@end example

If @var{n} list arguments are provided, then the @var{kons}
function must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples:
@example
(fold + 0 '(3 1 4 1 5 9)) @result{} 23 ;@r{sum up the elements}
(fold cons '() '(a b c d e)) @result{} (e d c b a) ;@r{reverse}
(fold cons* '() '(a b c) '(1 2 3 4 5))
    @result{} (c 3 b 2 a 1) ;@r{n-ary case}
@end example
@end defun

@defun fold-right kons knil clist1 clist2 @dots{}
[SRFI-1] The fundamental list recursion operator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@example
(@var{kons} @var{e1} (@var{kons} @var{e2} @dots{} (@var{kons} @var{en} @var{knil})))
@end example

If @var{n} list arguments are provided, then the @var{kons} function
must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples: 
@example
(fold-right cons '() '(a b c d e))
   @result{} (a b c d e) ;@r{copy list}
(fold-right cons* '() '(a b c) '(1 2 3 4 5))
   @result{} (a 1 b 2 c 3) ;@r{n-ary case}
@end example
@end defun

@defun pair-fold kons knil clist1 clist2 @dots{}
[SRFI-1] 
@end defun

@defun pair-fold-right kons knil clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun reduce f ridentity list
[SRFI-1]
@end defun

@defun reduce-right f ridentity list
[SRFI-1]
@end defun

@defun unfold p f g seed &optional tail-gen
[SRFI-1]
@end defun

@defun unfold-right p f g seed &optional tail
[SRFI-1]
@end defun

@defun append-map f clist1 clist2 @dots{}
@defunx append-map! f clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun map! f list1 clist2 @dots{}
[SRFI-1]
@end defun

@defun map-in-order f clist1 clist2 @dots{}
[SRFI-1] A variant of @code{map}, but it guarantees to apply @var{f}
on each elements of arguments in a left-to-right order.
Since Gauche's @code{map} implementation follows the same order,
this function is just a synonym of @code{map}.
@end defun

@defun pair-for-each f clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun filter-map  f clist1 clist2 @dots{}
[SRIF-1]
@end defun

@node SRFI-1 Filterling & partitioning, SRFI-1 Searching, SRFI-1 Fold, List library
@subsection List filtering & partitioning

@defun filter pred list
@defunx filter! pred list
[SRFI-1] A procedure @var{pred} is applied on each element of @var{list},
and a list of elements that @var{pred} returned true on it is returned.
@example
(filter odd? '(3 1 4 5 9 2 6)) @result{} (3 1 5 9)
@end example
@code{filter!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@defun remove pred list
@defunx remove! pred list
[SRFI-1] A procedure @var{pred} is applied on each element of @var{list},
and a list of elements that @var{pred} returned false on it is returned.
@example
(remove odd? '(3 1 4 5 9 2 6)) @result{} (4 2 6)
@end example
@code{remove!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@defun partition pred list
@defunx partition! pred list
[SRFI-1] @code{filter} and @code{remove} simultaneously, i.e. 
returns two lists, the first is the result of filtering elements of
@var{list} by @var{pred}, and the second is the result of
removing elements of @var{list} by @var{pred}.
@example
(partition odd? '(3 1 4 5 9 2 6))
  @result{} (3 1 5 9) (4 2 6)
@end example
@code{partition!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@node SRFI-1 Searching, SRFI-1 Deletion, SRFI-1 Filterling & partitioning, List library
@subsection List searching

@defun find pred clist
[SRFI-1] Applies @var{pred} for each elements of @var{clist}, from 
left to right, and returns the first element that @var{pred} returns
true on.
@end defun

@defun find-tail pred clist
[SRFI-1]
@end defun

@defun take-while pred clist
@defunx take-while! pred list
[SRFI-1]
@end defun

@defun drop-while pred clist
[SRFI-1]
@end defun

@defun span pred clist
@defunx span! pred list
@defunx break pred clist
@defunx break! pred list
[SRFI-1]
@end defun

@defun any pred clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun every pred clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun list-index pred clist1 clist2 @dots{}
[SRFI-1]
@end defun

@node SRFI-1 Deletion, SRFI-1 Association lists, SRFI-1 Searching, List library
@subsection List deletion

@defun delete x list &optional elt=
@defunx delete! x list &optional elt=
[SRFI-1]
@end defun

@defun delete-duplicates list &optional elt=
@defunx delete-duplicates! list &optional elt=
[SRFI-1]
@end defun

@node SRFI-1 Association lists, SRFI-1 set operations, SRFI-1 Deletion, List library
@subsection Association lists

@defun alist-cons key datum alist
[SRFI-1] Returns @code{(cons (cons @var{obj1} @var{obj2}) @var{obj3})}.
This is an alias of the Gauche builtin procedure @code{acons}.
@end defun

@defun alist-copy alist
[SRFI-1] Returns a fresh copy of @var{alist}.
@end defun

@defun alist-delete key alist &optional =
@defunx alist-delete! key alist &optional =
[SRFI-1]
@end defun

@node SRFI-1 set operations,  , SRFI-1 Association lists, List library
@subsection Lists as sets

@defun lset@code{<=} elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset= elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-adjoin elt= list elt @dots{}
[SRFI-1]
@end defun

@defun lset-union elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset-intersection elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-difference elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-xor elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset-diff+intersection elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-union! elt= list @dots{}
@defunx lset-intersection! elt= list1 list2 @dots{}
@defunx lset-difference! elt= list1 list2 @dots{}
@defunx lset-xor! elt= list1 @dots{}
@defunx lset-diff+intersection! elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@c ----------------------------------------------------------------------
@node And-let*, Homogeneous Vectors, List library, Libarary Modules
@section @code{srfi-2} - And-let*

@deftp {Module} srfi-2
@mdindex srfi-2
@end deftp

@defmac and-let* (bindings @dots{}) body @dots{}
@end defmac

@c ----------------------------------------------------------------------
@node Homogeneous Vectors, SRFI String ports, And-let*, Libarary Modules
@section @code{srfi-4} - Homogeneous Vectors

@deftp {Module} srfi-4
@mdindex srfi-4
@end deftp

@deftp {Builtin Class} <s8vector>
@deftpx {Builtin Class} <u8vector>
@deftpx {Builtin Class} <s16vector>
@deftpx {Builtin Class} <u16vector>
@deftpx {Builtin Class} <s32vector>
@deftpx {Builtin Class} <u32vector>
@deftpx {Builtin Class} <s64vector>
@deftpx {Builtin Class} <u64vector>
@deftpx {Builtin Class} <f32vector>
@deftpx {Builtin Class} <f64vector>
@clindex s8vector
@clindex u8vector
@clindex s16vector
@clindex u16vector
@clindex s32vector
@clindex u32vector
@clindex s64vector
@clindex u64vector
@clindex f32vector
@clindex f64vector
[SRFI-4]
@end deftp

@defun s8vector? obj
@defunx u8vector? obj
@defunx s16vector? obj
@defunx u16vector? obj
@defunx s32vector? obj
@defunx u32vector? obj
@defunx s64vector? obj
@defunx u64vector? obj
@defunx f32vector? obj
@defunx f64vector? obj
[SRFI-4]
@end defun

@defun s8vector n @dots{}
@defunx u8vector n @dots{}
@defunx s16vector n @dots{}
@defunx u16vector n @dots{}
@defunx s32vector n @dots{}
@defunx u32vector n @dots{}
@defunx s64vector n @dots{}
@defunx u64vector n @dots{}
@defunx f32vector x @dots{}
@defunx f64vector x @dots{}
[SRFI-4]
@end defun

@defun  make-s8vector len &optional fill
@defunx make-u8vector len &optional fill
@defunx make-s16vector len &optional fill
@defunx make-u16vector len &optional fill
@defunx make-s32vector len &optional fill
@defunx make-u32vector len &optional fill
@defunx make-s64vector len &optional fill
@defunx make-u64vector len &optional fill
@defunx make-f32vector len &optional fill
@defunx make-f64vector len &optional fill
[SRFI-4]
@end defun

@defun  s8vector-ref vec k
@defunx u8vector-ref vec k
@defunx s16vector-ref vec k
@defunx u16vector-ref vec k
@defunx s32vector-ref vec k
@defunx u32vector-ref vec k
@defunx s64vector-ref vec k
@defunx u64vector-ref vec k
@defunx f32vector-ref vec k
@defunx f64vector-ref vec k
[SRFI-4]
@end defun

@defun  s8vector-set! vec k n
@defunx u8vector-set! vec k n
@defunx s16vector-set! vec k n
@defunx u16vector-set! vec k n
@defunx s32vector-set! vec k n
@defunx u32vector-set! vec k n
@defunx s64vector-set! vec k n
@defunx u64vector-set! vec k n
@defunx f32vector-set! vec k x
@defunx f64vector-set! vec k x
[SRFI-4]
@end defun

@defun  s8vector-copy vec
@defunx u8vector-copy vec
@defunx s16vector-copy vec
@defunx u16vector-copy vec
@defunx s32vector-copy vec
@defunx u32vector-copy vec
@defunx s64vector-copy vec
@defunx u64vector-copy vec
@defunx f32vector-copy vec
@defunx f64vector-copy vec
[SRFI-4]
@end defun

@defun  s8vector-copy! dstvec srcvec
@defunx u8vector-copy! dstvec srcvec
@defunx s16vector-copy! dstvec srcvec
@defunx u16vector-copy! dstvec srcvec
@defunx s32vector-copy! dstvec srcvec
@defunx u32vector-copy! dstvec srcvec
@defunx s64vector-copy! dstvec srcvec
@defunx u64vector-copy! dstvec srcvec
@defunx f32vector-copy! dstvec srcvec
@defunx f64vector-copy! dstvec srcvec
[SRFI-4]
@end defun

@defun  s8vector->list vec
@defunx u8vector->list vec
@defunx s16vector->list vec
@defunx u16vector->list vec
@defunx s32vector->list vec
@defunx u32vector->list vec
@defunx s64vector->list vec
@defunx u64vector->list vec
@defunx f32vector->list vec
@defunx f64vector->list vec
[SRFI-4]
@end defun

@defun  s8vector->vector vec
@defunx u8vector->vector vec
@defunx s16vector->vector vec
@defunx u16vector->vector vec
@defunx s32vector->vector vec
@defunx u32vector->vector vec
@defunx s64vector->vector vec
@defunx u64vector->vector vec
@defunx f32vector->vector vec
@defunx f64vector->vector vec
@end defun

@defun  list->s8vector list
@defunx list->u8vector list
@defunx list->s16vector list
@defunx list->u16vector list
@defunx list->s32vector list
@defunx list->u32vector list
@defunx list->s64vector list
@defunx list->u64vector list
@defunx list->f32vector list
@defunx list->f64vector list
[SRFI-4]
@end defun

@defun  vector->s8vector vec
@defunx vector->u8vector vec
@defunx vector->s16vector vec
@defunx vector->u16vector vec
@defunx vector->s32vector vec
@defunx vector->u32vector vec
@defunx vector->s64vector vec
@defunx vector->u64vector vec
@defunx vector->f32vector vec
@defunx vector->f64vector vec
@end defun

@c ----------------------------------------------------------------------
@node SRFI String ports, Syntax to receive multiple values, Homogeneous Vectors, Libarary Modules
@section @code{srfi-6} - String ports

@deftp {Module} srfi-6
@mdindex srfi-6
String ports, defined in SRFI-6, are builtin feature of Gauche.
The form @code{(use srfi-6)} doesn't do anything.
@end deftp

@c ----------------------------------------------------------------------
@node Syntax to receive multiple values, Record types, SRFI String ports, Libarary Modules
@section @code{srfi-8} - Syntax to receive multiple values

@deftp {Module} srfi-8
@mdindex srfi-8
Syntax @code{receive}, defined in SRFI-8, is builtin feature of Gauche.
The form @code{(use srfi-8)} doesn't do anything.
@end deftp


@c ----------------------------------------------------------------------
@node Record types, Let-values, Syntax to receive multiple values, Libarary Modules
@section @code{srfi-9} - Record types

@deftp {Module} srfi-9
@mdindex srfi-9
Contains a macro to use record types.  A record type is implemented on
top of Gauche's object system.

The SRFI-9 record type is not as powerful as the object system, but
it will be useful if you want your program to be portable.
@end deftp

@defmac define-record-type name (constructor init-tag @dots{}) predicate (field accessor [modifier]) @dots{}
Creates a record type and binds it to @var{name}.
In Gauche, a record type is just a subclass of @code{<record>}.

@var{constructor} is bound to a procedure that creates an instance
of the record type,
which takes as many arguments as @var{init-tag} @dots{}.  Each
@var{init-tag} corresponds to one of the field name, and the fields
of the created record instance is initialized accordingly.  Not all
of fields need to appear in @var{init-tag}; uninitialized fields remain
unbound.

@var{predicate} is bound to a procedure that takes one argument, and
returns #t if the argument is an instance of the defined record type,
#f otherwise.

Followings are field specifications.  The record has fields
@var{field} @dots{}, and each field can be accessed by a method
@var{accessor}.  If @var{modifier} is given to the field, it is bound
to a method that sets the value to the field.

Example:
@example
(define-record-type pare
  (kons x y) pare?
  (x kar set-kar!)
  (y kdr))
 @result{} #<class pare>

(pare? (kons 2 3)) @result{} #t
(pare? (cons 2 3)) @result{} #f

(kar (kons 2 3)) @result{} 2
(kdr (kons 2 3)) @result{} 3

(let ((x (kons 2 3)))
  (set-kar! x -1)
  (kar x)) @result{} -1
@end example

Conceptually, the above example is expanded into the following
sequence of forms.
@example
(define-class pare (<record>) (x y))
(define (kons x y)
  (let ((obj (make pare)))
    (slot-set! obj 'x x) 
    (slot-set! obj 'y y)
    obj))
(define (pare? obj) (is-a? obj pare))
(define-method kar ((obj pare))
  (slot-ref obj 'x))
(define-method set-kar! ((obj pare) value)
  (slot-set! obj 'x value))
(define-method kdr ((obj pare))
  (slot-ref obj 'y))
@end example

@end defmac

@c ----------------------------------------------------------------------
@node Let-values, String library, Record types, Libarary Modules
@section @code{srfi-11} - Let-values

@deftp {Module} srfi-11
@mdindex srfi-11
Defines two macros, @code{let-values} and @code{let*-values}.
They are convenient to use with multiple values.


@end deftp

@defmac let-values ((vars expr) @dots{}) body @dots{}
[SRFI-11]
@var{vars} are a list of variables. @var{expr} is evaluated, and
its first return value is bound to the first variable in @var{vars},
its second return value to the second variable, and so on, then
@var{body} is evaluated.
The scope of @var{expr}s are the outside of @code{let-values} form,
like @code{let}.

@example
(let-values (((a b) (values 1 2))
             ((c d) (values 3 4)))
  (list a b c d)) @result{} (1 2 3 4)

(let ((a 1) (b 2) (c 3) (d 4))
  (let-values (((a b) (values c d))
               ((c d) (values a b)))
    (list a b c d))) @result{} (3 4 1 2)
@end example

@var{vars} can be a dotted list or a single symbol, like the
lambda parameters.

@example
(let-values (((x . y) (values 1 2 3 4)))
  y) @result{} (2 3 4)

(let-values ((x (values 1 2 3 4)))
  x) @result{} (1 2 3 4)
@end example

If @var{expr} returns less values than specified in @var{vars},
an error is signalled.  If @var{expr} returns more values than
specified in @var{vars}, the unused values are discarded.
@end defmac

@defmac let*-values ((vars expr) @dots{}) body @dots{}
[SRFI-11]
Same as @code{let-values}, but each @var{expr}'s scope includes
the preceding @var{vars}.

@example
(let ((a 1) (b 2) (c 3) (d 4))
  (let*-values (((a b) (values c d))
                ((c d) (values a b)))
    (list a b c d))) @result{} (3 4 3 4)
@end example
@end defmac

@c ----------------------------------------------------------------------
@node String library, Character-set library, Let-values, Libarary Modules
@section @code{srfi-13} - String library

@deftp {Module} srfi-13
@mdindex srfi-13
Defines a large set of string-related functions.
In Gauche, those functions are splitted to number of files
and the form @code{(use srfi-13)} merely sets up autoloading of
those files.  So it is not likely to slow down the script startup.

See the
@uref{http://srfi.schemers.org/srfi-13/srfi-13.html, SRFI-13 document}
for the detailed specification and discussion of design issues.
This manual serves as a reference of function API.
Some SRFI-13 functions are Gauche built-in and not listed here.

Note: SRFI-13 documents suggests the name of the module that
implements these functions to be ``string-lib'' and ``string-lib-internals''.
Gauche uses the name ``srfi-13'' for consistency.
@end deftp

@menu
* SRFI-13 General conventions::  
* SRFI-13 String predicates::   
* SRFI-13 String Constructors::  
* SRFI-13 String Selection::    
* SRFI-13 String Comparison::   
* SRFI-13 String Prefixes & Suffixes::  
* SRFI-13 String searching::    
* SRFI-13 String case mapping::  
* SRFI-13 String reverse & append::  
* SRFI-13 String mapping::      
* SRFI-13 String rotation::     
* SRFI-13 other string operations::  
* SRFI-13 String filtering::    
* SRFI-13 Low-level string procedures::  
@end menu

@node SRFI-13 General conventions, SRFI-13 String predicates, String library, String library
@subsection General conventions

There are a few common factors in string library API, which I don't
repeat in each function description

@table @emph
@item argument convention
The following argument names imply their types.
@table @var
@item s, s1, s2
Those arguments must be strings.
@item char/char-set/pred
This argument can be a character, a character-set object,
or a predicate that takes a single character and returns a boolean value.
``Applying @var{char/char-set/pred} to a character'' means,
if @var{char/char-set/pred} is a character, it is compared to the given
character; if @var{char/char-set/pred} is a character set, it is
checked if the character set contains the given character; if
@var{char/char-set/pred} is a procedure, it is applied
to the given character.  ``A character satisfies @var{char/char-set/pred}''
means such application to the character yields true value.

@item start, end
Lots of SRFI-13 functions takes these two optional arguments, which
limit the area of input string from @var{start}-th character
(inclusive) to @var{end}-th character (exclusive),
where the operation is performed.
When specified, the condition
0 <= @var{start} <= @var{end} <= @var{length of the string} must be
satisfied.  Default value of @var{start} and @var{end} is
0 and the length of the string, respectively.
@end table

@item `shared' variant
Some functions have variants with ``/shared'' attached to its name.
SRFI-13 defines those functions to allow to share the part of input
string, for better performance.  Gauche doesn't have a concept of
shared string, and these functions are mere synonyms of their
non-shared variants.  However, Gauche @emph{internally} shares
the storage of strings, so generally you don't need to worry
about the overhead of copying substrings.

@item `right' variant
Most functions works from left to right of the input string.
Some functions have variants with ``-right'' to its name, 
that works from right to left.

@end table

@node SRFI-13 String predicates, SRFI-13 String Constructors, SRFI-13 General conventions, String library
@subsection String predicates

@defun string-null? s
[SRFI-13] Returns @code{#t} if @var{s} is an empty string, @code{""}.
@end defun

@defun string-every char/char-set/pred s &optional start end
[SRFI-13] Sees if every character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-every} returns
the value that is returned at the last application of @var{char/char-set/pred}.
If any of the application returns @code{#f}, @code{string-every}
returns @code{#f} immediately.
@end defun

@defun string-any char/char-set/pred s &optional start end
[SRFI-13] Sees if any character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-any} returns
the value that is returned by the application.   If no character
satisfies @var{char/char-set/pred}, @code{#f} is returned.
@end defun

@node SRFI-13 String Constructors, SRFI-13 String Selection, SRFI-13 String predicates, String library
@subsection String Constructors

@defun string-tabulate proc len
[SRFI-13] @var{proc} must be a procedure that takes an integer
argument and returns a character.  @code{string-tabulate}
creates a string, whose @var{i}-th character is calculated by
@code{(proc i)}.
@example
(string-tabulate
  (lambda (i) (integer->char (+ i #x30))) 10)
 @result{} "0123456789"
@end example

@end defun

@defun reverse-list->string char-list
[SRFI-13] @equiv{} @code{(list->string (reverse char-list))}.
@end defun

@node SRFI-13 String Selection, SRFI-13 String Comparison, SRFI-13 String Constructors, String library
@subsection String selection

@defun substring/shared s start &optional end
[SRFI-13]
@end defun

@defun string-copy! target tstart s &optional start end
[SRFI-13]
@end defun

@defun string-take s nchars
@defunx string-drop s nchars
@defunx string-take-right s nchars
@defunx string-drop-right s nchars
[SRFI-13]
@end defun

@defun string-pad s len &optional char start end
@defunx string-pad-right s len &optional char start end
[SRFI-13]
@end defun

@defun string-trim s &optional char/char-set/pred start end
@defunx string-trim-right s &optional char/char-set/pred start end
@defunx string-trim-both s &optional char/char-set/pred start end
[SRFI-13]
@end defun

@node SRFI-13 String Comparison, SRFI-13 String Prefixes & Suffixes, SRFI-13 String Selection, String library
@subsection String comparison

@defun string-compare s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
@defunx string-compare-ci s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string= s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-ci@code{=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-hash s &optional bound start end 
@defunx string-hash-ci s &optional bound start end 
[SRFI-13]
@end defun

@node SRFI-13 String Prefixes & Suffixes, SRFI-13 String searching, SRFI-13 String Comparison, String library
@subsection String Prefixes & Suffixes

@defun string-prefix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-length-ci s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-prefix? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix? s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-ci? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-ci? s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@node SRFI-13 String searching, SRFI-13 String case mapping, SRFI-13 String Prefixes & Suffixes, String library
@subsection String searching

@defun string-index s char/char-set/pred &optional start end
@defunx string-index-right s char/char-set/pred &optional start end
@defunx string-skip s char/char-set/pred &optional start end
@defunx string-skip-right s char/char-set/pred &optional start end
[SRFI-13]
@end defun

@defun string-count s char/char-set/pred &optional start end
[SRFI-13]
@end defun

@defun string-contains s1 s2 &optional start1 end1 start2 end2
@defunx string-contains-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@node SRFI-13 String case mapping, SRFI-13 String reverse & append, SRFI-13 String searching, String library
@subsection String case mapping

@defun string-titlecase s &optional start end
@defunx string-titlecase! s &optional start end
[SRFI-13]
@end defun

@defun string-upcase s &optional start end
@defunx string-upcase! s &optional start end
[SRFI-13]
@end defun

@defun string-downcase s &optional start end
@defunx string-downcase! s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String reverse & append, SRFI-13 String mapping, SRFI-13 String case mapping, String library
@subsection String reverse & append

@defun string-reverse s &optional start end
@defunx string-reverse! s &optional start end
[SRFI-13]
@end defun

@defun string-concatenate string-list
[SRFI-13]
@end defun

@defun string-concatenate/shared string-list
@defunx string-append/shared s @dots{}
[SRFI-13]
@end defun

@defun string-concatenate-reverse string-list
@defunx string-concatenate-reverse/shared string-list
[SRFI-13]
@end defun

@node SRFI-13 String mapping, SRFI-13 String rotation, SRFI-13 String reverse & append, String library
@subsection String mapping

@defun string-map proc s &optional start end
@defunx string-map! proc s &optional start end
[SRFI-13]
@end defun

@defun string-fold kons knil s &optional start end
@defunx string-fold-right kons knil s &optional start end
[SRFI-13]
@end defun

@defun string-unfold p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-unfold-right p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-for-each proc s &optional start end
[SRFI-13]
@end defun

@defun string-for-each-index proc s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String rotation, SRFI-13 other string operations, SRFI-13 String mapping, String library
@subsection String rotation

@defun xsubstring s from &optional to start end
[SRFI-13]
@end defun

@defun string-xcopy! target tstart s sfrom &optional sto start end
[SRFI-13]
@end defun

@node SRFI-13 other string operations, SRFI-13 String filtering, SRFI-13 String rotation, String library
@subsection Other string operations

@defun string-replace s1 s2 start1 end2 &optional start2 end2
[SRFI-13]
@end defun

@defun string-tokenize s &optional token-set start end
[SRFI-13]
@end defun

@node SRFI-13 String filtering, SRFI-13 Low-level string procedures, SRFI-13 other string operations, String library
@subsection String filtering

@defun string-filter s char/char-set/pred &optional start end
@defunx string-delete s char/char-set/pred &optional start end
[SRFI-13]
@end defun

@node SRFI-13 Low-level string procedures,  , SRFI-13 String filtering, String library
@subsection Low-level string procedures

@defun string-parse-start+end proc s args
@defunx string-parse-final-start+end proc s args
[SRFI-13]
@end defun

@defmac let-string-start+end (start end [rest]) proc-exp s-exp args-exp body @dots{}
[SRFI-13]
@end defmac

@defun check-substring-spec proc s start end
@defunx substring-spec-ok? s start end
[SRFI-13]
@end defun

@defun make-kmp-restart-vector s &optional c= start end
[SRFI-13]
@end defun

@defun kmp-step pat rv c i c= p-start
[SRFI-13]
@end defun

@defun string-kmp-partial-search pat rv s i &optional c= p-start s-start s-end
[SRFI-13]
@end defun

@c ----------------------------------------------------------------------
@node Character-set library,  , String library, Libarary Modules
@section @code{srfi-14} - Character-set library

@deftp {Module} srfi-14
@mdindex srfi-14
@end deftp

@menu
* SRFI-14 Character-set constructors::  
* SRFI-14 Character-set Comparison::  
* SRFI-14 Character-set iteration::  
* SRFI-14 Character-set query::  
* SRFI-14 Character-set algebra::  
* SRFI-14 Predefined character-set::  
@end menu

@node SRFI-14 Character-set constructors, SRFI-14 Character-set Comparison, Character-set library, Character-set library
@subsection Character-set constructors

@defun list->char-set char-list &optional base-cs
@defunx list->char-set! char-list base-cs
[SRFI-14]
@end defun

@defun string->char-set char-list &optional base-cs
@defunx string->char-set! char-list base-cs
[SRFI-14]
@end defun

@defun char-set-filter pred char-set &optional base-cs
@defunx char-set-filter! pred char-set base-cs
[SRFI-14]
@end defun

@defun ucs-range->char-set lower upper &optional error? base-cs
@defunx ucs-range->char-set! lower upper error? base-cs
[SRFI-14]
@end defun

@defun integer-range->char-set lower upper &optional error? base-cs
@defunx integer-range->char-set! lower upper error? base-cs
@end defun

@defun ->char-set x
[SRFI-14]
@end defun

@node SRFI-14 Character-set Comparison, SRFI-14 Character-set iteration, SRFI-14 Character-set constructors, Character-set library
@subsection Character-set comparison

@defun char-set= char-set1 @dots{}
[SRFI-14]
@end defun

@defun char-set@code{<=} char-set1 @dots{}
[SRFI-14]
@end defun

@defun char-set-hash char-set &optional bound
[SRFI-14]
@end defun

@node SRFI-14 Character-set iteration, SRFI-14 Character-set query, SRFI-14 Character-set Comparison, Character-set library
@subsection Character-set iteration

@defun char-set-cursor char-set
[SRFI-14]
@end defun

@defun char-set-ref char-set cursor
[SRFI-14]
@end defun

@defun char-set-cursor-next char-set cursor
[SRFI-14]
@end defun

@defun end-of-char-set? ccursor
[SRFI-14]
@end defun

@defun char-set-fold kons knil char-set
[SRFI-14]
@end defun

@defun char-set-unfold pred fun gen seed &optional base-char-set
@defunx char-set-unfold! pred fun gen seed base-char-set
[SRFI-14]
@end defun

@defun char-set-for-each proc char-set
[SRFI-14]
@end defun

@defun char-set-map proc char-set
[SRFI-14]
@end defun

@node SRFI-14 Character-set query, SRFI-14 Character-set algebra, SRFI-14 Character-set iteration, Character-set library
@subsection Character-set query

@defun char-set-size char-set
[SRFI-14]
@end defun

@defun char-set-count pred char-set
[SRFI-14]
@end defun

@defun char-set->list char-set
[SRFI-14]
@end defun

@defun char-set->string char-set
[SRFI-14]
@end defun

@defun char-set-every pred char-set
[SRFI-14]
@end defun

@defun char-set-any pred char-set
[SRFI-14]
@end defun

@node SRFI-14 Character-set algebra, SRFI-14 Predefined character-set, SRFI-14 Character-set query, Character-set library
@subsection Character-set algebra

@defun char-set-adjoin char-set char1 @dots{}
@defunx char-set-adjoin! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-delete char-set char1 @dots{}
@defunx char-set-delete! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-complement char-set
@defunx char-set-complement! char-set
[SRFI-14]
@end defun

@defun char-set-union char-set @dots{}
@defunx char-set-union! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-intersection char-set @dots{}
@defunx char-set-intersection! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-difference char-set1 char-set2 @dots{}
@defunx char-set-difference! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-xor char-set @dots{}
@defunx char-set-xor! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-diff+intersection char-set1 char-set2 @dots{}
@defunx char-set-diff+intersection! char-set1 char-set2 char-set3 @dots{}
[SRFI-14]
@end defun



@node SRFI-14 Predefined character-set,  , SRFI-14 Character-set algebra, Character-set library
@subsection Predefined character-set

@defvar char-set:letter
[SRFI-14]
@end defvar

@defvar char-set:blank
[SRFI-14]
@end defvar

@defvar char-set:iso-control
[SRFI-14]
@end defvar

@defvar char-set:digit
@defvarx char-set:hex-digit
[SRFI-14]
@end defvar

@defvar char-set:graphic
[SRFI-14]
@end defvar

@defvar char-set:lower-case
@defvarx char-set:upper-case
@defvarx char-set:title-case
[SRFI-14]
@end defvar

@defvar char-set:printing
[SRFI-14]
@end defvar

@defvar char-set:punctuation
[SRFI-14]
@end defvar

@defvar char-set:whitespace
[SRFI-14]
@end defvar

@defvar char-set:symbol
[SRFI-14]
@end defvar

@defvar char-set:ascii
[SRFI-14]
@end defvar

@defvar char-set:empty
[SRFI-14]
@end defvar

@defvar char-set:full
[SRFI-14]
@end defvar


@c ======================================================================
@node References, Function and Syntax Index, Libarary Modules, Top
@unnumbered References


@c Appendix : C to Scheme mapping
@c Appendix : Common Lisp to Scheme mapping
@c Appendix : Perl to Scheme mapping
@c Appendix : Python to Scheme mapping?

@c ======================================================================
@node Function and Syntax Index, Module Index, References, Top
@unnumbered Function and Syntax Index
@printindex fn

@node Module Index, Class Index, Function and Syntax Index, Top
@unnumbered Module Index
@printindex md


@node Class Index, Variable Index, Module Index, Top
@unnumbered Class Index

For readability, the surrounding @code{<} and @code{>} are stripped off.

@printindex cl

@node Variable Index,  , Class Index, Top
@unnumbered Variable Index
@printindex vr


@contents
@bye
