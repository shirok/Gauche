\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@c EN
@setfilename gauche-refe
@settitle Gauche Reference Manual
@c JP
@setfilename gauche-refj
@settitle Gauche リファレンスマニュアル
@c COMMON
@comment %**end of header

@c $Id: gauche-ref.texi,v 1.166 2002-02-26 09:44:09 shirok Exp $

@c module and class index
@defcodeindex md
@defcodeindex cl

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@c EN
@title Gauche Reference Manual
@c JP
@title Gauche リファレンスマニュアル
@c COMMON
@subtitle version @VERSION@
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)

@ifnottex
@c EN
This is a reference manual of Gauche, an R5RS Scheme implementation.
This manual is for version @VERSION@.
@c JP
本書は、R5RS準拠のScheme処理系、Gaucheのリファレンスマニュアルです。
Gaucheのバージョン@VERSION@に対応します。
@c COMMON
@end ifnottex

@menu
* Introduction::                
* Concepts::                    
* Programming in Gauche::       
* Core syntax::                 
* Macros::                      
* Core library::                
* Object system::               
* Library modules::             
* References::                  
* C to Scheme mapping::         
* Indices::                     
@end menu

@node Introduction, Concepts, Top, Top
@chapter Introduction
@c NODE はじめに

@c EN
This is a programmers' guide and reference manual of
the Gauche Scheme system.
Here I tried to describe Gauche's implementation precisely,
sometimes referring to background design choices.
@c JP
本書はGauche Scheme systemに関する、プログラマーのためのガイドと
リファレンスです。なるべくGaucheの実装を正確に記述することを
目的として、時には背景となる設計上の選択も含めて説明しています。
@c COMMON

@c EN
The target readers are those who already know Scheme and
want to write useful programs in Gauche.
For those who are new to Scheme, it'll be easier to start
from some kind of tutorial.  I'm planning to write one.
@c JP
したがって、既にSchemeを知っていてGaucheの全機能を活用して
プログラムを書きたいという読者を対象にしています。
Schemeに触れるのが初めての読者は、何らかのチュートリアルを併用すると
良いでしょう。私もいずれチュートリアルめいたものを書くつもりです。
@c COMMON

@c EN
This manual only deals with Scheme side of things.  Gauche has
another face, a C interface.   Details of it will be discussed
in a separate document to be written.
Those who wants to use Gauche as an embedded language, or wants
to write an extension, need that volume.
@c JP
このマニュアルでは、GaucheのScheme言語としての面のみを扱います。
GaucheはC言語から呼べる汎用リスト処理ライブラリとしての側面も持っていますが、
それは別ドキュメントで解説する予定です。Gaucheを組み込み言語として使いたい、
もしくはGaucheをC言語で拡張したいという読者はそのドキュメントが必要となります。
@c COMMON

@c EN
For the Scheme side, I tried to make this manual self-contained
for reader's convenience, i.e. as far as you want to look up
Gauche's features you don't need to refer to other documents.
For example, description of functions defined in the standard
documents are included in this manual, instead of saying
``see the standard document''.   However, this document is not a verbatim
copy of the standard documents; sometimes I omit detailed
discussions in the standard documents for brevity.
I put pointers to the original documents, so please consult them if you
need to refer to the standards.
@c JP
Scheme言語としての側面に関しては、なるべくこのマニュアル一冊でリファレンスとしての
用が足りるように記述しました。標準に定められている関数でも、こちらのマニュアルだけで
使うのに必要な事項を知ることができます。但し、このマニュアルは標準文書の替わりには
なりません。記述を短くするために理論的な背景などは省略してあります。
オリジナルのドキュメントへのポインタを参考文献の項に上げておきましたので、
必要に応じて参照して下さい。
@c COMMON

@c EN
If you're reading this document off-line, you may find the most
recent version on the web:
@c JP
もしあなたがこのマニュアルをオフラインで読んでいるなら、
時々下記のURLをチェックしてみて下さい。更新があるかもしれません。
@c COMMON
@example
@uref{http://www.shiro.dreamhost.com/scheme/gauche/}.
@end example

@menu
* Overview of Gauche::          
* Notations::                   
@end menu

@node Overview of Gauche, Notations, Introduction, Introduction
@section Overview of Gauche
@c NODE  Gaucheの概要

@c EN
Gauche is a script interpreter based on Scheme.
Gauche conforms the language standard
"Revised^5 Report on the Algorithmic Language Scheme"
(@ref{r5rs,[R5RS],R5RS}),
and supports various common libraries defined in SRFIs
(@uref{http://srfi.schemers.org}).
@c JP
GaucheはScheme言語に基づくスクリプトインタプリタです。
Scheme言語の標準である、"Revised^5 Report on the Algorithmic Language Scheme"
(@ref{r5rs,[R5RS],R5RS})に準拠しています。また、SRFI
(@uref{http://srfi.schemers.org}) に規定されている数多くのライブラリを
サポートしています。
@c COMMON

@c EN
The goal of Gauche is to provide a handy tool for
programmers and system administrators to handle
daily works conveniently and efficiently in the production environment.
@c JP
Gaucheは、プログラマやシステム管理者がこなす日常の雑事を
効率よくSchemeで書けるようにすることを目的として設計されています。
@c COMMON

@c EN
There are lots of Scheme implementations available, and each
of them has its design emphasis and weeknesses.  Gauche is
designed with emphasis on the following criteria.
@c JP
世の中には多くのSchemeの実装がありますが、
それぞれの実装には長所と短所があります。
Gaucheが長所とするべく重点を置いているのは次のようなポイントです。
@c COMMON

@table @b
@c EN
@item Quick startup
@c JP
@item 立ち上りが速いこと
@c COMMON
@c EN
One of the situation Gauche is aiming at is in the production
environment, where you write ten-lines throw-away script that
may invoked very frequently.  This includes CGI scripts as well.
Gauche includes a set of most common features in its executable,
while splits less common stuffs into libraries which are to be loaded
on demand, to make itself start quickly.
@c JP
Gaucheが想定している用途のひとつは、プロダクション環境でちょろっと
10行スクリプトをでっちあげて、それが非常に頻繁に呼ばれるようなケースです。
CGIスクリプトなどもそうです。
Gaucheでは、言語のコアとスクリプトとして良く使いそうな機能に絞って
実行ファイルにコンパイルインし、使う分野が特定される機能は必要に応じて
読み込むようにしています。
@c COMMON

@c EN
@item Multibyte strings
@c JP
@item マルチバイト文字列
@c COMMON
@c EN
We can no longer live happily in ASCII-only or 1-byte-per-character world.
The practical language implementations are required to handle
multibyte (wide) characters.
Gauche supports multibyte strings natively, providing robust and
consistent support than @i{ad hoc} library-level implementation.
@xref{Multibyte Strings}, for details.
@c JP
文字列が1バイトキャラクタのみを扱っていれば良かった時代は過ぎ去りました。
現代のプログラミングシステムは、様々なエンコーディングによるマルチバイト文字／文字列を
自然に扱える必要があります。
Gaucheは内部的に文字列を全て、コンパイル時に選択したエンコーディングの
マルチバイト文字列として扱います。後から付け足したライブラリレベルでの
マルチバイト文字列のサポートよりも、一貫性がありロバストな文字列操作が可能になっています。
詳しくは@ref{Multibyte Strings}を参照してください。
@c COMMON

@c EN
@item Modular development
@c JP
@item モジュラー開発
@c COMMON
@c EN
Gauche has a simple module system to separate namespaces,
which allows the developers to work in parallel without
worrying name collision.  
@c JP
Gaucheは名前空間を分離する単純なモジュールシステムを備えており、
名前の衝突を心配せずに複数の開発者が並行して作業をすることができます。
@c COMMON

@c EN
@item Integrated object system
@c JP
@item 統合されたオブジェクトシステム
@c COMMON
@c EN
A powerful CLOS-like object system with MetaObject protocol
(mostly compatible with STklos and Guile) is provided.
@c JP
CLOSライクなメタオブジェクトプロトコルを備えた強力なオブジェクトシステム
が組み込んであります。STklosやGuileのオブジェクトシステムとかなり互換性があります。
@c COMMON

@c EN
@item System interface
@c JP
@item システムインタフェース
@c COMMON
@c EN
Although Scheme abstracts lots of details of the machine,
sometimes you have to bypass these high-level layers and
go down to the basement to make things work.
Gauche has built-in support of most of POSIX.1 system calls.
Other modules, such as networking module, usually provide
both high-level abstract interface and low-level interface
close to system calls.
@c JP
Schemeは計算機の詳細の多くを抽象化しますが、プログラムを書いていると、
それらの高レベル層をバイパスして地下室に降りて作業しなければならないような時が
あります。GaucheはPOSIX.1システムコールのほとんどを組み込みでサポートします。
また、ネットワーキングモジュールなど他のシステム関連モジュールは通常、
高レベルの抽象的なインタフェースと低レベルのシステムコールに近いインタフェースを
両方提供します。
@c COMMON

@c EN
@item Enhanced I/O
@c JP
@item 強化された入出力
@c COMMON
@c EN
No real application can be written without dealing with I/O.
Scheme neatly abstracts I/O as a port, but defines least operations on it.
Gauche uses a port object as a unified abstraction, providing
utility functions to operate on the underlying I/O system.
@xref{Input and output}, for the basic I/O support.
@c JP
本物のアプリケーションはI/O無しでは成り立ちません。
SchemeはI/Oをポートとして簡潔に抽象化していますが、
標準のSchemeには最低限の操作しか定義されていません。
Gaucheはポートオブジェクトを入出力のための統合された抽象化オブジェクトと考え、
それを通して下位のI/Oシステム層にアクセスするユーティリティ関数を提供しています。
@ref{Input and output}を参照して下さい。
@c COMMON
@end table

@c EN
On the other hand, Gauche is @emph{not} designed for 
applications such like high-performance number cruncher or
very large scale database handling.  It is an interpreter, after all.

You can still use Gauche as a "glue" language for such applications,
however.  For example, you can write a performance-critical part 
in another language that compiles to native code, and use Gauche to set up.
@c JP
一方、Gaucheは所詮インタプリタですから、高速に大量の計算をこなしたり
巨大なデータセットを扱ったりするのは苦手です。

但し、そのような場合でも、Gaucheを各コンポーネントをつなぐ「糊」言語として
使うことは可能です。例えば性能の要求の厳しい部分はネイティブコードにコンパイルする言語で
書いておき、セットアップにGaucheを使うといった方法があります。
@c COMMON


@node Notations,  , Overview of Gauche, Introduction
@section Notations
@c NODE 表記について

@c EN
In this manual, each entry is represented like this:

@deftp {Category} foo arg1 arg2
[spec] Description of foo @dots{}
@end deftp
@c JP
このマニュアルでは、各項目は次のようなフォーマットで表記されています。

@deftp {カテゴリ} foo arg1 arg2
[spec] fooの説明
@end deftp
@c COMMON

@c EN
@var{Category} denotes the category of the entry @b{foo}.
The following category will appear in this manual:
@c JP
@var{カテゴリ} は項目@b{foo}の種別を示します。
次のようなカテゴリがあります。
@c COMMON

@multitable @columnfractions .4 .6
@item Function
@c EN
@tab A Scheme function.
@c JP
@tab Scheme手続き
@c COMMON
@item Special Form
@c EN
@tab A special form (in the R5RS term, ``syntax'').
@c JP
@tab 特殊形式 (R5RSでは「構文」)
@c COMMON
@item Macro
@c EN
@tab A macro.
@c JP
@tab マクロ
@c COMMON
@item Module
@c EN
@tab A module
@c JP
@tab モジュール
@c COMMON
@item Class
@c EN
@tab A class.
@c JP
@tab クラス
@c COMMON
@item Generic Function
@c EN
@tab A generic function
@c JP
@tab ジェネリックファンクション
@c COMMON
@item Method
@c EN
@tab A method
@c JP
@tab メソッド
@c COMMON
@item Reader Syntax
@c EN
@tab A lexical syntax that is interpreted by the reader.
@c JP
@tab リーダによって解釈される構文要素
@c COMMON
@end multitable

@c EN
For functions, special forms and macros, the entry may followed
by one or more arguments.  In the argument list, the following notations
may appear:
@c JP
手続き、特殊形式、マクロに関しては、エントリの後に引数の仕様が示されます。
引数リストの中には次のような表記が現れることがあります。
@c COMMON

@table @var
@item arg @dots{}
@c EN
Indicates zero or more arguments.
@c JP
ゼロ個以上の可変個の引数。
@c COMMON
@item &optional x y z
@itemx &optional (x x-default) (y y-default) z
@c EN
Indicates it may take up to three optional arguments.
The second form specifies default values.
Note that Gauche doesn't really support Common-Lisp style
@code{&optional} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@c JP
省略可能な引数の表記。この例では3つまでの省略可能な引数が取られることを示します。
2番目の形式では省略された場合の既定値も示しています。
この表記はCommonLispのスタイルにならっていますが、Gauche自身がラムダリストに
@code{&optional}のような表記を受け付けるわけではないことに注意してください。
マニュアルの表記を簡潔にするためにこのような表現を用いているだけです。
@c COMMON
@item &keyword x y z
@itemx &keyword (x x-default) (y y-default) z
@c EN
Indicates it may take keyword arguments @var{x}, @var{y} and @var{z.}
Note that Gauche doesn't really support Common-Lisp style
@code{&keyword} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@c JP
キーワード引数の表記。この例では@var{x}、@var{y}、@var{z}の3つのキーワード引数を
取ることが示されます。2番目の形式では省略された場合の既定値も示されます。
この表記はCommonLispのスタイルにならっていますが、Gauche自身がラムダリストに
@code{&optional}のような表記を受け付けるわけではないことに注意してください。
マニュアルの表記を簡潔にするためにこのような表現を用いているだけです。
@c COMMON
@item &rest args
@c EN
Indicates it may take rest arguements.
Note that Gauche doesn't really support Common-Lisp style
@code{&rest} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@c JP
残りの引数全てがリストになって@var{args}に束縛されることを示します。
この表記はCommonLispのスタイルにならっていますが、Gauche自身がラムダリストに
@code{&optional}のような表記を受け付けるわけではないことに注意してください。
マニュアルの表記を簡潔にするためにこのような表現を用いているだけです。
@c COMMON
@end table

@c EN
The description of the entry follows the entry line.
If the specification of the entry comes from some standard or
implementation, its origin is noted in the bracket at the beginning
of the description.  The following origins are noted:
@c JP
説明が項目の行に続きます。もし項目が特定の標準に準拠している場合は、
もととなった標準が次のような形式で示されます。
@c COMMON

@table @asis
@item [R5RS]
@itemx [R5RS+]
@c EN
The entry works as specified in ``Revised^5 Report of Algorithmic Language
Scheme.''.  If it is marked as "[R5RS+]", the entry has additional
functionality.
@c JP
この項目はR5RSに定義されるように動作します。"[R5RS+]"とマークされている場合は
R5RSの仕様に上位互換な形で追加の機能が実装されていることを示します。
@c COMMON
@item [SRFI-@var{n}]
@itemx [SRFI-@var{n}+]
@c EN
The entry works as specified in SRFI-@var{n}.  If it is marked as
"[SRFI-@var{n}+]", the entry has additional functionality.
@c JP
この項目はSRFI-@var{n}に定義されるように動作します。"[SRFI-@var{n}+]"とマークされている場合は
SRFI-@var{n}の仕様に上位互換な形で追加の機能が実装されていることを示します。
@c COMMON
@item [POSIX]
@c EN
The API of the entry reflects the API specified in POSIX.
@c JP
この項目はPOSIXのAPIを反映していることを示します。
@c COMMON
@end table

@c @node Structure of this document,  , Notations, Introduction
@c @section Structure of this document
@c @c NODE 本書の構成

@c @c EN
@c @c JP
@c @c COMMON

@c ======================================================================
@node Concepts, Programming in Gauche, Introduction, Top
@chapter Concepts
@c NODE 主要な概念

@c EN
In this chapter I describe a few Gauche's design concepts
that help you to understand how Gauche works.
@c JP
本章では、Gauche動作の背景となるいくつかの概念を説明します。
Gaucheの動作を正確に理解する助けになると思います。
@c COMMON

@menu
* Compilation::                 
* Multibyte Strings::           
* Case-sensitivity::            
* Integerated Object System::   
* Module System::               
@end menu

@node Compilation, Multibyte Strings, Concepts, Concepts
@section Compilation
@c NODE コンパイル

@c EN
Gauche is a Scheme interpreter, in the sense that it reads
a Scheme form at a time and evaluates it.   Actually,
Gauche compiles every toplevel form into an intermediate form
before executing.
@c JP
Gaucheは、Schemeフォームをひとつづつ読み込んでは評価するという意味では
インタプリタです。しかし内部では、Gaucheはひとつひとつのフォームを中間形式に
コンパイルして仮想マシンで実行しています。
@c COMMON

@c EN
Built-in sytanxes and macros are recognized and expanded
at the compilation time.  Some built-in procedures are
expanded in-line as far as the compiler can see the global
binding is not altered at the time the form is compiled.
@c JP
組み込みの構文とマクロはコンパイル時に認識されて展開されます。
よく使われる組み込み関数は、コンパイル時にグローバルな束縛が置き換わっていない場合に、
インライン展開されます。
@c COMMON

@c EN
This raises a few problems you should care.
@c JP
プログラマは通常、コンパイラの動作を気にする必要はほとんどありませんが、
いくつかの点に注意する必要があります。
@c COMMON

@table @emph
@c EN
@item load is done at run time.
@code{load} is a procedure in Gauche, therefore evaluated at run time.
If the loaded program defines a macro, which is available for the compiler
after the toplevel form containing @code{load} is evaluated.  So, suppose
@code{foo.scm} defines a macro @code{foo}, and you use the macro
like this:
@c JP
@item loadは実行時に評価される
@code{load}はGaucheでは一般の関数なので、実行時に評価されます。
ロードされるファイル中でマクロを定義している場合、そのマクロは
その@code{load}の呼び出しを含むトップレベルフォームが評価された後で
有効になります。例えば、@code{foo.scm}がマクロ@code{foo}を定義しているとして、
次のような用法を考えてみてください。
@c COMMON
@example
;; @r{in ``foo.scm''}
(define-syntax foo
  (syntax-rules () (_ arg) (quote arg)))

;; @r{in your program}
(begin (load "foo") (foo (1 2 3)))
  @result{} @r{error, bad procedure: `1'}

(load "foo")
(foo (1 2 3)) @result{} '(1 2 3)
@end example
@c EN
The @code{(begin (load ...))} form fails,  because the compiler
doesn't know @code{foo} is a special form at the compilation time
and compiles @code{(1 2 3)} as if it is a normal procedure call.
The latter example works, however, since the execution
of the toplevel form @code{(load "foo")} is done before
@code{(foo (1 2 3))} is compiled.
@c JP
@code{begin}で@code{load}と@code{foo}の呼び出しを囲んだ場合、
コンパイラはまず@code{begin}全体をコンパイルします。その時点でマクロ
@code{foo}は定義されていませんから、これは評価時にエラーになります。
一方、後者では@code{load}が評価されてから@code{foo}がコンパイルされるので、
問題は起きません。
@c COMMON

@c EN
To avoid this kind of subtleties, use @code{require} or @code{use}
to load a program fragments.  Those are recognized by the compiler.
@c JP
このような混乱を避けるために、別のプログラムファイルを読み込む必要がある時は
@code{require}か@code{use}を使うことを勧めます。これらは構文であり、
コンパイラに認識されます。
@c COMMON

@c EN
@item require is done at compile time
On the other hand, since @code{require} and @code{use} is recognized
by the compiler, the specified file is loaded even if the form
is in the conditional expression.   If you really need to load
a file on certain condition, use @code{load} or do dispatch in macro
(i.e. at compile time).
@c JP
@item require はコンパイル時に評価される
上記の裏返しですが、@code{require}と@code{use}はコンパイル時に
解釈されます。したがって、@code{if}などの条件文のボディにこれらのフォームを
置いておいても、指定されたファイルは条件にかかわらず読み込まれてしまいます。
どうしてももし条件によって読み込むかどうかを変えたい場合は、@code{load}を使うか、
条件判断自体をマクロで行うようにしてください。
@c COMMON


@end table

@node Multibyte Strings, Case-sensitivity, Compilation, Concepts
@section Multibyte Strings
@c NODE マルチバイト文字列

@c EN
Traditionally, a string is considered as a simple array of bytes.
Programmers tend to image a string as a simple
array of characters (though a character may occupy more than one byte).
It's not the case in Gauche.
@c JP
伝統的に、文字列は単なるバイトの配列として長く扱われてきました。
一文字が複数バイトを占めるようになっても、
文字列は単純な文字の配列であると考えられがちです。
しかしGaucheはそうではありません。
@c COMMON

@c EN
Gauche supports @emph{multibyte string} natively,
which means characters are represented by variable number of bytes
in a string.   Gauche retains semantic compatibility of
Scheme string, so such details can be hidden, but it'll helpful
if you know a few points.
@c JP
Gaucheは内部的に@emph{マルチバイト文字列}をサポートします。
すなわち、文字列中の文字が占めるバイト数は一定していません。
Schemeの文字列プリミティブのセマンティクスは保たれているので、
詳細を気にしないでもプログラムは書けますが、
下にあげるいくつかの点を知っておいたほうが良いでしょう。
@c COMMON

@c EN
A string object keeps a type tag and a pointer to the storage
of the string body.  The storage of the body is managed in a sort of
``copy-on-write''
way---if you take substring, e.g. using directly by @code{substring}
or using regular expression matcher, or even if you copy a string
by @code{copy-string}, the underlying storage is shared
(the ``anchor'' of the string is different, so the copied string
is not @code{eq?} to the original string).
The actual string is copied only if you destructively modify it.
@c JP
文字列オブジェクトは型タグと文字列本体へのポインタを保持しています。
文字列本体は「copy-on-write」方式で管理されます。すなわち、@code{substring}
や正規表現を使って部分文字列を切り出したり、あるいは単に文字列をコピーした場合、
文字列オブジェクトそのものは別につくられますが、文字列本体は共有されます。
文字列が破壊的に変更される場合にのみ、文字列本体がコピーされます。
@c COMMON

@c EN
Consequently the algorithm like pre-allocating a string by
@code{make-string} and filling it with @code{string-set!}
becomes @emph{extremely} inefficient in Gauche.  Don't do it.
(It doesn't work with mulitbyte strings anyway).
Sequential access of string is much more efficient
using @emph{string ports} (@xref{String ports}).
@c JP
したがって、@code{make-string}である大きさの文字列をあらかじめアロケート
しておき、@code{string-set!}で順に埋めて行くようなアルゴリズムは
Gaucheでは非常に効率が悪くなります。そのようなアルゴリズムは使わない方が良いでしょう。
(そのようなアルゴリズムはマルチバイト文字列とも相性が良くありません)。
文字列を順に埋めて行く場合は@emph{string ports}を使うのが
効率の良い方法です (@ref{String ports}参照)。
@c COMMON

@c EN
String search primitives such as @code{string-scan} (@xref{String utilities})
and regular expression matcher (@xref{Regular expression})
can return a matched string directly, without
using index access at all.
@c JP
@code{string-scan} (@ref{String utilities}参照) や正規表現
(@ref{Regular expression}参照) など文字列を検索するプリミティブは、
インデックスを介さずに一致した文字列を直接返すことができます。
@c COMMON

@c EN
You can choose @emph{internal} encoding scheme at the time of compiling
Gauche.  Conversions from other encoding scheme is provided 
as a special port. @xref{Character code conversion}, for details.
@c JP
Gaucheのコンパイル時に、文字の@emph{内部エンコーディング} を選択することができます。
他の文字エンコーディングからの変換は特別なポートを使って行われます。
@ref{Character code conversion} を参照して下さい。
@c COMMON

@c EN
Gauche assumes the Scheme program is written in its internal
encoding scheme.
@c JP
Gaucheは、Schemeプログラムはその内部エンコーディングと同じエンコーディングで
書かれているものとして読み込みます。
@c COMMON

@node Case-sensitivity, Integerated Object System, Multibyte Strings, Concepts
@section Case-sensitivity
@c NODE 大文字小文字の区別

@c EN
Historically, most Lisp-family languages are case-insensitive
for symbols.  Scheme is no exception and R5RS defines symbols are
read in case-insensitive way.  (Note that symbols are case-sensitive
internally even in R5RS Scheme; case-insensitivity is about readers.)
@c JP
Lisp系の言語は歴史的にシンボルの大文字小文字を区別していませんでした。
Schemeもその流れを汲んでおり、R5RSでもシンボルは読み込まれる時に大文字小文字の
区別をしないと定義されています。(但し、R5RSの範囲内でも内部的なシンボル名は
大文字小文字の区別がなされます。ここで問題としているのは読み込み時の動作です)。
@c COMMON

@c EN
However, nowadays programming is hardly completed in one language.
When you interacts with other languages that distinguishes uppercase
and lowercase characters, it is desirable that Scheme distinguishes them
as well.
@c JP
しかし現在では、プログラミングが一つの言語で完結することは滅多にありません。
他の言語とインタフェースを取る場合、Scheme側でも大文字小文字を区別するように
しておいた方が便利です。
@c COMMON

@c EN
So Gauche has two modes in reading and writing symbols.
@emph{By default, Gauche reads and writes symbols in case-sensitive manner}.
This behavior doesn't conform R5RS.
@c JP
そこでGaucheでは、シンボルの読み込みと書き出しに2つのモードを用意しました。
@emph{デフォルトのモードでは、Gaucheのリーダとライタはシンボルの大文字小文字を区別します}。
このふるまいは厳密にはR5RSに準拠しません。
@c COMMON

@example
; @r{In case-sensitive mode (default)}
(eq? 'a 'A) @result{} #f  ; #t @r{in R5RS}
(symbol->string 'ABC) @result{} "ABC"
(symbol->string 'abc) @result{} "abc"
(display (string->symbol "ABC")) @result{} @r{writes} ABC
(display (string->symbol "abc")) @result{} @r{writes} abc
@end example

@c EN
You can make Gauche case-insensitive by giving @code{-fcase-fold}
command-line option to the @code{gosh} interpreter (@xref{Invoking Gosh}).
In this mode, the reader folds uppercase characters in symbols to lowercase
ones.  If a symbol name contains uppercase characters, it is written
out using |-escape (@xref{Symbols}).
@c JP
@code{gosh}インタプリタの起動時に@code{-fcase-fold}コマンドライン引数を
与えると、Gaucheは大文字小文字を区別しないモードで動作します (@ref{Invoking Gosh}参照)。
このモードでは、リーダはシンボルの読み込みの際に大文字を小文字に変換します。
大文字を含んでいるシンボルに関しては、`|' 文字でエスケープされて書き出されます
(@ref{Symbols}参照)。
@c COMMON

@example
; @r{In case-insensitive mode (with -fcase-fold option)}
(eq? 'a 'A) @result{} #t
(symbol->string 'ABC) @result{} "abc"
(symbol->string 'abc) @result{} "abc"
(display (string->symbol "ABC")) @result{} @r{writes} |ABC|
(display (string->symbol "abc")) @result{} @r{writes} abc
@end example

@c EN
Right now, there's no way to switch these two modes back and forth
inside the intepreter; an API will be provided in the later versions.
@c JP
今のところ、インタプリタの中から両方のモードを切り替えることはできません。
将来のバージョンではその方法が提供されるでしょう。
@c COMMON


@node Integerated Object System, Module System, Case-sensitivity, Concepts
@section Integrated Object System
@c NODE 統合されたオブジェクトシステム

@c EN
Gauche has a STklos-style object system, similar to CLOS.
If you have used some kind of object oriented (OO) languages,
you'll find it easy to understand the basic usage:
@c JP
GaucheはCLOSに類似した、STklosスタイルのオブジェクトシステムを持っています。
あなたが何らかのオブジェクト指向(OO)言語を使ったことがあれば、
基本的な使い方は簡単にわかるでしょう。
@c COMMON
@example
@c EN
;; @r{Defines a class point, that has x and y coordinate}
@c JP
;; @r{x, y座標を持つpointクラスを定義}
@c COMMON
(define-class point ()
  ((x :init-value 0)
   (y :init-value 0))
  )

(define-method move ((p point) dx dy)
  (inc! (slot-ref p 'x) dx)
  (inc! (slot-ref p 'y) dy))

(define-method write-object ((p point) port)
  (format port "[point ~a ~a]"
          (slot-ref p 'x)
          (slot-ref p 'y)))
@end example

@c EN
However, if you are familiar with mainstream OO langauges but new to CLOS-style
object system, Gauche's object system may look strange
when you look deeper into it.
Here I describe several characteristics of Gauche object system quickly.
@xref{Object system}, for details.
@c JP
しかし、主流のオブジェクト指向言語に慣れてはいるがCLOSスタイルのオブジェクトシステムに
慣れていないプログラマは、Gaucheのオブジェクトシステムの詳細を見てゆくと
奇妙に感じることがあるのではないかと思います。
ここではGaucheのオブジェクトシステムの代表的な性質を簡単に述べておきます。
詳しくは@ref{Object system}の章を参照して下さい。
@c COMMON

@table @emph
@c EN
@item Everything is an object (if you care)
You have seen this tagline for the other languages.
And yes, in Gauche, everything is an object in the sense that you can
query its class, and get various meta information of
the object at run time.  You can also define a new method
on any class including built-in classes.

Note that, however, in CLOS-like paradigm it doesn't really matter
whether everything is an object or not, because of the following
characteristics:
@c JP
@item 全てはオブジェクトである (それが気になる人には)
このような主張は他のOO言語でも見たことがあるでしょう。
Gaucheもその例にもれず、実行時にクラスを得たりメソッドを呼び出したりといった
操作が任意のオブジェクトに対して出来るという意味で、全てはオブジェクトです。
また組込みクラスを含めたどんなクラスに対しても新しいメソッドを定義することができます。

しかし、CLOS系のパラダイムでは、全てがオブジェクトかどうかという議論はあまり
問題ではありません。というのは次のような性質があるからです。
@c COMMON

@c EN
@item Method is dispatched by all of its arguments.
Unlike other object-oriented languages such as C++, Objective-C,
Python, Ruby, etc., in which a method always belong to a single
class, a Gauche method doesn't belong to a specific class.

For example, suppose you define a numeric vector class
@code{<num-vector>} and a numeric matrix class @code{<num-matrix>}.
You can define a method @code{product} with all possible combinations
of those type of arguments:
@c JP
@item メソッドは全ての引数によってディスパッチされる
C++、Objective C、Python、RubyなどのOO言語では、メソッドは特定のクラスに
所属しています。Gaucheではメソッドはクラスに従属しません。

例えば、数値だけを要素に持つベクタークラス@code{<num-vector>}と
行列クラス@code{<num-matrix>}を定義したとします。
プログラマは、以下のようなあらゆる場合についてメソッド@code{product}を
別々に定義することができます。
@c COMMON

@example
  (product <num-vector> <num-matrix>)
  (product <num-matrix> <num-vector>)
  (product <num-vector> <num-vector>)
  (product <num-matrix> <num-matrix>)
  (product <number>     <num-vector>)
  (product <number>     <num-matrix>)
  (product <number>     <number>)
@end example

@c EN
Each method belongs to neither @code{<num-vector>} class nor
@code{<num-matrix>} class.

Since a method is not owned by a class, you can always define your
own method on the existing class (except a few cases
that the system prohibits altering pre-defined methods).  The above
example already shows it; you can make @code{product} method work
on the built-in class @code{<number>}.   That is why I said
it doesn't make much sense to discuss whether everything is object
or not in CLOS-style object system.
@c JP
これらの各メソッドは、@code{<num-vector>}クラスや@code{<num-matrix>}
クラスに所属するわけではありません。

メソッドがクラスに所有されているわけではないので、既に存在するクラスに対していつでも
独自のメソッドを定義することができます(但し、いくつかの組込みクラスの既定のメソッドには
変更できないものがあります)。上の例で既にこれは示されています。プログラマは
メソッド@code{product}を組込みクラス@code{<number>}に対して定義することが
できます。これが、全てはオブジェクトであるかどうかはCLOSスタイルのオブジェクトシステム
では問題にならないと言った理由です。
@c COMMON

@c EN
@item Class is also an instance.
By default, a class is also an instance of class
@code{<class>}, and a generic function is an instance of class
@code{<generic>}.  You can subclass @code{<class>} to customize
how a class is initialized or how its slots are accessed.
You can subclass @code{<generic>} to customize how the
applicable methods are selected, which order those methods are
called, etc.   The mechanism is called @emph{metaobject protocol}.
Metaobject protocol allows you to extend the language by
the language itself.  

To find examples, see the files @code{lib/gauche/singleton.scm} and
@code{lib/gauche/validator.scm} included in the distribution.
You can also read @code{lib/gauche/object.scm}, which actually
defines how a class is defined in Gauche.
For more details about metaobject protocol, see @ref{mop,[MOP],MOP}.
@c JP
@item クラスはインスタンスでもある
デフォルトでは、クラスは@code{<class>}というクラスのインスタンスであり、
ジェネリック関数は@code{<generic>}というクラスのインスタンスです。
しかし、@code{<class>}を継承したクラスを定義することにより、
オブジェクトの初期化がどのように行われるかとか、スロットがどのように
アクセスされるかといった動作をカスタマイズすることができます。
また、@code{<generic>}を継承したクラスを定義することにより、
適用可能なメソッドがどのように選択されて、どのような順序で適用されるか
といったことがカスタマイズ可能です。このメカニズムは@emph{メタオブジェクトプロトコル}
と呼ばれています。メタオブジェクトプロトコルは、言語をその言語そのもので拡張する方法と
言えるでしょう。

例として、ディストリビューションに含まれる@code{lib/gauche/singleton.scm}や
@code{lib/gauche/validator}等があります。@code{lib/gauche/object.scm}を
読めば、クラス自身がGaucheでどのように定義されているかがわかります。
メタオブジェクトプロトコルの更に詳しいことについては、
@ref{mop,[MOP],MOP}が参考になります。
@c COMMON
@end table

@node Module System,  , Integerated Object System, Concepts
@section Module System
@c NODE モジュールシステム

@c EN
Gauche adopts a simple module system that allows
modularlized development of large software.
@c JP
Gaucheは大きなソフトウェアをモジュール化して開発するための、
単純なモジュールシステムを備えています。
@c COMMON

@c EN
A higher level interface is simple enough from the user's point
of view.   It works like this:
When you want to use the features provided by module
@code{foo}, you just need to say @code{(use foo)} in your code.
This form is a macro and interpreted at compile time.
Usually it loads the files that defines @code{foo}'s features,
and imports the external APIs into the calling module.
@c JP
高レベルのインタフェースを使うのはユーザにとっては非常に簡単です。
モジュール@code{foo}が提供する機能を使いたければ、
プログラム中で@code{(use foo)}と表記するだけです。
このフォームはマクロで、コンパイル時に解釈されます。
通常は、@code{foo}の機能を実装したファイルをロードし、
その外部APIを呼び出したモジュール中にインポートします。
@c COMMON

@c EN
The @code{use} mechanism is built on top of two independent
lower mechanisms, namespace separation and file loading mechanism.
Those two lower mechanisms can be used separately, although it is much more
convenient when used together.
@c JP
@code{use}メカニズムは、名前空間の分離とファイルローディングという
二つの独立な低レベルのメカニズムの上に実装されています。
これらの低レベルメカニズムはそれぞれ別々に使うこともできます。
@c COMMON

@c EN
The following sections in this manual describes
modules in details.
@itemize @bullet
@item
@ref{Writing Gauche modules} explains the convention of
writing modules.
@item
@ref{Modules} describes special forms and macros to
define and to use modules, along the built-in functions
to introspect module internals.
@end itemize
@c JP
以下のセクションでモジュールの機能について詳しく説明しています。
@itemize @bullet
@item
@ref{Writing Gauche modules} ではモジュールの書き方について
説明します。
@item
@ref{Modules} ではモジュールを定義したり使うための特殊形式とマクロ、
およびモジュールの内部を調べるための組込み手続きについて説明します。
@end itemize
@c COMMON

@c ======================================================================
@node Programming in Gauche, Core syntax, Concepts, Top
@chapter  Programming in Gauche
@c NODE Gaucheでのプログラミング

@menu
* Invoking Gosh::               
* Interactive development::     
* Debugging::                   
* Writing Scheme scripts::      
* Writing Gauche modules::      
@end menu

@node Invoking Gosh, Interactive development, Programming in Gauche, Programming in Gauche
@section Invoking Gosh
@c NODE Gaucheを起動する

@c EN
Gauche can be used either as an independent Scheme interpreter
or as an embedded Scheme library.   The interpreter
which comes with Gauche distribution is a program named @code{gosh}.
@c JP
Gaucheは独立したSchemeインタプリタとしても、組み込みのSchemeライブラリとしても
使うことができます。Gaucheのディストリビューションには、@code{gosh}という
インタプリタが附属しています。
@c COMMON

@deftp {Program} gosh [options] [scheme-file arg @dots{}]
@c EN
Gauche's interpreter.   Without @var{scheme-file}, @code{gosh} works
interactively, i.e. it reads a Scheme expression from the standard input,
evaluates it, and prints the result, and repeat that until it reads EOF or
is terminated.
@c JP
Gaucheのインタプリタです。  @var{scheme-file}が与えられなければ、
@code{gosh}はインタラクティブに動作します。すなわち、標準入力からScheme式を読み込み、
それを評価して結果をプリントするという動作を、EOFを読むか明示的に終了させられるまで
続けます。
@c COMMON

@c EN
If @code{gosh} is invoked without @var{scheme-file}, but the input
is not a terminal, it enters read-eval-print loop but not writes
out a prompt while waiting input form.  This is useful when you
pipe Scheme program into @code{gosh}.  You can force this behavior
or suppress this behavior by @code{-b} and @code{-i} options.
@c JP
もし@var{scheme-file}が与えられておらず、しかし入力が端末でない場合、
@code{gosh}はread-eval-printループに入りますが、入力待ちの際にプロンプトを
表示しません。これはScheme式をパイプで@var{gosh}に処理させる場合に便利です。
@code{-b}または@code{-i}オプションでこの動作を強制的にonまたはoffできます。
@c COMMON

@c EN
If @var{scheme-file} is specified, @code{gosh} runs it as a
Scheme program and exit.
@xref{Writing Scheme scripts}, for details.
@c JP
@var{scheme-file}が与えられた場合、@code{gosh}はそれをSchemeプログラムとして
ロードし、終了します。この動作に関しては@ref{Writing Scheme scripts}を参照して
下さい。
@c COMMON
@end deftp

@c EN
The following command line options are recognized by @code{gosh}.
The first command line argument which doesn't begin with `@minus{}'
is recognized as the script file.  If you want to specify a file
that begins with a minus sign, use a dummy option `@code{--}'.
@c JP
以下のコマンドラインオプションが@code{gosh}に認識されます。
`@minus{}' で始まらない最初のコマンドライン引数がスクリプトファイルと認識されます。
スクリプトファイル名が `@minus{}' で始まっている可能性がある場合は、ダミーオプション
`@code{--}' をスクリプトファイル名の前に置いて下さい。
@c COMMON

@deftp {Command Option} -I path
@c EN
Prepends @var{path} to the load path list.
You can specify this option more than once to add multiple paths.
@c JP
@var{path}をロードパスのリストに加えます。このオプションは複数指定できます。
@c COMMON
@end deftp

@deftp {Command Option} -q
@c EN
Makes @code{gosh} not to load the default initialization file.
@c JP
@code{gosh}が起動時にシステムの初期化ファイルを読まないようにします。
@c COMMON
@end deftp

@deftp {Command Option} -V
@c EN
Prints the @code{gosh} version and exits.
@c JP
@code{gosh}のバージョンを表示して終了します。
@c COMMON
@end deftp

@deftp {Command Option} -u module
@c EN
Use @var{module}.  Before starting execution of @var{scheme-file} or entering
the read-eval-print loop, the specified module is @var{use}d, i.e.
it is loaded and imported (@xref{Module syntax}, for details of @code{use}).
You can specify this option more than once to use multiple modules.
@c JP
起動後、インタラクティブなread-eval-printループに入る前、もしくは@var{scheme-file}
をロードする前に@var{module}を``use''します。つまりそのモジュールがロードされ
インポートされます。(@code{use}の詳細については@ref{Module syntax}を参照して下さい)。
このオプションは複数回指定できます。
@c COMMON
@end deftp

@deftp {Command Option} -l file
@c EN
Load @var{file} before starting execution of @var{scheme-file} or entering
the read-eval-print loop.   The file is loaded in the same way as
@code{load} (@xref{Loading Scheme file}).
You can specify this option more than once to load multiple files.
@c JP
起動後、インタラクティブなread-eval-printループに入る前、もしくは@var{scheme-file}
をロードする前に@var{file}をロードします(ロードの詳細については@ref{Loading Scheme file}
を参照して下さい)。このオプションは複数回指定できます。
@c COMMON
@end deftp

@deftp {Command Option} -e scheme-expression
@c EN
Evaluate @var{scheme-expression}
before starting execution of @var{scheme-file} or entering
the read-eval-print loop.   Evaluation is done in the
@var{interaction-environment} (@xref{Eval}).
You can specify this option more than once to load multiple files.
@c JP
起動後、インタラクティブなread-eval-printループに入る前、もしくは@var{scheme-file}
をロードする前に@var{scheme-expression}を評価します。評価は
@var{interaction-environment}中で行われます(@ref{Eval}参照)。
このオプションは複数回指定できます。
@c COMMON
@end deftp

@deftp {Command Option} -b
@c EN
Batch. Does not print prompts in read-eval-print loop even if
the input is a terminal.
@c JP
バッチ。入力が端末であっても、read-eval-printループがプロンプトを出さないようにします。
@c COMMON
@end deftp

@deftp {Command Option} -i
@c EN
Interactive. Print prompts in read-eval-print loop even if
the input is not a terminal.
@c JP
インタラクティブ。入力が端末で無くても、read-eval-printループが
プロンプトを出すようにします。
@c COMMON
@end deftp

@deftp {Command Option} -f compiler-option
@c EN
This option controls the compiler behavior.  For now we have
following options available:
@table @asis
@item no-inline
Prohibits the compiler from inilining primitive Scheme procedures.
@item no-source-info
Don't keep source information for debugging.  Consumes less memory.
@item load-verbose
Reports whenever a file is loaded.
@item case-fold
Ignore case for symbols as specified in R5RS.
(It is distinguished by default).  @xref{Case-sensitivity}.
@end table
@c JP
このオプションはコンパイラの動作に影響を与えます、今のところ、次のオプションのみが
@var{compiler-option}として有効です。
@table @asis
@item no-inline
Schemeの基本関数のインライン展開を行いません。
@item no-source-info
デバッグのためのソースファイル情報を保持しません。メモリの使用量は小さくなります。
@item load-verbose
ファイルがロードされる時にそれを報告します。
@item case-fold
R5RSに示される通り、シンボルの大文字小文字を区別しません。
(デフォルトではこれらは区別されます)。 @ref{Case-sensitivity} を参照して下さい。
@end table
@c COMMON
@end deftp

@deftp {Command Option} @code{--}
@c EN
When @code{gosh} sees this option, it stops processing the options
and takes next command line argument as a script file.  It is useful
in case if you have a script file that begins with a minus sign,
although it is not generally recommended.
@c JP
このオプションに出会うと、@code{gosh}はオプションの解析を止めて、その次の引数を
無条件に@var{scheme-file}であると見倣します。@var{scheme-file}がマイナス記号で
始まっている場合に必要です。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node Interactive development, Debugging, Invoking Gosh, Programming in Gauche
@section Interactive development
@c NODE  インタラクティブな開発

@c EN
When @code{gosh} is invoked without any script files,
it goes into interactive read-eval-print loop.
@c JP
スクリプトファイルが与えられなかった場合、
@code{gosh}はインタラクティブなread-eval-printループに入ります。
@c COMMON

@c EN
To exit the interpreter, type EOF (usually Control-D in Unix termials)
or evaluate @code{(exit)}.
@c JP
インタプリタを終了するには、EOF文字(Unix端末では通常Control-D)をタイプするか、
@code{(exit)}を評価します。
@c COMMON

@c EN
I recommend you to run @code{gosh} inside Emacs, for it has
rich features useful to interact with internal Scheme process.
Put the following line to your @file{.emacs} file:
@example
(setq scheme-program-name "gosh")
@end example
And you can run @code{gosh} by @key{M-x run-scheme}.
@c JP
@code{gosh}をEmacs内部で走らせることをお勧めします。
EmacsはSchemeサブプロセスを操作するための豊富な機能を持っています。
次の行を@file{.emacs}に加えておくと、@key{M-x run-scheme} で
Emacsのバッファ内で@code{gosh}が走ります。
@example
(setq scheme-program-name "gosh")
@end example
@c COMMON

@c EN
If you want to use multibyte characters in the interaction,
make sure your terminal's settings is in sync with @code{gosh}'s
internal character encodings.
@c JP
対話環境でマルチバイト文字を使う場合は、端末の文字エンコーディングを@code{gosh}の
内部エンコーディングと合わせるようにして下さい。
@c COMMON

@c EN
Currently @code{gosh} has no fancy features such as
line-editing or command history.   They'll be added in future.
@c JP
今のところ、@code{gosh}は行編集やコマンドヒストリなどの便利な機能を
備えていません。将来はこのへんも充実してゆくでしょう。
@c COMMON

@c EN
@xref{Interactive session}, for some procedures useful in
interactive session.
@c JP
インタラクティブセッションで便利な手続きが@ref{Interactive session}で定義されています。
@c COMMON

@c ----------------------------------------------------------------------
@node Debugging, Writing Scheme scripts, Interactive development, Programming in Gauche
@section Debugging
@c NODE デバッグ




@c ----------------------------------------------------------------------
@node Writing Scheme scripts, Writing Gauche modules, Debugging, Programming in Gauche
@section Writing Scheme scripts
@c NODE Schemeスクリプトを書く

@c EN
When a Scheme program file is given to @code{gosh}, it
bounds a global varialbe @code{*argv*} to the list of the remaining
command-line arguments, then loads the Scheme program.
If the first line of @var{scheme-file} begins with two character
sequence ``@code{#!}'', the entire line is ignored by @code{gosh}.
This is useful to write a Scheme program that works as an executable
script in unix-like systems.
@c JP
@code{gosh}のコマンドラインにSchemeプログラムのファイル名が渡された場合、
@code{gosh}はそれ以降のコマンドライン引数のリストをグローバル変数@code{*argv*}に束縛し、
Schemeプログラムをロードします。もし@var{scheme-file}の最初の行が``@code{#!}''で始まって
いたら、その行は無視されます。これにより、Unix系のシステムで実行可能なSchemeスクリプト
を書くことが出来ます。
@c COMMON

@c EN
Typical Gauche script has the first
line like these
@example
#!/usr/local/bin/gosh
  @r{or,}
#!/usr/bin/env gosh
  @r{or,}
#!/bin/sh
:; exec gosh -- $0 "$@@"
@end example
The second and third form uses a ``shell trampoline'' technique
so that the script works as far as @code{gosh} is in the PATH.
The third form is useful when you want to pass extra arguments
to @code{gosh}, for typically @code{#!}-magic of executable scripts
has limitations for the number of arguments to pass the interpreter.
@c JP
典型的なGaucheスクリプトの最初の行は次のようなものです。
@example
#!/usr/local/bin/gosh
  @r{または,}
#!/usr/bin/env gosh
  @r{または,}
#!/bin/sh
:; exec gosh -- $0 "$@@"
@end example
後の2つは「シェルトランポリン」テクニックを用いて、@code{gosh}がPATHにあるディレクトリの
どこかにあれば起動できるようにしています。3番目の方法は、
@code{gosh}にいくつかコマンドラインオプションを渡したい時に便利です。
@c COMMON

@c EN
After the file is successfully loaded, @code{gosh} calls a
procedure named `@code{main}' if it is defined in the user module.
@code{Main} receives a single argument, a list of command line
arguments.  Its first element is the script name itself.

When @code{main} returns, and its value is an integer, @code{gosh}
uses it for exit code of the program.
Otherwise, @code{gosh} exits with exit code 70 (@code{EX_SOFTWARE}).
This behavior is compatible with the SRFI-22.

(@emph{Note: this interface has been changed from Gauche release 0.5
in incompatible way.   @xref{Script compatibility before release 0.5},
for details.})

If the @code{main} procedure is not defined, @code{gosh} exits
after loading the script file.
@c JP
ファイルが正常にロードされたら、@code{gosh}は
userモジュールに `@code{main}' という手続きが定義されているかどうか調べ、
定義されていればそれを呼びます。@code{main}には、スクリプトへの引数のリストが
唯一の引数として渡されます。リストの最初の要素はスクリプトファイル名です。

@code{main}が整数の値を返したら、@code{gosh}はその値を終了ステータスとして終了します。
@code{main}が整数以外の値を返した場合は@code{gosh}は終了ステータス70
(@code{EX_SOFTWARE})で終了します。このふるまいはSRFI-22と互換です。

(@emph{注：このインタフェースはGauche release 0.5から非互換な形で
変更されました。@ref{Script compatibility before release 0.5}を参照して下さい。})

@code{main}が定義されていなければ@code{gosh}はロード後にそのままステータス0で
終了します。
@c COMMON

@c EN
Although you can still write the program
main body as toplevel expressions, like shell scripts or Perl scripts,
it is much convenient to use this `@code{main}' convention, for
you can load the script file interactively to debug.
@c JP
シェルスクリプトやPerlスクリプトと同じように、スクリプトのボディに直接
実行される式を書くこともできますが、なるべく `@code{main}' を使った方法を
使うことをお薦めします。そうすると、スクリプトをインタプリタにインタラクティブに
ロードしてデバッグすることもできます。
@c COMMON


@defvar *argv*
@c EN
The program arguments passed to the Scheme script is bound to this
variable.  If @code{gosh} is invoked in an interactive mode, this
variable always contains @code{()}.

STk uses this variable to pass the command line argument as well,
but other Scheme implementations use different ways.  It is better
to define @code{main} procedure and uses its argument to receive
command line arguments, for it is expected to be more portable.
@c JP
Schemeスクリプト以降のコマンドライン引数のリストは、スクリプトのロードの前に
この変数に束縛されます。@code{gosh}がインタラクティブモードで起動された場合は
この変数は@code{()}となります。

この変数はSTkと互換性がありますが、他のScheme実装は違った方法を使ってコマンドライン
引数を得ます。ポータブルなスクリプトを書くには、@code{main}手続きを使う方法を
お薦めします。
@c COMMON
@end defvar

@defvar *program-name*
@c EN
This variable is bound to the script file name passed to @code{gosh}.
If @code{gosh} is invoked in the interactive mode, this variable
contains the pathname of @code{gosh} itself.

STk uses the same variable to access the program/script name.
Other Scheme implementations use different ways.
@c JP
この変数はスクリプトファイル名に束縛されます。インタラクティブモードでは
この変数は@code{gosh}自身の名前を持っています。

この変数はSTkと互換性がありますが、他の実装は違った方法を使います。
@c COMMON
@end defvar

@c EN
Now I show several simple examples below.
First, this script works like @code{cat(1)}, without any command-line
option processing and error handling.
@c JP
いくつか簡単な例を示します。最初の例はUnixの@code{cat(1)}コマンドを模するものです。
エラー処理やコマンドラインオプションの処理は行っていません。
@c COMMON

@example
@cartouche
#!/usr/bin/env gosh

(define (main args)   ;@r{entry point}
  (if (null? (cdr args))
      (copy-port (current-input-port) (current-output-port))
      (for-each (lambda (file)
                  (call-with-input-file file
                    (lambda (in)
                      (copy-port in (current-output-port)))))
                (cdr args)))
  0)
@end cartouche
@end example

@c EN
The following script is a simple grep command.
@c JP
次のスクリプトは簡単なgrepコマンドです。
@c COMMON

@example
@cartouche
#!/usr/bin/env gosh

(define (usage)
  (format (current-error-port)
          "Usage: ~a regexp file ...\n" *program-name*)
  (exit 2))

(define (grep rx port)
  (with-input-from-port port
    (lambda ()
      (port-for-each
       (lambda (line)
         (when (rxmatch rx line)
           (format #t "~a:~a: ~a\n"
                   (port-name port)
                   (- (port-current-line port) 1)
                   line)))
       read-line))))

(define (main args)
  (if (null? (cdr args))
      (usage)
      (let ((rx (string->regexp (cadr args))))
        (if (null? (cddr args))
            (grep rx (current-input-port))
            (for-each (lambda (f)
                        (call-with-input-file f
                          (lambda (p) (grep rx p))))
                      (cddr args)))))
  0)
@end cartouche
@end example

@c EN
See also @ref{Parsing command-line options}, for a convenient way to
parse command-line options.
@c JP
コマンドライン引数を処理するモジュールがあります。
@ref{Parsing command-line options}を参照してください。
@c COMMON

@menu
* Script compatibility before release 0.5::  
@end menu

@node Script compatibility before release 0.5,  , Writing Scheme scripts, Writing Scheme scripts
@subsection Script compatibility before release 0.5
@c NODE リリース0.5以前とのスクリプトの互換性

@c EN
In order to conform final SRFI-22,
Gauche release 0.5.1 changes the way @code{main} is called.
Unfortunately, this makes the Scheme scripts that is written for older
Gauche no longer work.
I decided to take this change now, in the early stage of Gauche,
rather than keeping incomatibility to the standard (srfi).
@c JP
SRFI-22に準拠するために、Gaucheはリリース0.5.1から@code{main}の呼ばれ方を
変更しました。残念ながら、この変更によりそれ以前のGaucheのために書かれたスクリプトは
動作しなくなります。
標準(srfi)との非互換性を後々まで引きずるよりは、まだ開発の早い段階の今の時点で
変更をしておいたほうが良いと判断しました。
@c COMMON

@c EN
The incompatible changes are these two points.
@c JP
非互換な変更は以下の2点です。
@c COMMON
@itemize @bullet
@item
@c EN
The argument list passed to @code{main} now includes the script
name itself as the first element.  In older version, only the
arguments after the script file name are passed.
@c JP
@code{main}に渡されるコマンドライン引数リストは、その第一要素にスクリプトファイル名を
持つようになります。古いバージョンではスクリプトファイル名以降のコマンドライン引数だけが
渡されていました。
@c COMMON
@item
@c EN
When @code{main} returns non-integral value, @code{gosh} exits
with code 70.  In older version, @code{gosh} exits with code 0
in such case.
@c JP
@code{main}が整数でない値を返した場合、@code{gosh}は終了ステータス70で終了します。
古いバージョンではこのような場合、終了ステータス0で終了していました。
@c COMMON
@end itemize

@c EN
To help transition, @code{gosh} keeps the previous behavior if
either (a) command line argument @code{-fcompat-0.5} is given,
or (b) an environment variable @code{GAUCHE_COMPAT_0_5} is defined.
You can run the Scheme scripts written for previous Gauche
unchanged using either of these methods.
@c JP
移行を助けるため、@code{gosh}は (a)コマンドライン引数@code{-fcompat-0.5}が与えられるか
(b)環境変数@code{GAUCHE_COMPAT_0_5} が定義されていた場合は
以前のバージョンと同じ振舞いをします。このいずれかの手段を用いることにより、
以前のGaucheのために書かれたスクリプトを走らせることができます。
@c COMMON

@c EN
This backward compatibility feature is a temporary solution,
and will be removed after a few releases.
I encourage you to move to the new interface by then.
@c JP
この後方互換機能は一時的な解決で、いくつかリリースを重ねた時点で
取り除かれる予定です。なるべくそれまでに新しいインタフェースに
移行して下さい。
@c COMMON

@c EN
To write a script that works both 0.5.1 and the previous version,
you can use some hack like this:
@c JP
0.5.1とそれ以前のGaucheと両方で動作するスクリプトを書くには、
次のようなハックが必要になります。
@c COMMON
@example
(define (main args)
  (let ((pure-args (if (string=? (gauche-version) "0.5.1")
                       (cdr args)
                       args)))
    @dots{}
   ))
@end example

@c EN
(@code{Cond-expand} form is the mechanism supposed to be used in
this kind of situation.  Unfortunately, the implementation of
@code{cond-expand} in the previous versions of Gauche was broken
and didn't work.)
@c JP
(@code{Cond-expand} フォームが、本来このような状況で使われるべき
ものなのですが、以前のGaucheでは@code{cond-expand}の実装が壊れて
いたため使えません。)
@c COMMON

@c ----------------------------------------------------------------------
@node Writing Gauche modules,  , Writing Scheme scripts, Programming in Gauche
@section Writing Gauche modules
@c NODE Gaucheのモジュールを書く

@c EN
Gauche's libraries are organized by modules.   Although Gauche
can load any valid Scheme programs, there is a convention that
Gauche library follows.    When you write a chunk of Scheme
code for Gauche, it is convenient to make it a module,
so that it can be shared and/or reused.
@c JP
Gaucheのライブラリはモジュール毎に整理されています。Gaucheはどんな形式でも、
有効なScheme式が書かれてさえいればロードすることができますが、
Gaucheのライブラリは一定の形式を保って書かれています。
Gauche用にまとまったSchemeコードを書いたら、それをモジュール形式にしておくと
再利用がしやすくなるでしょう。
@c COMMON

@c EN
Usually a module is contained in a file, but you can make
a multi-file module.   
First I explain the structure of a single-file module.
The following template is the convention used in Gauche's libraries.
@c JP
通常ひとつのファイルで
ひとつのモジュールを定義しますが、モジュールを複数のファイルに分けることもできます。
まずひとつのファイルでモジュールを定義する方法を説明します。
Gaucheのライブラリで使われているテンプレートは次のような形式です。
@c COMMON

@example
@c EN
;; Define the module interface
@c JP
;; モジュールのインタフェースの定義
@c COMMON
(define-module foo
  (use xxx)
  (use yyy)
  (export foo1 foo2 foo3)
  )
@c EN
;; Enter the module
@c JP
;; モジュール本体
@c COMMON
(select-module foo)

@dots{} module body @dots{}

@c EN
;; Make `require' happy
@c JP
;; `require' に対応するprovide
@c COMMON
(provide "foo")
@end example

@c EN
This file must be saved as ``foo.scm'' in some directory in the
@code{*load-path*}.
@c JP
このファイルは``foo.scm''という名で、@code{*load-path*}にあるディレクトリの
いずれかに置かれなければなりません。
@c COMMON

@c EN
The @code{define-module} form creates a module @code{foo}.
It also loads and imports some other modules by `@code{use}' macros,
and declares which symbols the @code{foo} module exports, by `@code{export}'
syntax.
(See section @ref{Module syntax}, for detailed specification of those
syntaxes).
@c JP
まず、@code{define-module}フォームがモジュール@code{foo}を作成します。
@code{define-module}フォーム内で、このモジュールが依存している他のモジュール
を `@code{use}' マクロを使ってロードし、このモジュールがエクスポートするシンボルを
`@code{export}' 構文を使って指定します。(これらの構文の詳細は@ref{Module syntax}を
参照して下さい)。
@c COMMON

@c EN
Those @code{use} forms or @code{export} forms are not required to appeare
in the @code{define-module} form, but it is a good convention to keep
them in there at the head of the file so that it is visually recognizable
which modules @code{foo} depends and which symbols it exports.
@c JP
これらの@code{use}フォームや@code{export}フォームは必ずしも@code{define-module}
フォームの先頭に置く必要はありませんが、このようにファイルの最初の方に固めておくことで、
@code{foo}が依存しているモジュール群や@code{foo}が提供するシンボル等が
一覧しやすくなります。
@c COMMON

@c EN
The second form, `@code{select-module}', 
specifies the rest of the file is evaluated in the
module @code{foo} you just defined.   Again, this is just a
convention; you can write entire module body inside @code{define-module}.
However, I think it is error-prone, for the closing parenthesis
can be easily forgotten or the automatic indentation mechanism of
editor will be confused.
@c JP
次の、`@code{select-module}' フォームにより、それ以降のScheme式が
モジュール@code{foo}の中で評価されます。モジュールの内容を全て@code{define-module}の中に
書いてしまうことも出来ますが、最後の括弧を閉じ忘れやすいことや、エディタのインデントが
狂うことなどから、あまりお薦めしません。
@c COMMON

@c EN
After @code{select-module} you can write whatever Scheme expression.
It is evaluated in the selected module, @code{foo}.   Only the bindings
of the exported symbols will be directly accessible from outside.
@c JP
@code{select-module}フォームの後には、モジュールの内容であるScheme式を自由に書けます。
それらはモジュール@code{foo}の中で評価されます。モジュール内で定義するトップレベルの
束縛のうち、明示的に`export'で指定されたシンボルのみが、このモジュールをインポートする他の
モジュールから見えます。
@c COMMON

@c EN
The last @code{provide} form is just a cliche.  It is needed since
the `use' mechanism uses traditional require-provide mechanism (if you
don't know about it, it's ok--just put it as a magic spell).
@c JP
最後の@code{provide}は一種の定型句です。`use'がrequire-provideメカニズムを
利用しているために必要です。
@c COMMON

@c EN
So, that's it.   Other programs can use your module by just saying
`@code{(use foo)}'.   If you want to make your module available on your site,
you can put it to the site library location, which can be obtained by
@example
(gauche-site-library-directory)
@end example
in gosh, or
@example
gauche-config --sitelibdir
@end example
from shell.
@c JP
これで、他のプログラムは `@code{(use foo)}' とするだけでこのモジュールの機能が
利用可能になります。もしモジュールをサイト全体で利用できるようにしたければ、@code{gosh}内で
@example
(gauche-site-library-directory)
@end example
を評価して得られるディレクトリに@code{foo.scm}を置いて下さい。
@c COMMON

@c EN
If you feel like to conserve global module name space, you can organize
modules hierarchically.   Some Gauche libraries already does so.
@xref{Library modules}, for examples.
For example, @code{text.tr} module is implemented in ``text/tr.scm'' file.
Note that the pathname separator `/' in the file becomes a period in the
module name.
@c JP
モジュールの名前空間のトップに新たなモジュールを追加するのに気が引ける場合は、
モジュールを階層的に構成することもできます。Gaucheのモジュールの多くは既に階層的に
構成されています。具体的なモジュール例は@ref{Library modules}を参照して下さい。
例えば、@code{text.tr}モジュールは ``@code{text/tr.scm}'' ファイルに
実装されています。パス名の区切り文字`/'がモジュール名ではピリオドになることに
注意して下さい。
@c COMMON

@c EN
@c JP
@c COMMON

@c ======================================================================
@node Core syntax, Macros, Programming in Gauche, Top
@chapter Core syntax
@c NODE 基本的な構文

@c ----------------------------------------------------------------------
@menu
* Literals::                    
* Making Procedures::           
* Assignments::                 
* Conditionals::                
* Binding constructs::          
* Sequencing::                  
* Iteration::                   
* Quasiquotation::              
* Definitions::                 
* Modules::                     
@end menu

@node Literals, Making Procedures, Core syntax, Core syntax
@section Literals
@c NODE リテラル

@defspec quote datum
[R5RS]
@c EN
Evaluates to @var{datum}.
@c JP
@var{datum}それ自身を返します。
@c COMMON
@example
(quote x) @result{} x
(quote (1 2 3)) @result{} (1 2 3)
@end example
@end defspec

@deftp {Reader Syntax} @code{'@var{datum}}
[R5RS]
@c EN
Equivalent to @code{(quote datum)}.
@c JP
@code{(quote datum)}の略記です。
@c COMMON
@example
'x @result{} x
'(1 2 3) @result{} (1 2 3)
@end example
@end deftp

@c EN
@emph{Note:}  R5RS says it is an error to alter the value of
a literal expression.
Gauche doesn't check constant-ness of pairs and vectors, so you can
alter them using the destructive procedures such as @code{set-car!}
and @code{vector-set!}.  Doing so will cause unexpected results.
Gauche does check constant-ness of strings, and signals an error
if you try to alter a constant string.
@c JP
@emph{注:} R5RSは、リテラル式の値を変更するのはエラーであるとしています。
しかしGaucheはペアとベクタについてはそれが定数であるかどうかをチェックしておらず、
@code{set-car!}や@code{vector-set!}等の破壊的手続きによってそれらの値を
変更できてしまいます。そうした場合の動作は不定です。
文字列に関しては定数かどうかのチェックを行っており、定数文字列を変更しようとすると
エラーが報告されます。
@c COMMON

@c ----------------------------------------------------------------------
@node Making Procedures, Assignments, Literals, Core syntax
@section Making Procedures
@c NODE  手続きを作る

@defspec lambda formals body @dots{}
[R5RS]
@c EN
Evaluates to a procedure.  The environment in effect when this expression
is evaluated is stored in the procedure.   When the procedure
is called, @var{body} is evaluated sequentially in the
stored environment extended by the bindings of the formal arguments,
and returns the value(s) of the last expression in the body.
@c JP
この式は評価されると手続きを生成します。この式が評価された時点の環境が手続き中に保持されます。
手続きが呼ばれると、記憶された環境に引数の束縛を追加した環境中で@var{body} が順に評価され、
最後の式の値が返されます。
@c COMMON

@c EN
@var{Formals} should have one of the following forms:
@itemize @bullet
@item
@code{(@var{variable} @dots{})} : The procedure takes a fixed number of
arguments.  The actual arguments are bound to the corresponding
variables.
@item
@code{@var{variable}} : The procedure takes any number of argumnets.
The actual arguments are collected to form a new list and bound to
the variable.
@item
@code{(@var{variable_0} @dots{} @var{variable_N-1}. @var{variable_N})} : 
The procedure takes at least @var{N} arguments.  The actual arguments
up to @var{N} is bound to the corresponding varibles.
If more than @var{N} arguments are given, the rest arguments are
collected to form a new list and bound to @var{variable_N}.
@end itemize
@c JP
@var{Formals} は以下のいずれかの形でなければなりません。
@itemize @bullet
@item
@code{(@var{variable} @dots{})} : 手続きは決まった数の引数を取ります。
実引数がそれぞれ対応する@var{variable}に束縛されます。
@item
@code{@var{variable}} : 手続きは不定個の引数を取ります。
実引数は新しいリストに集められて、そのリストが@var{varible}に束縛されます。
@item
@code{(@var{variable_0} @dots{} @var{variable_N-1}. @var{variable_N})} :
手続きは少なくとも@var{N}個の引数を取ります。@var{N}個までの実引数は対応する@var{variable}
に束縛されます。@var{N}個を越えた実引数は新しいリストに集められて
@var{variable_N}に束縛されます。
@end itemize
@c COMMON

@example
(lambda (a b) (+ a b))
@c EN
  @result{} @r{procedure that adds two arguments}
@c JP
  @result{} @r{二つの引数を加算する手続き}
@c COMMON

((lambda (a b) (+ a b)) 1 2)
  @result{} 3
@end example
@end defspec

@c EN
@emph{Note:} Some Scheme implementations extend the syntax of @var{formals}
to have notation of optional arguments or keyword arguments, similar to
CommonLisp's.  Gauche doesn't have such extensions now.
@c JP
@emph{注:} いくつかのSchemeの実装では@var{formals}の構文を拡張して、
CommonLispのように省略可能引数やキーワード引数などの表記を可能にしているものが
あります。Gaucheには今のところそのような拡張はありません。
@c COMMON

@c ----------------------------------------------------------------------
@node Assignments, Conditionals, Making Procedures, Core syntax
@section Assignments
@c NODE  代入

@defspec set! symbol expression
@defspecx set! (proc arg @dots{}) expression
[R5RS][SRFI-17]
@c EN
First, @var{expression} is evaluated.
In the first form, the binding of @var{symbol} is modified
so that next reference of @var{symbol} will return
the result of @var{expression}.
If @var{symbol} is not locally bound, the global variable named @var{symbol}
must already exist, or an error is signalled.
@c JP
まず@var{expression}が評価されます。最初の形式では、@var{symbol}への束縛が
@var{expression}の結果を指すように変更されます。
もし@var{symbol}がローカルに束縛されていない場合は、グローバルな変数@var{symbol}が
存在していなければなりません。そうでなければエラーが報告されます。
@c COMMON

@c EN
The second form is a ``generalized set!'' specified in SRFI-17.
It is a syntactic sugar of the following form.
@example
((setter @var{proc}) @var{arg} @dots{} @var{expression})
@end example
Note the order of the arguments of the setter method
differs from CommonLisp's @code{setf}.

Some examples:
@c JP
2番目の形式はSRFI-17に定義されている「一般化されたset!」です。
これは構文的な装飾であり、実際は以下のように解釈されます。
@example
((setter @var{proc}) @var{arg} @dots{} @var{expression})
@end example
CommonLispの@code{setf}とは、setter手続きに渡される引数の順序が異なることに注意して下さい。

例：
@c COMMON

@example
(define x 3)
(set! x (list 1 2))  @result{} @r{undefined}
x                    @result{} (1 2)

(set! (car x) 5)     @result{} @r{undefined}
x                    @result{} (5 2)
@end example
@end defspec

@defun setter proc
[SRFI-17]
@c EN
Returns a setter procedure associated to the procedure @var{proc}.
If no setter is associated to @var{proc}, an error is signalled.

A setter procedure @var{g} of a procedure @var{f} is such that when used
as @code{(g a b @dots{} v)}, the next evaluation of @code{(f a b @dots{})}
returns @var{v}.

To associate a setter procedure to another procedure, you can use
the setter of @code{setter}, like this:
@example
(set! (setter @var{f}) @var{g})
@end example

A procedure's setter can be ``locked'' to it.  System default setters,
like @code{set-car!} for @code{car}, is locked and can't be set by
the above way.   In order to lock a setter to a user defined procedure,
use @code{getter-with-setter} below.
@c JP
手続き@var{proc}のsetter手続きを返します。もし@var{proc}がsetter手続きを持たなければ、
エラーが返されます。

ある関数@var{f}のsetter手続き@var{g}とは、もし@code{(g a b @dots{} v)}のように
呼ばれた場合、次の@code{(f a b @dots{})}が@var{v}を返すようになる手続きのことです。

ある手続きにsetter手続きを関連付けるには、@code{setter}自身のsetter手続きを使うことが
できます。
@example
(set! (setter @var{f}) @var{g})
@end example

特定の手続きにsetter手続きを「ロック」することができます。システム既定のsetter手続き、
例えば@code{car}に対する@code{set-car!}等はロックされていて、上記のような方法で
変更することは出来ません。ユーザ定義手続きにsetter手続きをロックするには下記の
@code{getter-with-setter}を使います。
@c COMMON
@end defun

@defun getter-with-setter get set
[SRFI-17]
@c EN
Takes two procedure @var{get} and @var{set}.  Returns a new
procedure which does the same thing as @var{get}, and its setter is
locked to @var{set}.

The intention of this procedure is, according to the SRFI-17 document,
to allow implementations to inline setters efficiently.  Gauche
hasn't implement such optimization yet.
@c JP
2つの手続き、@var{get}と@var{set}を取り、新しい手続きを返します。
新しい手続きは@var{get}と同じ動作をし、そのsetter手続きは@var{set}にロックされて
います。

この手続きは、SRFI-17によれば、setter手続きのインライン展開を可能にするための
ものですが、Gaucheではまだそのような最適化は実装されていません。
@c COMMON
@end defun

@c EN
A few macros that adopts the same semantics of generalized @code{set!}
are also provided.  They are built on top of @code{set!}.
@c JP
Gaucheでは、一般化された@code{set!}と同じセマンティクスを持ついくつかのマクロが定義
されています。これらは@var{set!}を使った形に展開されます。
@c COMMON

@defmac push! place item
@c EN
Conses @var{item}
and the value of @var{place}, then sets the result to @var{place}.
@var{place} is either a variable or a form @var{(proc arg @dots{})}, 
as the second argument of @code{set!}.   The result of this form
is undefined.
@c JP
@var{item}と@var{place}の値をコンスし、その結果を再び@var{place}にセットします。
@var{place}は@code{set!}と同様に、
変数か@var{(proc arg @dots{})}という形式でなければなりません。このマクロの戻り値は
未定義です。
@c COMMON

@example
(define x (list 2))
(push! x 3) @result{} @r{undefined}
x @result{} (3 2)

(push! (cdr x) 4) @result{} @r{undefined}
x @result{} (3 4 2)
@end example

@c EN
When @var{place} is a list, it roughly expands like the following.
@c JP
@var{place}がリストの場合、だいたいこんなふうに展開されます。
@c COMMON

@example
(push! (foo x y) item)
 @equiv{}
 (let ((tfoo foo)
       (tx x)
       (ty y))
   ((setter tfoo) tx ty (cons item (tfoo tx ty))))
@end example

@c EN
Note: Common Lisp's @code{push} macro takes its argument reverse
order.   I adopted this order since it is consistent with other
destructive operations.  Perl's @code{push} function takes the same
argument order, but it appends @var{item} at the end of the array
(Perl's @code{unshift} is closer to @code{push!}).
You can use a queue (@xref{Queue}) if you need a behavior of Perl's
@code{push}.
@c JP
註：Common Lispの@code{push}マクロは引数を逆の順番で取ります。
@code{push!}は他の副作用を持つ形式との互換性を考えてこの順番としました。
Perlの@code{push}関数は@code{push!}マクロと同じ引数順ですが、
@var{item}はシーケンスの末尾に追加されます (Perlの@code{unshift}の方が
@code{push!}の動作に近いです)。
Perlのpushオペレータの動作が必要ならQueueが使えます (@ref{Queue}参照)。
@c COMMON
@end defmac

@defmac pop! place
@c EN
Retrieves the value of @var{place}, sets its cdr back to @var{place}
and returns its car.
@c JP
@var{place}の値を取り出し、その@code{cdr}を@var{place}にセットします。
元の値の@code{car}を返します。
@c COMMON

@example
(define x (list 1 2 3))
(pop! x) @result{} 1
x @result{} (2 3)

(define x (vector (list 1 2 3)))
x @result{} #((1 2 3))
(pop! (vector-ref x 0)) @result{} 1
x @result{} #((2 3))
@end example

@c EN
Note: This works the same as Common Lisp's @code{pop}.
Perl's @code{pop} pops value from the end of the sequence;
its @code{shift} does the same thing as @code{pop!}.
@c JP
註：この動作はCommon Lispの@code{pop}と同じです。
Perlの@code{pop}はシーケンスの末尾から値を取ります。
Perlなら@code{shift}が@code{pop!}の動作に近いです。
@c COMMON
@end defmac


@defmac inc! place &optional delta
@defmacx dec! place &optional delta
@c EN
Evaluates the value of @var{place}.  It should be a number.
Adds (@code{inc!}) or subtracts (@code{dec!}) @var{delta} to/from it,
and then stores the result to @var{place}.  The default value of
@var{delta} is 1.

This is Common Lisp's @code{incf} and @code{decf}.
@c JP
@var{place}の値を評価します。それは数値にならなければなりません。
その値に@var{delta}が加算(@code{inc!})もしくは減算(@code{dec!})され、
結果が@var{place}に格納されます。@var{delta}の既定値は1です。

Common Lispの@code{incf}と@code{decf}に当たります。
@c COMMON
@end defmac

@c ----------------------------------------------------------------------
@node Conditionals, Binding constructs, Assignments, Core syntax
@section Conditionals
@c NODE 条件式

@defspec if test consequent alternative
@defspecx if test consequent
[R5RS]
@c EN
@var{Test} is evaluated.  If it yields a true value,
@var{consequent} is evaluated.  Otherwise, @var{alternative} is
evaluated.  If @var{alternative} is not provided, it results undefined value.
@c JP
まず@code{test}を評価し、それが真の値を返したら@var{consequent}を評価します。
そうでなければ@var{alternative}を評価します。もし@var{alternative}が与えられて
いなければ未定義の値を返します。
@c COMMON

@example
(if (number? 3) 'yes 'no) @result{} yes
(if (number? #f) 'yes 'no) @result{} no

(let ((x '(1 . 2)))
  (if (cons? x)
      (values (car x) (cdr x))
      (values #f #f)))
  @result{} 1 @r{and} 2
@end example
@end defspec

@defspec cond clause1 clause2 @dots{}
[R5RS]
@c EN
Each @code{clause} must be the form
@example
(@var{test} @var{expr} @dots{})
(@var{test} => @var{expr})
(else @var{expr} @var{expr2} @dots{})
@end example
The last form can appear only as the last clause.

@code{cond} evaluates @var{test} of each clauses in order, until
it yields a true value.   Once it yields true, if the clause
is the first form,  the corresponding @var{expr}s are evaluated
and the result(s) of last @var{expr} is(are) returned; if the clause
is the second form, the @var{expr} is evaluated and it must yield
a procedure that takes one argument.  Then the result of @var{test}
is passed to it, and the result(s) it returns will be returned.
If no test yields true, and the last clause is not the third form
(else clause), an undefined value is returned.

If the last clause is else clause and all tests are failed,
@var{expr}s in the else clause are evaluated, and its last
@var{expr}'s result(s) is(are) returned.
@c JP
各@code{clause}節は次のいずれかの形式でなければなりません。
@example
(@var{test} @var{expr} @dots{})
(@var{test} => @var{expr})
(else @var{expr} @var{expr2} @dots{})
@end example
最後の形式は最後の節のみに許されます。

最初の節から順に@var{test}が評価され、それが真の値を返すまで次の節の@var{test}が
評価されます。@var{test}が真の値を返したら、それが最初の形式であれば
その節の@var{expr}が順に評価され、最後の評価値が戻り値となります。
それが2番目の形式であれば、@var{expr}がまず評価されます。
@var{expr}は引数をひとつ取る手続きを返さねばなりません。
続いて、@var{test}の結果がその手続きに渡され、その手続きの戻り値が@code{cond}形式の
評価値となります。
もし全てのテストが偽の値を返し、最後の節が3番目の形式(else節)でなければ、未定義の値が返されます。

最後の節が@code{else}節で、他の全てのテストが失敗した場合、@code{else}節の@var{expr}
が順に評価され、その最後の値が@code{cond}形式の値となります。
@c COMMON

@example
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less)) @result{} greater
(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal)) @result{} equal
(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else #f)) @result{} 2
@end example
@end defspec


@defspec case key clause1 clause2 @dots{}
[R5RS]
@c EN
@var{Key} may be any expression. 
Each @var{clause} should have the form 
@example
((@var{datum} ...) @var{expr} @var{expr2} @dots{})
@end example
where each @var{datum} is an external representation of some object.
All the @var{datum}s must be distinct. The last @var{clause}
may be an ``else clause,'' which has the form 
@example
(else @var{expr} @var{expr2} @dots{})
@end example

First, @var{key} is evaluated and its result is compared against each
@var{datum}.  If the result of evaluating @var{datum} is equivalent
(using @code{eqv?}, @xref{Equivalence}), to a @var{datum},
then the expressions in the corresponding clause are evaluated
sequentially, and the result(s) of the last expression in the
@var{clause} is(are) returned from the case expression.
If the result of evaluating @var{key} is different from every @var{datum},
then if there is an else clause its expressions are evaluated and
the result(s) of the last is(are) the result(s) of the case expression;
otherwise the result of the case expression is unspecified.
@c JP
@var{key}は任意の式です。@var{clause}は以下の形式でなければなりません。
@example
((@var{datum} ...) @var{expr} @var{expr2} @dots{})
@end example
ここで、各@var{datum}はSchemeオブジェクトの外部表現であり、全ての@var{datum}は
異なっていなければなりません。最後の@var{clause}には次の形式を持つelse節が許されます。
@example
(else @var{expr} @var{expr2} @dots{})
@end example

まず@var{key}が評価され、その結果がそれぞれの@var{datum}と比較されます。
@var{key}の値と@code{eqv?}(@ref{Equivalence}参照)を使って一致する@var{datum}
が見つかれば、対応する@var{expr}が順に評価され、その最後の値が@code{case}の
値となります。もし一致する@var{datum}が見つからない場合、else節が与えられていれば
その@var{expr}が順に評価され、最後の値が返されます。else節がなければ@code{case}節
の値は未定義です。
@c COMMON
@example
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite)) @result{} composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b)) @result{} @r{undefined}
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant)) @result{} consonant
@end example
@end defspec


@defspec and test @dots{}
[R5RS] 
@c EN
The @var{test} expressions are evaluated from left to right,
and the value of the first expression that evaluates to a false
value is returned.
Any remaining expressions are not evaluated.
If all the expressions evaluate to true values,
the value of the last expression is returned.
If there are no expressions then @code{#t} is returned.
@c JP
@var{test}式が順に評価されます。最初に偽の値を返したところで評価が止まり、
偽の値が返されます。残りの式は評価されません。
もし全ての式が真の値を返した場合は、最後の式の値が返されます。
式が与えれない場合は@code{#t}が返されます。
@c COMMON

@example
(and (= 2 2) (> 2 1)) @result{} #t
(and (= 2 2) (< 2 1)) @result{} #f
(and 1 2 'c '(f g))   @result{} (f g)
(and)                 @result{} #t
@end example
@end defspec


@defspec or test @dots{}
[R5RS]
@c EN
The @var{test} expressions are evaluated from left to right,
and the value of the first expression that evaluates to a true
value is returned. Any remaining expressions are not evaluated.
If all expressions evaluate to false values, the value of the
last expression is returned. If there are no expressions then
@code{#f} is returned.
@c JP
@var{test}式が順に評価されます。最初に真の値を返したところで評価が止まり、
その値が返されます。残りの式は評価されません。
もし全ての式が偽の値を返した場合は、偽の値が返されます。
式が与えれない場合は@code{#f}が返されます。
@c COMMON

@example
(or (= 2 2) (> 2 1)) @result{} #t
(or (= 2 2) (< 2 1)) @result{} #t
(or #f #f #f)        @result{} #f
(or (memq 'b '(a b c)) 
    (/ 3 0)) @result{} (b c)
@end example
@end defspec

@defspec when test body @dots{}
@defspecx unless test body @dots{}
@c EN
Evaluates @var{test}.  If it yields true value (or false in case of
@code{unless}), @var{body} @dots{} are evaluated sequentially, and
the result(s) of the last evaluation is(are) returned.  Otherwise, undefined
value is returned.
@c JP
まず@var{test}が評価されます。それが真の値(@code{unless}の場合は偽の値)を返した場合、
引続き@var{body}が順に評価され、最後の@var{body}の評価値が返されます。
そうでなければ、未定義の値が返されます。
@c COMMON
@end defspec

@node Binding constructs, Sequencing, Conditionals, Core syntax
@section Binding constructs
@c NODE 変数束縛

@defspec let ((var expr) @dots{}) body @dots{}
@defspecx let* ((var expr) @dots{}) body @dots{}
@defspecx letrec ((var expr) @dots{}) body @dots{}
[R5RS]
@c EN
Creates a local scope where @var{var} @dots{} are bound to the
value of @var{expr} @dots{}, then evaluates @var{body} @dots{}.
@var{var}s must be symbols, and there shouldn't be a duplication.
The value(s) of the last expression of @var{body} @dots{} becomes
the value(s) of this form.
@c JP
各変数@var{var}が@var{expr}の値に束縛されてているローカルな環境を作成し、
その中で@var{body} @dots{}を評価します。@var{var}はシンボルでなければ
ならず、重複があってはなりません。@var{body} @dots{}の最後の式の値が
このフォームの値となります。
@c COMMON

@c EN
The three forms differ in terms of the scope @var{expr}s are evaluated.
@code{Let} evaluates @var{expr}s before (outside of) @code{let} form.
@code{Let*} evaluates @var{expr}s in the scope where @var{var}s before
it are bound.   @code{Letrec} evaluates @var{expr}s in the environment
where @var{var}s are already bound (to an undefined value, initially).
@code{letrec} is necessary to define mutually recursive local procedures.
@c JP
これらの3つのフォームの違いは、@var{expr}が評価される時点のスコープにあります。
@code{let}は@var{expr}を@var{let}フォームに入る前の環境において評価します。
@code{let*}は@var{expr}を順に、それ以前の@var{var}が束縛された環境において評価して
ゆきます。@var{letrec}は全ての@var{var}が仮想的に不定の値に束縛された環境において
各@var{expr}を評価します。@var{letrec}は相互再帰的なローカル関数を定義する場合に
必要です。
@c COMMON
@example
(define x 'top-x)

(let  ((x 3) (y x)) (cons x y)) @result{} (3 . top-x)
(let* ((x 3) (y x)) (cons x y)) @result{} (3 . 3)

(let ((cons (lambda (a b) (+ a b)))
      (list (lambda (a b) (cons a (cons b 0)))))
  (list 1 2))  @result{} (1 2 . 0)

(letrec ((cons (lambda (a b) (+ a b)))
         (list (lambda (a b) (cons a (cons b 0)))))
  (list 1 2))  @result{} 3
@end example
@end defspec

@defspec receive formals expression body @dots{}
[SRFI-8]
@c EN
This is the way to receive multiple values.
@var{Formals} can be a (maybe-improper) list of symbols.
@var{Expression} is evaluated, and the returned value(s)
are bound to @var{formals} like the binding of lambda formals,
then @var{body} @dots{} are evaluated.
@c JP
この構文により、多値を受け取ることができます。
@var{formals}はシンボルのリストです。不完全なリストであっても構いません。
@var{expression}が評価され、返された値がlambda形式の引数の束縛と
同じようにして@var{formals}内の変数と束縛され、その環境下で@var{body} @dots{}が
評価されます。
@c COMMON

@example
(define (divrem n m)
  (values (quotient n m) (remainder n m)))

(receive (q r) (divrem 13 4) (list q r))
  @result{} (3 1)

(receive all (divrem 13 4) all)
  @result{} (3 1)

(receive (q . rest) (divrem 13 4) (list q rest)
  @result{} (3 (1))
@end example

@c EN
See also @code{call-with-values} in @ref{Multiple values}
which is the procedural equivalent of @code{receive}.
Also @code{let-values} and @code{let*-values} 
in SRFI-11 (@ref{Let-values}) provides
@code{let}-like syntax with multiple values.
@c JP
なお、@ref{Multiple values}の@var{call-with-values}は
@code{receive}と等価な手続き的インタフェースです。
また、SRFI-11 (@ref{Let-values}) の@code{let-values}と
@code{let*-values}は@code{let}のような形式で多値を扱うことができます。
@c COMMON
@end defspec

@node Sequencing, Iteration, Binding constructs, Core syntax
@section Sequencing
@c NODE 順次実行


@defspec begin form @dots{}
[R5RS]
@c EN
Evaluates @var{form}s sequentially, and returns the last result(s).
@c JP
@var{form}を順に評価し、最後の値を返します。
@c COMMON

@c EN
@code{Begin} doesn't introduce new "block" like @code{let}, that is,
you can't place "internal define" at the beginning of @var{form}s
generally.   Semantically @code{begin} behaves as if @var{form}s
are spliced into the surrounding context.
For example, topleve expression like the following is the same
as two toplevel definitions:
@c JP
@code{Begin}は@code{let}のような「ブロック」を作成するわけではありません。
すなわち、一般的には@var{form} @dots{}の先頭に「内部のdefine (internal define)」を
置くことはできません。意味的には、@code{begin}はまるで@var{form} @dots{}が
@code{begin}を囲むコンテクスト中に展開されているかのように振舞います。
例えば、トップレベルに次のような式があった場合、それは2つのトップレベルのdefineと
同等です。
@c COMMON

@example
(begin (define x 1) (define y 2))
@end example

@c EN
Here's a trickier example:
@c JP
よりトリッキーな例:
@c COMMON

@example
(let ()
  (begin 
    (define x 2)
    (begin
      (define y 3)
    ))
  (+ x y))

  @equiv{}

(let ()
  (define x 2)
  (define y 3)
  (+ x y))
@end example
@end defspec


@node Iteration, Quasiquotation, Sequencing, Core syntax
@section Iteration
@c NODE 繰り返し

@defspec do ((variable init [step]) @dots{}) (test expr @dots{}) body @dots{}
[R5RS]
@end defspec


@defspec let name bindings body @dots{}
[R5RS]
@end defspec



@defmac dotimes (variable limit [result]) body @dots{}
@c EN
Imported from Common Lisp.  This is equivalent to
@c JP
Common Lispからの輸入です。以下のように展開されます。
@c COMMON
@example
(do ((tlimit limit)
     (variable 0 (+ variable 1)))
    ((>= variable tlimit) result)
  body @dots{})
@end example
@end defmac

@c EN
There's no @code{dolist}.  Use @code{for-each}, or write your own.
@c JP
Common Lispの@code{dolist}は提供されていません。@code{for-each}を使うか、
自分で書いて下さい。
@c COMMON

@c ----------------------------------------------------------------------
@node Quasiquotation, Definitions, Iteration, Core syntax
@section Quasiquotation
@c NODE 準クオート, 準クオート(Quasiquote)

@defspec quasiquote template
[R5RS]
@end defspec


@c ----------------------------------------------------------------------
@node Definitions, Modules, Quasiquotation, Core syntax
@section Definitions
@c NODE 定義

@defspec define variable expression
@defspecx define (variable formals) body @dots{}
[R5RS]
@c EN
This form has different meanings in the toplevel (without no
local bindings) or inside a local scope.

On toplevel, it defines a global binding to a symbol @var{variable}.
In the first form, it globally binds a symbol @var{variable}
to the value of @var{expression}, in the current module.
@c JP
この形式はトップレベル (ローカルな束縛が無い状態) とローカルスコープがある状態とで
別の意味を持ちます。

トップレベルでは、この形式は変数@var{variable}に対するグローバルな束縛を定義します。
最初の形式では、@var{expression}が評価され、その結果が変数@var{variable}の値となります。
@c COMMON
@example
(define x (+ 1 2))
x @result{} 3
(define y (lambda (a) (* a 2)))
(y 8) @result{} 16
@end example

@c EN
The second form is a syntactic sugar of defining a procedure.
It is equivalent to the following form.
@c JP
2番目の形式は手続きを定義するための構文的な修飾で、以下の形式と同じです。
@c COMMON
@example
(define (@var{name} . @var{args}) @var{body} @dots{})
  @equiv{} (define @var{name} (lambda @var{args} @var{body} @dots{}))
@end example

@c EN
If the form appears inside a local scope (internal define),
this introduce a local binding of the variable.

@c explanation of internal define here
@c JP
このフォームがローカルスコープの中に現われた場合、ローカル変数の束縛となります。
@c COMMON


@c EN
Note that @code{begin} (@xref{Sequencing}) doesn't introduce a new scope.
@code{Define}s in the @code{begin} act as if @code{begin} and surrounding
parenthesis are not there.  Thus these two forms are equivalent.
@c JP
@code{begin}は新しいスコープを作らないことに注意してください(@ref{Sequencing}参照)。
@code{begin}の中に現われる@code{define}は、あたかも@code{begin}とそれを囲む
括弧な無いかのように振舞います。すなわち、以下の2つの形式は等価です。
@c COMMON
@example
(let ((x 0))
  (begin
    (define (foo y) (+ x y)))
  (foo 3))
 @equiv{}
(let ((x 0))
  (define (foo y) (+ x y))
  (foo 3))
@end example

@end defspec

@c ----------------------------------------------------------------------
@node Modules,  , Definitions, Core syntax
@section Modules
@c NODE モジュール

@c EN
Module is an object that maps symbols onto @emph{bindings}.

Unlike CommonLisp's packages, which map names to symbols,
in Gauche symbols are always @code{eq?} if two have the
same name.  However, different bindings can be associated
to the same symbol, that yield different values.
@c JP
モジュールは、シンボルを束縛へとマップするオブジェクトです。

CommonLispのパッケージは名前からシンボルへのマッピングを行いますが、
Gaucheでは同じ名前を持つシンボルは常に@code{eq?}です。しかし、
モジュールが違えば同じシンボルは別々の束縛へとマップされ、違う値を
返します。
@c COMMON

@c EN
See also @ref{Writing Gauche modules}, for the conventions
Gauche is using for its modules.
@c JP
Gaucheで使われているモジュールの書法については@ref{Writing Gauche modules}も
併せて参照して下さい。
@c COMMON

@menu
* Module syntax::               
* Module introspection::        
* Predefined modules::          
@end menu

@node Module syntax, Module introspection, Modules, Modules
@subsection Module syntax
@c NODE モジュール構文

@defspec define-module name body @dots{}
@c EN
@var{Name} must be a symbol
If a module named @var{name} does not exist, create one.
Then evaluates @var{body} sequentially in the module.
@c JP
@var{name}はシンボルでなければなりません。
名前@var{name}を持つモジュールが存在しなければまず作成します。
それから、@var{body} @dots{} をモジュール@var{name}中で評価します。
@c COMMON
@end defspec

@defspec select-module name
@c EN
Makes a module named @var{name} as the current module.
It is an error if no module named @var{name} exists.

If @code{select-module} is used in the Scheme file, its effect is
limited inside the file, i.e. even if you load/require a file that uses
@code{select-module} internallly, the current module of requirer is
not affected.
@c JP
名前@var{name}を持つモジュールをカレントモジュールとします。
その名前を持つモジュールが無ければエラーとなります。

@code{select-module}がSchemeファイルの中で用いられた場合、
その効果はそのファイルの終了までに限られます。@code{select-module}を中で呼んでいる
ファイルをloadやrequireしても、呼んだ側のカレントモジュールは影響を受けません。
@c COMMON
@end defspec

@defspec with-module name body @dots{}
@c EN
Evaluates @var{body} sequentially in the module
named @var{name}.  Returns the last result(s).
If no moudle named @var{name}, an error is signalled.
@c JP
名前@var{name}を持つモジュールをカレントモジュールとした状態で@var{body} @dots{}
を順に評価し、最後の結果を返します。該当するモジュールが存在しなければエラーとなります。
@c COMMON
@end defspec

@defspec export symbol @dots{}
@c EN
Makes bindings of @var{symbol}s in the current module available
to modules that imports the current module.
@c JP
カレントモジュールの中で、シンボル@var{symbol}に対応する束縛をエクスポートします。
エクスポートされた束縛は、カレントモジュールをインポートしたモジュール中で見えるようになります。
@c COMMON
@end defspec

@defspec export-all
@c EN
Makes all bindings in the current module available to modules
that imports it.
@c JP
カレントモジュール中の全ての束縛をエクスポートします。
@c COMMON
@end defspec

@defspec import module-name @dots{}
@c EN
Makes all exported bindings in the module named @var{module-name}
available in the current module.   The named modules should exist
when the compiler sees this special form.
@c JP
名前@var{module-name}を持つモジュールがエクスポートしている束縛を
カレントモジュール中で使えるようにします。該当するモジュールが既に定義されて
いなければなりません。
@c COMMON
@end defspec

@defspec current-module
@c EN
Evaluates to the current module in the compile context.
Note that this is a special form, not a function.
Module in Gauche is statically determined at compile time.
@c JP
コンパイル時点でのカレントモジュールに評価されます。
これは手続きではなく特殊形式です。
Gaucheではモジュールはコンパイル時に静的に決定されます。
@c COMMON
@lisp
(define-module foo
  (export get-current-module)
  (define (get-current-module) (module-name (current-module))))

(define-module bar
  (import foo)
  (get-current-module)) @result{} foo @r{; not bar}
@end lisp
@end defspec

@defmac use name
@c EN
A convenience macro that combines module imports and on-demand
file loading.  Basically, @code{(use foo)} is equivalent
to the following two forms:
@example
(require "foo")
(import foo)
@end example
That is, it loads the library file named ``@code{foo}'' (if not yet
loaded) which defines a module named @code{foo} in it,
and then import the module
@code{foo} into the current module.
@c JP
モジュールのインポートとオンデマンドのファイルのロードを合わせて行う、
便利なマクロです。基本的に、@code{(use foo)} は以下のふたつのフォームと
等価です。
@example
(require "foo")
(import foo)
@end example
すなわち、まず名前``@code{foo}''を持つライブラリファイルが(まだロードされて
いなければ)ロードされ、その中で定義されているモジュール@code{foo}をカレントモジュールに
インポートします。
@c COMMON

@c EN
Although the files and modules are orthogonal concept,
it is practically convenient to separate files by modules.
Gauche doesn't force you to do so, and you can always use
@code{require} and @code{import} separately.  However, all
modules provided with Gauche are arranged so that they can be
used by @code{use} macro.
@c JP
ファイルのロードとモジュールとは直交する概念ですが、
現実にはモジュール毎にファイルを分割するのが便利です。
必ずしもそうする必要は無く、@code{require} と @code{import} を別々に
使っても構いません。が、Gaucheに附属してくるライブラリはすべて、
@code{use} マクロで使えるように書かれています。
@c COMMON

@c EN
If a module is too big to fit in one file, you can split them
into several subfiles and one main file.  The main file defines
the module, and either loads, requires, or autoloads subfiles.
@c JP
もしモジュールが一つのファイルに収めるには大きすぎる場合、一つのメインファイルと
いくつかのサブファイルに分けることも出来ます。メインファイルの中でモジュールを
定義し、サブファイルをまとめてロードするか、オートロードを設定します。
@c COMMON

@c EN
If @var{name} contains periods `@code{.}', it is replaced to `@code{/}'
in the file name.to be @code{require}d, for example,
@code{(use foo.bar.baz)} is expanded to:
@example
(require "foo/bar/baz")
(import foo.bar.baz)
@end example
This is not very Scheme-ish way, but nevertheless convenient.
(The alternative design is to use a list of symbols to represent
hierarchical file/module configuration, as in Guile.)
@c JP
もし@var{name}がピリオド`@code{.}'を含んでいる場合、@code{require}するファイル名
ではそれが`@code{/}'に置換されます。例えば@code{(use foo.bar.baz)}は
@example
(require "foo/bar/baz")
(import foo.bar.baz)
@end example
となります。これはあまりScheme風ではありませんが、便利ではあります。
(別の設計方針として、Gaucheでは採用していませんが、
例えばGuileで用いられているような、シンボルのリストを
階層的なモジュールに使用することも考えられます。)
@c COMMON
@end defmac

@node Module introspection, Predefined modules, Module syntax, Modules
@subsection Module introspection
@c NODE モジュールイントロスペクション

@deftp {Builtin Class} <module>
@clindex module
@c EN
A module class.
@c JP
モジュールクラスです。
@c COMMON
@end deftp

@defun module? obj
@c EN
Returns true if @var{obj} is a module.
@c JP
@var{obj}がモジュールなら真の値を返します。
@c COMMON
@end defun

@defun find-module name
@c EN
Returns a module object whose name is a symbol @var{name}.
If the named module doesn't exist, @code{#f} is returned.
@c JP
名前がシンボル@var{name}であるようなモジュールを返します。
その名前をもつモジュールが存在しなければ、@code{#f}を返します。
@c COMMON
@end defun

@defun all-modules
@c EN
Returns a list of modules currently known to the system.
@c JP
現在存在する全てのモジュールのリストを返します。
@c COMMON
@end defun

@defun module-name module
@defunx module-imports module
@defunx module-exports module
@defunx module-table module
@c EN
Accessors of a module object.  Returns the name of the module (a symbol),
list of imported modules, list of exported symbols, and a hash table
that maps symbols to bindings, of the @var{module} are returned,
respectively.
@c JP
モジュールオブジェクトのアクセスメソッドです。
@var{module}の名前(シンボル)、@var{module}がインポートしているモジュールのリスト、
エクスポートしているシンボルのリスト、そして
シンボルから束縛へのマップを行うハッシュテーブルを返します。
@c COMMON

@c EN
If the @var{module} exports all symbols, @code{module-exports} returns
@code{#t}.
@c JP
もし@var{module}が全てのシンボルをエクスポートしている場合は、@code{module-exports}
は@code{#t}を返します。
@c COMMON

@c EN
It is an error to pass a non-module object.
@c JP
モジュールオブジェクト以外が渡された場合はエラーになります。
@c COMMON
@end defun

@node Predefined modules,  , Module introspection, Modules
@subsection Predefined modules
@c NODE 組み込みモジュール

@c EN
Several modules are predefined in Gauche.
@c JP
Gauche起動時にいくつかのモジュールがあらかじめ定義されています。
@c COMMON

@deftp {Builtin Module} null
@mdindex null
@c EN
This module corresponds to the null environment referred in R5RS.
This module contains only syntactic bindings of R5RS syntax.
(With one exception in the current implmenetation:
Syntax @code{with-module} is in this module, since Gauche needed it
for certain internal setup.  It'll be removed in future.)
@c JP
このモジュールはR5RSで述べられている"null environment"に相当します。
R5RSの構文要素への束縛だけを含んだモジュールです。
(但し現在の実装では一つだけ例外があります：Gaucheが内部処理に必要とするために、
構文@code{with-module}がこのモジュールに含まれています。
将来これは除かれます。)
@c COMMON
@end deftp

@deftp {Builtin Module} scheme
@mdindex scheme
@c EN
This module contains all the binding of @code{null} module,
and the binding of procedures defined in R5RS.
@c JP
このモジュールは@code{null}モジュール内の束縛全てに加えて、
R5RSで定義されている全ての手続きの束縛を含みます。
@c COMMON
@end deftp

@deftp {Builtin Module} gauche
@mdindex gauche
@c EN
This module contains all the bindings of @code{scheme} module,
plus Gauche specific built-in procedures.
@c JP
このモジュールは@code{scheme}モジュール内の全ての束縛に加え、
Gaucheの組込み手続きや構文が含まれています。
@c COMMON
@end deftp

@deftp {Builtin Module} user
@mdindex user
@c EN
This module is the default module the user code is compiled.
all the bindings of @code{gauche} module is imported.
@c JP
このモジュールはユーザコードがコンパイルされる既定のモジュールです。
@code{gauche}モジュール内の全ての束縛がインポートされています。
@c COMMON
@end deftp

@c ======================================================================
@node Macros, Core library, Core syntax, Top
@chapter Macros
@c NODE マクロ

@c EN
Gauche supports both R5RS hygienic macros and
traditional macros.
@c JP
Gaucheでは、R5RSに定義される「健全な(hygienic)」マクロと
伝統的なマクロの両方が使えます。
@c COMMON

@c EN
Macro of Lisp-family language is very different feature from
ones of other languages, such as C preprocessor macros.
It allows you to extend the original language syntax.
You can use macros to change Gauche syntax
so that you can run a Scheme program written to other Scheme
implementations, and you can even design your own mini-language
to solve your problem easily.
@c JP
Lisp系言語のマクロは、他の言語に見られるマクロ(例えばCプリプロセッサマクロ)とは
大きく異なります。Lispのマクロは元の言語の構文を拡張する手段なのです。
例えば、Gaucheの構文を若干変えることで他のScheme実装用に書かれたSchemeプログラムを
走らせたり、あるいは自分の問題解決に適した「ミニ言語」をデザインすることさえできます。
@c COMMON

@menu
* Hygienic Macros::             
* Traditional Macros::          
* Macro expansion::             
* Macro utilities::             
@end menu

@node Hygienic Macros, Traditional Macros, Macros, Macros
@section Hygienic Macros
@c NODE 健全なマクロ

@c EN
R5RS hygienic macro is based on a special pattern language,
and guaranteed that no "variable capture" occurs.
"Variable catpture" means that if you insert new variable
bindings in the expanded form, the new bindings
shadows the bindings in the form passed to the macro.
@c JP
R5RSの健全なマクロは特別なパターン言語に基づいていて、
また「変数捕捉」が起こらないことが保証されています。
「変数捕捉」とは、マクロが新しい変数束縛を導入した時に、その束縛が
マクロに渡されたフォーム中の変数名と衝突して、その変数名の本来の束縛を隠して
しまうことを言います。
@c COMMON

@defspec define-syntax name transformer-spec
[R5RS]
@end defspec

@defspec let-syntax ((name transformer-spec) @dots{}) body
@defspecx letrec-syntax ((name transformer-spec) @dots{}) body
[R5RS]
@end defspec

@defspec syntax-rules literals clause1 clause2 @dots{}
[R5RS]
@end defspec


@node Traditional Macros, Macro expansion, Hygienic Macros, Macros
@section Traditional Macros
@c NODE 伝統的なマクロ

@defspec define-macro name procedure
@defspecx define-macro (name formals) body @dots{}
Defines @var{name} to be a global macro whose transformer is @var{procedure}.
The second form is a shorthand notation of the following form:
@example
(define-macro name (lambda formals body @dots{}))
@end example

When a form @code{(name @var{arg} @dots{})} is seen by the compiler,
it calls @var{procedure} with @var{arg} @dots{}.  When @var{procedure}
returns, the compiler inserts the returned form in place of the original
form, and compile it again.


@end defspec

@node Macro expansion, Macro utilities, Traditional Macros, Macros
@section Macro expansion
@c NODE マクロの展開

@defun macro-expand form
@defunx macro-expand-1 form
If @var{form} is a list and its first element is a variable
globally bound to a macro, @code{macro-expand-1}
invokes its macro transformer and
returns the expanded form.  Otherwise, returns @var{form} as is.

@code{macro-expand} repeats @code{macro-expand-1} until the
@var{form} can't be expanded.

These procedures can be used to expand globally defined macros.
@end defun

@defspec %macro-expand form
@defspecx %macro-expand-1 form
@end defspec

@node Macro utilities,  , Macro expansion, Macros
@section Macro utilities
@c NODE マクロユーティリティ

@defmac syntax-error msg arg @dots{}
@defmacx syntax-errorf fmt arg @dots{}
Signal an error.  They are same as
@code{error} and @code{errorf} (@xref{Signalling errors}),
except that the error is signalled at macro-expansion time
(i.e. compile time) rather than run time.

They are useful to tell the user the wrong usage of macro in
the comprehensive way, instead of the cryptic error from the macro
expander.   Because of the purpose, @var{arg} @dots{} are first
passed to @code{unwrap-syntax} described below, to strip off
the internal syntactic binding informations.

@example
(define-syntax my-macro
  (syntax-rules ()
    ((_ a b)   (foo2 a b))
    ((_ a b c) (foo3 a b c))
    ((_ . ?)
     (syntax-error "malformed my-macro" (my-macro . ?)))))

(my-macro 1 2 3 4)
  @result{} @r{error: "malformed my-macro: (mymacro 1 2 3 4)"}
@end example

@end defmac

@defun unwrap-syntax form
Removes internal syntactic information from @var{form}.
In order to implement a hygienic macro, macro expander replaces
symbols in the macro form for identifiers, which captures the
syntactic environment where they are defined.  Although it is
necessary information for the compiler, it is rather confusing
for users if it appears in the messages.  This function
replaces occurrences of identifiers in @var{form} to the original
symbols.
@end defun

@c ======================================================================
@node Core library, Object system, Macros, Top
@chapter Core library
@c NODE 組み込みライブラリ

@c ----------------------------------------------------------------------
@menu
* Equivalence::                 
* Numbers::                     
* Booleans::                    
* Pairs and Lists::             
* Symbols::                     
* Keywords::                    
* Identifiers::                 
* Characters::                  
* Character set::               
* Strings::                     
* Regular expression::          
* Vectors::                     
* Hashtables::                  
* Control features::            
* Exceptions::                  
* Eval::                        
* Input and output::            
* Loading Programs::            
* Comparison and sorting::      
* System interface::            
@end menu

@node Equivalence, Numbers, Core library, Core library
@section Equivalence
@c NODE 等価

@defun eq? obj1 obj2
@defunx eqv? obj1 obj2
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun equal? obj1 obj2
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Numbers, Booleans, Equivalence, Core library
@section Numbers
@c NODE 数値

@c EN
Gauche supports the following types of numbers
@table @asis
@item multi-precision exact integer
There's no limit of the size of number except the memory of the machine.
@item inexact floating-point real number
Using @code{double}-type of underlying C compiler, usually IEEE 64-bit
floating point number.
@item inexact floating-point complex number
Real part and imaginary part are represented by inexact floating-point
real numbers.
@end table
@c JP
Gaucheは次のタイプの数値をサポートしています。
@table @asis
@item 多倍長の正確な整数
メモリの許す限りの精度が扱えます。
@item 浮動少数点の不正確な実数
実装に使われるC言語の@code{double}型で表現されます。通常IEEE 64bit浮動少数点数です。
@item 浮動少数点の不正確な複素数
実部と虚部はそれぞれ浮動少数点の不正確な実数で表現されます。
@end table
@c COMMON

@menu
* Number classes::              
* Numerical predicates::        
* Numerical comparison::        
* Arithmetics::                 
* Numerical conversions::       
* Bitwise operations::          
@end menu

@node Number classes, Numerical predicates, Numbers, Numbers
@subsection Number classes
@c NODE 数値クラス

@deftp {Builtin Class} <number>
@deftpx {Builtin Class} <complex>
@deftpx {Builtin Class} <real>
@deftpx {Builtin Class} <integer>
@clindex number
@clindex complex
@clindex real
@clindex integer
@c EN
These classes consist a class hierarchy of number objects.
@code{<complex>} inherits @code{<number>}, @code{<real>} inherits
@code{<complex>} and @code{<integer>} inherits @code{<real>}.

Note that these classes does not exactly corresponds to the
number hierarchy defined in R5RS.  Especially, 
only exact integers are the instances of the @code{<integer>}
class.  That is,
@c JP
数値オブジェクトのクラス階層を構成します。@code{<complex>}は
@code{<number>}を継承し、@code{<real>}は@code{<complex>}を継承し、
@code{<integer>}は@code{<real>}を継承します。

これらのクラスはR5RSで定義されている数値の階層とは必ずしも対応しません。
特に、@code{<integer>}クラスのインスタンスはR5RSでいうexact integerのみになります。
@c COMMON
@lisp
(integer? 1)        @result{} #t
(is-a? 1 <integer>) @result{} #t
(is-a? 1 <real>)    @result{} #t

(integer? 1.0)        @result{} #t
(is-a? 1.0 <integer>) @result{} #f
(is-a? 1.0 <real>)    @result{} #t

(class-of (expt 2 100)) @result{} #<class <integer>>
(class-of (sqrt -3)) @result{} #<class <complex>>
@end lisp
@end deftp

@node Numerical predicates, Numerical comparison, Number classes, Numbers
@subsection Numerical predicates
@c NODE 数値に関する述語

@defun number? obj
@defunx complex? obj
@defunx real? obj
@defunx rational? obj
@defunx integer? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a number, a complex number, a real number,
a rational number or an integer, respectively.   In Gauche, a set of
numbers is the same as a set of complex numbers, and a set of
rational numbers is the same as a set of integers.
@c JP
@var{obj}がそれぞれ数、複素数、実数、有理数、整数ならば@code{#t}を返します。
Gaucheでは、数の集合は複素数の集合と同一であり、有理数の集合は整数の集合と同一です。
@c COMMON

@example
(complex? 3+4i)   @result{} #t
(complex? 3)      @result{} #t
(real? 3)         @result{} #t
(real? -2.5+0.0i) @result{} #t
(real? #e1e10)    @result{} #t
(integer? 3+0i)   @result{} #t
(integer? 3.0)    @result{} #t
@end example
@end defun

@defun exact? obj
@defunx inexact? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is an exact number and an inexact number,
respectively.
@c JP
@var{obj}がそれぞれ正確な数、不正確な数ならば@code{#t}を返します。
@c COMMON

@example
(exact? 1)       @result{} #t
(exact? 1.0)     @result{} #f
(inexact? 1)     @result{} #f
(inexact? 1.0)   @result{} #t

(exact? (modulo 5 3)) @result{} #t
(inexact? (modulo 5 3.0)) @result{} #f
@end example
@end defun

@defun zero? z
[R5RS]
@c EN
Returns @code{#t} if a number @var{z} equals to zero.
@c JP
数値@var{z}がゼロに等しければ@code{#t}を返します。
@c COMMON

@example
(zero? 1)        @result{} #f
(zero? 0)        @result{} #t
(zero? 0.0)      @result{} #t
(zero? 0.0+0.0i) @result{} #t
@end example
@end defun

@defun positive? x
@defunx negative? x
[R5RS]
@c EN
Returns @code{#t} if a real number @var{x} is positive and negative,
respectively.  It is an error to pass a non-real number.
@c JP
実数@var{x}がそれぞれ正または負なら@code{#t}を返します。
非実数を渡すとエラーになります。
@c COMMON
@end defun

@defun odd? n
@defunx even? n
[R5RS]
@c EN
Returns @code{#t} if an integer @var{n} is odd and even, 
respectively.  It is an error to pass a non-integral number.
@c JP
整数@var{n}がそれぞれ奇数または偶数なら@code{#t}を返します。
非整数を渡すとエラーになります。
@c COMMON

@example
(odd? 3)     @result{} #t
(even? 3)    @result{} #f
(odd? 3.0)   @result{} #t
@end example
@end defun

@node Numerical comparison, Arithmetics, Numerical predicates, Numbers
@subsection Numerical comparison
@c NODE 数値の比較

@defun @code{=} z1 z2 z3 @dots{}
[R5RS]
@c EN
If all the numbers @var{z} are equal, returns @code{#t}.
@c JP
与えられた全ての数値@var{z}が等しければ@code{#t}を返します。
@c COMMON

@example
(= 2 2)          @result{} #t
(= 2 3)          @result{} #f
(= 2 2.0)        @result{} #t
(= 2 2.0 2.0+0i) @result{} #t
@end example
@end defun

@defun @code{<} x1 x2 x3 @dots{}
@defunx @code{<=} x1 x2 x3 @dots{}
@defunx @code{>} x1 x2 x3 @dots{}
@defunx @code{>=} x1 x2 x3 @dots{}
[R5RS]
@c EN
Returns @code{#t} If all the real numbers @var{x} are
monotonically increasing,
monotonically nondecreasing, monotonically decreasing, or monotonically
nonincreasing, respectively.
@c JP
与えられた全ての実数@var{x}がそれぞれ単調増加、単調非減少、単調減少、単調非増加している
場合に@code{#t}を返します。
@c COMMON
@end defun


@defun max x1 x2 @dots{}
@defunx min x1 x2 @dots{}
[R5RS]
@c EN
Returns a maximum or minimum number in the given real numbers, respectively.
@c JP
与えられた実数のうち、それぞれ最大と最小のものを返します。
@c COMMON
@end defun

@node Arithmetics, Numerical conversions, Numerical comparison, Numbers
@subsection Arithmetics
@c NODE 数値の演算

@defun @code{+} z @dots{}
@defunx @code{*} z @dots{}
[R5RS]
@c EN
Returns the sum or the product of given numbers, respectively.
If no argument is given, @code{(+)} yields 0 and @code{(*)} yields 1.
@c JP
与えられた数の和と積をそれぞれ返します。引数が与えられない場合、
@code{(+)} は 0、 @code{(*)} は 1 となります。
@c COMMON
@end defun

@defun @code{-} z1 z2 @dots{}
@defunx @code{/} z1 z2 @dots{}
[R5RS]
@c EN
If only one number @var{z1} is given, returns its
negation and reciprocal, respectively.

If more than one number are given, returns:
@example
@var{z1} - @var{z2} - @var{z3} @dots{}
@var{z1} / @var{z2} / @var{z3} @dots{}
@end example
respectively.
@c JP
一つだけ数値が与えられた場合、それぞれnegationと逆数を返します。

2つ以上の数値が与えられた場合、それぞれ次の結果を返します。
@example
@var{z1} - @var{z2} - @var{z3} @dots{}
@var{z1} / @var{z2} / @var{z3} @dots{}
@end example
@c COMMON

@example
(- 3)       @result{} -3
(- -3.0)    @result{} 3.0
(- 5+2i)    @result{} -5.0-2.0i
(/ 3)       @result{} 0.333333333333333
(/ 5+2i)    @result{} 0.172413793103448-0.0689655172413793i

(- 5 2 1)     @result{} 2
(- 5 2.0 1)   @result{} 2.0
(- 5+3i -i)   @result{} 5.0+2.0i
(/ 6+2i 2)    @result{} 3.0+1.0i
@end example
@end defun

@defun abs z
[R5RS+]
@c EN
For real number @var{z}, returns an absolute value of it.
For complex number @var{z}, returns the magnitude of the number.
The complex part is Gauche extension.
@c JP
実数の@var{z}に対しては、その絶対値を返します。
複素数の@var{z}に対しては、そのmagnitudeを返します。
複素数を扱うのはGaucheの拡張です。
@c COMMON
@example
(abs -1)   @result{} 1
(abs -1.0) @result{} 1.0
(abs 1+i)  @result{} 1.4142135623731
@end example
@end defun

@defun quotient n1 n2
@defunx remainder n1 n2
@defunx modulo n1 n2
[R5RS]
@c EN
Returns the quotient, remainder and modulo of dividing an integer @var{n1}
by an integer @var{n2}.   The result is an exact number only if
both @var{n1} and @var{n2} are exact numbers.

Remainder and modulo differ when either one of the arguments is negative.
Remainder @var{R} and quotient @var{Q} have the following relationship.
@example
  @var{n1} = @var{Q} * @var{n2} + @var{R}
@end example
where @code{abs(@var{Q}) = floor(abs(@var{n1})/abs(@var{n2}))}.
Consequently, @var{R}'s sign is always the same as @var{n1}'s.

On the other hand, modulo works as expected for positive @var{n2},
regardless of the sign of @var{n1}
(e.g. @code{(modulo -1 @var{n2}) == @var{n2} - 1}).
If @var{n2} is negative, it is mapped to the positive case by
the following relationship.
@example
  modulo(@var{n1}, @var{n2}) = @minus{}modulo(@minus{}@var{n1}, @minus{}@var{n2})
@end example
Consequently, @var{modulo}'s sign is always the same as @var{n2}'s.
@c JP
整数@var{n1}を整数@var{n2}で割った商(quotient)および余り(remainder, modulo)
を返します。  @var{n1}と@var{n2}の両方が正確な数値の時のみ、戻り値は正確な数値になります。

@code{remainder}と@code{modulo} はどちらかの引数が負の時に異なる値を返します。
Remainder @var{R} と商 @var{Q} とは次の関係があります。
@example
  @var{n1} = @var{Q} * @var{n2} + @var{R}
@end example
ここで商について @code{abs(@var{Q}) = floor(abs(@var{n1})/abs(@var{n2}))}
ですから、@var{R}の符号は常に@var{n1}と同じになります。

一方、moduloは@var{n2}が正の時は@var{n1}の符号に関わらず期待したように動作します
(例: @code{(modulo -1 @var{n2}) == @var{n2} - 1})。
@var{n2}が負の場合は次の式によって正の場合にマップできます。
@example
  modulo(@var{n1}, @var{n2}) = @minus{}modulo(@minus{}@var{n1}, @minus{}@var{n2})
@end example
したがって、moduloの結果の符号は常に@var{n2}の符号と同じになります。
@c COMMON
@example
(remainder 10 3)    @result{} 1
(modulo 10 3)       @result{} 1

(remainder -10 3)   @result{} -1
(modulo -10 3)      @result{} 2

(remainder 10 -3)   @result{} 1
(modulo 10 -3)      @result{} -2

(remainder -10 -3)  @result{} -1
(modulo -10 -3)     @result{} -1
@end example
@end defun

@defun gcd n @dots{}
@defunx lcm n @dots{}
[R5RS]
@c EN
Returns the greatest common divisor or the least common multiplier
of the given integers, respectively
@c JP
与えられた整数の、最大公約数と最小公倍数をそれぞれ返します。
@c COMMON
@end defun

@defun numerator q
@defunx denominator q
[R5RS]
@c EN
Returns the numerator and denominator of a rational number @var{q}.
Since Gauche doesn't support full rational numbers, they actually
work only on integers; that is, given integer @var{q}, @code{numerator}
always returns @var{q} and @code{denominator} always return 1.
@c JP
有理数@var{q}の分子と分母をそれぞれ返します。Gaucheでは今のところ有理数を完全には
サポートしていないため、これらの手続きは実際には整数にしか使えません。すなわち、
整数@var{q}に対して@code{numerator}は常に@var{q}を返し、@code{denominator}
は常に1を返します。
@c COMMON
@end defun


@defun floor x
@defunx ceiling x
@defunx truncate x
@defunx round x
[R5RS]
@c EN
The argument @var{x} must be a real number.
@code{Floor} and @code{ceiling} return a minimum integer that
is greater than @var{x} and a maximim integer that is less than @var{x},
respectively.  @var{Truncate} returns an integer that truncates
@var{x} towards zero.  @var{Round} returns an integer that is closest
to @var{x}.  If fractional part of @var{x} is exactly 0.5, @var{round}
returns the closest even integer.
@c JP
引数@var{x}は実数でなければなりません。@code{floor}と@code{ceiling}はそれぞれ
@var{x}を越えない最大の整数と、@var{x}を下回らない最小の整数を返します。
@var{truncate}は@var{x}の小数部をゼロの方向に向かって切捨てた整数を返します。
@var{round}は@var{x}に最も近い(四捨五入した)整数を返します。@var{x}の
小数部が0.5ぴったりだった場合は@var{round}は最も近い偶数を返します。
@c COMMON
@end defun

@defun clamp x &optional min max
@c EN
Returns
@example
 @var{min} @r{if} @var{x} @code{<} @var{min}
 @var{x}   @r{if} @var{min} @code{<=} @var{x} @code{<=} @var{max}
 @var{max} @r{if} @var{max} @code{<} @var{x}
@end example
If @var{min} or @var{max} is omitted or @code{#f}, it is regarded
as @var{-infinity} or @var{+infinity}, respectively.
Returns an exact integer only if all the given numbers are exact integers.
@c JP
@example
 @var{min} @r{if} @var{x} @code{<} @var{min}
 @var{x}   @r{if} @var{min} @code{<=} @var{x} @code{<=} @var{max}
 @var{max} @r{if} @var{max} @code{<} @var{x}
@end example
を返します。もし@var{min}または@var{max}が省略されるか@code{#f}が与えられたら、
それぞれ @var{-∞} もしくは @var{+∞} と解釈されます。
与えられた全ての数値が正確な整数の場合に限り正確な整数を返します。
@c COMMON
@example
(clamp 3.1 0.0 1.0) @result{} 1.0
(clamp 0.5 0.0 1.0) @result{} 0.5
(clamp -0.3 0.0 1.0) @result{} 0.0
(clamp -5 0)        @result{} 0
(clamp 3724 #f 256) @result{} 256
@end example
@end defun


@defun exp z
@defunx log z
@defunx sin z
@defunx cos z
@defunx tan z
@defunx asin z
@defunx acos z
@defunx atan z
[R5RS]
@c EN
Transcedental functions.  Work for complex numbers as well.
@c JP
超越関数です。複素数も扱えます。
@c COMMON
@end defun

@defun atan x y
[R5RS]
@c EN
For real numbers @var{x} and @var{y}, returns @code{atan(@var{y}/@var{x})}.
@c JP
実数@var{x}と@var{y}に対して@code{atan(@var{y}/@var{x})}を返します。
@c COMMON
@end defun

@defun sinh z
@defunx cosh z
@defunx tanh z
@defunx asinh z
@defunx acosh z
@defunx atanh z
@c EN
Hyperbolic trigonometric functions.  Work for complex numbers as well.
@c JP
双曲線関数です。複素数も扱えます。
@c COMMON
@end defun

@defun sqrt z
[R5RS]
@c EN
Returns a square root of a complex number @var{z}.
The branch cut scheme is the same as Common Lisp.
For real numbers, it returns a positive root.
@c JP
複素数@var{z}の平方根のひとつを返します。枝刈りの定義はCommon Lispと同じです。
実数に対しては正の平方根を返します。
@c COMMON
@end defun

@defun expt z1 z2
[R5RS]
@c EN
Returns @var{z1}^@var{z2} (@var{z1} powered by @var{z2}),
where @var{z1} and @var{z2} are complex numbers.
@c JP
複素数@var{z1}, @var{z2}に対して、
@var{z1}^@var{z2} (@var{z1}の@var{z2}乗)を返します。
@c COMMON
@end defun

@node Numerical conversions, Bitwise operations, Arithmetics, Numbers
@subsection Numerical conversions
@c NODE 数値の変換

@defun make-rectangular x1 x2
@defunx make-polar x1 x2
[R5RS]
@c EN
Creates a complex number from two real numbers, @var{x1} and @var{x2}.
@code{make-rectangular} returns @var{x1} + @b{i}@var{x2}.
@code{make-polar} returns @var{x1}@b{e}^(@b{i}@var{x2}).
@c JP
二つの実数@var{x1}と@var{x2}から複素数を作ります。
@code{make-rectangular} は @var{x1} + @b{i}@var{x2} を返します。
@code{make-polar} は @var{x1}@b{e}^(@b{i}@var{x2}) を返します。
@c COMMON
@end defun

@defun real-part z
@defunx imag-part z
@defunx magnitude z
@defunx angle z
[R5RS]
@c EN
Decompose a complex number @var{z} and returns a real number.
@code{real-part} and @code{imag-part} return @var{z}'s real and imaginary
part, respectively.  @code{magnitude} and @code{angle} return
@var{z}'s magnitude and angle, respectively.
@c JP
複素数@var{z}を取り、実数を返します。
@code{real-part}と@code{imag-part}は@var{z}の実数部と虚数部をそれぞれ返し、
@code{magnitude}と@code{angle}は@var{z}の絶対値と偏角をそれぞれ返します。
@c COMMON
@end defun

@defun exact->inexact z
@defunx inexact->exact z
[R5RS]
@c EN
Converts an exact number to an inexact number, or vice versa.

Since Gauche doesn't support general rational numbers, 
the result of @code{inexact->exact} is always a whole number.
If the passed number is not an integer, the fraction part is
rounded.  Note that it is an implementation dependent behavior.
If you want to get a closest exact integer of the given inexact
real number, it's better to use @code{round} explicitly before
@code{inexact->exact}.

If you pass an inexact number to @code{exact->inexact} or
an exact number to @code{inexact->exact}, Gauche returns
the argument as is, instead of reporting an error.
This is also an implementation dependent behavior and
you shouldn't count on that.
@c JP
正確な数を不正確な数に変換、またその逆を行う手続きです。

Gaucheは一般的な有理数をサポートしないため、@code{inexact->exact}の結果は
常に整数となります。整数でない数を渡した場合は小数点以下が丸められます。但しこれは
実装依存の振舞いなので、ポータブルなプログラムで不正確な実数を正確な整数に丸めたい
時には@code{inexact->exact}の前に明示的に@code{round}を使うべきでしょう。

不正確な数を@code{exact->inexact}に渡したり、または正確な数を
@code{inexact->exact}に渡した場合、Gaucheでは今のところエラーにならず
引数がそのまま返されます。これも実装依存の振舞いなのでなるべく避けるようにして下さい。
@c COMMON
@end defun

@defun number->string z &optional radix use-upper?
@defunx string->number string &optional radix
[R5RS+]
@c EN
These procedurs convert a number and its string representation
in radix @var{radix} system.
@var{radix} must be between 2 and 36 inclusive.
If @var{radix} is omitted, 10 is assumed.

@code{Number->string} takes a number @var{z} and returns a string.
If @var{z} is not an exact integer, @var{radix} must be 10.
For the numbers with radix more than 10, lower case alphabet
character is used for digits, unless the optional argument
@var{use-upper?} is true, in that case upper case characters are used.
The argument @var{use-upper?} is Gauche's extension.

@code{String->number} takes a string @var{string} and parses it
as a number in radix @var{radix} system.  If the number looks like
non-exact number, only radix 10 is allowed.  If the given string
can't be a number, @code{#f} is returned.
@c JP
これらの手続きは数値とそれを@var{radix}進数で表現する文字列とを変換します。
@var{radix}は2から36の間でなければなりません。省略された場合は10進数とみなされます。

@code{number->string}は数値@var{z}を取り文字列を返します。
@var{z}が正確な整数以外の場合、@var{radix}は10でなければなりません。
10より大きい@var{radix}に関しては、小文字のアルファベットが桁として使われます。
但し、省略可能な引数@var{use-upper?}に真の値が与えられた場合は大文字のアルファベットが
使われます。@var{use-upper?}引数はGaucheの拡張です。

@code{string->number}は文字列@var{string}を取り数値を返します。
不正確な数値は10進数表記しか認識されません。与えられた文字列が数値を構成しない
場合は@code{#f}が返されます。
@c COMMON
@end defun

@deffn {Generic Function} x->number obj
@deffnx {Generic Function} x->integer obj
@c EN
Generic coercion functions.  Returns `natural' interpretation of @var{obj}
as a number or an exact integer, respectively.
The default methods are defined for numbers and strings; a string is
interpreted by @var{string->number}, and if the string can't be
interpreted as a number, 0 is returned.
Other @var{obj} is simply converted to 0.
If @var{obj} is naturally interpreted
as a number that is not an exact integer, @code{x->integer} uses
@code{round} and @code{inexact->exact} to obtain an integer.

Other class may provide a method to customize the behavior.
@c JP
数値への強制型変換手続きです。
@var{obj}をそれぞれ数値もしくは正確な整数と解釈して返します。
数値と文字列に対してのメソッドは定義されています
(文字列は@var{string->number}を使って変換されます。
数値として解釈できない文字列に関しては0が返されます)。
その他の@var{obj}については単に0が返されます。
@code{x->integer}は、@var{obj}が数値として表現できるけれど正確な整数では
ない場合、@code{round}と@code{inexact->exact}によって正確な整数に変換します。

他のクラスはこのメソッドを定義することにより、独自の変換関数を提供することができます。
@c COMMON
@end deffn

@node Bitwise operations,  , Numerical conversions, Numbers
@subsection Bitwise operations
@c NODE ビット演算

@c EN
These procedures treat integers as half-open bit vectors.
If an integer is positive, it is regarded as if infinite number
of zeros are padded to the left.  If an integer is negative,
it is regarded in 2's complement form, and infinite number of
1's are padded to the left.
@c JP
これらの手続きは整数を半無限のビットベクタとして扱います。
正の整数の場合、数値の左側に無限に0が続いていると見倣されます。
負の整数の場合、数値は2の補数で表現され、左側に無限に1が続いていると見倣されます。
@c COMMON

@c EN
The API is consisntent to SLIB's ``logical'' module.
@c JP
APIはSLIBの``logical''モジュールに合わせてあります。
@c COMMON

@defun ash n count
@c EN
Shifts integer @var{n} left with @var{count} bits.
If @var{count} is negative, @code{ash} shifts @var{n} right with
@minus{}@var{count} bits.
@c JP
整数@var{n}を左に整数@var{count}ビットだけシフトします。
@var{count}が負であれば、@minus{}@var{count}だけ@var{n}を右にシフトします。
@c COMMON

@example
; @r{Note: 6  @equiv{} [...00110], and}
; @r{      -6 @equiv{} [...11010]}
(ash 6 2)   @result{} 24  ;@r{[...0011000]}
(ash 6 -2)  @result{} 1   ;@r{[...0000001]}
(ash -6 2)  @result{} -24 ;@r{[...1101000]}
(ash -6 -2) @result{} -2  ;@r{[...1111110]}
@end example
@end defun
        
@defun logand n1 n2 @dots{}
@defunx logior n1 n2 @dots{}
@defunx logxor n1 n2 @dots{}
@c EN
Returns bitwise and, bitwise inclusive or and bitwise exclusive or
of two or more integers @var{n1}, @var{n2} @dots{}.
@c JP
2つ以上の整数@var{n1}, @var{n2} @dots{}の、それぞれ論理和、論理積、
排他的論理積を返します。
@c COMMON
@end defun

@defun lognot n
@c EN
Returns bitwise not of an integer @var{n}.
@c JP
整数@var{n}のビット否定を返します。
@c COMMON
@end defun

@defun logtest n1 n2 @dots{}
 @equiv{} @code{(not (zero? (logand @var{n1} @var{n2} @dots{})))}
@end defun

@defun logbit? index n
@c EN
Returns @code{#t} if @var{index}-th bit of integer @var{n} is 1, 
@var{#f} otherwise.
@c JP
整数@var{n}の@var{index}目のビットが1ならば@code{#t}を、0ならば@code{#f}を
返します。
@c COMMON
@end defun

@defun bit-field n start end
@c EN
@c JP
@c COMMON
@end defun

@defun copy-bit index n bit
@c EN
@c JP
@c COMMON
@end defun

@defun copy-bit-field n start end from
@c EN
@c JP
@c COMMON
@end defun

@defun logcount n
@c EN
@c JP
@c COMMON
@end defun

@defun integer-length n
@c EN
@c JP
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Booleans, Pairs and Lists, Numbers, Core library
@section Booleans
@c NODE 論理値

@deftp {Builtin Class} <boolean>
@clindex boolean
@c EN
A boolean class.  Only @code{#t} and @code{#f} belong to this class.
@c JP
論理値のクラスです。@code{#t}と@code{#f}のみがこのクラスのインスタンスです。
@c COMMON
@end deftp

@defun not obj
[R5RS]
@c EN
Returns @code{#t} if and only if @var{obj} is @code{#t},
and returns @code{#f} otherwise.
@c JP
@var{obj}が@code{#f}の時のみ@code{#t}を返し、それ以外の場合は@code{#f}を
返します。
@c COMMON
@end defun

@defun boolean? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a boolean value.
@c JP
@var{obj}が論理値である場合に@code{#t}を返します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Pairs and Lists, Symbols, Booleans, Core library
@section Pairs and Lists
@c NODE ペアとリスト

@menu
* Pair and null class::         
* List predicates::             
* List constructors::           
* List accessors and modifiers::  
* Other list procedures::       
@end menu

@node Pair and null class, List predicates, Pairs and Lists, Pairs and Lists
@subsection Pair and null class
@c NODE pairクラスとnullクラス

@deftp {Builtin Class} <list>
@clindex list
@c EN
An abstract class respresents lists.   A parent class of @code{<null>}
and @code{<pair>}.   Inherits @code{<sequence>}.

Note that a cirular list is also an instance of the @code{<list>} class,
while R5RS procedure @code{list?} returns false on the circular lists and
dotted lists.
@c JP
リストを表す抽象クラスで、クラス@code{<null>}とクラス@code{<pair>}の親クラスです。
クラス@code{<sequence>}を継承します。

循環リストやドットリストも@code{<list>}クラスのインスタンスですが、
@code{list?}は偽の値を返すことに注意して下さい。
@c COMMON
@lisp
(use srfi-1)
(list? (circular-list 1 2)) @result{} #f
(is-a? (circular-list 1 2) <list>) @result{} #t
@end lisp
@end deftp

@deftp {Builtin Class} <null>
@clindex null
@c EN
A class of empty list.  @code{()} is the only instance.
@c JP
空リストのクラスです。@code{()}がこのクラスの唯一のインスタンスです。
@c COMMON
@end deftp

@deftp {Builtin Class} <pair>
@clindex pair
@c EN
A class of pairs.
@c JP
ペアのクラスです。
@c COMMON
@end deftp

@node List predicates, List constructors, Pair and null class, Pairs and Lists
@subsection List predicates
@c NODE リストに関する述語

@defun pair? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a pair, @code{#f} otherwise.
@c JP
@var{obj}がペアなら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun null? obj
[R5RS] 
@c EN
Returns @code{#t} if @var{obj} is an empty list, @code{#f} otherwise.
@c JP
@var{obj}が空リストなら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun list? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a proper list, @code{#f} otherwise.
This function returns @code{#f} if @var{obj} is a dotted or circular list.

See also @code{proper-list?}, @code{circular-list?} and
@code{dotted-list?} in @ref{SRFI-1 List predicates}.
@c JP
@var{obj}が正しいリストなら@code{#t}を、そうでなければ@code{#f}を返します。
この手続きは@var{obj}がドットリストや循環リストなら@var{#f}を返します。

SRFI-1(@ref{SRFI-1 List predicates})には更に、
@code{proper-list?}、@code{circular-list?}、@code{dotted-list?}
といった手続きが定義されています。
@c COMMON
@end defun

@node List constructors, List accessors and modifiers, List predicates, Pairs and Lists
@subsection List constructors
@c NODE リストの作成

@defun cons obj1 obj2
[R5RS] 
@c EN
Constructs a pair of @var{obj1} and @var{obj2} and returns it.
@c JP
@var{obj1}と@var{obj2}のペアを作成します。
@c COMMON
@lisp
(cons 'a 'b) @result{} (a . b)
@end lisp
@end defun

@defun acons obj1 obj2 obj3
@c EN
Returns @code{(cons (cons @var{obj1} @var{obj2}) @var{obj3})}.
Useful to put an entry at the head of an associative list.
@c JP
@code{(cons (cons @var{obj1} @var{obj2}) @var{obj3})} を返します。
連想リストの先頭に新しいエントリを加えるのに便利です。
@c COMMON
@lisp
(acons 'a 'b '((c . d))) @result{} ((a . b) (c . d))
@end lisp
@end defun

@defun make-list len &optional fill
[SRFI-1]
@c EN
Makes a proper list of length @var{len}.  If optional argument
@var{fill} is provided, each element is initialized by it.  Otherwise
each element is undefined.
@c JP
長さ@var{len}の正規のリストを返します。引数@var{fill}が与えられていれば、各要素は
@var{fill}になります。そうでなければ各要素の値は不定です。
@c COMMON
@lisp
(make-list 5 #t) @result{} (#t #t #t #t #t)
@end lisp
@end defun

@defun list obj @dots{}
[R5RS]
@c EN
Makes a list, whose elements are @var{obj} @dots{}.
@c JP
要素が@var{obj} @dots{}であるリストを作成します。
@c COMMON
@lisp
(list 1 2 3) @result{} (1 2 3)
(list) @result{} ()
@end lisp
@end defun

@defun list* obj1 obj2 @dots{}
@c EN
Like @code{list}, but the last argument becomes cdr of the last pair.
SRFI-1 defines the same function with the name @code{cons*}.
@c JP
@code{list}とほぼ同じですが、最後の引数が作成されるリストの最後のペアのcdrになります。
SRFI-1ではこの手続きが@code{cons*}という名で定義されています。
@c COMMON
@lisp
(list* 1 2 3) @result{} (1 2 . 3)
(list* 1) @result{} 1
@end lisp
@end defun

@defun list-copy list
[SRFI-1]
@c EN
Shallow copies @var{list}.  If @var{list} is circular,
this function diverges.
@c JP
@var{list}の浅いコピーを行います。
@var{list}が循環リストの場合、この手続きは停止しません。
@c COMMON
@end defun


@node List accessors and modifiers, Other list procedures, List constructors, Pairs and Lists
@subsection List accessors and modifiers
@c NODE リストへのアクセスと変更

@defun car pair
@defunx cdr pair
[R5RS] 
@c EN
Returns car and cdr of @var{pair}, respectively.
@c JP
それぞれ@var{pair}のcarとcdrを返します。
@c COMMON
@end defun

@defun set-car! pair obj
@defunx set-cdr! pair obj
[R5RS] 
@c EN
Modifies car and cdr of @var{pair}, by @var{obj}, respectively.

Note: @code{(setter car)} @equiv{} @code{set-car!}, and
@code{(setter cdr)} @equiv{} @code{set-cdr!}.
@c JP
@var{pair}のcarもしくはcdrを@var{obj}で置き換えます。

注： @code{(setter car)} @equiv{} @code{set-car!} であり、
@code{(setter cdr)} @equiv{} @code{set-cdr!} です。
@c COMMON
@end defun

@defun caar pair
@defunx cadr pair
@defunx cdar pair
@defunx cddr pair
@defunx caaar pair
@defunx caadr pair
@defunx cadar pair
@defunx caddr pair
@defunx cdaar pair
@defunx cdadr pair
@defunx cddar pair
@defunx cdddr pair
@defunx caaaar pair
@defunx caaadr pair
@defunx caadar pair
@defunx caaddr pair
@defunx cadaar pair
@defunx cadadr pair
@defunx caddar pair
@defunx cadddr pair
@defunx cdaaar pair
@defunx cdaadr pair
@defunx cdadar pair
@defunx cdaddr pair
@defunx cddaar pair
@defunx cddadr pair
@defunx cdddar pair
@defunx cddddr pair
[R5RS]
@c EN
@code{caar} @equiv{} @code{(car (car x))},
@code{cadr} @equiv{} @code{(car (cdr x))}, and so on.

The corresponding setters are also defined.
@c JP
@code{caar} @equiv{} @code{(car (car x))},
@code{cadr} @equiv{} @code{(car (cdr x))}, 等々。

対応するsetterも定義されています。
@c COMMON
@example
(let ((x (list 1 2 3 4 5)))
  (set! (caddr x) -1)
  x)
  @result{} (1 2 -1 4 5)
@end example
@end defun

@defun length list
[R5RS]
@c EN
Returns the length of a proper list @var{list}.
If @var{list} is a dotted list, an error is signalled.
If @var{list} is a circular list, this function diverges.

If you want to handle circular lists as well, 
See @code{length+} in @ref{SRFI-1 List miscellaneous routines}.
@c JP
正規のリスト@var{list}の長さを返します。
@var{list}がドットリストならばエラーが起きます。
@var{list}が循環リストの場合、この関数は無限ループします。

循環リストも取り扱う場合は、SRFI-1の@code{length+}を使って下さい
(@ref{SRFI-1 List miscellaneous routines}参照)。
@c COMMON
@end defun

@defun list-tail list k
[R5RS]
@c EN
Returns @var{k}-th cdr of @var{list}.
@var{list} can be a proper, dotted or circular list.
@c JP
@var{list}の@var{k}番目のcdrを返します。@var{list}は
正規のリストでもドットリストでも循環リストでも構いません。
@c COMMON
@end defun

@defun list-ref list k &optional fallback
[R5RS+]
@c EN
Returns @var{k}-th element of @var{list}.
@var{list} can be a proper, dotted or circular list.

By default, @code{list-ref} signals an error if @var{k} is
negative, or greater than or equal to the length of @var{list}.
However, if an optional argument @var{fallback} is given,
it is returned for such case.  This is an extension of Gauche.
@c JP
@var{list}の@var{k}番目の要素を返します。@var{list}は
正規のリストでもドットリストでも循環リストでも構いません。

もし@var{k}がリストの長さを超えていたり、負数であった場合は通常はエラーが起こります。
しかし、オプショナルな引数@var{fallback}が与えられていた場合は、エラーは起きず
@var{fallback}が返されます。これはGaucheの拡張です。
@c COMMON
@end defun

@defun last-pair list
[SRFI-1]
@c EN
Returns the last pair of @var{list}.
@var{list} can be a proper or dotted list.
@c JP
@var{list}の最後のペアを返します。@var{list}は
正規のリストかドットリストです。
@c COMMON
@end defun

@node Other list procedures,  , List accessors and modifiers, Pairs and Lists
@subsection Other list procedures
@c NODE 他のリスト手続き

@defun append list @dots{}
[R5RS]
@c EN
Returns a list consisting of the elements of the first @var{list} followed by
the elements of the other lists.  The resulting list is always newly
allocated, except that it shares structure with the last list argument.
The last argument may actually be any object; an improper list results
if the last argument is not a proper list. 
@c JP
渡されたリストの要素を繋げたリストを返します。最後の引数の部分以外は新しいセルがアロケート
されて使われます。最後の引数は正規のリストである必要がありません。その場合、結果は正規でない
リストとなります。
@c COMMON
@end defun

@defun append! list @dots{}
[SRFI-1]
@c EN
Returns a list consisting of the elements of the first @var{list} followed by
the elements of the other lists.  The cells in the lists except the last
one may be reused to construct the result.   The last argument may be
any object.
@c JP
渡されたリストの要素を繋げたリストを返します。最後の引数以外のリストのセルは、結果を
作成するために再利用されるかもしれません。
最後の引数は正規のリストである必要はありません。
@c COMMON
@end defun


@defun reverse list
[R5RS]
@c EN
Returns a newly allocated list consisting of the elements of @var{list}
in reverse order.
@c JP
@var{list}の各要素を逆順に持つリストを新しく作成して返します。
@c COMMON
@end defun

@defun reverse! list
[SRFI-1]
@c EN
Returns a list consisting of the elements of @var{list} in reverse order.
The cells of @var{list} may be reused to construct the returned list.
@c JP
@var{list}の各要素を逆順に持つリストを返します。結果を作成するために、
@var{list}のセルは再利用されるかもしれません。
@c COMMON
@end defun

@defun memq obj list
@defunx memv obj list
[R5RS]
@c EN
Searches @var{obj} in the @var{list}.  If @code{n}-th element of
@var{list} equals to @var{obj} (in the sense of @code{eq?} for @code{memq},
@code{eqv?} for @code{memv}), @code{(list-tail @var{list} @var{n})} is
returned.   Otherwise, @code{#f} is returned.
@c JP
@var{list}から@var{obj}を探します。もし@var{list}の@var{n}番目の要素が
@var{obj}と同一ならば、@code{(list-tail @var{list} @var{n})}を返します。
@code{memq}は同一性の判定に@code{eq?}を、@code{memv}は@code{eqv?}を使います。
@var{obj}が@var{list}中に見つからなければ@code{#f}が返されます。
@c COMMON

@example
(memq 'a '(a b c))          @result{} (a b c)
(memq 'b '(a b c))          @result{}  (b c)
(memq 'a '(b c d))          @result{} #f
(memq (list 'a) '(b (a) c)) @result{} #f
(memv 101 '(100 101 102))   @result{} (101 102)
@end example
@end defun

@defun member obj list [=]
[R5RS+][SRFI-1]
@c EN
@c JP
@c COMMON
@end defun

@defun assq obj list
@defunx assv obj list
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun assoc obj list [=]
[R5RS+][SRFI-1]
@c EN
@c JP
@c COMMON
@end defun


@c ----------------------------------------------------------------------
@node Symbols, Keywords, Pairs and Lists, Core library
@section Symbols
@c NODE シンボル

@deftp {Builtin Class} <symbol>
@clindex symbol
@c EN
A class for symbols.

In Gauche, all symbols are @emph{interned}, i.e. two symbols with
the same print name are always @code{eq?}.
@c JP
シンボルを表すクラスです。

Gaucheでは、全てのシンボルはintern、すなわち内部のテーブルに登録されています。
そのため、同じ外部表記を持つシンボルは常に@code{eq?}です。
@c COMMON
@end  deftp

@deftp {Reader Syntax} @code{|@i{name}|}
@c EN
Denotes a symbol that has weird name, i.e. the name including the
characters which is not allowed in the R5RS symbol syntax.
If the interpreter is running in case-insensitive mode, this syntax
can be used to include uppercase characters in a symbol
(@xref{Case-sensitivity}).

The syntax is taken from CommonLisp.  Some other Scheme implementation
use it as well.
@c JP
R5RSのシンボルの定義では許されていない文字を使った妙な名前のシンボルを表記するのに
使う構文です。インタプリタが大文字小文字を区別しないモードで走っている場合は、
大文字を含むシンボルを表記するときにも使えます (@ref{Case-sensitivity}参照)。

この表記はCommonLispから取られました。いくつかのSchemeでも同様の表記を採用しています。
@c COMMON
@end deftp

@defun symbol? obj
[R5RS] 
@c EN
Returns true if and only if @var{obj} is a symbol.
@c JP
@var{obj}がシンボルなら@code{#t}を返します。
@c COMMON
@example
(symbol? 'abc)     @result{} #t
(symbol? 0)        @result{} #f
(symbol? 'i)       @result{} #t
(symbol? '-i)      @result{} #f
(symbol? '|-i|)    @result{} #t
@end example
@end defun

@defun symbol->string symbol
[R5RS]
@c EN
Returns the name of @var{symbol} in a string.  Returned
string is immutable.
@c JP
@var{symbol}の名前を文字列で返します。返される文字列は変更不可です。
@c COMMON

@example
(symbol->string 'foo) @result{} foo
@end example
@end defun

@defun string->symbol string
[R5RS]
@c EN
Returns a symbol whose name is a string @var{string}.
@var{String} may contain weird characters.
@c JP
文字列@var{string}を名前に持つシンボルを返します。
@c COMMON

@example
(string->symbol "a") @result{} a
(string->symbol "A") @result{} A
(string->symbol "weird symbol name" @result{} |weird symbol name|
@end example
@end defun

@defun gensym &optional prefix
@end defun

@c ----------------------------------------------------------------------
@node Keywords, Identifiers, Symbols, Core library
@section Keywords
@c NODE キーワード

@deftp {Builtin Class} <keyword>
@clindex keyword
@end  deftp

@defun keyword? obj
@end defun

@defun make-keyword name
@end defun

@defun get-keyword key list [fallback]
@end defun

@c ----------------------------------------------------------------------
@node Identifiers, Characters, Keywords, Core library
@section Identifiers
@c NODE Identifier

@deftp {Builtin Class} <identifier>
@clindex identifier
@end  deftp

@defun identifier? obj
@end defun

@defun identifier->symbol identiifer
@end defun


@c ----------------------------------------------------------------------
@node Characters, Character set, Identifiers, Core library
@section Characters
@c NODE 文字

@deftp {Builtin Class} <char>
@clindex char
@end  deftp

@deftp {Reader Syntax} @code{#\@i{charname}}
[R5RS]
@c EN
Denotes a literal character.

When the reader reads @code{#\}, it fetches a sbusequent character.
If it is one of @code{()[]@{@}" \|;#}, this is a character literal of itself.
Otherwise, the reader reads subsequent characters until it sees
a non word-constituent character.  If only one character is read,
it is the character.  Otherwise, the reader matches the read characters
with predefined character names.  If it doesn't match any, an error
is signalled.

The following character names are recognized.
These haracter names are case insensitive.
@table @code
@item space
Whitespace (ASCII #x20)
@item newline, nl, lf
Newline (ASCII #x0a)
@item return, cr
Carriage return (ASCII #x0d)
@item tab, ht
Horizontal tab (ASCII #x09)
@item page
Form feed (ASCII #x0c)
@item escape, esc
Escape (ASCII #x1b)
@item delete, del
Delete (ASCII #x7f)
@item null
NUL character (ASCII #x00)
@item x@var{N}
A character whose internal encoding is the integer @var{N},
when @var{N} is a hexadecimal integer.
Note that this notation is not portable among different
internal encoding schemes except ASCII character range.
@end table
@c JP
リテラルの文字オブジェクトを表現します。

リーダーは@code{#\}に出会うと、まず次の文字を読み込みます。それが文字
@code{()[]@{@}" \|;#} のいずれかならば、その文字自身となります。
そうでなければ、単語を構成しない文字に出会うまで文字が続けて読み込まれます。
もし一文字しか読まれなければ、その文字自身となります。そうでなければ
その単語が文字の名前として解釈されます。
それが有効な文字の名前でなければエラーとなります。

以下の文字の名前が認識されます。これらの文字の名前は大文字小文字を区別しません。
@table @code
@item space
スペース (ASCII #x20)
@item newline, nl, lf
改行文字 (ASCII #x0a)
@item return, cr
復帰文字 (ASCII #x0d)
@item tab, ht
水平タブ (ASCII #x09)
@item page
フォームフィード、改ページ (ASCII #x0c)
@item escape, esc
エスケープ (ASCII #x1b)
@item delete, del
デリート (ASCII #x7f)
@item null
NUL文字 (ASCII #x00)
@item x@var{N}
@var{N} が16進表記の整数であるとき、内部エンコーディングが整数@var{N}
であるような文字。この表記はASCII文字の範囲の外では、内部エンコーディングが異なる
処理系間で互換性が無いことに注意。
@end table
@c COMMON

@c EN
You can denote multibyte characters with this syntax if
the program text is written in the same encoding as the internal
character encoding.
@c JP
プログラムテキストがGaucheの内部エンコーディングと同じエンコーディングで
書かれていれば、マルチバイト文字を直接表記することもできます。
@example
#\あ @result{} ; @r{文字「あ」}
@end example
@c COMMON
@end deftp

@defun char? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a character, @code{#f} otherwise.
@c JP
@var{obj}が文字なら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun char@code{=}? char1 char2
@defunx char@code{<}? char1 char2
@defunx char@code{<=}? char1 char2
@defunx char@code{>}? char1 char2
@defunx char@code{>=}? char1 char2
[R5RS]
@c EN
Compares characters.  Character comparison is done in internal
character encoding.
@c JP
文字を比較します。比較は内部の文字エンコーディングで行われます。
@c COMMON
@end defun

@defun char-ci@code{=}? char1 char2
@defunx char-ci@code{<}? char1 char2
@defunx char-ci@code{<=}? char1 char2
@defunx char-ci@code{>}? char1 char2
@defunx char-ci@code{>=}? char1 char2
[R5RS]
@c EN
Compares characters in case-insensitive way.
In the current version, character cases are not well defined
outside the ASCII character range.
@c JP
文字を、大文字小文字を区別せずに比較します。
現在のバージョンではASCII文字の範囲外における大文字小文字の扱いが
きちんと定義されていないことに注意して下さい。
@c COMMON
@end defun

@defun char-alphabetic? char
@defunx char-numeric? char
@defunx char-whitespace? char
@defunx char-upper-case? char
@defunx char-lower-case? char
[R5RS]
@end defun

@defun char->integer char
@defunx integer->char n
[R5RS]
@c EN
@var{char->integer} returns an exact integer that represents
internal encoding of the character @var{char}.
@var{integer->char} returns a character whose internal encoding
is an exact integer @var{n}.  The following expression is always
true for valid charcter @var{char}:
@example
(eq? char (integer->char (char->integer char)))
@end example

The result is undefined if you pass @var{n} to @var{integer->char}
that doesn't have a corresponding character.
@c JP
@var{char->integer}は文字@var{char}の内部エンコーディングに対応する
整数値を返します。@var{integer->char}は数値@var{n}と内部エンコーディングが
同じ文字を返します。有効な文字@var{char}に対して以下の式は常に真となります。
@example
(eq? char (integer->char (char->integer char)))
@end example

対応する内部エンコーディングを持つ文字が無い数値を@var{integer->char}に渡した
場合の結果は不定です。
@c COMMON
@end defun

@defun char-upcase char
@defunx char-downcase char
[R5RS]
@c EN
Returns the upper case and lower case of @var{char}, respectively.
If @var{char} doesn't have such distinction of upper or lower case,
@code{char} itself is returned.

In the current version, character cases are not well defined
outside the ASCII character range.
@c JP
@var{char}の大文字と小文字をそれぞれ返します。@var{char}に大文字小文字の区別が
無ければ@var{char}がそのまま返されます。

現在のバージョンではASCII文字の範囲外における大文字小文字の扱いが
きちんと定義されていないことに注意して下さい。
@c COMMON
@end defun

@defun digit->integer char &optional (radix 10)
@c EN
If given character @var{char} is a valid digit character in radix
@var{radix} number, the corresponding integer is returned.  Otherwise
@code{#f} is returned.
@c JP
文字@var{char}が @var{radix}進数の数字を構成するのに有効な文字であれば、
対応する整数が、そうでなければ@code{#f}が返されます。
@c COMMON
@example
(digit->integer #\4) @result{} 4
(digit->integer #\e 16) @result{} 14
(digit->integer #\9 8) @result{} #f
@end example
@c EN
Note: CommonLisp has a similar function in rather confusing name,
@code{digit-char-p}.
@c JP
Common Lispには同様の手続きが@code{digit-char-p}というやや曖昧な名で定義されています。
@c COMMON
@end defun

@defun integer->digit integer &optional (radix 10)
@c EN
Reverse operation of @code{digit->integer}.  Returns a character that
represents the number @var{integer} in the radix @var{radix} system.
If @var{integer} is out of the valid range, @code{#f} is returned.
@c JP
@code{digit->integer}の逆です。整数@var{integer}を @var{radix}進数 ひと桁で
表現するのに使われる文字を返します。@var{integer}がひと桁で表現できない数値の場合は
@code{#f}が返されます。
@c COMMON
@example
(integer->digit 13 16) @result{} #\d
(integer->digit 10) @result{} #f
@end example
@c EN
Note: CommonLisp's @code{digit-char}.
@c JP
Common Lispの@code{digit-char}に当たります。
@c COMMON
@end defun

@defun gauche-character-encoding
@c EN
Returns a symbol designates the native character encoding, selected
at the compile time.
The possible return values are those:
@c JP
コンパイル時に選択された内部文字エンコーディングを表すシンボルを返します。
返される値は以下のいずれかです。
@c COMMON
@table @code
@item euc-jp
EUC-JP
@item utf-8
UTF-8
@item sjis
Shift JIS
@item none
No multibyte character support (8-bit fixed-length character).
@end table
@end defun

@defun supported-character-encodings
Returns a list of string names of character encoding schemes
that are supported in the native multibyte encoding scheme.
@end defun



@c ----------------------------------------------------------------------
@node Character set, Strings, Characters, Core library
@section Character Set
@c NODE 文字集合

@deftp {Builtin Class} <char-set>
@clindex char-set
@c EN
Character set class.  Character set object represents a set of characters.
Gauche provides built-in support of character set creation and
a predicate that tests whether a character is in the set or not.

Further operations, such as set algebra, is defined in SRFI-14
module (@xref{Character-set library}).
@c JP
文字の集合を取り扱う、文字集合(キャラクタセット)のクラスです。
Gaucheは文字集合オブジェクトのサポートと、
ある文字がその集合に属するかどうかを調べる手続きを言語組み込みで持っています。

文字集合に関する他の操作、例えば集合演算などは、SRFI-14モジュール
(@ref{Character-set library}参照) で提供されています。
@c COMMON
@end deftp

@deftp {Reader Syntax} @code{#[@i{char-set-spec}]}
@c EN
You can write a literal character set in this syntax.
@i{char-set-spec} is a sequence of characters to be included
in the set.  You can include the following special sequences:
@table @code
@item @var{x}-@var{y}
Characters between @var{x} and @var{y}, inclusive.
@var{x} must be smaller than @var{y} in the internal encoding.
@item ^
If @i{char-set-spec} begins with caret, the actual character set
is a complement of what the rest of @i{char-set-spec} indicates.
@item \x@var{NN}
A character whose internal code is a hexadecimal number @var{NN}.
@item \s
Whitespace characters.
@item \S
Complement of whitespace characters.
@item \d
Decimal digit characters.
@item \D
Complement of decimal digit characters.
@item \w
Alphanumeric characters.
@item \W
Complement of alphanumeric characters.
@item \\
A backslash character.
@item \-
A minus character.
@item \^
A caret character.
@end table

@example
#[aeiou]     ; @r{a character set consists of vowels}
#[a-zA-Z]    ; @r{alphabets}
#[\x0d\x0a]  ; @r{newline and carriage return}
#[\\\-]      ; @r{backslash and minus}
#[]          ; @r{empty charset}
@end example
@c JP
この構文で、リテラル文字集合を記述することができます。
@i{char-set-spec}には集合に含める文字を列挙します。
次の特殊なシーケンスを含めることができます。
@table @code
@item @var{x}-@var{y}
文字@var{x}と文字@code{y}の間の文字全て。@var{x}と@var{y}も含みます。
@var{x}は@var{y}よりも内部文字コードで比較して小さくなければなりません。
@item ^
カレットが@i{char-set-spec}の最初に来た場合、以降に示される文字集合の
補集合がこの文字集合となります。
@item \x@var{NN}
内部文字コード@var{NN}(16進数表記)の文字。
@item \s
空白文字。
@item \S
空白でない文字。(@code{\s}の補集合)
@item \d
10進数の数字
@item \D
@code{\d}の補集合
@item \w
アルファベットと数字
@item \W
@code{\w}の補集合
@item \\
バックスラッシュ文字
@item \-
マイナス文字
@item \^
カレット文字
@end table

@example
#[aeiou]     ; @r{母音文字'a', 'e', 'i', 'o', 'u'の集合}
#[a-zA-Z]    ; @r{アルファベット}
#[\x0d\x0a]  ; @r{改行とリターン}
#[\\\-]      ; @r{バックスラッシュとマイナス文字}
#[]          ; @r{空の文字集合}
#[ぁ-ん]     ; @r{平仮名の集合}
@end example
@c COMMON
@end deftp

@defun char-set? obj
[SRFI-14]
@c EN
Returns true if and only if @var{obj} is a character set object.
@c JP
@var{obj}が文字集合であれば真の値を返します。
@c COMMON
@end defun

@defun char-set-contains? char-set char
[SRFI-14]
@c EN
Returns true if and only if a character set object
@var{char-set} contains a character @var{char}.
@c JP
文字集合@var{char-set}が文字@var{char}を含んでいれば真の値を返します。
@c COMMON
@example
(char-set-contains? #[a-z] #\y) @result{} #t
(char-set-contains? #[a-z] #\3) @result{} #f

(char-set-contains? #[^ABC] #\A) @result{} #f
(char-set-contains? #[^ABC] #\D) @result{} #t

@c JP
(char-set-contains? #[あ-お] #\う) @result{} #t
(char-set-contains? #[あ-お] #\ぷ) @result{} #f
@c COMMON
@end example
@end defun

@defun char-set char @dots{}
[SRFI-14]
@c EN
Creates a character set that contains @var{char} @dots{}.
@c JP
文字@var{char} @dots{} からなる文字集合を作成して返します。
@c COMMON
@example
(char-set #\a #\b #\c)   @result{} #[a-c]
@c JP
(char-set #\あ #\い #\う) @result{} #[あいう]
@c COMMON
@end example
@end defun

@defun char-set-copy char-set
[SRFI-14]
@c EN
Copies a character set @var{char-set}.
@c JP
@var{char-set}のコピーを作って返します。
@c COMMON
@end defun


@c ----------------------------------------------------------------------
@node Strings, Regular expression, Character set, Core library
@section Strings
@c NODE 文字列

@deftp {Builtin Class} <string>
@clindex string
@c EN
A string class.   In Gauche, a string can be viewed in two ways:
a sequence of characters, or a sequence of bytes.
@c JP
文字列のクラスです。Gaucheでは、文字列は文字のシーケンスともバイトのシーケンスとも
みなすことができます。
@c COMMON
@end deftp

@c EN
R5RS string operations are very minimal.  Gauche supports some
extra built-in operations, and also a rich string library
defined in SRFI-13.   @xref{String library}, for details about SRFI-13.
@c JP
R5RSに定義されている文字列操作は非常に限られています。
Gaucheでは追加の組込み手続きのほか、
SRFI-13に定義されている豊富な文字列ライブラリを備えています。
SRFI-13については@ref{String library}を参照してください。
@c COMMON

@menu
* String Predicates::           
* String Constructors::         
* String Interpolation::        
* String Accessors & Modifiers::  
* String Comparison::           
* String utilities::            
* String Pointers::             
* Incomplete strings::          
@end menu

@node String Predicates, String Constructors, Strings, Strings
@subsection String Predicates
@c NODE 文字列に関する述語

@defun string? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a string, @code{#f} otherwise.
@c JP
@var{obj}が文字列なら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun string-immutable? obj
@c EN
Returns @code{#t} if @var{obj} is an immutable string, @code{#f} otherwise
@c JP
@var{obj}が変更不可な文字列なら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun string-incomplete? obj
Returns @code{#t} if @var{obj} is an incomplete string, @code{#f} otherwise
@end defun

@node String Constructors, String Interpolation, String Predicates, Strings
@subsection String Constructors
@c NODE 文字列の作成

@defun make-string k &optional char
[R5RS]
@c EN
Returns a string of length @var{k}.  If optional @var{char} is given,
the new string is filled with it.  Otherwise, the string is filled with
a whitespace.  The result string is always complete.

@example
(make-string 5 #\x) @result{} "xxxxx"
@end example

Note that the algorithm to allocate a string by @code{make-string} and
then fills it one character at a time is @emph{extremely} inefficient
in Gauche, and should be avoided.   That kind of algorithms unnecessarily
assumes underlying string allocation and representation mechanism,
which Gauche doesn't follow.
You can use an output string port for a string construction
(@xref{String ports}).
Even creating a list of characters and
using @code{list->string} is faster than using @code{make-string} and
@code{string-set!}.
@c JP
長さ@var{k}の文字列を作成して返します。
@var{char}が与えられればそれで内容を満たします。@var{char}が与えられなければ
空白文字で満たされます。常に完全な文字列が返されます。

@example
(make-string 5 #\x) @result{} "xxxxx"
(make-string 5 #\ふ) @result{} "ふふふふふ"
@end example

@code{make-string}で必要な長さの文字列をアロケートして、@code{string-set!}
で順番に埋めて行くアルゴリズムは、Gaucheでは@emph{極めて}非効率であることに
注意してください。そのようなアルゴリズムは、文字列の内部表現とアロケーションメカニズムに
関して不必要な仮定を置いており、Gaucheはその仮定とは合致しません。
文字列の順次作成に適しているのは文字列ポートです
(@ref{文字列ポート}参照)。それが使えない場合、
文字のリストを作成し、@code{list->string}で変換する方がまだ@code{make-string}と
@code{string-set!}を使うより良いでしょう。
@c COMMON
@end defun

@defun string char @dots{}
[R5RS]
@c EN
Returns a string consisted by @var{char} @dots{}.
@c JP
文字@var{char} @dots{} から構成された文字列を返します。
@c COMMON
@end defun

@deffn {Generic Function} x->string obj
@c EN
A generic coercion function.
Returns a string representation of @var{obj}.
The default methods are defined as follows: strings are returned
as is, numbers are converted by @code{number->string}, symbols are
converted by @code{symbol->string}, and other objects are
converted by @code{display}.

Other class may provide a method to customize the behavior.
@c JP
文字列への強制型変換手続きです。
@var{obj}の文字列表現を返します。
デフォルトのメソッドでは、文字列はそのまま返され、数値は@code{number->string}で、
シンボルは@code{symbol->string}で変換され、その他のオブジェクトは@code{display}表現
が使われます。

他のクラスはこのメソッドを定義することにより、独自の変換関数を提供することができます。
@c COMMON
@end deffn

@node String Interpolation, String Accessors & Modifiers, String Constructors, Strings
@subsection String Interpolation
@c NODE 文字列の補間

@c EN
The term "string interpolation" is used in various scripting languages
such as Perl and Python to refer to the feature to embed expressions
in a string literal, which are evaluated and then their results are
inserted into the string literal at run time.
@c JP
「文字列の補間(string interpolation)」という用語は、
PerlやPythonなど様々なスクリプト言語で、文字列リテラル内に式を埋め込んでおき
実行時に式を評価した値をそのリテラル内に埋め込む機能を指します。
@c COMMON

@c EN
Scheme doesn't define such a feature, but Gauche implements it as a
reader macro.
@c JP
Schemeはそのような機能を定義していませんが、Gaucheではリーダーマクロを使って
文字列の補間を実装しました。
@c COMMON

@deftp {Reader syntax} #`@var{string-literal}

@c EN
Evaluates to a string.  If @var{string-literal} contains the
character sequence @code{,@var{expr}}, where 
@var{expr} is a valid external representation
of a Scheme expression, @var{expr} is evaluated and
its result is inserted in the original place (by using @code{x->string},
see @ref{String Constructors}).
@c JP
文字列に評価されます。@var{string-literal}内に、@code{,@var{expr}}
というシーケンス(ここで@var{expr}は有効なScheme式の外部表現)が
現われたら、@var{expr}が評価されてその結果がもとの位置に埋め込まれます。
結果の文字列化には@code{x->string}が使われます(@ref{String Constructors}参照)。
@c COMMON

@c EN
The comma and the following expression must be adjacent (without containing
any whitespace characters), or it is not recognized as a special sequence.
@c JP
コンマと続く式とは、空白文字等を入れずに隣接していなければなりません。
そうでない場合は置換されません。
@c COMMON

@c EN
Two adjacent commas are converted to a single comma.  You can embed
a comma before a non-whitespace character in @var{string-literal}
by this.
@c JP
二つの連続するコンマは一つのリテラルのコンマ文字に置き換えられます。
これによって、コンマと非空白文字の連続を@var{string-literal}に入れることができます。
@c COMMON

@c EN
Other characters in the @var{string-literal} are copied as is.
@c JP
それ以外の@var{string-literal}内の文字シーケンスはそのままコピーされます。
@c COMMON

@c EN
If you use a variable as @var{expr} and need to delimit it from the
subsequent string, you can use the symbol escape syntax
using `|' character, as shown in the last two examples below.
@c JP
@var{Expr}に単独の変数を使う場合で、それに続く文字列と変数名を区切りたい
場合は、`|'文字を使ったシンボルエスケープ構文が使えます。下の例の最後の
2つを見て下さい。
@c COMMON

@example
#`"This is Gauche, version ,(gauche-version)."
 @result{} "This is Gauche, version @VERSION@."

#`"Date: ,(sys-strftime \"%Y/%m/%d\" (sys-localtime (sys-time)))"
 @result{} "Date: 2002/02/18"

(let ((a "AAA")
      (b "BBB"))
 #`"xxx ,a ,b zzz")
 @result{} "xxx AAA BBB zzz"

#`"123,,456,,789"
 @result{} "123,456,789"

(let ((n 5)) #`"R,|n|RS")
 @result{} "R5RS"

(let ((x "bar")) #`"foo,|x|.")
 @result{} "foobar"
@end example

@c EN
In fact, the reader expands this syntax into a macro call,
which is then expanded into a call of @code{string-append}
as follows:
@c JP
実は、リーダーはこの構文をマクロ呼び出しへと変換し、それが最終的には
@code{string-append}への呼び出しへと変換されます。
@c COMMON
@example
#`"This is Gauche, version ,(gauche-version)."
 @equiv{}
(string-append "This is Gauche, version "
               (x->string (gauche-version))
               ".")
@end example
@end deftp

@c EN
@emph{Rationale of the syntax:}
Some other scripting languages use `@code{$expr}' or '@code{#@{...@}}'.
I chose this syntax with respect to the quasiquote (@xref{Quasiquotation}).
Althogh it may be awkward to delimit variable names by `|',
the comma syntax should be easier to read than the other exotic syntax
for seasoned Scheme programmers.

Note that Scheme allows wider range of characters for valid identifier names
than usual scripting languages.
Consequently, you will almost always need to use `|' delimiters
when you interpolate the value of a variable.
For example, while you can write
@code{"$year/$month/$day $hour:$minutes:$seconds"} in Perl,
you should write @code{#`",|year|/,|month|/,day ,|hour|:,|minutes|:,seconds"}.
It may be better always to delimit direct variable references
in this syntax to avoid confusion.
@c JP
@emph{この構文を採用した理由:} 
他のスクリプト言語では、`@code{$expr}' や '@code{#@{...@}}' が良く使われています。
準クオート (@ref{Quasiquotation}参照) との類似性からこの構文を採用しました。
変数名の区切りを明確にするのに`|'を使う必要があるのは少々奇妙ですが、
慣れたSchemeプログラマならコンマ構文を読むのは他の言語から借りた構文よりも
楽だと思います。

Schemeは他のスクリプト言語より一般的により多くの文字を変数名に使うことが出来ることに注意して下さい。
結果として、変数の値を文字列に挿入する際、ほとんどの場合において変数名を`|'で区切る
必要があるでしょう。例えば、Perlでは
@code{"$year/$month/$day $hour:$minutes:$seconds"}
と書けたものが、Gaucheでは
@code{#`",|year|/,|month|/,day ,|hour|:,|minutes|:,seconds"}
と書かねばなりません。
混乱を避けるためには、この構文内では常に直接の変数参照は`|'で区切るようにしておくのが良いかもしれません。
@c COMMON

@node String Accessors & Modifiers, String Comparison, String Interpolation, Strings
@subsection String Accessors & Modifiers
@c NODE 文字列のアクセスと変更

@defun string-length string
[R5RS]
@c EN
Returns a length of (possibly incomplete) string @var{string}.
@c JP
文字列@var{string}の長さ(文字数)を返します。
@var{string}は不完全な文字列であっても構いません。
@c COMMON
@end defun

@defun string-size string
@c EN
Returns a size of (possibly incomplete) @var{string}.
A size of string is a number of bytes @var{string} occupies on memory.
The same string may have different sizes if the native encoding scheme
differs.

For incomplete string, its length and its size always match.
@c JP
文字列@var{string}の大きさを返します。文字列の大きさは、
@var{string}が占めるメモリ上のバイト数で、これは文字列の内部エンコーディングに
依存します。同じ文字列であっても内部エンコーディングが違えば違う大きさになる場合も
あります。

不完全な文字列では、文字列の長さと大きさは常に一致します。
@c COMMON
@end defun

@defun string-ref cstring k &optional fallback
[R5RS+]
@c EN
Returns @var{k}-th character of a complete string @var{cstring}.
It is an error to pass an incomplete string.

By default, an error is signalled if @code{k} is out of range
(negative, or greater than or equal to the length of @var{cstring}).
However, if an optional argument @var{fallback} is given,
it is returned in such case.  This is Gauche's extension.
@c JP
完全な文字列@var{cstring}の@var{k}番目の文字を返します。
不完全な文字列を渡すのはエラーです。

@var{k}が負数であったり@var{cstring}の長さと同じかそれ以上であった場合には
エラーが報告されます。但し、引数@var{fallback}が与えられている場合にはエラーを
報告せず@var{fallback}が返されます。これはGaucheの拡張です。
@c COMMON
@end defun

@defun string-byte-ref string k
Returns @var{k-th} byte of a (possibly incomplete) string @var{string}.
Returned value is an integer in the range between 0 and 255.
@var{k} must be greater than or equal to zero, and less than
@code{(string-size @var{string})}.
@end defun

@defun string-set! string k char
[R5RS] Substitute @var{string}'s @var{k}-th character by @var{char}.
@var{k} must be greater than or equal to zero, and less than
@code{(string-length @var{string})}.
Return value is undefined.

If @var{string} is an incomplete string, integer value of the lower 8 bits
of @var{char} is used to set @var{string}'s @var{k}-th byte.

See the notes in @code{make-string} about performance consideration.
@end defun

@defun string-byte-set! string k byte
Substitute @var{string}'s @var{k}-th byte by integer @var{byte}.
@var{byte} must be in the range between 0 to 255, inclusive.
@var{k} must be greater than or equal to zero, and less than
@code{(string-size @var{string})}.
If @var{string} is a complete string, it is turned to incomplete string
by this operation.
Return value is undefined.
@end defun

@node String Comparison, String utilities, String Accessors & Modifiers, Strings
@subsection String Comparison
@c NODE 文字列の比較

@defun string=? string1 string2
@defunx string-ci@code{=}? string1 string2
[R5RS]
@end defun

@defun string@code{<}? string1 string2
@defunx string@code{<=}? string1 string2
@defunx string@code{>}? string1 string2
@defunx string@code{>=}? string1 string2
@defunx string-ci@code{<}? string1 string2
@defunx string-ci@code{<=}? string1 string2
@defunx string-ci@code{>}? string1 string2
@defunx string-ci@code{>=}? string1 string2
[R5RS]
@end defun

@node String utilities, String Pointers, String Comparison, Strings
@subsection String utilities
@c NODE 文字列を扱うその他の手続き

@defun substring string start end
[R5RS]
@end defun

@defun string-append string @dots{}
[R5RS]
@end defun

@defun string->list string &optional start end
@defunx list->string list
[R5RS+][SRFI-13]
@end defun

@defun string-copy string &optional start end
[R5RS+][SRFI-13]
@end defun

@defun string-fill! string char &optional start end
[R5RS+][SRFI-13] Fills @var{string} by @var{char}.  Optional
@var{start} and @var{end} limits the effective area.
@example
(string-fill! "orange" #\X)
  @result{} "XXXXXX"
(string-fill! "orange" #\X 2 4)
  @result{} "orXXge"
@end example
@end defun

@defun string-join strs &optional delim grammer
[SRFI-13] Concatenate strings in the list @var{strs},
with a string @var{delim} as `glue'.

The argument @var{grammer} may be one of the following symbol
to specify how the strings are concatenated.
@table @code
@item infix
Use @var{delim} between each string.  This mode is default.
Note that this mode introduce ambiguity when @var{strs}
is an empty string or a list with a null string.
@example
(string-join '("apple" "mango" "banana") ", ") 
  @result{} "apple, mango, banana"
(string-join '() ":")
  @result{} ""
(string-join '("") ":")
  @result{} ""
@end example
@item strict-infix
Works like @code{infix}, but empty list is not allowed to @var{strs},
thus avoiding ambiguity.
@item prefix
Use @var{delim} before each string.
@example
(string-join '("usr" "local" "bin") "/" 'prefix)
  @result{} "/usr/local/bin"
(string-join '() "/" 'prefix)
  @result{} ""
(string-join '("") "/" 'prefix)
  @result{} "/"
@end example
@item suffix
Use @var{delim} after each string.
@example
(string-join '("a" "b" "c") "&" 'suffix)
  @result{} "a&b&c&"
(string-join '() "&" 'suffix)
  @result{} ""
(string-join '("") "&" 'suffix)
  @result{} "&"
@end example
@end table

@end defun

@defun string-scan string item &optional return
Scan @var{item} (either a string or a character) in @var{string}.
The @var{return} argument specifies what value should be returned
when @var{item} is found in @var{string}.  It must be one of the
following symbols.

@table @code
@item index
Returns the index in @var{string} if @var{item} is found, or @code{#f}.
This is the default behavior.
@example
(string-scan "abracadabra" "ada") @result{} 5
(string-scan "abracadabra" #\c) @result{} 4
(string-scan "abracadabra" "aba") @result{} #f
@end example
@item before
Returns a substring of @var{string} before @var{item}, or
@code{#f} if @var{item} is not found.
@example
(string-scan "abracadabra" "ada" 'before) @result{} "abrac"
(string-scan "abracadabra" #\c 'before) @result{} "abra"
@end example
@item after
Returns a substring of @var{string} after @var{item}, or
@code{#f} if @var{item} is not found.
@example
(string-scan "abracadabra" "ada" 'after) @result{} "bra"
(string-scan "abracadabra" #\c 'after) @result{} "adabra"
@end example
@item before*
Returns a substring of @var{string} before @var{item}, and
the substring after it.  If @var{item} is not found, returns
@code{(values #f #f)}.
@example
(string-scan "abracadabra" "ada" 'before*)
  @result{} "abrac" @r{and} "adabra"
(string-scan "abracadabra" #\c 'before*)
  @result{} "abra" @r{and} "cadabra"
@end example
@item after*
Returns a substring of @var{string} up to the end of @var{item},
and the rest.  If @var{item} is not found, returns
@code{(values #f #f)}.
@example
(string-scan "abracadabra" "ada" 'after*)
  @result{} "abracada" @r{and} "bra"
(string-scan "abracadabra" #\c 'after*)
  @result{} "abrac" @r{and} "adabra"
@end example
@item both
Returns a substring of @var{string} before @var{item} and
after @var{item}.  If @var{item} is not found, returns
@code{(values #f #f)}.
@example
(string-scan "abracadabra" "ada" 'both)
  @result{} "abrac" @r{and} "bra"
(string-scan "abracadabra" #\c 'both)
  @result{} "abra" @r{and} "adabra"
@end example
@end table
@end defun

@defun string-split s char
@end defun


@node String Pointers, Incomplete strings, String utilities, Strings
@subsection String Pointers
@c NODE 文字列ポインタ

@deftp {Builtin Class} <string-pointer>
@clindex string-pointer
String pointer is an object to access string efficiently in sequential
order (either forward or backward).

Higher level string iterators and accessors are constructed on top of 
this primitive.  @xref{String library}, for details.
It is highly recommended to use SRFI-13 functions instead of these
string pointer objects, for portability.
@end deftp

@defun make-string-pointer str &optional index
@end defun

@defun string-pointer? obj
@end defun

@defun string-pointer-next! sp
@defunx string-pointer-prev! sp
@end defun

@defun string-pointer-set! sp index
@end defun

@defun string-pointer-substring sp &keyword (after #f)
@end defun

@defun string-pointer-index sp
@end defun

@node Incomplete strings,  , String Pointers, Strings
@subsection Incomplete strings

@defun string-complete->incomplete str
@end defun

@defun string-incomplete->complete str
@end defun

@c ----------------------------------------------------------------------
@node Regular expression, Vectors, Strings, Core library
@section Regular expression
@c NODE 正規表現

@deftp {Builtin Class} <regexp>
@clindex regexp
Regular expression object.  You can construct a regexp object
from a string by @code{string->regexp} at run time.  Gauche also 
has a special syntax to denote regexp literals, which construct
regexp object at reading time.

Gauche's regexp engine is fully aware of multibyte characters.
@end deftp

@deftp {Builtin Class} <regmatch>
@clindex regmatch
Regexp match object.  A regexp matcher @code{rxmatch} returns
this object if match.  This object contains all the information
about the match, including submatches.

The advantage of using match object, rather than substrings or
list of indices is efficiency.  The regmatch object keeps internal
state of match, and computes indices and/or substrings only when
requested.
@end deftp

@deftp {Reader Syntax} @code{#/@i{regexp-spec}/}
Denotes literal regular expression object.  When read, it becomes
an instance of @code{<regexp>}.

The advantage of using this syntax over @code{string->regexp} is
that the regexp is compiled only once.  You can use literal regexp
inside loop without worring about regexp compilation overhead.
If you want to construct regexp on-the-fly, however, use @code{string->regexp}.

The recognized syntax is a subset of POSIX extended regular expression,
with a bit of extension taken from Perl.  Specifically, Gauche supports:
@itemize @bullet
@item
Repetition by @code{*}, @code{+} and @code{?}.
@item
Grouping by @code{()}.  No backslash escape is needed.
@item
Alternative by @code{|}.
@item 
Character class by @code{[]}.
@item
Beginning of line @code{^} and end of line @code{$} assertions.
@item
Several special character class abbreviations;
@code{\d} for digits, @code{\D} for non-digits, @code{\w} for alfphanumeric
characters, @code{\W} for non-alphanumeric characters, @code{\s} for
whitespace characters, and @code{\S} for non-whitespace characters.
These can be used both inside and outside of @code{[]}.
@end itemize

And Gauche does not supports:
@itemize @bullet
@item
Symbolic character class notation, e.g. @code{[:alpha:]}.
@item
Collating elements, e.g. @code{[=e=]} and @code{[.ll.]}.
@item
Beginning/end of word assertions.
@item
Fixed-number repetition, @code{@{m,n@}}.
@item
Back reference of submatches.
@end itemize

Among those unsupported features, the first four will eventually
be supported.  It is unlikely to support back reference, however.
If you use back reference, you're not dealing with regular grammer
any more.  And if you're dealing with higher class of grammer,
there should be appropriate tools rather than regular expressions.
@end deftp

@defun string->regexp string
Takes @var{string} as a regexp specification, and constructs
an instance of @code{<regexp>} object.
@end defun

@defun rxmatch regexp string
@var{Regexp} is a regular expression object.
A string @var{string} is matched by
@var{regexp}.  If it matches, the function returns a @code{<regmatch>}
object.  Otherwise it returns @code{#f}.

This corresponds to scsh's @code{regexp-search}.
@end defun

@defun rxmatch-substring match &optional (i 0)
@defunx rxmatch-start match &optional (i 0)
@defunx rxmatch-end match &optional (i 0)
@var{Match} is a match object returned by @code{rxmatch}.
If @var{i} equals to zero, the functions return
start, end or the substring of entire match, respectively.
With positive integer @var{I}, it returns those of @var{I}-th
submatches.  It is an error to pass other values to @var{I}.

It is allowed to pass @code{#f} to @var{match} for convenience.
The functions return @code{#f} in such case.

These functions correspond to scsh's @code{match:start}, @code{match:end}
and @code{match:substring}.
@end defun

@defun rxmatch-after match &optional (i 0)
@defunx rxmatch-before match &optional (i 0)
Returns substring of the input string after or before @var{match}.
If optional argument is given, the @var{i}-th submatch is used
(0-th submatch is the entire match).
@example
(define match (rxmatch #/(\d+)\.(\d+)/ "pi=3.14..."))

(rxmatch-after match) @result{} "..."
(rxmatch-after match 1) @result{} ".14..."

(rxmatch-before match) @result{} "pi="
(rxmatch-before match 2) @result{} "pi=3."
@end example
@end defun

Seel also @ref{Regular expression utilities}, which defines
useful macros and functions to deal with regular expression matching.

@c ----------------------------------------------------------------------
@node Vectors, Hashtables, Regular expression, Core library
@section Vectors
@c NODE ベクター

@deftp {Builtin Class} <vector>
@clindex vector
@c EN
A vector is a simple 1-dimensional array of Scheme objects.
You can access its element by index in constant time.
Once created, a vector can't be resized.

Class @code{<vector>} inherits @code{<sequence>} and 
you can use various generic functions such as @code{map} and @code{fold}
on it.   @xref{Collection framework}, and @xref{Sequence framework}.

If you keep only a homogeneous numeric type, you may be able
to use SRFI-4 homogenous vectors (@xref{Homogeneous Vectors}).
@c JP
ベクタはSchemeオブジェクトの単純な一次元配列です。
インデックスを用いて定数時間でその要素にアクセスできます。
一度作成されたベクタはその大きさを変えることはできません。

@code{<vector>}クラスはまた@code{<sequence>}クラスを継承し、
@code{map}や@code{fold}など様々な総称関数を使うことができます。
@ref{Collection framework} と
@ref{Sequence framework} を参照して下さい。

数値しか要素に持たないベクタを使う場合、SRFI-4の
単一型ベクタも使えるかもしれません (@ref{Homogeneous Vectors}参照)。
@c COMMON
@end deftp

@defun vector? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a vector, @code{#f} otherwise.
@c JP
@var{obj}がベクタなら@code{#t}を、そうでなければ@var{#f}を返します。
@c COMMON
@end defun

@defun make-vector k &optional fill
[R5RS]
@c EN
Creates and returns a vector with length @var{k}.
If optional argument @var{fill} is given, each element of the vector
is initialized by it.  Otherwise, the initial value of each element
is undefined.
@c JP
長さ@var{k}のベクタを作成して返します。
省略可能な引数@var{fill}が与えられていれば、ベクタの各要素はその値で
初期化されます。そうでなければベクタの各要素の値は不定です。
@c COMMON
@end defun

@defun vector obj @dots{}
[R5RS]
@c EN
Creates a vector whose elements are @var{obj} @dots{}.
@c JP
要素が@var{obj} @dots{}であるようなベクタを作成して返します。
@c COMMON
@end defun

@defun vector-length vector
[R5RS]
@c EN
Returns the length of a vector @var{vector}.

With @code{gauche.collection} module,
you can also use a method @code{size-of}.
@c JP
ベクタ@var{vector}の長さを返します。

@code{gauche.collection}モジュールをロードしていれば、
メソッド@code{size-of}も同じ目的で使えます。
@c COMMON
@end defun

@defun vector-ref vector k &optional fallback
[R5RS+]
@c EN
Returns @var{k}-th element of vector @var{vector}.

By default, @code{vector-ref} signals an error if @var{k} is
negative, or greater than or equal to the length of @var{vector}.
However, if an optional argument @var{fallback} is given,
it is returned for such case.  This is an extension of Gauche.

With @code{gauche.sequence} module,
you can also use a method @code{ref}.
@c JP
ベクタ@var{vector}の@var{k}番目の要素を返します。

@code{vector-ref}は@var{k}が負の値であったりベクタの長さより
大きかったりした場合はエラーを通知します。但し、省略可能な引数@var{fallback}
が与えられている場合はその値が返されます。これはGaucheの拡張です。

@code{gauche.sequence}モジュールをロードしていれば、
メソッド@code{ref}も同じ目的で使えます。
@c COMMON
@end defun

@defun vector-set! vector k obj
[R5RS]
@c EN
Sets @var{k}-th element of the vector @var{vector} to @var{obj}.
It is an error if @var{k} is negative or greater than or equal to the
length of @var{vector}.
@c JP
@c COMMON
ベクタ@var{vector}の@var{k}番目の要素を@var{obj}に変更します。
@var{k}が負数であったりベクタの長さより大きい場合はエラーとなります。
@end defun

@defun vector->list vector
@defunx list->vector list
[R5RS]
@c EN
Converts a vector to a list, or vice versa.

With @var{gauche.collection} module, you can use
@code{(coerce-to <list> @var{vector})} and 
@code{(coerce-to <vector> @var{list})} as well.
@c JP
ベクタをリストに変換したり、その逆を行う手続きです。

@code{gauche.collection}モジュールをロードしていれば、
@code{(coerce-to <list> @var{vector})} と
@code{(coerce-to <vector> @var{list})} も同じ目的で使えます。
@c COMMON
@end defun

@defun vector-fill! vector fill
[R5RS]
@c EN
Sets all elements in a vector @var{vector} to @var{fill}.
@c JP
ベクタ@var{vector}の全ての要素を@var{fill}に変更します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Hashtables, Control features, Vectors, Core library
@section Hashtables
@c NODE ハッシュテーブル

@deftp {Builtin Class} <hash-table>
@clindex hash-table
@c EN
Hash table class.
@c JP
ハッシュテーブルのクラスです。
@c COMMON
@end deftp

@defun make-hash-table &optional type
@c EN
Creates a hash table.   A symbol @var{type} specifies the type of the table.
The following types are currently supported.
@c JP
ハッシュテーブルを作成します。シンボル@var{type}はテーブルのタイプを指定します。
現在、以下のようなタイプがサポートされています。
@c COMMON
@table @code
@item eq?
@c EN
Keys are compared by @code{eq?}
@c JP
キーの比較に@code{eq?}を使います。
@c COMMON
@item eqv?
@c EN
Keys are compared by @code{eqv?}
@c JP
キーの比較に@code{eqv?}を使います。
@c COMMON
@item equal?
@c EN
Keys are compared by @code{equal?}
@c JP
キーの比較に@code{equal?}を使います。
@c COMMON
@item string=?
@c EN
Keys are compared by @code{string=?}.  Key must be a string.
@c JP
キーの比較に@code{string=?}を使います。キーは文字列でなければなりません。
@c COMMON
@end table

@c EN
If @var{type} is omitted, @code{eq?} is assumed.

@c JP
@var{type}が省略された場合は@code{eq?}とみなされます。
@c COMMON
@end defun

@defun hash-table? obj
@c EN
Returns @code{#t} if @var{obj} is a hash table.
@c JP
@var{obj}がハッシュテーブルであれば@code{#t}を返します。
@c COMMON
@end defun

@defun hash-table-get hash key &optional default
@c EN
Search @var{key} from a hash table @var{hash}, and returns its value
if found.  If the key is not found in the table and @var{default} is
given, it is returned.  Otherwise an error is signalled.
@c JP
キー@var{key}をハッシュテーブル@var{hash}から探します。見つかればキーに対応する
値を返します。キーが見つからなかった場合、@var{default}が与えられていればそれを
返し、そうでなければエラーを報告します。
@c COMMON
@end defun

@defun hash-table-put! hash key value
@c EN
Puts a key @var{key} with a value @var{value} to the hash table @var{hash}.
@c JP
キー@var{key}と対応する値@var{value}をハッシュテーブル@var{hash}に挿入します。
@c COMMON
@end defun

@defun hash-table-exists? hash key
@c EN
Returns @code{#t} if a hash table @var{hash} has a key @var{key}.
@c JP
ハッシュテーブル@var{hash}にキー@var{key}を持つエントリがあれば@code{#t}を返します。
@c COMMON
@end defun

@defun hash-table-delete! hash key
@c EN
Deletes an entry that has a key @var{key} from the hash table @var{hash}.
Returns @code{#t} if the entry has exist, or @code{#f} if the entry
hasn't exist.   The same function is called @code{hash-table-remove!} in STk
(except that it returns an undefined value); I use `delete' for consistency
to SRFI-1, SRFI-13 and other parts of the libraries.
@c JP
ハッシュテーブル@code{hash}からキー@var{key}を持つエントリを削除します。
@var{key}を持つエントリが実際に存在して削除された場合は@code{#t}を、
エントリが存在しなかった場合は@code{#f}を返します。
この手続きはSTkで@code{hash-table-remove!}と呼ばれているものです
(STkのは戻り値が定義されていませんが)。GaucheではSRFI-1, SRFI-13やその他の
ライブラリとの一貫性のために `delete' を採用しました。
@c COMMON
@end defun

@defun hash-table-push! hash key value
@c EN
Conses @var{value} to the existing value for the key @var{key} in the
hash table @var{hash} and makes it the new value for @var{key}.
If there's no entry for @var{key}, an entry
is created with the value @code{(list @var{value})}.

Works the same as the following code, except that this function
only looks up the @var{key} once, thus it's more efficient.
@c JP
ハッシュテーブル@var{hash}中の、キー@var{key}に対応する値に@var{value}をコンスし、
それを@var{key}に対する新たな値とします。もし@var{key}に対応する値がまだ無ければ、
新たなエントリが作成され、@code{(list @var{value})}がその値となります。

この手続きは次のコードと同じ動作をしますが、キーの探索が一度しか行われないためより高速です。
@c COMMON
@example
(hash-table-put! hash key
    (cons value (hash-table-get hash key '())))
@end example
@end defun

@defun hash-table-pop! hash key &optional default
@c EN
Looks for the value for the key @var{key} in the hash table @var{hash}.
If found and it is a pair, replaces the value for its cdr and returns
car of the original value.  If no entry for @var{key} is in the table,
or the value is not a pair, the table is not modified and
the procedure returns @var{default} if given, or signals an error otherwise.  

During the operation the key is looked for only once, thus runs
efficiently.
@c JP
ハッシュテーブル@var{hash}中のキー@var{key}に対応する値が存在し、かつペアで
あった場合に、そのエントリーを元の値のcdrで置き換え、元の値のcarを返します。
@var{key}に対応する値が存在しないかペアではなかった場合、テーブルは変更されず、
@var{default}が与えられていればそれが返され、与えられていなければエラーが報告されます。

値が置き換えれる場合でもキーの探索は一度しか行われないため効率が良いです。
@c COMMON
@end defun

@defun hash-table-for-each hash proc
@defunx hash-table-map hash proc
@c EN
A procedure @var{proc} is called with two arguments, a key and associated
value, over all the entries in the hash table @var{hash}.
@c JP
ハッシュテーブル@var{hash}内の全てのエントリについて、各エントリのキーと値を
2つの引数として手続き@var{proc}を呼びます。
@c COMMON
@end defun

@defun hash-table-keys hash
@defunx hash-table-values hash
@c EN
Returns all the keys or values of hash table @var{hash} in a list,
 respectively.
@c JP
それぞれ、ハッシュテーブル@var{hash}内の全てのキーまたは値をリストにして返します。
@c COMMON
@end defun

@c @defun hash-table-stat hash
@c @end defun


@c ----------------------------------------------------------------------
@node Control features, Exceptions, Hashtables, Core library
@section Control features
@c NODE 制御

@menu
* Procedures::                  
* Continuation::                
* Multiple values::             
* Delayed Evaludation::         
@end menu

@node Procedures, Continuation, Control features, Control features
@subsection Procedures
@c NODE 手続き

@deftp {Builtin Class} <procedure>
@clindex procedure
@end deftp

@defun procedure? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a procedure, @code{#f} otherwise.
@c JP
@var{obj}が手続きなら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun apply proc arg1 @dots{} args
[R5RS]
@c EN
Calls a procedure @var{proc} with a list of arguments,
@code{(@var{arg1} @dots{} . @var{args})}.
The last argument @var{args} must be a proper list.
Returns (a) value(s) @var{proc} returns.
@c JP
@code{(@var{arg1} @dots{} . @var{args})}を引数として手続き@var{proc}を呼びます。
最後の引数@var{args}は正規のリストでなければなりません。 @var{proc}が返す
値をそのまま返します。
@c COMMON
@example
(apply list 'a 'b '(c d e)) @result{} (a b c d e)

(apply + 1 2 '(3 4 5))      @result{} 15
@end example
@end defun

@defun map proc list1 list2 @dots{}
[R5RS+]
@c EN
Applies @var{proc} for each element(s) of given list(s),
and returns a list of the results.  R5RS doesn't specify
the application order of @code{map}, but Gauche guarantees
@var{proc} is always applied in order of the list(s).
Gauche's @code{map} also terminates as soon as one of
the list is exhausted.
@c JP
与えられたリストの各要素に対して@var{proc}を適用し、その結果をリストにして
返します。R5RSでは@var{proc}の適用順序が定められていませんが、Gaucheでは
常に@var{proc}はリスト内の順番で呼ばれます。
複数のリストが与えられた場合、最も短いリストが終了した時点で@var{proc}の適用を
打ち切ります。
@c COMMON

@example
(map car '((a b) (c d) (e f))) @result{} (a c e)

(map cons '(a b c) '(d e f))
  @result{} ((a . d) (b . e) (c . f))
@end example

@c EN
Note that the @code{gauche.collection} module (@xref{Collection framework})
extends @code{map} to work on any type of collection.
@c JP
@code{gauche.collection}モジュール(@ref{Collection framework}参照)
を使うと、@code{map}がリスト以外のコレクション型に対しても動作するようになります。
@c COMMON
@end defun

@defun for-each proc list1 list2 @dots{}
[R5RS]
@c EN
Applies @var{proc} for each element(s) of given list(s) in order.
The results of @var{proc} are discarded.  The return value of
@code{for-each} is undefined.  When more than one list is given,
@code{for-each} terminates as soon as one of the list is exhausted.
@c JP
手続き@var{proc}をリストの各エレメントに対して順に適用します。
@var{proc}の結果は捨てられます。@code{for-each}の戻り値は定義されていません。
複数のリストが与えられた場合、一番短いリストが終了した時点で@code{for-each}は終了します。
@c COMMON

@c EN
Note that the @code{gauche.collection} module (@xref{Collection framework})
extends @code{for-each} to work on any type of collection.
@c JP
@code{gauche.collection}モジュール(@ref{Collection framework}参照)
を使うと、@code{for-each}がリスト以外のコレクション型に対しても動作するようになります。
@c COMMON
@end defun

@node Continuation, Multiple values, Procedures, Control features
@subsection Continuation
@c NODE 継続


@defun call-with-current-continuation proc
@defunx call/cc proc
[R5RS]
@c EN
Encapsulates the current continuation to a procedure
(``continuation procedure''), and calls @var{proc} with it.
When @var{proc} returns, its value becomes @code{call/cc}'s value.
When the continuation procedure is invoked with zero or more arguments
somewhere, the further calculation is abandoned and @code{call/cc} returns
with the arguments given to the continuation procedure.

First class continuation is one of the most distinct feature of Scheme, but
this margin is too small to contain explanation.
Please consult to the appropriate documents.
@c JP
現在の継続を手続き (継続手続き) にパッケージ化して、それを引数として
@var{proc}を呼び出します。@var{proc}が戻ったら、その返り値が@code{call/cc}の
値となります。作成された継続手続きがどこかで0個または複数個の引数を伴って呼ばれたら、
あたかも@code{call/cc}から戻ったかのように実行が継続されます。その場合、
@code{call/cc}は、継続手続きに与えられた引数を複数の値とし返します。

ファーストクラスの継続はSchemeの最も特徴的な機能のひとつですが、それを
十分に説明するにはこの本の余白は狭すぎます。適切なドキュメントを参照してください。
@c COMMON

@c EN
Gauche supports full continuation, with a few limitations in rare
cases.   Normally a continuation has an unlimited extent.  However,
if a continuation is created during ``callback'' from C code---
that is, you call some C-implemented function that calls Scheme
code again---the continuation's extent is limited until the Scheme
evaluation returns to the C code.   If you try to invoke the continuation
from out of its extent, Gauche detects it and signals an error.
This is a fundamental limitation and not likely to be addressed.
@c JP
Gaucheはわずかの例外を除いて、完全な継続をサポートしています。つまり継続は通常
無制限のエクステントを持ちます。しかし、継続がCコードからの「コールバック」
---SchemeがCで書かれたコードを呼び出し、それが再びSchemeコードを呼び出した場合---
で作られたら、その継続のエクステントはコールバックが呼び出したCコードに戻るまでと
なります。エクステントの切れた継続を呼ぼうとするとGaucheはエラーを報告します。
これは根本的な制限であり、おそらく解決されないでしょう。
@c COMMON

@c EN
Note that it is still allowed to invoke a continuation from
such callbacks.
Also, the typical higher-order functions such as @code{map}, @code{for-each}
or @code{apply} are not using callbacks, and not affected by this limitation
@c JP
なお、コールバックコードから有効な継続を呼ぶことは常に可能です。また、
高階関数を使う@code{map}や@code{for-each}、@code{apply}といった手続きは
Cからのコールバックを使っておらず、この制限の影響を受けません。
@c COMMON

@c EN
Fortunately, there are not much cases that you need to create an
unlimited extent continuation in such callbacks.
So far, the following code is executed in such callbacks.  Besides them,
typical callback functions from external C libraries, like GUI toolkit,
obeys the same limitation.
@itemize @bullet
@item
A @code{write-object} method that is invoked from @code{write},
@code{display} or @code{format} (@xref{Output}).
@item
A comparison function invoked from @code{sort} (@xref{Comparison and sorting}).
@item
A filler and a flusher callbacks of buffered ports
(@xref{Procedural ports}).
@end itemize
@c JP
おそらく、そのようなコールバック内で無制限のエクステントを持つ継続を作る必要というのは
あまり無いでしょう。Gauche組み込みの機能では、以下のようなコードがCからのコールバックで
呼び出されます。さらに、外部のCライブラリを使った場合、例えばGUIツールキットからの
コールバックなどはこの制限を受けるでしょう。
@itemize @bullet
@item
@code{write}、@code{display}、@code{format}から呼び出される
@code{write-object}メソッド (@ref{Output}参照)。
@item
@code{sort}から呼び出される比較クロージャ (@ref{Comparison and sorting}参照)。
@item
バッファードポートから呼び出されるfillerとflusher手続き。
(@ref{Procedural ports}参照)。
@end itemize
@c COMMON

@example
(define *oob-cont* #f)

(call/cc (lambda (valid-cont)
           (sort '(1 2 3 4 5 6)
                 (lambda (a b)
                   (call/cc (lambda (oob-cont)
                              (set! *oob-cont* oob-cont)))
                   (valid-cont 'ok)))))
 @result{} ok  ;@r{callback can call a continuation}

(*oob-cont* 'not-ok)
 @result{} ;@r{error -- *oob-cont* is out of its extent}.
@end example
@end defun

@defun dynamic-wind before thunk after
[R5RS]
@c EN
@var{Before}, @var{thunk} and @var{after} are all procedures with
no arguments.
In normal situation, @code{dynamic-wind} calls @var{before}, then @var{thunk},
then @var{after}, then returns whatever value(s) @var{thunk} returned.

If a control flow goes out from @var{thunk} by invoking a continuation
captured outside of the dynamic scope of @code{dynamic-wind}
(for example, an error is signalled in @var{thunk}),
@var{after} is called.  

If a control flow goes into @var{thunk} by invoking a continuation
captured inside @var{thunk} from outside of the dynamic
scope of @code{dynamic-wind}, @var{before} is called.
@c JP
@var{before}、@var{thunk}および@var{after} は引数を取らない手続きです。
@code{dynamic-wind}はまず@var{before}を呼び出し、続いて@var{thunk}を呼び出し、
続いて@var{after}を呼び出します。そして@var{thunk}が返した値を返します。

もし@code{dynamic-wind}のダイナミックスコープの外で捕捉された継続が
@var{thunk}の中で呼ばれることにより制御が@var{thunk}から飛び出した場合、
(@var{thunk}の中でエラーが起こった場合などが考えられます)、
@var{after}が呼ばれます。

もし、@var{thunk}の中で捕捉された継続が@var{dynamic-wind}のダイナミックスコープの
外で呼ばれることにより制御が@var{thunk}の中へ飛び込んだ場合、
@var{before}が呼ばれます。
@c COMMON
@example
(letrec ((paths '())
         (c #f)
         (add (lambda (s) (push! paths s))))
  (dynamic-wind
   (lambda () (add 'connect))
   (lambda ()
     (add (call/cc (lambda (c0) (set! c c0) 'talk1))))
   (lambda () (add 'disconnect)))
  (if (< (length paths) 4)
      (c 'talk2)
      (reverse paths)))
 @result{} (connect talk1 disconnect connect talk2 disconnect)
@end example
@end defun

@node Multiple values, Delayed Evaludation, Continuation, Control features
@subsection Multiple values
@c NODE 多値

@defun values obj @dots{}
[R5RS]
@c EN
Returns @var{obj} @dots{} as multiple values.
Caller can capture multiple values by a built-in syntax
@code{receive} (@ref{Binding constructs}), or the R5Rs procedure
@code{call-with-values} described below.  See also @ref{Let-values}.
@c JP
@var{obj} @dots{} を多値として返します。
呼び出し側は、組み込み構文の @code{receive} (@ref{Binding constructs}参照)か、
下に説明するR5RSの手続き@code{call-with-values}を使って多値を受け取ることが
できます。@ref{Let-values}も参照してください。
@c COMMON
@example
(values 1 2) @result{} 1 @r{and} 2
@end example
@end defun

@defun call-with-values producer consumer
[R5RS]
@c EN
Call a procedure @var{producer} with no argument.
Then applies a procedure @var{consumer} on the
value(s) @var{producer} returned.  Returns the value(s) @var{consumer}
returns.
@c JP
手続き@var{producer}を引数無しで呼びます。そして、それが返した値
を引数として@var{consumer}を呼びます。@var{consumer}が返す値を
返します。
@c COMMON
@example
(call-with-values (values 1 2) cons) @result{} (1 . 2)
@end example
@end defun

@node Delayed Evaludation,  , Multiple values, Control features
@subsection  Delayed Evaludation
@c NODE 遅延評価

@defspec delay expression
[R5RS]
@end defspec

@defun force promise
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Exceptions, Eval, Control features, Core library
@section Exceptions
@c NODE 例外

In Gauche, error singnaling mechanism is implemented in multiple
layers.   The lower layer provides very simple mechanism with which
the user can implement various semantics.  The higher layer provides
a way to handle common patterns like error handling in a simple way.

@menu
* Signalling errors::           
* Handling errors::             
* Exception object::            
* Low-level exception mechanism::  
@end menu

@node Signalling errors, Handling errors, Exceptions, Exceptions
@subsection Signalling errors
@c NODE エラーの通知

@defun error string arg @dots{}
[SRFI-23] Signals an error.   Internally the action is realized
by those two steps.
@enumerate
@item
An error exception is created, with the message prefixed
by @var{string} and followed by @var{arg}s.
@item
The error exception is thrown, which may be handled by the
current active error handler, if any.
@end enumerate

If no error handler is active, the default error handler is
used, which prints the error message to the current error port
and some debug information.   Then, if Gauche is running
interactively, the control moves to the toplevel; if Gauche
is running as a script, it exits with the exit status @code{EX_SOFTWARE}
(70).
@end defun

@defun errorf fmt-string arg @dots{}
Similar to an error, but the error message is formatted by
@code{format}, i.e. it is equivalent to:
@example
(define (errorf fmt . args)
  (error (apply format #f fmt args)))
@end example
@end defun

@node Handling errors, Exception object, Signalling errors, Exceptions
@subsection Handling errors
@c NODE エラーの処理

@defun with-error-handler handler thunk
Makes @var{handler} the active error handler and executes @var{thunk}.
If @var{thunk} returns normally, the result(s) will be returned.
If an error is signalled during execution of @var{thunk},
@var{handler} is called with one argument, an exception object
representing the error, with the continuation of @code{with-error-handler}.
That is, @code{with-error-handler} returns whatever value(s) @var{handler}
returns.

If @var{handler} signals an error, it will be handled by the
handler installed when @code{with-error-handler} called.

The dynamic environment where @var{handler} is executed is
the same as the error occurs.  If @code{dynamic-wind} is used
in @var{thunk}, its @var{after} method is called after @var{handler}
has returned, and before @code{with-error-handler} returns.

The behavior of @code{with-error-handler} can be
described in the form of Scheme code shown below,
using the low-level mechanism (@xref{Low-level exception mechanism}).
Note that the actual function is built in VM, using lighter
mechanisms (similar to "one-shot continuation", @ref{onecont, [1CC], 1CC}).

@example
;; @r{conceptual implementation of with-error-handler}
(define (with-error-handler handler thunk)
  (call/cc
    (lambda (cont)
      (let* ((prev-handler (current-exception-handler))
        (with-exception-handler
          (lambda (exn)
            (if (error? exn)
                (with-exception-handler
                  (lambda (err) (prev-handler err))
                  (lambda () (call-with-values (handler exn) cont)))
                (prev-handler exn)))
          thunk))))))
@end example
@end defun

@node Exception object, Low-level exception mechanism, Handling errors, Exceptions
@subsection Exception object
@c NODE 例外オブジェクト

@deftp {Class} <exception>
@clindex exception
Represents An exception.
The complete exception class hierarchy is under construction.
Right now, only the following information is available.

@defivar {<exception>} message
For an error exception, this is the error message.
@end defivar
@end deftp

@node Low-level exception mechanism,  , Exception object, Exceptions
@subsection Low-level exception mechanism

This layer provides SRFI-18 compatible simple exception mechanism.
You can override the behavior of higher-level constructs such as
@code{with-error-handler} by using @code{with-exception-handler}.

Note that it is a double-edged sword.  You'll get a freedom to
construct your own exception handling semantics, but the Gauche
system won't save if something goes wrong.   Use these primitives
when you want to customize the system's higher-level semantics
or you are porting from other SRFI-18 code.

@defun current-exception-handler
[SRFI-18]
Returns the current exception handler.
@end defun

@defun raise exception
[SRFI-18] 
Invokes the current exception handler with one argument, @var{exception}.
@var{exception} can be any Scheme object; it doesn't need to be
an instance of @code{<exception>} class.
Combined with @code{with-exception-handler} you can give your own
semantics to the @var{exception}.
@code{raise} returns whatever the handler returns.
@end defun

@defun with-exception-handler handler thunk
[SRFI-18]
A procedure @var{handler} must take one argument.  This procedure
sets @var{handler} to the current exception handler and calls
@var{thunk}.
@end defun

Generally, if you want to handle non-continuable exception such as
errors using this low-level mechanism,
you have to transfer the control from the handler explicitly
(See the explanation of @code{with-error-handler} above).
@code{raise} detects if the handler returns on the
non-continuable exceptions and reports an error using the
default error handler mechanism, but it is just a safety net.

Note also that @var{handler} is called in the same dynamic environment
of @code{raise}.  So if you raise an exception inside @var{handler},
it is captured by @var{handler} again.   It is the programmer's
responsibility to propagate the exception handling to the ``outer''
exception handlers.

The behavior of those procedures can be explained in
the following conceptual Scheme code.

@example
;; @r{Conceptual implementation of low-level exception mechanism.}
;; @r{Suppose %xh is a list of exception handlers}

(define (current-exception-handler) (car %xh))

(define (raise exn)
  (receive r ((car %xh) exn)
    (when (uncontinuable-exception? exn)
      (set! %xh (cdr %xh))
      (raise (@r{@i{make-error}} "returned from uncontinuable exception")))
    (apply values r)))

(define (with-exception-handler handler thunk)
  (let ((prev %xh))
    (dynamic-wind
      (lambda () (set! %xh (cons handler)))
      thunk
      (lambda () (set! %xh prev)))))
@end example

@c ----------------------------------------------------------------------
@node Eval, Input and output, Exceptions, Core library
@section Eval

@defun eval expr env
[R5RS]
Evaluate @var{expr}.   @var{env} must be a value returned by
the following procedures below.  Right now it is just a
@code{<module>} object, but it is possible that the Gauche
adopts a first-class environment object in future.
@end defun

@defun null-environment version
@defunx scheme-report-environment version
@defunx interaction-environment
[R5RS]
Returns an environment specifier which can be used as the second
argument of @code{eval}.   Right now an environment specifier
is just a module.  @code{(null-environment 5)} returns
a @code{null} module, which contains just the syntactic bindings
specified in R5RS, @code{(scheme-report-environment 5)}
returns a @code{scheme} module, which contains syntactic and procedure
bindings in R5RS, and @code{(interaction-environment)} returns
a @code{user} module that contains all the Gauche built-ins plus
whatever the user defined.
It is possible that the Gauche adopts a first-class environment object
in future, so do not rely on the fact that the environment specifier
is just a module.

An error is signaled if a value other than 5 is passed as @var{version}
argument.

There's one difference from R5RS in @code{null-environment} and
@code{scheme-report-environment}; they contain @code{with-module}
special form.   It is necessary to define R5RS procedure using
Gauche built-ins for now.  It'll be removed as soon as I find
a better way.
@end defun

@c ----------------------------------------------------------------------
@node Input and output, Loading Programs, Eval, Core library
@section Input and Output
@c NODE 入出力

@menu
* Ports::                       
* Common port operations::      
* File ports::                  
* String ports::                
* Procedural ports::            
* Input::                       
* Output::                      
@end menu

@node Ports, Common port operations, Input and output, Input and output
@subsection Ports
@c NODE ポート

@deftp {Builtin Class} <port>
@clindex port
@c EN
A port class.   A port is Scheme's way of abstraction of I/O channel.
Gauche extends a port in number of ways so that it can be used
in wide range of applications.
@c JP
Portは、Schemeにおいて抽象化された入出力のインタフェースを提供します。
Gaucheはportにいくつかの拡張を行い、いろいろなアプリケーションに対応できるようにしました。
@c COMMON

@c EN
Standard Scheme (R5RS) essentially defines a port as an entity that
you can fetch a character at a time and
look one character ahead from an input port, 
and put a character at a time to an output port.
Other R5RS I/O routines can be built on top of them.
@c JP
標準のSchemeでは、portはキャラクタを一文字づつ読み込む(一文字先読み可)、
もしくは書き出すだけのもので、他の入出力ルーチンはその上に構築されています。
@c COMMON

@c EN
Besides this basics, Gauche's port can handle the following
opertaions.
@c JP
Gaucheではさらに次のような操作がportに対して可能になっています。
@c COMMON

@table @asis
@c EN
@item Byte I/O
You can read/write one byte at a time, instead of a character.
(Remember, Gauche handles multibyte characters, so a character
may be consisted from more than one bytes).
Most ports allow you to mix byte I/O and character I/O, if needed.
@c JP
@item バイトI/O
キャラクタ毎でなく、バイト毎のI/Oが可能です(Gaucheではマルチバイト文字を
扱うので、この２つが異なることに注意して下さい)。大抵のポートでは
キャラクタI/OとバイトI/Oを混ぜて使うことができます。
@c COMMON

@c EN
@item Block I/O
You can read/write a specified number of byte sequences.
This can be an efficient way of moving block of data,
if the port's underlying implementation supports block I/O
operation (for example, if the underyling port is a unix buffered
stream, this operation uses @code{fread} or @code{fwrite}).
@c JP
@item ブロックI/O
ポートから指定した数のバイト列を読んだり、ポートへ書いたりできます。
ポートがブロックI/Oを行うデバイスに接続されている場合、ある程度大きなブロック毎に
読み書きすると効率の良いデータ転送ができます。
@c COMMON

@c EN
@item Conversion
Some ports can be used to convert a data stream from one format
to another; one of such applications is character code conversion
ports, provided by @code{gauche.charconv} module
(@xref{Character code conversion}, for details).
You can define a procedural ports, in both Scheme and C, 
to implement other functionality.
@c JP
@item 変換
ポートはまた、データストリームを変換するのにも使えます。例えば@code{gauche.charconv}
モジュールでは、文字コード間の変換を行うポートを提供しています
(詳しくは@ref{Character code conversion}を参照)。
プロシージャルなポートを定義することにより、様々な機能を実装できます。
@c COMMON
@end table

@end deftp

@node Common port operations, File ports, Ports, Input and output
@subsection Common port operations
@c NODE ポート共通の操作

@defun input-port? obj
@defunx output-port? obj
[R5RS]
@c EN
Returns true if @var{obj} is an input port and an output port, respectively.
@c JP
@var{obj} がそれぞれ入力ポートと出力ポートなら真を返します。
@c COMMON
@end defun

@defun port-closed? port
@c EN
Returns true if @var{obj} is a port and it is already closed.
A closed port can't be reopened.
@c JP
@var{obj}がポートであり、既に閉じられていた場合に真を返します。
一度閉じたポートは再び開くことはできません。
@c COMMON
@end defun

@defun current-input-port
@defunx current-output-port
[R5RS]
@c EN
Returns the current input port and the current output port, respectively.
@c JP
現在の入力ポートと出力ポートをそれぞれ返します。
@c COMMON
@end defun

@defun current-error-port
@c EN
Returns the current output port.
@c JP
現在のエラーポートを返します。
@c COMMON
@end defun

@defun standard-input-port
@defunx standard-output-port
@defunx standard-error-port
@c EN
Returns ports that are bound initially to current input, output and
error port, respectively.
@c JP
プログラム開始時点の入力、出力、エラーポートをそれぞれ返します。
@c COMMON
@end defun

@defun with-input-from-port port thunk
@defunx with-output-to-port port thunk
@defunx with-error-to-port port thunk
@c EN
Calls @var{thunk}.  During evaluation of thunk, the current input port, current
output port and current error port are set to @var{port}, respectively.
@c JP
それぞれ入力、出力、エラーポートは@var{port}にセットした状態で@var{thunk}を呼び出します。
@c COMMON
@end defun

@defun close-input-port port
@defunx close-output-port port
[R5RS]
@c EN
Closes input and output @var{port}, respectively
@c JP
それぞれ、入力ポートと出力ポートを閉じます。
@c COMMON
@end defun

@defun port-type port
@c EN
Returns the type of @var{port} in one of the symbols @code{file}, 
@code{string} or @code{proc}.
@c JP
@var{port}のタイプを、シンボル@code{file}、@code{string}、@code{proc}の
いずれかで返します。
@c COMMON
@end defun

@defun port-name port
@c EN
Returns the name of @var{port}.  If the port is associated to a file,
it is the name of the file.   Otherwise, it is some description of the port.
@c JP
@var{port}の名前を返します。ポートがファイルに関連付けられている場合は、ポートの名前は
ファイル名です。そうでない場合、ポートを説明する文字列が返されます。
@c COMMON
@end defun

@defun port-current-line port
@c EN
Returns the current line count of @var{port}.  This information is
only available on file-based port, and as long as you're doing
sequential character I/O on it.  Otherwise, this returns -1.
@c JP
@var{port}の現在の行番号を返します。行番号は、ファイルに関連付けられたポートで
かつシーケンシャルなキャラクタI/Oを行っている場合のみ有効です。それ以外の場合は
-1を返します。
@c COMMON
@end defun

@defun port-file-number port
@c EN
Returns an integer file descriptor, if the @var{port} is associated
to the system file I/O.  Returns @code{#f} otherwise.
@c JP
@var{port}がファイルに関連付けられている場合、そのファイルディスクリプタ番号を
返します。それ以外の場合は@code{#f}を返します。
@c COMMON
@end defun

@defun copy-port src dst &keyword (unit 0)
@c EN
Copies data from an input port @var{src} to an output port @var{dst},
until eof is read from @var{src}.
@c JP
@var{src}からEOFまでデータを読みだし、@var{dst}へ書き出します。
@c COMMON

@c EN
The keyword argument @var{unit} may be zero, a positive exact integer,
a symbol @code{byte} or a symbol @code{char}, to specify the unit
of copying.  If it is an integer, a buffer of the size
(in case of zero, a system default size) is used to copy,
using block I/O.  Generally it is the fastest if you copy
between normal files.   If @var{unit} is a symbol @code{byte},
the copying is done byte by byte, using C-verson of @code{read-byte}
and @code{write-byte}.  If @var{unit} is a symbol @code{char},
the copying is done character by character, using C-version of
@code{read-char} and @code{write-char}.
@c JP
キーワード引数@var{unit}は0以上の整数か、シンボル@code{byte}もしくは@code{char}
でなければなりません。これはデータをコピーする単位を指定します。
整数ならば、その大きさ(0の場合はシステム規定の大きさ)のバッファが確保され、
ブロックI/Oを使って転送が行われます。通常のファイルをコピーする場合などはこれが
速いでしょう。もし@var{unit}がシンボル@code{byte}であれば、バイト毎
に読みだし／書き込みが行われます。@var{unit}がシンボル@code{char}であれば、
キャラクタ毎に読みだし／書き込みが行われます。
@c COMMON
@end defun


@node File ports, String ports, Common port operations, Input and output
@subsection File ports
@c NODE ファイルポート

@defun open-input-file filename &keyword if-does-not-exist element-type
@defunx open-output-file filename &keyword if-does-not-exist if-exists element-type
[R5RS+]
@c EN
Opens a file @var{filename} for input or output, and
returns an input or output port associated with it, respectively.

The keyword arguments specify precise behavior on the exceptional case.
@c JP
ファイル@var{filename}を入力または出力用にオープンし、
入力ポートまたは出力ポートを作成して返します。

キーワード引数により、例外的な場合の動作を細かく指定できます。
@c COMMON

@table @code
@item :if-exists
@c EN
This keyword argument can be specified only for @code{open-output-file}, and
specifies the action when the @var{filename} already exists.
One of the following value can be given.
@c JP
このキーワード引数は@code{open-output-file}のみに指定でき、
@var{filename}が既に存在した場合の動作を指定します。次の値のいずれかを与えることができます。
@c COMMON
@table @code
@item :supersede
@c EN
The existing file is truncated.  This is the default behavior.
@c JP
既存のファイルが長さ0に縮められます。これが既定の動作です。
@c COMMON
@item :append
@c EN
The output data will be appended to the existing file.
@c JP
既存のファイルにこれから書き出す内容が追加されます。
@c COMMON
@item :error
@c EN
An error is signalled.
@c JP
エラーが報告されます。
@c COMMON
@item #f
@c EN
No action is taken, and the function returns @code{#f}.
@c JP
何もせず、@code{#f}を返します。
@c COMMON
@end table

@item :if-does-not-exist
@c EN
This keyword argument specifies the action when @var{filename} does not exist.
@c JP
このキーワード引数は@var{filename}が存在しない場合の動作を指定します。
@c COMMON
@table @code
@item :error
@c EN
An error is signalled.  This is the default behavior of
@code{open-input-file}.
@c JP
エラーを報告します。これが@code{open-input-file}の既定の動作です。
@c COMMON
@item :create
@c EN
A file is created.  This is the default behavior of @code{open-output-file}.
The check of file existence and creation is done atomically; you can
exclusively create the file by specifying @code{:error} or @code{#f} to
@var{if-exists}, along this option.
You can't specify this value for @code{open-input-file}.
@c JP
ファイルが作成されます。これが@code{open-output-file}の既定の動作です。
ファイルの存在のチェックと作成はアトミックに行われます。
このオプションに加え、@var{if-exists}オプションに@code{:error}か@code{#f}を
指定することで、排他的にファイルを作成することができます。
@code{open-input-file}に対してはこの値を指定することはできません。
@c COMMON
@item #f
@c EN
No action is taken, and the function returns @code{#f}.
@c JP
何もせず、@code{#f}を返します。
@c COMMON
@end table

@item :element-type
@c EN
This argument specifies the type of the file.
@c JP
この引数はファイルのタイプを指定します。
@c COMMON
@table @code
@item :character
@c EN
The file is opened in ``character'' (or ``text'') mode.
@c JP
ファイルはキャラクタモード(テキストモード)でオープンされます。
@c COMMON
@item :binary
@c EN
The file is opened in ``binary'' mode.
@c JP
ファイルはバイナリモードでオープンされます。
@c COMMON
@end table
@c EN
The two makes no difference on most Unix systems.
@c JP
Unixシステムでは両者の動作に違いはありません。
@c COMMON
@end table

@c EN
By combination of @var{if-exists} and @var{if-does-not-exist} flags,
you can implement various actions:
@example
(open-output-file "foo" :if-exists :error)
 @result{} ;@r{opens "foo" exclusively, or error}

(open-output-file "foo" :if-exists #f)
 @result{} ;@r{opens "foo" exclusively, or returns} #f

(open-output-file "foo" :if-exists :append
                        :if-does-not-exist :error)
 @result{} ;@r{opens "foo" for append only if it already exists}
@end example
@c JP
@var{if-exists}と@var{if-does-not-exist}フラグの組合せにより、
色々な動作を実現できます。
@example
(open-output-file "foo" :if-exists :error)
 @result{} ;@r{"foo"を排他的にオープンするかエラーを報告する}

(open-output-file "foo" :if-exists #f)
 @result{} ;@r{"foo"を排他的にオープンするか}#f@r{を返す}

(open-output-file "foo" :if-exists :append
                        :if-does-not-exist :error)
 @result{} ;@r{"foo"が既に存在する場合に限り、それを追加モードでオープン}
@end example
@c COMMON

@c EN
To check the existence of a file without opening it,
use @code{sys-access} or @code{file-exists?} (@xref{File stats}).
@c JP
ファイルをオープンせずにその存在をチェックするには、
@code{sys-access}か@code{file-exists?}を使って下さい (@ref{File stats}参照)。
@c COMMON

@c EN
Note: @code{gauche.charconv} module extends these procedures to
take @var{encoding} keyword argument so that they can read or write
in different character encoding scheme.  @xref{Character code conversion}.
@c JP
註：@code{gauche.charconv}モジュールはこれらの手続きを、
@var{encoding}キーワード引数を取るように拡張して、
異なる文字エンコーディングでのファイルの読み書きを可能にします。
@ref{Character code conversion}参照。
@c COMMON

@c EN
Note for portability: Some Scheme implementations (e.g. STk) allows
you to specify a command to @var{filename} and reads from, or
writes to, the subprocess standard input/output.  Some other scripting
languages (e.g. Perl) have similar features.  In Gauche,
@code{open-input-file} and @code{open-output-file} strictly operates
on files (what the underlying OS thinks as files).
However, you can use ``process ports'' to invoke
other command in a subprocess and to communiate it.
@xref{Process ports}, for details.
@c JP
移植性に関する註：Schemeシステムによっては、@var{filename}のところに
シェルコマンドを指定して、サブプロセスの標準入出力と通信できるようにするものが
あります。他のスクリプティング言語(例：Perl)にも同様の機能があります。
Gaucheでは、@code{open-input-file}と@code{open-output-file}は
あくまでファイル (OSがファイルとして扱うもの) のみに対して使えます。
サブプロセスと通信するためには、「プロセスポート」という機能が提供されています。
@ref{Process ports}を参照して下さい。
@c COMMON
@end defun

@defun call-with-input-file string proc &keyword if-exists element-type
@defunx call-with-output-file string proc &keyword if-does-not-exist if-exists element-type
[R5RS]
@c EN
Opens a file specified by @var{string} for input/output,
and call @var{proc} with one argument, the file port.  When @var{proc}
returns, or an error is signalled from @var{proc} that is not captured
within @var{proc}, the file is closed.

The keyword arguments have the same meanings of
@code{open-input-file} and @code{open-output-file}'s.  Note that
if you specify @code{#f} to @var{if-exists} and/or @var{if-does-not-exist},
@var{proc} may receive @code{#f} instead of a port object when
the file is not opened.

Returns the value(s) @code{proc} returned.
@c JP
@var{string}で示されるファイルを入力または出力用にオープンし、
作成されたポートを引数として手続き@var{proc}を呼び出します。
@var{proc}が正常終了するか、@var{proc}内で捕捉されないエラーが起きた場合に
ファイルはクローズされます。

キーワード引数は
@code{open-input-file}及び@code{open-output-file}のものと同じ意味を持ちます。
@var{if-exists}や@var{if-does-not-exist}に@code{#f}を指定した場合、
ファイルがオープンされなかった場合は@var{proc}にポートではなく@code{#f}が渡される
ことに注意して下さい。

@var{proc}が返す値を返します。
@c COMMON
@end defun

@defun with-input-from-file string thunk &keyword if-exists element-type
@defunx with-output-to-file string thunk &keyword if-does-not-exist if-exists element-type
[R5RS]
@c EN
Opens a file specified by @var{string} for input or output
and makes the opened port as the current input or output port,
then calls @var{thunk}.  The file is closed when @var{thunk}
returns or an error is signalled from @var{thunk} that is not
captured within @var{thunk}.

The keyword arguments have the same
meanings of @code{open-input-file} and @code{open-output-file}'s,
except that @code{#f} is not allowed to @var{if-exists} and
@var{if-does-not-exist}; i.e. an error is always signalled if the
file can't be opened.

Returns the value(s) @code{thunk} returned.
@c JP
@var{string}で示されるファイルを入力または出力用にオープンし、オープンされた
ポートを現在の入力または出力ポートに設定して、@var{thunk}を呼び出します。
@var{thunk}が戻るか、@var{thunk}内で捕捉されないエラーが生じた際にファイルは閉じられます。

キーワード引数は
@code{open-input-file}及び@code{open-output-file}のものと同じ意味を持ちます。
但し@var{if-exists}や@var{if-does-not-exist}に@code{#f}を指定することは
出来ません。ファイルがオープンできなかった場合は常にエラーとなります。

@var{thunk}が返す値を返します。
@c COMMON
@end defun

@c EN
@emph{Notes on semantics of closing file ports:}
R5RS states, in the description of @code{call-with-input-file} et al., 
that @emph{"If @emph{proc} does not return, then the port will
not be closed automatically unless it is possible
to prove that the port will never again be used for read or write
operation."}
@c JP
@emph{ポートを閉じるセマンティクスについて:} 
R5RSは@code{call-with-input-file}等の説明において、次のように述べています。
「@emph{procが戻って来なかった場合、今後ポートが読み書きに一切使われないことが
証明できない限りは、ポートは自動的には閉じられない}」。
@c COMMON

@c EN
Gauche's implementation slightly misses this criteria; the mere fact
that an uncaptured error is thrown in @var{proc} does not prove
the port will never be used.  Nevertheless, it is very diffcult
to think the situation that you can do meaningful operation on
the port after such an error is signalled; you'd have no idea
what kind of state the port is in.  In practical programs, you
should capture error explicitly inside @var{proc} if you still want
to do some meaningful operation with the port.
@c JP
Gaucheの実装は若干この条件には反しています。捕捉されないエラーが@var{proc}から
発せられたというだけでは、そのポートが今後一切使われないかどうかはわかりません。
しかし実際には、そのようなエラーが発せられた後でポートに対して意味のある操作をするのは
非現実的です。ポートがどのような状態にあるかわからないわけですから。
現実的なプログラムでは、ポートに対して意味のある操作をしつづけたいのなら、
@var{proc}の中で明示的にエラーをハンドルすべきでしょう。
@c COMMON

@c EN
Note that if a continuation captured outside @code{call-with-input-file}
et al. is invoked inside @var{proc}, the port is not closed.
It is possible that the control returns later into the @var{proc},
if a continuation is captured in it (e.g. coroutines).
The low-level exceptions 
(@xref{Low-level exception mechanism}) also doesn't ensure closing 
the port.
@c JP
@code{call-with-input-file}の外で捕捉された継続を@var{proc}内で呼んだ場合には
ポートは閉じられないことに注意して下さい。後で@var{proc}へと制御が戻ってくるかも
しれないからです (コルーチン等)。また、
低レベルの例外メカニズム(@ref{Low-level exception mechanism}
参照)を利用した場合、エラー時にポートを閉じるのはプログラマの責任になります。
@c COMMON

@node String ports, Procedural ports, File ports, Input and output
@subsection String ports
@c NODE 文字列ポート

@c EN
String ports are the ports that you can read from or write to
memory.
@c JP
文字列ポートは、メモリ上のデータと関連付けられたポートです。
@c COMMON

@defun open-input-string string
[SRFI-6]
@c EN
Creates an input string port that has the content @var{string}.
This is a more efficient way to access a string in order
rather than using @code{string-ref} with incremental index.

@example
(define p (open-input-string "foo x"))
(read p) @result{} foo
(read-char p) @result{} #\space
(read-char p) @result{} #\x
(read-char p) @result{} #<eof>
(read-char p) @result{} #<eof>
@end example
@c JP
@var{string}を内容とする入力文字列ポートを作って返します。
文字列に逐次的にアクセスする場合、インデックスをインクリメントしながら
@code{string-ref}を呼び出すより効率の良い方法です。
@example
(define p (open-input-string "文字 列"))
(read p) @result{} 文字
(read-char p) @result{} #\space
(read-char p) @result{} #\列
(read-char p) @result{} #<eof>
(read-char p) @result{} #<eof>
@end example
@c COMMON
@end defun

@defun open-output-string
[SRFI-6]
@c EN
Creates an output string port.   Anything written to the
port is accumulated in the buffer, and can be obtained
as a string by @code{get-output-string}.
This is a far more efficient way to construct a string
sequentially than pre-allocate a string and fill it with
@code{string-set!}.
@c JP
出力文字列ポートを作成して返します。このポートに書き出された文字列は
内部のバッファにたくわえられ、@code{get-output-string} で取り出すことが
できます。
これは、順番に文字列を構成する方法として、あらかじめ文字列をアロケートして
@code{string-set!}で埋めて行くよりもずっと効率の良い方法です。
@c COMMON
@end defun

@defun get-output-string port
[SRFI-6]
@c EN
Takes an output string port @code{port} and returns a string
that has been accumulated to @code{port} so far.
If a byte data has been written to the port, this function
re-scans the buffer to see if it can consist a complete string;
if not, an incomplete string is returned.
@c JP
出力文字列ポート@code{port}を取り、それまでそのポートに蓄積された
文字列を返します。バイトデータがそのポートに書き出されていた場合、
この手続きはまず内部バッファをスキャンし、結果が完全な文字列で表現できるかどうかを
調べます。もし表現できなければ、不完全な文字列が返されます。
@c COMMON
@end defun

@defun call-with-input-string string proc
@defunx call-with-output-string proc
@defunx with-input-from-string string thunk
@defunx with-output-to-string thunk
@c EN
These utility functions are trivially defined as follows.
The interface is parallel to the file port version.
@c JP
これらのユーティリティ関数は次に定義されるような動作をします。
インタフェースはファイルポートを扱う類似の関数と揃えてあります。
@c COMMON
@example
(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

(define (call-with-input-string str proc)
  (let ((in (open-input-string str)))
    (proc in)))

(define (with-output-to-string thunk)
  (let ((out (open-output-string)))
    (with-output-to-port out thunk)
    (get-output-string out)))

(define (with-input-from-string str thunk)
  (with-input-from-port (open-input-string str) thunk))
@end example
@end defun

@defun call-with-string-io str proc
@defunx with-string-io str thunk
@example
(define (call-with-string-io str proc)
  (let ((out (open-output-string))
        (in  (open-input-string str)))
    (proc in out)
    (get-output-string out)))

(define (with-string-io str thunk)
  (with-output-to-string
    (lambda ()
      (with-input-from-string str
        thunk))))
@end example
@end defun

@defun write-to-string obj &optional writer
@defunx read-from-string string &optional start end
@c EN
These convenience functions cover commin idioms using string ports.
@example
(write-to-string obj writer)
  @equiv{}
  (with-output-to-string (lambda () (writer obj)))

(read-from-string string)
  @equiv{}
  (with-input-from-string string read)
@end example
The default value of @var{writer} is the procedure @code{write}.
The default values of @var{start} and @var{end} is 0 and
the length of @var{string}.

Portability note: Common Lisp has these functions, with
different optional arguments.
STk has @code{read-from-string} without optional argument.
@c JP
文字列ポートを使う定型句をユーティリティ関数にしました。
@example
(write-to-string obj writer)
  @equiv{}
  (with-output-to-string (lambda () (writer obj)))

(read-from-string string)
  @equiv{}
  (with-input-from-string string read)
@end example
@var{writer}の既定値は@code{write}です。@var{start}, @var{end}は
省略されればそれぞれ0と文字列の長さになります。

移植性への註：Common Lispに同名の関数があります。必須引数の動作は同じですが、
省略可能な引数は異なります。
STkには@code{read-from-string}がありますが、省略可能な引数は取りません。
@c COMMON
@end defun

@node Procedural ports, Input, String ports, Input and output
@subsection Procedural ports
@c NODE 手続き的ポート

The underlying mechanism of procedural ports is very flexible,
but I don't have Scheme interface yet, except the following ones:

@defun open-input-buffered-port filler buffer-size
@defunx open-output-buffered-port flusher buffer-size
These are the Scheme interface to the ``buffered port''.

@code{open-input-buffered-port} creates and returns an input port,
with associated buffer of size @var{buffer-size}.
The data is read from the buffer.
When the port is read and the buffer is empty, a procedure @var{filler}
is called with one argument, the size of required data.
@var{filler} must return a string (either complete or incomplete)
of the specified size.  It is permitted for @var{filler}
to return a string shorter than the size, if not enough data is available.
The behavior is undefined if @var{filler} returns larger string than
specified.  Note that the @var{size} of string matters, not the @var{length}
of string.
If @var{filler} finds that it reached EOF of its data source, it can
return EOF.  Retuning zero size string has the same effect as EOF.
Initially, the buffer is empty, so @var{filler} is always called
at the first attempt of reading from the port.

@code{open-output-buffered-port} creates and returns an output port,
with associated buffer of size @var{buffer-size}.
The data output to the port is accumulated in the buffer.
When the buffer gets full, or @code{flush} is called on the port,
a procedure @var{flusher} is called with an @emph{incomplete} string
to be flushed.   @var{flusher} must return a number of bytes flushed,
which must be the same as the size of the passed string.
The string may shorter than @var{buffer-size}.
When the port is closed, @var{flusher} is called with any data
remaining in the buffer, then it is called again with argument @code{#f},
indicating that the port is closed.
@end defun

@node Input, Output, Procedural ports, Input and output
@subsection Input 
@c NODE 入力

@c EN
For the following procedures, the optional @var{iport} argument must be
an input port, and when omitted, the current input port is assumed.
@c JP
以下の手続きで、省略可能な引数@var{iport}は入力ポートでなければなりません。
省略された場合が現在の入力ポートが使われます。
@c COMMON

@defun read &optional iport
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun read-char &optional iport
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun peek-char &optional iport
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun read-byte &optional iport
@c EN
Reads one byte from an input port @var{iport}, and returns an integer
in the range between 0 and 255.
If @var{iport} has already reached EOF, an eof object is returned.
@c JP
入力ポート@var{iport}から1バイト読み込み、0から255までの整数値として返します。
@var{iport}が既にEOFに達していた場合はeofオブジェクトを返します。
@c COMMON
@end defun

@defun read-line &optional iport
@c EN
Reads one line (a sequence of characters terminated by newline or EOF)
and returns a string.  The terminating newline is not included.
This function recognizes popular line terminators (LF only, CRLF, and CR only).
If @var{iport} has already reached EOF, an eof object is returned.
@c JP
入力ポートから、行末もしくはEOFまで読み込んで文字列として返します。
よく使われる行末 (LF only, CRLF, and CR only) を認識します。
戻り値にはこれらの行末文字は含まれません。
@var{iport}が既にEOFに達していた場合はeofオブジェクトを返します。
@c COMMON
@end defun

@defun read-block nbytes &optional iport
Reads @var{nbytes} bytes from @var{iport}, and returns an incomplete
string consisted by those bytes.  The size of returned string may
shorter than @var{nbytes} when @var{iport} doesn't have enough bytes
to fill.  If @var{iport} has already reached EOF, an eof object is returned.

When the available data in @var{iport} is less than @var{nbytes},
the behavior of this function differs by the underlying port mechanism.
@table @bullet
@item
If the input port is a buffered port, this function uses @code{fread(3)},
and usually it suspends until either the requested bytes becomes available
or the EOF is read.
@item
If the input port is an unbuffered port, this function uses @code{read(2)},
and usually returns after reading as many bytes as avaialble, which may
less than @var{nbytes}.   This is critical when you're communicating
with some other entity (e.g. a person via interactive session, or an other
process over the network) through the port; you can specify big @var{nbytes}
and retrieve small size of packet.   Note that, however, the function
does suspend when no data is immediately available from @var{iport}.
@item
If the input port is based on the in-core source (e.g. an input string),
the function never suspends.
@end table

Note: if you want to write a chunk of bytes (incomplete string) to a port,
use @code{display}.
@end defun

@defun eof-object? obj
[R5RS] Returns true if @var{obj} is an EOF object.
@end defun

@defun char-ready? port
[R5RS] If a character is ready to be read from @var{port}, returns @code{#t}.
@end defun

@defun port->string port
@defunx port->list reader port
@defunx port->string-list port
@defunx port->sexp-list port
Generally useful input procedures.  The API is taken from
scsh and STk.

@code{port->string} reads @var{port}
until EOF and returns the accumulated data as a string.

@code{port->list} applies @var{reader} on @var{port} repeatedly, until
@var{reader} returns an EOF, then returns the list of objects
@var{reader} returned.

@code{(port->string-list port)} @equiv{}
@code{(port->list read-line port)}, and
@code{(port->sexp-list port)} @equiv{}
@code{(port->list read port)}.
@end defun

@defun port-fold fn knil reader
@defunx port-fold-right fn knil reader
@defunx port-for-each fn reader
@defunx port-map fn reader
Convenient iterators over the input read by @var{reader}.
Basically, @var{reader} is called repeatedly without arguments
and @var{fn} is called for each item it returns, until @var{reader}
returns EOF.   Actually @var{reader} can be any thunk; it doesn't
need to be related to input port.

Suppose @var{reader} returns a series of items
@{X0, X1, @dots{}, Xn@}.
@code{port-fold} returns the following:
@example
(fn Xn (fn Xn-1 @dots{} (fn X0 knil)))
@end example
while @var{port-fold-right} returns the following:
@example
(fn X0 (fn X1 @dots{} (fn Xn knil)))
@end example
That is, @code{(port-fold cons '() read)} returns a reverse
list of all the inputs, while @code{(port-fold-right cons '() read)}
returns the same thing as @code{(port->list read port)}.

On the other hand, @code{port-for-each} and @code{port-map}
applies @var{fn} to each item.  The former discards the results
@var{fn} returns, while the latter returns a list of results.
@end defun

@node Output,  , Input, Input and output
@subsection Output
@c NODE 出力

@c EN
For the following procedures, the optional @var{port} argument must be
an output port, and when omitted, the current output port is assumed.
@c JP
以下の手続きで、省略可能な引数@var{port}は出力ポートでなければなりません。
省略された場合が現在の出力ポートが使われます。
@c COMMON

@defun write obj &optional port
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun display obj &optional port
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@deffn {Method} write-object (obj <object>) port
You can customize how the object is printed out by this method.
@end deffn

@defun newline &optional port
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun flush &optional port
@c @defunx flush-output-port &optional port
[R5RS]
@c EN
Output the buffered data in @var{port}.
This function is called in variety of ways on the various
Scheme implementations: @code{force-output} (Scsh, SCM),
@code{flush-output} (Gambit), or @code{flush-output-port} (Bigloo).
The name @code{flush} is taken from STk and STklos.
@c JP
@var{port}にバッファされているデータを全て書き出します。
この手続きはScheme実装によって様々な名前で呼ばれています：
@code{force-output} (Scsh, SCM)、
@code{flush-output} (Gambit)、@code{flush-output-port} (Bigloo) 等。
@code{flush}の名前はSTkとSTklosから取りました。
@c COMMON
@end defun

@defun write-char char &optional port
[R5RS]
@c EN
Write a single character @var{char} to the output port @var{port}.
@c JP
文字@var{char}をポートに出力します。
@c COMMON
@end defun

@defun write-byte byte &optional port
@c EN
Write a byte @var{byte} to the port.
@var{byte} must be an exact integer in range between 0 and 255.
@c JP
出力ポートに1バイトのデータ@var{byte}を書き出します。
@var{byte}は0から255の間の正確な整数でなければなりません。
@c COMMON
@end defun

@defun write* obj &optional port
@end defun

@defun format port string arg @dots{}
@c EN
Format @var{arg} @dots{} according to @var{string}.
This function is a subset of CommonLisp's @code{format} function,
with a bit of extension.
@c JP
@var{string} の指示に従い、@var{arg} @dots{}をフォーマットします。
この手続きはCommonLispの@code{format}のサブセットに、Gauche独自の拡張を
加えたものです。
@c COMMON

@c EN
@var{port} specifies the destination; if it is an output port, the
formatted result is written to it; if it is @code{#t},
the result is written to the current output port;
if it is @code{#f}, the formatted result is returned as a string.
@c JP
@var{port}は出力先を指定します。それが出力ポートであれば、フォーマットされた
結果はそのポートに書き出されます。@var{port}が@code{#t}であれば、結果は
現在の出力ポートに書き出されます。@var{port}が@code{#f}であれば、結果は
文字列として@code{format}から返されます。
@c COMMON

@c EN
@var{string} is a string that contains format directives.
A format directive is a character sequence begins with tilda, `@code{~}',
and ends with some specific characters.  A format directive takes
the corresponding @var{arg} and formats it.  The rest of string is
copied to the output as is.
@c JP
@var{string}はフォーマット指示子を含んだ文字列です。
フォーマット指示子はチルダ`@code{~}'から始まり、特定の文字で終了する文字の並びで、
それぞれのフォーマット指示子が対応する@var{arg}を取りフォーマットします。
@var{string}内のフォーマット指示子以外の文字列はそのまま出力されます。
@c COMMON

@example
(format #f "the answer is ~s" 42)
  @result{} "the answer is 42"
@end example

@c EN
The format directive can take one or more @var{parameters}, separated
by comma characters.  A parameter may be an integer or a character;
if it is a character, it should be preceded by a quote character.
Parameter can be omitted, in such case the system default value is
used.  The interpretation of the parameters depends on the 
format directive.
@c JP
フォーマット指示子は一つ以上のコンマで区切られたパラメータを取ることもできます。
パラメータは整数か文字です。文字の場合、クオート文字に続けてその文字を置きます。
パラメータが省略された場合は既定値が使われます。パラメータの意味はフォーマット指示子毎に
異なります。
@c COMMON

@c EN
Furthermore, a format directive can take two
additional flags: atmark `@code{@@}' and colon `@code{:}'.  One or
both of them may modify the behavior of the format directive.
Those flags must be placed immediately before the directive
character.
@c JP
さらに、フォーマット指示子は2種類のフラグ、`@code{@@}' と `@code{:}' を
取ることができます。これらの組合せでフォーマットの動作が変わります。フラグは
(もしあれば)パラメータの後、指示子の文字の直前に置かれなければなりません。
@c COMMON

@c EN
If a character `@code{v}' or `@code{V}' is in the place of the
parameter, the value of the parameter is taken from the format's
argument.  The argument must be either an integer, a character, or
@code{#f} (indicating that the parameter is effectively omitted).
@c JP
パラメータの位置に文字 `@code{v}' か `@code{V}' を置くこともできます。
その場合、パラメータの値が引数リストから取られます。対応する引数は整数か
文字、または@code{#f}でなければなりません。@code{#f}の場合はそのパラメータが
省略されたのと同じになります。
@c COMMON

@c EN
Some examples:

@table @code
@item ~10,2s
A format directive @code{~s}, with two parameters, 10 and 2.
@item ~12,,,'*A
A format directive @code{~a}, with 12 for the first parameter and
a character `@code{*}' for the fourth parameter.  The second and
third parameters are omitted.
@item ~10@@d
A format directive @code{~d}, with 10 for the first parameter and
`@code{@@}' flag.
@item ~v,vx
A format directive @code{~x}, whose first and second parameter will
be taken from the arguments.
@end table
@c JP
いくつかの例です。

@table @code
@item ~10,2s
パラメータ10と2を伴う、フォーマット指示子@code{~s}。
@item ~12,,,'*A
第1パラメータに数値12、第4パラメータに文字`@code{*}'を取るフォーマット指示子@code{~a}。
第2と第3のパラメータは省略されています。
@item ~10@@d
フォーマット指示子@code{~d}。パラメータ10と`@code{@@}'フラグがついています。
@item ~v,vx
フォーマット指示子@code{~x}。第1パラメータと第2パラメータは引数リストから取られます。
@end table
@c COMMON

@c EN
The following is a complete list of the supported format directives.
Either upper case or lower case character can be used for the format
directive; usually they have no distinction, except noted.
@c JP
以下にサポートされているフォーマット指示子を示します。フォーマット指示子の文字自体は
大文字であっても小文字であっても構いません。特に断りのない限り両者は同じ動作をします。
@c COMMON

@table @asis
@item @b{~}@var{mincol},@var{colinc},@var{minpad},@var{padchar},@var{maxcol}@b{A}
@c EN
Ascii output.  The corresponding argument is printed by @code{display}.
If an integer @var{mincol} is given, it specifies the minimum number
of characters to be output; if the formatted result is shorter than
@var{mincol}, a whitespace is padded to the right (i.e. the result
is left justified).
@c JP
ASCII出力。対応する引数が@code{display}を使ってフォーマットされます。
整数が@var{mincol}に与えられた場合、それは出力される最小の文字数を指定します。
引数のフォーマット結果が@var{mincol}より短ければ、空白が右に追加されます(つまり、
左詰めになります)。
@c COMMON

@c EN
The @var{colinc}, @var{minpad} and @var{padchar} parameters
control, if given, further padding.  A character @var{padchar} replaces
the padding character for the whitespace.  If an integer @var{minpad}
is given and greater than 0, at least @var{minpad} padding character
is used, regardless of the resulting width.  If an integer @var{colinc}
is given, the padding character is added (after @var{minpad}) in chunk
of @var{colinc} characters, until the entire width exceeds @var{mincol}.
@c JP
@var{colinc}、@var{minpad}、そして@var{padchar}は更に細かいパディング方法を
指定します。@var{padchar}に文字が与えられた場合、それが空白文字の代わりにパディング文字と
して使われます。@var{minpad}に0以上の整数が与えられた場合、少なくともその数だけの
パディング文字が追加されます。@var{colinc}が指定された場合、
追加されるパディング文字の数が@var{colinc}の倍数に調整されます。
@c COMMON

@c EN
If atmark-flag is given, the format result is right justified, i.e.
padding is added to the left.
@c JP
アトマーク `@code{@@}' フラグが与えられた場合、結果は右詰めになります。
@c COMMON

@c EN
The @var{maxcol} parameter, if given, limits the maximum number of characters
to be written.  If the length of formatted string exceeds
@var{maxcol}, only @var{maxcol} characters are written.
If colon-flag is given as well and the length of formatted string
exceeds @var{maxcol}, @var{maxcol} - 4 characters are written and
a string ``@code{ ...}'' is attached after it.
@c JP
@var{maxcol}パラメータは与えられていれば書かれる文字数の上限を指定します。
フォーマット後の文字列の長さが@var{maxcol}を超えた場合、@var{maxcol}文字だけが
書かれます。コロン `@code{:}' フラグが同時に与えられていれば、
@var{maxcol} - 4 文字が書かれた後、文字列``@code{ ...}''が書かれます。
@c COMMON

@example
(format #f "|~a|" "oops")
  @result{} "|oops|"
(format #f "|~10a|" "oops")
  @result{} "|oops      |"
(format #f "|~10@@a|" "oops")
  @result{} "|      oops|"
(format #f "|~10,,,'*@@a|" "oops")
  @result{} "|******oops|"
@c JP
(format #f "|~10,,,'☆a|" "oops")
  @result{} "|oops☆☆☆☆☆☆|"
@c COMMON

(format #f "|~,,,,10a|" '(abc def ghi jkl)
  @result{} "|(abc def gh|" 
(format #f "|~,,,,10:a|" '(abc def ghi jkl)
  @result{} "|(abc de ...|" 
@end example

@item @b{~}@var{mincol},@var{colinc},@var{minpad},@var{padchar},@var{maxcol}@b{S}
@c EN
S-expression output.  The corresponding argument is printed
by @code{write}.  The semantics of parameters and flags are the same
as @code{~A} directive.
@c JP
S式出力。対応する引数が@code{write}を使ってフォーマットされます。
パラメータの意味は@code{~A}指示子と同じです。
@c COMMON

@example
(format #f "|~s|" "oops")
  @result{} "|\"oops\"|"
(format #f "|~10s|" "oops")
  @result{} "|\"oops\"    |"
(format #f "|~10@@s|" "oops")
  @result{} "|    \"oops\"|"
(format #f "|~10,,,'*@@s|" "oops")
  @result{} "|****\"oops\"|"
@c JP
(format #f "|~10,,,'★s|" "oops")
  @result{} "|\"oops\"★★★★|"
@c COMMON
@end example

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{D}
@c EN
Decimal output.  The argument is formatted as an decimal integer.
If the argument is not an integer, all parameters are ignored 
(after processing `@code{v}' parameters) and
it is formatted by @code{~A} directive.
@c JP
10進出力。対応する引数が10進数表記でフォーマットされます。もし引数が数値でなければ、
全てのパラメータは(`@code{v}'パラメータの処理後に)無視され、
引数は@code{~A}でフォーマットされます。
@c COMMON

@c EN
If an integer parameter @var{mincol} is given, it specifies minimum
width of the formatted result; if the result is shorter than it,
@var{padchar} is padded on the left (i.e. the result is right
justified).  The default of @var{padchar} is a whitespace.
@c JP
もし@var{mincol}に整数が与えられたら、それが最小の文字数を指定します。
結果の文字数がそれより少なければ、文字@var{padchar}が左に追加されます(右詰めになります)。
@var{padchar}が省略された場合は空白文字が使われます。
@c COMMON

@example
(format #f "|~d|" 12345)
  @result{} "|12345|"
(format #f "|~10d|" 12345)
  @result{} "|     12345|"
(format #f "|~10,'0d|" 12345)
  @result{} "|0000012345|"
@end example

@c EN
If atmark-flag is given, the sign `@code{+}' is printed for the
positive argument.
@c JP
アトマーク `@code{@@}' フラグが与えられた場合、正の引数に対して `@code{+}' が
先頭につけられます。
@c COMMON

@c EN
If colon-flag is given, every @var{interval}-th digit of
the result is grouped and @var{commachar} is inserted between them.
The default of @var{commachar} is `@code{,}', and the default of
@var{interval} is 3.
@c JP
コロンフラグ `@code{:}' が与えられた場合、結果の文字は@var{interval}文字毎に
まとめられ、間に文字@var{commachar}が挿入されます。デフォルトでは3文字毎にコンマが
挿入されます。
@c COMMON

@example
(format #f "|~:d|" 12345)
  @result{} "|12,345|"
(format #f "|~,,'_,4:d|" -12345678)
  @result{} "|-1234_5678|"
@end example

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{B}
@c EN
Binary output.  The argument is formatted as a binary integer.
The semantics of parameters and flags are the same as
the @code{~D} directive.
@c JP
2進出力。対応する引数が2進数の整数としてフォーマットされます。
パラメータの意味は@code{~D}と同じです。
@c COMMON

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{O}
@c EN
Octal output.  The argument is formatted as an octal integer.
The semantics of parameters and flags are the same as
the @code{~D} directive.
@c JP
8進出力。対応する引数が8進数の整数としてフォーマットされます。
パラメータの意味は@code{~D}と同じです。
@c COMMON

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{X}
@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{x}
@c EN
Hexadecimal output.
The argument is formatted as a hexadecimal integer.
If `@code{X}' is used, upper case alphabets are used for
the digits larger than 10.  If `@code{x}' is used, lower case
alphabets are used.
The semantics of parameters and flags are the same as
the @code{~D} directive.
@c JP
16進出力。対応する引数が16進数の整数としてフォーマットされます。
フォーマット指示文字に `@code{X}' が与えられた場合は `@code{ABCDEF}' が桁文字として
使われ、 `@code{x}' が与えられた場合は `@code{abcdef}' が桁文字として使われます。
パラメータの意味は@code{~D}と同じです。
@c COMMON

@example
(format #f "~8,'0x" 259847592)
  @result{} "0f7cf5a8"
(format #f "~8,'0X" 259847592)
  @result{} "0F7CF5A8"
@end example
@end table

@end defun


@c ----------------------------------------------------------------------
@node Loading Programs, Comparison and sorting, Input and output, Core library
@section Loading Programs
@c NODE プログラムのロード

@menu
* Loading Scheme file::         
* Loading dynamic library::     
* Require and provide::         
* Autoload::                    
@end menu

@node Loading Scheme file, Loading dynamic library, Loading Programs, Loading Programs
@subsection Loading Scheme file
@c NODE Schemeファイルのロード

@defun load file &keyword paths (error-if-not-found #t)
[R5RS+]
@c EN
Loads @var{file}, that is, read Scheme expressions in @var{file} and
evaluates them.
An extension ``@code{.scm}'' may be omitted from @var{file}.

If @var{file} doesn't begin with ``/'' or ``./'' or ``../'',
it is searched from the system file search list,
stored in a variable @code{*load-path*}.
Or you can explicitly specify the search path by passing
a list of directory names to the keyword argument @var{paths}.

On success, @code{load} returns @code{#t}.
If the specified file is not found, an error is signalled unless
the keyword argument @code{error-if-not-found} is @code{#f}, in
which case @code{load} returns @code{#f}.

The current module is preserved; even @code{select-module} is
called in @var{file}, the module in which @code{load} is called
is restored afterwards.

If you want to load a library file, it's better to use `@code{use}'
(@xref{Module syntax}), or `@code{require}' described below.
@xref{Compilation}, for difference between @code{load} and @code{require}.
@c JP
@var{file}をロードします。すなわち、@var{file}に書かれたScheme式を順次読み込んで
評価します。@var{file}の拡張子 (``@code{.scm}'') は省略できます。

@var{file}が ``/'', ``./'' または ``../'' で始まっていない場合は、
システムファイルサーチパス (変数@code{*load-path*} に格納されています)
の中から該当ファイルが探されます。あるいは、キーワード引数@var{paths}にディレクトリ名の
リストを渡すことによりサーチパスを指定することもできます。

ロードに成功した場合は@code{#t}が返されます。
指定ファイルがみつからない場合はエラーとなりますが、もしキーワード引数
@code{error-if-not-found}に@code{#f}が与えられていれば単に@code{load}から
@code{#f}が返されます。

カレントモジュールは保存されます。つまり、@var{file}中で@code{select-module}によって
カレントモジュールを変更しても、@code{load}が終わったら@code{load}を読んだ時点の
モジュールに戻ります。

ライブラリファイルをロードする場合は、`@code{use}' (@ref{Module syntax}参照) を
使うか、下に説明する`@code{require}' を使う方が良いでしょう。
@code{load}と@code{require}の違いについては@ref{Compilation}を参照してください。
@c COMMON
@end defun

@defvar *load-path*
@c EN
Keeps a list of directories that are searched by @code{load} and
@code{require}.

If you want to add other directories to the search path,
do not modify this variable directly; use @code{add-load-path},
described below, instead.
@c JP
@code{load}と@code{require}がファイルを探すディレクトリのリストを保持しています。

もしサーチパスにディレクトリを追加したい場合は、この変数を直接変更せずに、下に説明する
@code{add-load-path}を用いて下さい。
@c COMMON
@end defvar

@defspec add-load-path path &optional (afterp #f)
@c EN
Adds a path @var{path} to the library load path list.
If a true value is given to @var{afterp}, @var{path} is added
after the existing paths; otherwise, @var{path} is added before the
existing paths.

Use this form instead of changing @code{*load-path*} directly.
This form is a special form and recognized by the compiler;
if you change @code{*load-path*}, it is in effect at run time,
and that may be too late for ``use'' or ``require''.

Furthermore,
@code{add-load-path} looks for the architecture dependent directories
under the specified path and if it exists, sets up the internal
path list for dynamic loading correctly.   Suppose you have
your Scheme module in @code{/home/yours/lib}, and that requires 
a dyncamic loadable library.  You can put the library under
@code{/home/yours/lib/@var{ARCH}/}, where @var{ARCH} is
the value @code{(gauche-architecture)} returns (@xref{Environment Inquiry}).
Then you can have compiled libraries for multiple platforms and
Gauche can still find the right library.
@c JP
パス@var{path}をライブラリロードパスのリストに加えます。
@var{afterp}に真の値が与えられていれば@var{path}は既存のリストの末尾に
追加されます。そうでなければ@var{path}は既存のリストの先頭に追加されます。

ロードパスを変更したい場合、@code{*load-path*}を直接替えずにこのフォームを
使って下さい。このフォームはコンパイル時に解釈されるのに対し、@code{*load-path*}を
書き換えるコードは実行時に解釈されます。``@code{use}'' や ``@code{require}'' は
コンパイル時のロードパスを使うので、@code{*load-path*}への変更は反映されないかもしれません。

更に、@code{add-load-path}は@var{path}の下にアーキテクチャ依存のディレクトリが
ないかどうかを探し、あればそれを内部の共有ライブラリサーチパスに追加します。
例えばあなたが自分のSchemeモジュールを@code{/home/yours/lib}に入れていて、
それが共有ライブラリを必要としていたとします。手続き@code{gauche-architecture}
(@ref{Environment Inquiry}参照)が返す値を@var{ARCH}として、
共有ライブラリを@code{/home/yours/lib/@var{ARCH}/}に置いておくと、
共有ライブラリはそこからロードされます。この方法を取ると、複数のプラットフォーム用に
別々にコンパイルされた共有ライブラリを管理することができます。
@c COMMON
@end defspec

@defun load-from-port port
@c EN
Reads Scheme expressions from an input port @var{port} and evaluates
them, until EOF is read.
@c JP
入力ポート@var{port}から、EOFを読むまで繰り返しScheme式を読み込み評価します。
@c COMMON
@end defun

@defun current-load-port
@defunx current-load-history
@defunx current-load-next
@c EN
These procedures allows you to query the current context of loading.
They returns the following values when called inside a file being loaded:
@table @code
@item current-load-port
Returns the port object from which the file is being read.
@item current-load-history
Returns a list of pairs of a port and a line number (integer),
representing the nesting of loads.  Suppose you load
@file{foo.scm}, and from its line 7 it loads @file{bar.scm}, 
and from its line 18 it loads @file{baz.scm}.   If you call
@code{current-load-history} in the file @file{baz.scm}, you'll get
@example
((#<port "foo.scm"> . 7) (#<port "bar.scm"> . 18))
@end example
@item current-load-next
Returns a list of remaining directories to be searched
at the time this file is found.   Suppose the @code{*load-path*}
is @code{("." "../lib" "/home/gauche/lib" "/share/gauche/lib")}
and you load @file{foo.scm}, which happens to be in @file{../lib/}.
Then, inside @file{foo.scm}, @code{current-load-next} returns:
@example
("/home/gauche/lib" "/share/gauche/lib")
@end example
@end table

When called outside of @code{load}, these procedures returns
@code{#f}, @code{()} and @code{()}, respectively.
@c JP
これらの手続きによって、現在のロードのコンテクストを知ることができます。
ロードされているファイルの中でこれらの手続きを呼ぶと、次のような値が返されます。
@table @code
@item current-load-port
現在のファイルがロードされている入力ポート。
@item current-load-history
入力ポートと行番号のペアのリストで、ロードのネスティングを示したもの。
例えばあなたが@file{foo.scm}をロードし、そのファイルの7行目で
@file{bar.scm}がロードされ、そのファイルの18行目で@file{baz.scm}が
ロードされたとします。@code{current-load-history}を@file{baz.scm}中で
呼ぶと、それは次のような値を返します。
@example
((#<port "foo.scm"> . 7) (#<port "bar.scm"> . 18))
@end example
@item current-load-next
現在のファイルがロードされた時点での、ファイルサーチパスの残りを返します。
例えば @code{*load-path*} が
@code{("." "../lib" "/home/gauche/lib" "/share/gauche/lib")}で、
あなたが@file{foo.scm}をロードしたところ、それが@file{../lib/}中に見つかったと
しましょう。このとき、@file{foo.scm}中で@code{current-load-next}を呼べば
@example
("/home/gauche/lib" "/share/gauche/lib")
@end example
が返されます。
@end table

@code{load}されていない状態で呼ばれた時は、これらの手続きはそれぞれ@code{#f}、
@code{()}、@code{()}を返します。
@c COMMON
@end defun


@node Loading dynamic library, Require and provide, Loading Scheme file, Loading Programs
@subsection Load dynamic library
@c NODE ダイナミックライブラリのロード

@defun dynamic-load file &keyword init-function export-symbols
@c EN
Loads and links a dynamic loadable library (shared library) @var{file}.
@var{File} shouldn't contain the suffix (``.so'' on most systems);
@code{dynamic-load} adds it, for it may differ among platforms.

The keyword argument @var{init-function} specifies the initialization
function name of the library in a string.  By default, if the file
basename (without extension) is ``foo'', the initialization function
name is ``Scm_Init_foo''.

The keyword argument @var{export-symbols} tells whether the dynamic loader
that the external symbols in @var{file} should be appended to
the symbol table of the running process.  (Note: I'm talking about
C function and variable names, not Scheme symbols).
By default, the symbols
in @var{file} are not visible from other dynamically loaded libraries.
If you want to allow other dynamically loaded libraries to call
C function in your library, you should give @code{#t} to this 
argument.  It sets @code{RTLD_GLOBAL} flag for @code{dlopen()}.

Usually a dynamic loadable library is provided with wrapping Scheme
module, so the user doesn't have to call this function directly.

There's no way to unload the loaded libraries.
@c JP
ダイナミックローダブルライブラリ(共有ライブラリ)@var{file}をロードしてリンクします。
@var{file}にはサフィックス(``.so'' 等) を含めないで下さい。システムによって
サフィックスは異なるため、@code{dynamic-load}がそれを追加します。

キーワード引数@var{init-function}は共有ライブラリ中の初期化関数の名前を
指定します。デフォルトでは、サフィックスを除くファイル名が ``foo'' の場合、
初期化関数名は ``Scm_Init_foo'' となります。

キーワード引数@var{export-symbols}は、ロードされるライブラリ中の外部シンボルを
プロセスのシンボルテーブルに追加すべきかどうかを指定します。(註：ここでの「シンボル」
とはCの関数名や変数名のことで、Schemeのシンボルのことではありません)。
デフォルトでは共有ライブラリの外部シンボルはプロセスのシンボルテーブルに追加されず、
それぞれの共有ライブラリは他の共有ライブラリのシンボルを見ることができません。
@var{export-symbols}に真の値を渡すと、フラグ@code{RTLD_GLOBAL}が
@code{dlopen()}に渡されて、その共有ライブラリ中のシンボルがこれからロードされる
共有ライブラリからも見えるようになります。

通常、共有ライブラリはSchemeモジュール中でロードされるので、モジュールユーザが
直接この手続きを呼ぶ必要はほとんどないでしょう。

一度ロードされた共有ライブラリをアンロードすることはできません。
@c COMMON
@end defun


@node Require and provide, Autoload, Loading dynamic library, Loading Programs
@subsection Require and provide
@c NODE requireとprovide

@defspec require feature
@c EN
If @var{feature} is not loaded, load it.  @var{Feature} must be a string,
and it is taken as a file name (without suffix) to be loaded.
This loading takes place at compile time.   The loaded file must provide
@var{feature}; if not, a warning is issued.

If you load SLIB module, @code{require} is extended.  @xref{SLIB} for
details.
@c JP
@var{feature}がまだロードされていなければロードします。@var{feature}は文字列で
なければなりません。それがそのまま(サフィックスを除く)ファイル名としてロードパスから
探されます。@code{require}の解釈はコンパイル時に行われます。
ロードされたファイルはその中で@var{feature}をprovideしなければなりません。
そうでないと警告が出されます。

SLIBモジュールをロードすると、@code{require}が拡張されます。詳しくは@ref{SLIB}を
参照して下さい。
@c COMMON
@end defspec

@defun provide feature
@c EN
Adds @var{feature} to the system's provided feature list, so that
the subsequent @code{require} won't load the same file again.
Usually this procedure should be called at the end of the Scheme file
that is to be @code{require}d.   The reason that it should be at the end
of file is that if an error is raised during loading, you may want to
fix the error and @code{require} it again.
@c JP
@var{feature}をシステムのprovideされたフィーチャーリストに加えます。
以降、@var{feature}が@code{require}されてもファイルはふたたびロードされません。
通常この手続きは、requireされるファイルの末尾で呼ばれます。ファイルの末尾で呼ぶのが良いのは、
もしファイルのロード中にエラーが発生した場合、そのエラーを修正した上でふたたび@code{require}
でロードできるからです。
@c COMMON
@end defun

@defun provided? feature
@c EN
Returns @code{#t} if @var{feature} is already provided.
@c JP
@var{feature}が既にprovideされていれば@code{#t}を返します。
@c COMMON
@end defun

@node Autoload,  , Require and provide, Loading Programs
@subsection Autoload

@defmac autoload file/module item @dots{}
@c EN
Sets up @var{item} @dots{} to be autoloaded.
That is, when an @var{item} is referenced for the first time,
@var{file/module} is loaded before the @var{item} is evaluated.
This delays the loading of @var{file/module} until it is needed.
@c JP
@var{item} @dots{} がオートロードされるように設定します。すなわち、
次に@var{item}が参照された時、それが実際に評価される前に@var{file/module}がロード
されるようにします。これによって、必要とされる時まで@var{file/module}のロードを遅らせる
ことができます。
@c COMMON

@c EN
You can specify either a string file name or a symbol module name
to @var{file/module}.  If it is a string, the named file is
loaded.  If it is a symbol, the named module is loaded (using the
same rule as of @code{use}), then the binding of @var{item} in the
@var{file/module} is imported to the module used the autoload
(@xref{Module syntax}, for details of @code{use}).
@c JP
引数@var{file/module}には、文字列かシンボルを指定できます。文字列の場合は
そのファイルがロードされます。シンボルの場合、その名のモジュールが(@code{use}と
同じルールで)ロードされ、@var{item}が@var{file/module}から
オートロードを呼び出したモジュールへとインポートされます。
(モジュールの@code{use}の詳細については@ref{Module syntax}を参照して下さい)。
@c COMMON

@c EN
@var{Item} can be either a variable name (symbol), 
or a form @code{(:macro @var{symbol})}.  If it is a variable,
the named file/module is loaded when the variable is
about to be evaluated.  If it is the latter form,
the named file/module is loaded when a form
@code{(@var{symbol} arg @dots{})} is about to be @emph{compiled},
which enables autoloading macros.
@c JP
@var{item}は変数名(シンボル)か、@code{(:macro @var{symbol})}というフォーム
でなければなりません。変数名の場合は、その変数が評価されようとした時に
指定のファイル／モジュールがロードされます。後者のフォームの場合は、
@code{(@var{symbol} arg @dots{})} というフォームがコンパイルされようとした
時に指定のファイル／モジュールがロードされます。後者はマクロのオートロードになります。
@c COMMON

@c EN
@var{file/module} must define @var{symbol} in it, or an error is signalled
when @var{file/module} is autoloaded.
@c JP
@var{symbol}は@var{file/module}の中で定義されなければなりません。
そうでなければロード時にエラーが報告されます。
@c COMMON

@c EN
The following is an example of autoloading procedures.
@c JP
手続きのオートロードの例を示します。
@c COMMON
@example
(autoload "foo" foo0 foo1)
(autoload "bar" bar0 bar1)

(define (foobar x)
  (if (list? x)
      (map bar0 x)
      (foo0)))

@c EN
(foobar '(1 2)) ; @r{"bar" is loaded at this moment}

(foobar #f)     ; @r{"foo" is loaded at this moment}
@c JP
(foobar '(1 2)) ; @r{この時点で "bar" がロードされる}

(foobar #f)     ; @r{この時点で "foo" がロードされる}
@c COMMON
@end example

@c EN
Note that if you set to autoload macro, the file/module is loaded
immediately when such form that uses the macro is compiled,
regardless of the piece of
the code is executed or not.
@c JP
マクロのオートロードを設定した場合、指定のファイルまたはモジュールは、
そのマクロを使っているフォームが実行されるされないにかかわらず、
コンパイラがそのフォームを見た時点でロードされることに注意してください。
@c COMMON
@end defmac


@c ----------------------------------------------------------------------
@node Comparison and sorting, System interface, Loading Programs, Core library
@section Comparison and sorting
@c NODE 比較とソート

@defun sort list &optional cmfpn
@defunx sort! list &optional cmfpn
Sorts elements in @var{list} in ascending order and returns the sorted
list.  @code{sort!} destructively reuses the cons cells of the original
@var{list}.  The sorting order is specified by @code{cmpfn}, which is
a procedure takes two elements of @var{list}, and returns @code{#t}
if the first argument strictly precedes the second.

@example
(sort '(("Chopin" "Frederic") 
        ("Liszt" "Franz")
        ("Alkan" "Charles-Valentin"))
      (lambda (x y) (string<? (car x) (car y))))
  @result{} (("Alkan" "Charles-Valentin")
             ("Chopin" "Frederic")
             ("Liszt" "Franz"))
@end example

Some builtin objects have natural comparison order, and it is used
if @code{cmpfn} is omitted.
@end defun


@c ----------------------------------------------------------------------
@node System interface,  , Comparison and sorting, Core library
@section System interface
@c NODE システムインタフェース

@c EN
Gauche supports most of POSIX.1 functions and other system functions
popular among Unix variants as built-in procedures.
@c JP
GaucheはPOSIX.1の多くの関数と、さまざまなUnixで共通して使われているシステム関数へのインタフェースを
組込み手続きとして提供しています。
@c COMMON

@c EN
The procedures with name @code{sys-}@var{name} usually correspond to the
system call @var{name}.  I tried to keep the interface similar
whenever reasonable.  Sometimes Gauche has other routines that
are higher level than system calls, nevertheless I try to
provide lower level routines as well.
@c JP
@code{sys-}@var{name}という名前を持つ手続きは、多くの場合、
システムコール@var{name}に対応しています。
可能な限り、インタフェースが似るようにしました。
しばしばGaucheはシステムコールよりも高機能の手続きを提供していますが、
その場合でもなるべく低レベルのルーチンも提供するようにしています。
@c COMMON

@c EN
If you are familiar with system programming in C,
see also @ref{C to Scheme mapping}, which shows
correspondence between C standard library functions
and Gauche procedures.
@c JP
Cによるシステムプログラミングに慣れている方は、
@ref{C to Scheme mapping}も参考にして下さい。
Cの標準ライブラリとGaucheの手続きとの対応が示してあります。
@c COMMON

@menu
* Program termination::         
* Environment Inquiry::         
* Filesystems::                 
* Unix groups and passwords::   
* Locale::                      
* Signal::                      
* System Inquiry::              
* Time::                        
* Unix process management::     
* I/O multiplexing::            
* Miscellaneous system calls::  
@end menu

@node Program termination, Environment Inquiry, System interface, System interface
@subsection Program termination
@c NODE プログラムの終了

@defun exit &optional (code 0)
[POSIX]
@c EN
Terminates the current process with the exit code @var{code}.
@var{Code} must be zero or positive exact integer.
This procedure first invokes the @var{after} thunks of the current dynamic
handlers (@xref{Continuation}), then This calls @code{exit(2)}
which does some cleaning up, like flushing the opened file buffers.
@c JP
現在のプロセスを終了し、@var{code}を終了コードにします。
@var{code}はゼロもしくは正の正確な整数でなければなりません。
この手続きはまずアクティブなダイナミックハンドラの@var{after}手続きを全て呼び出し
(@xref{Continuation})、続いて@code{exit(2)}を呼び出します。
@c COMMON
@end defun


@defun sys-exit &optional (code 0)
[POSIX]
@c EN
Terminates the current process with the exit code @var{code}.
@var{Code} must be zero or positive exact integer.
This procedure calls @code{_exit(2)} directly.
No cleanup is done.  Unflushed file output is discarded.
@c JP
現在のプロセスを終了し、@var{code}を終了コードにします。
@var{code}はゼロもしくは正の正確な整数でなければなりません。
この手続きは@code{_exit(2)}を直接コールします。
クリーンアップは一切行われません。
フラッシュされてないファイルバッファの内容は捨てられます。
@c COMMON

@c EN
You may use this procedure if you find the system is screwed up
and no reasonable clean up can be done.  You should use this function
to terminate a forked process; @ref{Fork and exec} for details.
@c JP
この手続きは、
一切のクリーンアップに意味が無いほどシステムがどうしようもない状態になった時に使えます。
また、forkした子プロセスを終了させる時にこの手続きが必要になることがあります。
@ref{Fork and exec}を参照して下さい。
@c COMMON
@end defun

@node Environment Inquiry, Filesystems, Program termination, System interface
@subsection Environment Inquiry
@c NODE 環境の問い合わせ

@defun sys-getenv name
[POSIX]
@c EN
Returns the value of the environment variable @var{name} as a string,
or @code{#f} if the environment variable is not defined.
@c JP
環境変数@var{name}の値を文字列で返します。もし@var{name}が定義されていなければ、
@code{#f}が返ります。
@c COMMON
@end defun

@defun sys-putenv name value
@c EN
Add environment variable @var{name} with @var{value} to the current
process's environment.  This function is only available if the
platform supports putenv(3).
@c JP
プロセスの環境変数@var{name}に値@var{value}をセットします。この関数は
putenv()がサポートされているシステムでのみ定義されています。
@c COMMON
@end defun

@defun gauche-version
@defunx gauche-architecture
@defunx gauche-library-directory
@defunx gauche-architecture-directory
@defunx gauche-site-library-directory
@defunx gauche-site-architecture-directory
@c EN
These functions returns a string that tells information about Gauche
interpreter itself.
@c JP
これらの手続きはGaucheインタプリタの情報を文字列で返します。
@c COMMON
@end defun

@node Filesystems, Unix groups and passwords, Environment Inquiry, System interface
@subsection Filesystems
@c NODE ファイルシステム

@menu
* Directories::                 
* Directory manipulation::      
* Pathnames::                   
* File stats::                  
* Other file operations::       
@end menu

@node Directories, Directory manipulation, Filesystems, Filesystems
@subsubsection Directories
@c NODE ディレクトリ

@defun sys-readdir path
@c EN
@var{path} must be a string that denotes valid pathname of an existing
directory.  This function returns a list of strings of the directory
entries.  The returned list is not sorted.  An error is signalled
if @var{path} doesn't exists or is not a directory.
@c JP
@var{path}は存在するディレクトリを示すパス名でなければなりません。
この手続きはディレクトリの全エントリを文字列のリストとして返します。
リストはソートされません。@var{path}が存在しなかったり、ディレクトリでなかった場合は
エラーとなります。
@c COMMON
@end defun

@defun sys-glob pattern
@c EN
An interface to @code{glob(3)} function.  @var{pattern} is a file pattern
like sh(1): a character `@code{?}' matches any single character, 
`@code{*}' matches zero or more characters, `@code{[abc]}' matches
either `@code{a}', `@code{b}' or `@code{c}'.  If no pathname matches
@var{pattern}, an empty list is returned.

If the undelying platform doesn't have @code{glob()}, this function
signals an error of "feature not supported".

Note: it is known that on some systems glob() implementation has
a security issue.  Gauche will eventually implment glob() functionality
in itself.
@c JP
glob(3)関数へのインタフェースです。@var{pattern}はsh(1)で使われるパターンです:
`@code{?}'は任意の一文字にマッチし、`@code{*}'は0以上の任意の文字にマッチし、
`@code{[abc]}'は文字`@code{a}', `@code{b}', `@code{c}' のいずれにも
マッチします。マッチするパス名が無ければ空のリストが返されます。

glob()をサポートしていないシステムでは、エラーが通知されます。

註：glob()の実装にセキュリティ上の問題のあるシステムがあることが知られています。
Gaucheではいずれ、自前のglob()実装を持つ予定です。
@c COMMON
@end defun

@c EN
@xref{File stats}, to check if a path is actually a directory.
@c JP
パスがディレクトリかどうかチェックする方法は、@ref{File stats}を参照してください。
@c COMMON

@node Directory manipulation, Pathnames, Directories, Filesystems
@subsubsection Directory manipulation
@c NODE ディレクトリ操作

@defun sys-remove filenmae
[POSIX] 
@c EN
If @var{filename} is a file it is removed.
On some systems this may also work on an empty directory,
but portable scripts shouldn't depend on it.
@c JP
@var{filename}がファイルであればそれを消去します。
システムによっては@var{filename}が空のディレクトリであっても動作しますが、
移植性を気にする場合はその動作に依存しない方が良いでしょう。
@c COMMON
@end defun

@defun sys-rename old new
[POSIX]
@c EN
Renames a file @var{old} to @var{new}.  The new name
can be in different directory from the old name, but both paths
must be on the same device.
@c JP
ファイル@var{old}を@var{new}にリネームします。新しい名前は
古い名前と異なるディレクトリにあってもかまいませんが、両者は同じデバイス上に
なければなりません。
@c COMMON
@end defun

@defun sys-tmpnam
[POSIX]
@c EN
Creates a file name which is supposedly unique, and returns it.
This is in POSIX, but its use is discouraged because of potential
security risk.  Use @code{sys-mkstemp} below if possible.
@c JP
ユニークなファイル名を作成して返します。この関数はPOSIXに含まれていますが、
セキュリティ上の問題が指摘されており、使わない方が良いとされています。
可能なら下にあげる@code{sys-mkstemp}を使って下さい。
@c COMMON
@end defun

@defun sys-mkstemp template
@c EN
Creates and opens a file that has unique name, and returns two values;
opened port and the created filename.  The file is created exclusively,
avoiding race conditions.   @var{tmpname} is used as the prefix
of the file.  Unlinke Unix's mkstemp, you don't need padding characters.
The file is opened for writing, and its permission is set to 600.
@c JP
ユニークな名前を持つファイルを作成してオープンし、オープンされたポートとファイル名の
二つの値を返します。ファイルは排他的に作成されるため、レースコンディションは起こりません。
@var{tmpname}はファイル名のプレフィックスに使われます。Unixのmkstempと違って、
パディングキャラクタをつける必要はありません。ファイルは書き込み用としてオープンされ、
パーミッションは600にセットされます。
@c COMMON
@end defun

@defun sys-link existing new
[POSIX] 
@c EN
Creates a hard link named @var{new} to the existing file @var{existing}.
@c JP
既存のファイル@var{existing}に対し、@var{new}という名のハードリンクを作成します。
@c COMMON
@end defun

@defun sys-unlink pathname
[POSIX]
@c EN
Removes @var{pathname}.  It can't be a directory.
Returns @code{#t} if it is successfully removed, or
@var{#f} if @var{pathname} doesn't exist.
An error is signalled otherwise.
@c JP
@var{pathname}で示されるファイルを消去します。
@var{pathname}はディレクトリであってはなりません。
もし消去に成功したら@code{#t}が、@var{pathname}が存在しなければ@code{#f}が返されます。
他の場合はエラーが通知されます。
@c COMMON
@end defun

@defun sys-symlink existing new
@c EN
Creates a symbolic link named @var{new} to the pathname @var{existing}.
On systems that doesn't support symbolic links,
this function is unbound.
@c JP
@var{existing}を指す@var{new}という名のシンボリックを作成します。
シンボリックリンクをサポートしないシステムでは、この手続きは定義されません。
@c COMMON
@end defun

@defun sys-readlink path
@c EN
If a file specified by @var{path} is a symbolic link, its content is
returned.  If @var{path} doesn't exist or is not a symbolic link, an
error is signalled.
On systems that don't support symbolic links,
this function is unbound.
@c JP
@var{path}で示されるファイルがシンボリックリンクならば、それが指すパスを返します。
もし@var{path}が存在しなかったり、シンボリックリンクでなければ、エラーが通知されます。
シンボリックリンクをサポートしないシステムでは、この手続きは定義されません。
@c COMMON
@end defun

@defun sys-mkdir pathname mode
[POSIX] 
@c EN
Makes a directory @var{pathname} with mode @var{mode}.
The parent directory of @var{pathname} must exist and be writable
by the process.
@c JP
ディレクトリ@var{pathname}をモード@var{mode}で作成します。
@var{pathname}の親ディレクトリは存在して、プロセスが書き込めるようになっていなければ
なりません。
@c COMMON
@end defun

@defun sys-rmdir pathname
[POSIX]
@c EN
Removes a directory @var{pathname}.  The directory must be empty.
@c JP
ディレクトリ@var{pathname}を消去します。ディレクトリは空でなければなりません。
@c COMMON
@end defun

@defun sys-umask mode
[POSIX] 
@c EN
Sets umask setting to @var{mode}.  Returns previous umask setting.
See @code{man umask} for more details.
@c JP
umaskを@var{mode}にセットします。変更される前のumaskを返します。
umaskについては@code{man umask}を参照してください。
@c COMMON
@end defun

@node Pathnames, File stats, Directory manipulation, Filesystems
@subsubsection Pathnames
@c NODE パス名

@defun sys-normalize-pathname pathname &keyword absolute expand canonicalize
@c EN
Converts @var{pathname} according to the way specified by keyword arguments.
More than one keyword argument can be specified.
@c JP
与えられたキーワード引数によって@var{pathname}を以下のように変換します。
キーワード引数は同時に複数指定できます。
@c COMMON
@table @code
@item absolute
@c EN
  If this keyword arugment is given and true, and @var{pathname} is not
  an absolute pathname, it is converted to an absolute pathname by
  appending the current working directory in front of @var{pathname}.
@c JP
  このキーワード引数に真の値が与えられて、@var{pathname}が絶対パスでない場合、
  @var{pathname}の前にプロセスのワーキングディレクトリを足して絶対パスにします。
@c COMMON
@item expand
@c EN
  If this keyword argument is given and true, and @var{pathname} begins
  with `@code{~}', it is expanded as follows:
@c JP
  このキーワード引数に真の値が与えられて、@var{pathname}が`@code{~}' で始まっていた
  場合、以下のように展開されます。
@c COMMON
@itemize @bullet
@item
@c EN
    If @var{pathname} is consisted entirely by ``@code{~}'', or begins
    with ``@code{~/}'', then the character ``@code{~}'' is replaced
    for the pathname of the current user's home directory.
@c JP
    @var{pathname}が``@code{~}''のみであるか、または``@code{~/}''で始まっている
    場合、文字``@code{~}''が現在のプロセスのユーザのホームディレクトリに置き換えられます。
@c COMMON
@item
@c EN
    Otherwise, characters following `@code{~}' until either `@code{/}' or
    the end of @var{pathname} are taken as a user name, and the user's
    home directory is replaced in place of it.  If there's no such
    user, an error is signalled.
@c JP
    上記以外の場合、`@code{~}'以降、`@code{/}'か@var{pathname}の終端までの文字列
    がユーザ名とみなされ、そのユーザのホームディレクトリに置換されます。もし該当するユーザが
    いなければエラーとなります。
@c COMMON
@end itemize
@item canonicalize
@c EN
  Tries to remove pathname components ``@code{.}'' and ``@code{..}''.
  The pathname interpretation is done purely in textural level, i.e.
  it doesn't access filesystem to see the conversion reflects the
  real files.  It may be a problem if there's a symbolic links to
  other directory in the path.
@c JP
  パス名から ``@code{.}'' や ``@code{..}'' を除き、単純化します。
  この操作は実際のファイルシステムを参照せずに行われます。元のパス名がディレクトリへの
  シンボリックリンクを含んでいた場合、単純化されたパス名は正しくないかもしれません。
@c COMMON
@end table
@end defun

@defun sys-basename pathname
@defunx sys-dirname pathname
@c EN
@code{sys-basename} returns a basename, that is the last component of
@var{pathname}.  @code{sys-dirname} returns the components of @var{pathname}
but the last one.   If @var{pathname} has a trailing `@code{/}', 
it is simply ignored.
@c JP
@code{sys-basename}は与えられたパスのベース名、すなわち最後のコンポーネントを返します。
@code{sys-dirname}は与えられたパスのディレクトリ名、すなわち最後のコンポーネント以外の
コンポーネントを返します。@var{pathname}の末尾が`@code{/}'である場合、その文字は
無視されます。
@c COMMON
@example
(sys-basename "foo/bar/bar.z") @result{} "bar.z"
(sys-basename "coo.scm") @result{} "coo.scm"
(sys-basename "x/y/") @result{} "y"
(sys-dirname "foo/bar/bar.z") @result{} "foo/bar"
(sys-dirname "coo.scm") @result{} "."
(sys-dirname "x/y/") @result{} "x"
@end example
@c EN
These functions doesn't check if @var{pathname} really exists.
@c JP
この手続きは@var{pathname}が存在するかどうかはチェックしません。
@c COMMON

@c EN
Some boundary cases:
@c JP
特殊なケース：
@c COMMON
@example
(sys-basename "") @result{} ""
(sys-dirname "") @result{} "."

(sys-basename "/") @result{} ""
(sys-dirname "/") @result{} "/"
@end example
@c EN
Note: The above behavior is the same as Perl's @code{basename} and
@code{dirname}.   On some implementations, the command @code{basename}
may return @code{"/"} for the argument @code{"/"}, and
@code{"."} for the argument @code{"."}.
@c JP
註：このふるまいはPerlの@code{basename}および@code{dirname}と同様です。
システムによっては、コマンドの@code{basename}は@code{"/"}に対して@code{"/"}を、
@code{"."}に対して@code{"."}を返すものがあります。
@c COMMON
@end defun

@node File stats, Other file operations, Pathnames, Filesystems
@subsubsection File stats
@c NODE ファイルの状態

@defun file-exists? path
@defunx file-is-regular? path
@defunx file-is-directory? path
Returns true if @var{path} exists, is a regular file, or is a directory,
respectively.   The latter two returns false if @var{path} doesn't
exist at all.

These functions are built on top of primitive
system interfaces described below; I provide these for convenience
and compatibility (STk has the same functions).
@end defun

@deftp {Builtin Class} <sys-stat>
@clindex sys-stat
An object that represents @code{struct stat}, attributes of an
entry in the filesystem.
@end deftp

@defun sys-stat path
[POSIX] Returns a @code{<sys-stat>} object of @var{path}.
If @var{path} is a symbolic link, a stat of the file the link points
to is returned.
@end defun

@defun sys-lstat path
Like @code{sys-stat}, but it returns a stat of a symbolic link
if @var{path} is a symbolic link.
@end defun

@defun sys-fstat port-or-fd
[POSIX] @code{port-or-fd} may be a port or a positive exact integer
file descriptor.
Returns a @code{<sys-stat>} object of the underlying file of
@var{port-or-fd}.  If a port is given, and the port is not
associated to a file, @code{#f} is returned.
@end defun

@defun sys-stat->mode stat
@defunx sys-stat->ino stat
@defunx sys-stat->dev stat
@defunx sys-stat->rdev stat
@defunx sys-stat->nlink stat
@defunx sys-stat->size stat
@defunx sys-stat->uid stat
@defunx sys-stat->gid stat
@defunx sys-stat->atime stat
@defunx sys-stat->mtime stat
@defunx sys-stat->ctime stat
Accessors of @code{<sys-stat>} objects.  @code{sys-stat->mode} through
@code{sys-stat->gid} returns an exact integer.  @code{sys-stat->atime}
to @code{sys-stat->ctime} returns a number of seconds since Epoch.
@end defun

@defun sys-stat->file-type stat
@var{stat} is a @code{<sys-stat>} object.  Returns one of the following
symbols, according to the information of the mode word of @var{stat}.
@multitable {aaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item @code{regular} @tab a regular file
@item @code{directory} @tab a directory
@item @code{character} @tab a character device
@item @code{block} @tab a block device
@item @code{fifo} @tab a fifo
@item @code{symlink} @tab a symbolic link
@item @code{socket} @tab a socket
@end multitable
If the file type is none of the above, @code{#f} is returned.

Note: Some operating systems don't have the @code{socket} file type
and returns @code{fifo} for socket files.   Portable programs should
check both possibilities to see if the given file is a socket.
@end defun

@defun sys-access pathname amode
[POSIX]
An interface to @code{access(2)}.
Returns a boolean value of indicating whether @var{pathname} is allowed
in @var{amode}.  @var{amode} can be a combinations (logical or) of
following predefined flags.
@table @code
@item R_OK
@vindex R_OK
Checks whether @var{pathname} is readable by the current user.
@item W_OK
@vindex W_OK
Checks whether @var{pathname} is writable by the current user.
@item X_OK
@vindex X_OK
Checks whether @var{pathname} is executable (or searchable in case
@var{pathname} is a directory) by the current user.
@item F_OK
@vindex F_OK
Checks whether @var{pathname} exists or not, regardless of
the access permissions of @var{pathname}.  (But you need to have
access permissions of the directories containing @var{pathname}).
@end table
An error is signalled if @var{pathname} does not exist, or the permissions
of directories containing @var{pathname} prevents you from cheking
@var{pathname} itself.
@end defun

@defun sys-chmod path mode
Change the mode of the file named @var{path} to @var{mode}.
@var{mode} must be a small positive integer whose lower 9 bits
specifies POSIX style permission.
@end defun


@node Other file operations,  , File stats, Filesystems
@subsubsection Other file operations
@c NODE 他のファイル操作

@defun sys-chdir dir
[POSIX]
An interface to @code{chdir(2)}.  Change the process's current
working directory to @var{dir}.   An error is signalled if
@var{dir} doesn't exist, or you don't have enough permission to
access @var{dir}.
@end defun

@defun sys-pipe &keyword (buffered? @code{#t})
[POSIX] Creates a pipe, and returns two ports.
The first returned port is an input port and the second is an output port.
The data put to the output port can be read from the input port.

By default, the returned port is buffered using stdio interface,
i.e. you may want to call @code{flush} for the output port to make sure
the data can be read from the input port.  If the keyword argument
@var{buffered?} is false, however, the ports uses low-level
system calls (@code{read(2)} and @code{write(2)}.

@example
(receive (in out) (sys-pipe)
  (display "abc\n" out)
  (flush out)
  (read-line in)) @result{} "abc"
@end example

Note: the returned value is changed from version 0.3.15, in which
@code{sys-pipe} returned a list of two ports.
@end defun

@defun sys-isatty port-or-fd
[POSIX] @var{port-or-fd} may be a port or an integer file descriptor.
Returns @code{#t} if the port is connected to the console, @code{#f}
otherwise.
@end defun

@defun sys-ttyname port-or-fd
[POSIX] @var{port-or-fd} may be a port or an integer file descriptor.
Returns the name of the terminal connected to the port,
or @code{#f} if the port is not connected to a terminal.
@end defun

@node Unix groups and passwords, Locale, Filesystems, System interface
@subsection Unix groups and passwords
@c NODE Unixのグループとパスワード

@menu
* Unix group::                  
* Unix password::               
* Password encryption::         
@end menu

@node Unix group, Unix password, Unix groups and passwords, Unix groups and passwords
@subsubsection Unix Group
@c NODE Unixのグループ

@deftp {Builtin Class} <sys-group>
@clindex sys-group
@end deftp

@defun sys-getgrgid gid
@defunx sys-getgrnam name
[POSIX]
@end defun

@defun sys-gid->group->name gid
@defunx sys-group-name->gid name
@end defun

@node Unix password, Password encryption, Unix group, Unix groups and passwords
@subsubsection Unix Password
@c NODE Unixのパスワード

@deftp {Builtin Class} <sys-passwd>
@clindex sys-passwd
@end deftp

@defun sys-getpwuid uid
@defunx sys-getpwnam name
[POSIX]
@end defun

@defun sys-uid->user-name uid
@defunx sys-user-name->uid
@end defun


@node Password encryption,  , Unix password, Unix groups and passwords
@subsubsection Password encryption
@c NODE パスワードの暗号化

@defun sys-crypt key salt
This is the interface to @code{crypt(3)}.   @var{Key} and @var{salt}
must be a string, and an encrypted string is returned.
On systems where @code{crypt(3)} is not available, call to this
function signals an error.
@end defun

@node Locale, Signal, Unix groups and passwords, System interface
@subsection Locale
@c NODE ロケール

@defun sys-setlocate category locale
[POSIX]
@end defun


@node Signal, System Inquiry, Locale, System interface
@subsection Signal
@c NODE  シグナル

Gauche can send out POSIX signals to the other processes
(including itself) and can handle the incoming signals.

@menu
* Signals and signal sets::     
* Sending signals::             
* Handling signals::            
@end menu

@node Signals and signal sets, Sending signals, Signal, Signal
@subsubsection Signals and signal sets
@c NODE シグナルとシグナルセット

POSIX signals are referred by its signal number (a small integer)
defined on the system.
Variables are pre-defined to the system's signal number.
System's signal numbers may be architecture dependent, so you should
use those variables rather than using literal integers.

@defvar  SIGABRT
@defvarx SIGALRM
@defvarx SIGCHLD
@defvarx SIGCONT
@defvarx SIGFPE
@defvarx SIGHUP
@defvarx SIGILL
@defvarx SIGINT
@defvarx SIGKILL
@defvarx SIGPIPE
@defvarx SIGQUIT
@defvarx SIGSEGV
@defvarx SIGSTOP
@defvarx SIGTERM
@defvarx SIGTSTP
@defvarx SIGTTIN
@defvarx SIGTTOU
@defvarx SIGUSR1
@defvarx SIGUSR2
These variables are bound to the signal numbers of POSIX signals.
@end defvar

@defvar  SIGTRAP
@defvarx SIGIOT
@defvarx SIGBUS
@defvarx SIGSTKFLT
@defvarx SIGURG
@defvarx SIGXCPU
@defvarx SIGXFSZ
@defvarx SIGVTALRM
@defvarx SIGPROF
@defvarx SIGWINCH
@defvarx SIGPOLL
@defvarx SIGIO
@defvarx SIGPWR
These variables are bound to the signal numbers of system-dependent
signals.  Not all of them may be defined on some systems.
@end defvar

Besides each signal numbers, you can refer to a set of signals
using @code{<sys-sigset>} object.  It is used in the low-level
handlers inside Gauche and usual applications may not need to use it.

@deftp {Class} <sys-sigset>
@clindex sys-sigset
A set of signals.   An empty sigset can be created by
@example
(make <sys-sigset>)
@end example
@end deftp

@defun sys-sigset-add! sigset signal @dots{}
@defunx sys-sigset-delete! sigset signal @dots{}
@var{sigset} must be a @code{<sys-sigset>} object.
Those procedures adds and removes the specified signals from
@var{sigset} respectively, and returns the result.  @var{sigset} itself
is also modified.

@var{signal} may be either a signal number, another @code{<sys-sigset>}
object, or @code{#t} for all available signals.
@end defun

@defun sys-signal-name signal
Returns the human-readable name of the signal.
@end defun


@node Sending signals, Handling signals, Signals and signal sets, Signal
@subsubsection Sending signals
@c NODE シグナルの送出

To send a signal, you can use @code{sys-kill} which works like
@code{kill(2)}.

@defun sys-kill pid sig
[POSIX] Sends a signal @var{sig} to the specified process.  @var{sig}
must be a positive exact integer.  @var{pid} is an exact integer and
specifies the target process(es):
@itemize @bullet
@item
If @var{pid} is positive, it is the target process id.
@item
If @var{pid} is zero, the signal is sent to every process in the process
group of the current process.
@item
If @var{pid} is less than -1, the signal is sent to every process in
the process group @var{-pid}.
@end itemize
@end defun

There's no Scheme equivalence for @code{raise()}, but you can use
@code{(sys-kill (sys-getpid) @var{sig})}.


@node Handling signals,  , Sending signals, Signal
@subsubsection Handling signals
@c NODE シグナルの処理

You can set one or more signal handlers in Scheme,
using the following @code{with-signal-handlers} macro.
The list of "active" handlers are considered as a part of
dynamic environment; i.e. if you exit from its dynamic scope
by call/cc the handlers are uninstalled, and if you re-enter there
the handlers are reinstalled.

When you're using the @code{gosh} interpreter, all the signals
except @code{SIGABRT}, @code{SIGILL}, @code{SIGKILL}, @code{SIGCONT},
@code{SIGSTOP}, @code{SIGSEGV} and @code{SIGCHLD} can be handled
in Scheme.  If no handlers are available when a signal is delivered,
the default handler is called, which raises an error (unhandled signal).

If you're using Gauche embedded in some other application,
it may redefine the set of signals handleable by Gauche.

@emph{Note:} Sometimes it is useful to catch @code{SIGCHLD}.
Currently it interferes the internal mechanism of Gauche
so it is ignored.  It is purely an implementation restriction
that should be removed later.

@defmac with-signal-handlers (handler-clause @dots{}) thunk
Adds signal handlers specified in @var{handler-clause}s, then
call @var{thunk}.  After the control leaves @var{thunk},
the previous signal handlers are restored.

@var{handler-clause} may have one of the following forms.
@table @code
@item (@var{signals} @var{expr} @dots{})
When one of @var{signals} is delivered, @var{expr} @dots{} are
evaluated.
@var{signals} may be an expression that will yield either a signal,
a list of signals, or a @code{<sys-sigset>} object.

@item (@var{signals} => @var{proc})
When one of @var{signals} is delivered, a procedure @var{proc} is
called with one argument, the delivered signal.
@var{signals} are the same as above.
@end table

The VM examines the chain of handlers when a signal is delivered,
and picks up the one that catches it.  Then invokes the handler
with the current continuation.

Actually, when Gauche's VM gets a signal it just queues the
signal, and handles them when evaluation of Scheme expression
is safe.  So the invocation of handler may be delayed from
the actual delivery of the signal.  Unless signal handlers
invokes other contniuations, the original control flow
resumes after invocations of the handlers.
@end defmac

@emph{Caveat:} In the current implementation, some built-in operations
such as system calls and read/write calls can't be continued
after delivery of a signal.  If the signal handler returns,
the system reports an error (interrupted system call) or
returns prematurely (for example, read returns EOF in such case).
In future versions of Gauche more procedures will be correctly
restarted.


@node System Inquiry, Time, Signal, System interface
@subsection System Inquiry
@c NODE システムへの問い合わせ

@defun sys-uname
[POSIX]
@end defun

@defun sys-getcwd
[POSIX] Returns the current working directory by a string.
If the current working directory couldn't be obtained from the system,
an error is signalled.
@end defun

@defun sys-getgid
@defunx sys-getegid
[POSIX] Returns integer value of real and effective group id of the
current process, respectively.
@end defun

@defun sys-getuid
@defunx sys-geteuid
[POSIX] Returns integer value of real and effective user id of the
current process, respectively.
@end defun

@defun sys-getgroups
[POSIX] Returns a list of integer ids of supplementary groups.
@end defun

@defun sys-getlogin
[POSIX] Returns a string of the name of the user logged in on the
controlling terminal of the current process.
If the system can't determine the information, @code{#f} is returned.
@end defun

@defun sys-getpgrp
[POSIX]
@end defun

@defun sys-getpid
@defunx sys-getppid
[POSIX]
@end defun

@defun sys-times
[POSIX]
@end defun

@defun sys-ctermid
[POSIX]  Returns the name of the controlling terminal of the process.
This may be just a @code{"/dev/tty"}.   See also @code{sys-ttyname}.
@end defun

@node Time, Unix process management, System Inquiry, System interface
@subsection Time
@c NODE 時間

@deftp {Builtin Class} <sys-tm>
@clindex sys-tm
Represents @code{struct tm}.
@end deftp

@defun sys-time
[POSIX] Returns the time since Epoch (00:00:00 UTC, January 1, 1970),
measured in seconds.  It may be a non-integral number, depending on
the architecture.

Note that POSIX's definition of ``seconds since the Epoch'' doesn't
take leap seconds into acount.
@end defun

@defun sys-gmtime time
[POSIX] @var{time} is a number of seconds since Epoch.
This function converts it to @code{<sys-tm>} object, represented in GMT.
@end defun

@defun sys-localtime time
[POSIX] @var{time} is a number of seconds since Epoch.
This function converts it to @code{<sys-tm>} object, represented in the
local time.
@end defun

@defun sys-ctime time
[POSIX]
@end defun

@defun sys-difftime time1 time0
[POSIX]
@end defun

@defun sys-asctime tm
[POSIX]
@end defun

@defun sys-strftime format tm
[POSIX]
@end defun

@defun sys-mktime tm
[POSIX]
@end defun

@defun sys-tm->alist tm
@end defun

@node Unix process management, I/O multiplexing, Time, System interface
@subsection Unix process management
@c NODE Unixのプロセス管理

@menu
* Fork and exec::               
* Wait::                        
@end menu

@node Fork and exec, Wait, Unix process management, Unix process management
@subsubsection Fork and exec
@c NODE forkとexec

@defun sys-system command
[POSIX]
Runs @var{command} in a subprocess.   @var{command} is usually passed
to @code{sh}, so the shell metacharacters are interpreted.

This function returns an integer value @code{system()} returned.
Since POSIX doesn't define what @code{system()} returns, you can't
interpret the returned value in a portable way.
@end defun

@defun sys-fork
[POSIX]
Fork the current process.  Returns 0 if you're in the child process,
and a child process' pid if you're in the parent process.
All the opened file descriptors are shared between the parent and
the child.  See @code{fork(2)} of your system for details.

If the forked process runs some Scheme code and exits instead of
calling @code{sys-exec}, the forked process should call @code{sys-exit} to
terminate itself.  Normal exit call tries to flush the file
buffers, and on some OS it messes up the parent's file buffers.
@end defun

@defun sys-exec command args &optional iomap
[POSIX+]
Execute @var{command} with @var{args}, a list of arguments.
The current process image is replaced by @var{command},
so this function never returns.

All elements of @var{args} must be strings.  The first element of
@var{args} is used as @code{argv[0]}, i.e. the program name.

The optional @var{iomap} argument, when provided, specifies how the
open file descriptors are treated.  It must be the following format:
@example
((@i{to-fd} . @i{from-port-or-fd}) @dots{})
@end example
@i{To-fd} must be an integer,
and @i{from-port-or-fd} must be an integer file descriptor or a port.
Each element of the list makes the file descriptor of @i{from-port-or-fd}
of the current process be mapped to the file descriptr @i{to-fd}
in the executed process.

If @var{iomap} is provided,
any file descriptors other than specified in the iomap list will be closed
before @code{exec()}.  Otherwise, all file descriptors in the current
process remain open.

@example
(sys-exec "ls" '("ls" "-l")) @result{} ;; ls is executed.

(sys-exec "ls" '("ls" "-l") '((1 . 2) (1 . 1)))
   @result{} ;; ls is executed, with its stderr and stdout are mapped to the
              current process's stdout.
@end example

When it encounters an error, most of the time it raises an error condition.
Once the file descriptors are permuted, however, it would be impractical
to handle errors in reasonable way (you don't even know stderr is still
available!), so Gauche simply exits on the error.
@end defun

See also @ref{High Level Process Interface}, which provides
more convenient process handling on top of above primitives.

@node Wait,  , Fork and exec, Unix process management
@subsubsection Wait
@c NODE Wait

@defun sys-wait
[POSIX] Calls system's @code{wait(2)}.  The process suspends its execution
until one of the child terminates.  Returns two exact integer values,
the first one is the child's process id, and the second is a status code.
The status code can be interpreted by the following functions.
@end defun

@defun sys-waitpid pid &keyword nohang untraced
[POSIX] This is an interface to @code{waitpid(3)}, an extended version of
wait.

@var{pid} is an exact integer specifying which child(ren) it's waiting.
If it is a positive integer,
it waits fot that specific child.  If it is zero, it waits for any
member of this process group.  If it is -1, it waits for any child process.
If it is less than -1, it waits for any child process whose process group
id is equal to the absolute value of @var{pid}.

The calling process suspends until one of those child process is terminated,
unless true is specified to the keyword argument @var{nohang}.

If true is specified to the keyword argument @var{untraced},
the status of stopped child process can be also returned.

The return values are two exact integers, the first one is the child
process id, and the second is a status code.  If @var{nohang} is true and
no child process status is available, the first value is zero.
@end defun

@defun sys-wait-exited? status
@defunx sys-wait-exit-status status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-wait} or @code{sys-waitpid}.
@code{sys-wait-exited?} returns @code{#t} if the child process is 
terminated normally.   @code{sys-wait-exit-status} returns the exit
code the child process passed to @code{exit(2)}, or the return value
of @code{main()}.
@end defun

@defun sys-wait-signaled? status
@defunx sys-wait-termsig status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-wait} or @code{sys-waitpid}.
@code{sys-wait-signaled?} returns @code{#t} if the child process
is termintaed by an uncaught signal.
@code{sys-wait-termsig} returns the signal number that terminted the child.
@end defun

@defun sys-wait-stopped? status
@defunx sys-wait-stopsig status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-waitpid}.
@code{sys-wait-stopped?} returns @code{#t} if the child process is
stopped.   This status can be caught only by @code{sys-waitpid} with
true @var{untraced} argument.  @code{sys-wait-stopsig} returns the
signum number that stopped the child.
@end defun

@node I/O multiplexing, Miscellaneous system calls, Unix process management, System interface
@subsection I/O multiplexing
@c NODE I/Oの多重化

The interface functions for @code{select(2)}.
The higher level interface is provided on top of these
primitives; see @ref{Simple dispatcher}.

@deftp {Builtin Class} <sys-fdset>
@clindex sys-fdset
Represents @code{fd_set}, a set of file descriptors.  You can make
an empty file descriptor set by make method:
@example
(make <sys-fdset>)
@end example
@end deftp

@defun sys-fdset-ref fdset port-or-fd
@defunx sys-fdset-set! fdset port-or-fd flag
Gets and sets specific file descritor bit of @var{fdset}.
@var{port-or-fd} may be a port or an integer file descriptor.
If @var{port-or-fd} is a port that doesn't have associated file descriptor,
@code{sys-fdset-ref} returns @code{#f}, and @code{sys-fdset-set!} doesn't
modify @var{fdset}.  @var{flag} must be a boolean value.

You can use generic setter of @code{sys-fdset-ref} as this:
@example
(set! (sys-fdset-ref fdset port-or-fd) flag)
  @equiv{} (sys-fdset-set! fdset port-or-fd flag)
@end example
@end defun

@defun sys-fdset-max-fd fdset
Returns the maximum file descriptor number in @var{fdset}.
@end defun

@defun sys-select readfds writefds exceptfds &optional timeout
@defunx sys-select! readfds writefds exceptfds &optional timeout
Waits for a set of file descriptors to change status.
@var{readfds}, @var{writefds}, and @var{exceptfds} are @code{<fdset>}
objects to represent a set of file descriptors to watch.
File descriptors in @var{readfds} are watched to see if characters
are ready to be read.   File descriptors in @var{writefds} are
watched if writing to them is ok.  File descriptors in @var{exceptfds}
are watched for exceptions.  You can pass @code{#f} to one or more
of those arguments if you don't care about watching the condition.

@var{timeout} specifies maximum time @code{sys-select} waits for
the condition change.  It can be a real number, for number of microseconds,
or a list of two integers, the first is the number of seconds and
the second is the number of microseconds.  If you pass @code{#f},
@code{sys-select} waits indefinitely.

@code{sys-select} returns four values.  The first value is a number
of descriptors it detected status change.  It may be zero if 
timeout expired.  The second, third and fourth values are @code{<fdset>}
object that contains a set of descriptors that changed status
for reading, writing, and exception, respectively.
If you passed @code{#f} to one or more of @var{readfds},
@var{writefds} and @var{exceptfds}, the corresponding return value
is @code{#f}.

@code{sys-select!} variant works the same as @code{sys-select}, except
it modifies the passed @code{<fdset>} arguments.
@code{sys-select} creates new @code{<fdset>} objects and
doesn't modify its arguments.
@end defun


@node Miscellaneous system calls,  , I/O multiplexing, System interface
@subsection Miscellaneous system calls
@c NODE その他のシステムコール

@defun sys-pause
[POSIX] Suspends the process until it receives a signal whose
action is to either execute a signal-catching function or to terminate
the process.  This function only returns when the signal-catching
function returns.  The returned value is undefined.
@end defun

@defun sys-alarm seconds
[POSIX] Arranges a SIGALRM signal to be delivered after @var{seconds}.
The previous settings of the alarm clock is cancelled.  Passing zero
to @var{seconds} doesn't schedule new alarm.
Returns the number of seconds remaining until previously scheduled
alarm was due to be delivered (or zero if no alarm is active).
@end defun

@defun sys-sleep seconds
[POSIX] Suspends the process until the specified number of seconds elapses,
or the process receives a signal.  Returns zero if it sleeps well,
or the number of unslept seconds if it is woke up by a signal.

To be porable across POSIX implementation, keep @var{seconds} less than
65536.
@end defun

@defun sys-random
@defunx sys-srandom seed
A pseudo random number generator.
@code{sys-random} returns a random number between 0 and a positive
integer @var{rand_max}, inclusive.  This is a straightforward
interface to @code{random(3)}.  If the underlying system doesn't have
@code{random(3)}, @code{lrand48(3)} is used.

@code{sys-srandom} sets the seed of the random number generator.
It uses either @code{srandom(3)} or @code{srand48(3)}, depending on
the system.

The intension of these functions are to provide an off-the-stock handy
random number generator (RNG) for applications that doens't
sensitive to the quality and/or speed of RNG.  For serious statistics
analysis, better RNGs should be used.  Gauche will provide an
extention module of Mersenne Twister RNG soon.
@end defun

@defvar RAND_MAX
Bound to a positive integer that @code{sys-random} may return.
@end defvar

@c ======================================================================
@node Object system, Library modules, Core library, Top
@chapter Object system
@c NODE オブジェクトシステム

@c ----------------------------------------------------------------------
@menu
* General Inquiry::             
* Defining class::              
* Defining methods::            
* Creating Instance::           
* Accessing Instance::          
* Metaobject protocol::         
@end menu

@node General Inquiry, Defining class, Object system, Object system
@section  General Inquiry
@c NODE 一般的な問い合わせ

@defun class-of obj
Returns a class metaobject of @var{obj}.
@end defun

@defun is-a? obj class
Returns true if @var{obj} is an instance of @var{class} or an instance
of descendants of @var{class}.
@end defun

@c ----------------------------------------------------------------------
@node Defining class, Defining methods, General Inquiry, Object system
@section Defining class
@c NODE クラスの定義

A class is a first-class object in Gauche and you can create it
on the fly at run-time using procedure calls.
However, for convenience, a macro is defined to create a class
and bind it globally.

@defmac define-class name supers (slot-spec @dots{}) option @dots{}
Creates a class object according to the arguments, and globally
bind it to a variable @var{name}.   This macro should be used at toplevel.

@var{Supers} is a list of direct superclasses from which this class
inherits.   You can use multiple inheritance.
See @ref{Multiple inheritance}  below, for the rule that determines
precedence of inheritance chain.

@var{Slot-spec} is a specification of a "slot", sometimes known as 
a "field" or an "instance variable" (but you can specify "class variable"
in @var{slot-spec} as well). 
The simplest form of @var{slot-spec} is just a symbol, which names
the slot.  Or you can give a list, whose first element is a symbol
and whose rest is an interleaved list of keywords and values.
The list form not only defines a name of the slot but specifies
behavior of the slot.  See @ref{Slot specification}, for details.

Finally, @var{option} @dots{} is an interleaved list of keywords
and values, specifies how class object should be created.
This macro recognizes one keyword, @code{:metaclass}, whose
corresponding value is used for metaclass (class that instantiates
another class).   Other options are passed to the @code{make}
method to create the class object.  @xref{Class instantiation},
for the usage of metaclass.
@end defmac

@menu
* Multiple inheritance::        
* Slot specification::          
@end menu

@node Multiple inheritance, Slot specification, Defining class, Defining class
@subsection Multiple inheritance
@c NODE 多重継承

@node Slot specification,  , Multiple inheritance, Defining class
@subsection Slot specification
@c NODE スロットの記述


@c ----------------------------------------------------------------------
@node Defining methods, Creating Instance, Defining class, Object system
@section Defining methods
@c NODE メソッドの定義

@defmac define-generic name
@end defmac

@defmac define-method name specs body
@end defmac

@c ----------------------------------------------------------------------
@node Creating Instance, Accessing Instance, Defining methods, Object system
@section Creating Instance
@c NODE インスタンスの作成

@deffn {Generic Function} make class arg @dots{}
@end deffn

@deffn {Method} make (class <class>) arg @dots{}
@end deffn

@deffn {Method} make (class <method>)  arg @dots{}
@deffnx {Method} make (class <generic>)  arg @dots{}
@end deffn

@deffn {Method} initialize (class <class>) initargs
@end deffn

@c ----------------------------------------------------------------------
@node Accessing Instance, Metaobject protocol, Creating Instance, Object system
@section Accessing Instance
@c NODE インスタンスへのアクセス

@defun slot-ref obj slot
@end defun

@defun slot-set! obj slot
@end defun

@defun slot-bound? obj slot
@end defun

@defun slot-exists? slot
@end defun

@deffn {Generic Function} slot-unbound
@end deffn

@deffn {Method} slot-unbound (class <class>) obj slot
@end deffn

@deffn {Generic Function} slot-missing
@end deffn

@deffn {Method} slot-missing (class <class>) obj slot &optional value
@end deffn


@defun class-slot-ref class slot-name
@defunx class-slot-set! class slot-name obj
@end defun

@c ----------------------------------------------------------------------
@node Metaobject protocol,  , Accessing Instance, Object system
@section Metaobject procotol
@c NODE メタオブジェクトプロトコル

@menu
* System metaclasses::          
* Class introspection::         
* Class instantiation::         
* Customizing slot access::     
* Method instantiation::        
* Customizing method application::  
@end menu

@node System metaclasses, Class introspection, Metaobject protocol, Metaobject protocol
@subsection System metaclasses
@c NODE システムメタクラス

@deftp {Class} <top>
@clindex top
@end deftp

@deftp {Class} <class>
@clindex class
@end deftp

@deftp {Class} <generic>
@clindex generic
@end deftp

@deftp {Class} <method>
@clindex method
@end deftp

@deftp {Class} <object>
@clindex object
@end deftp


@node Class introspection, Class instantiation, System metaclasses, Metaobject protocol
@subsection Class introspection
@c NODE クラスのイントロスペクション

@menu
* Class metaobject::            
* Slot definition::             
@end menu

@node Class metaobject, Slot definition, Class introspection, Class introspection
@subsubsection Class metaobject
@c NODE クラスメタオブジェクト

@defun class-name class
@end defun

@defun class-precedence-list class
@end defun

@defun class-direct-supers class
@end defun

@defun class-direct-slots class
@end defun

@defun class-slots
@end defun

@node Slot definition,  , Class metaobject, Class introspection
@subsubsection Slot definition
@c NODE スロット定義

@deftp {Class} <slot-accessor>
@clindex slot-accessor
@end deftp


@defun class-slot-definition class slot-name
@end defun

@defun class-slot-accessor class slot-name
@end defun

@defun slot-definition-name slot-def
@end defun
@defun slot-definition-allocation slot
@end defun

@defun slot-definition-getter slot
@defunx slot-defininion-setter slot
@defunx slot-definition-accessor slot
@end defun

@defun slot-definition-options slot-def
@defunx slot-definition-option slot-def key &optional default
@end defun

@node Class instantiation, Customizing slot access, Class introspection, Metaobject protocol
@subsection Class instantiation
@c NODE クラスのインスタンシエーション

@deffn {Method} make (class <class>) &rest initargs
@end deffn


@node Customizing slot access, Method instantiation, Class instantiation, Metaobject protocol
@subsection Customizing slot access
@c NODE スロットアクセスのカスタマイズ


@deffn {Generic Function} compute-slots
@end deffn

@deffn {Generic Function} compute-get-n-set
@end deffn

@defun slot-ref-using-accessor obj slot-accessor
@defunx slot-set-using-accessor obj slot-accessor value
@end defun

@node Method instantiation, Customizing method application, Customizing slot access, Metaobject protocol
@subsection Method instantiation
@c NODE メソッドのインスタンシエーション

@deffn {Method} make (class <method>) &rest initargs
@end deffn

@node Customizing method application,  , Method instantiation, Metaobject protocol
@subsection Customizing method application
@c NODE メソッド適用のカスタマイズ

@deffn {Generic Function} apply-generic gf args
@end deffn

@deffn {Generic Function} sort-applicable-methods gf methods args
@end deffn

@deffn {Generic Function} method-more-specific? method1 method2 classes
@end deffn

@deffn {Generic Function} apply-methods gf methods args
@end deffn

@deffn {Generic Function} apply-method gf method build-next args
@end deffn


@c ======================================================================
@node Library modules, References, Object system, Top
@chapter Library modules
@c NODE ライブラリモジュール

@c ----------------------------------------------------------------------
@menu
* Library modules overview::    
* Generic DBM interface::       
* GDBM interface::              
* NDBM interface::              
* Original DBM interface::      
* Filtering file content::      
* Character code conversion::   
* Collection framework::        
* Low-level file operations::   
* Interactive session::         
* User-level logging::          
* Networking::                  
* Parsing command-line options::  
* High Level Process Interface::  
* Regular expression utilities::  
* Simple dispatcher::           
* Sequence framework::          
* Singleton::                   
* Termios::                     
* Unit Testing::                
* Slot with validator::         
* Comparing version numbers::   
* RFC822 Message parsing::      
* Base64 encoding/decoding::    
* HTTP cookie handling::        
* URI parsing and construction::  
* SLIB::                        
* Feature Conditional::         
* List library::                
* And-let*::                    
* Homogeneous Vectors::         
* SRFI String ports::           
* Syntax to receive multiple values::  
* Record types::                
* Let-values::                  
* String library::              
* Character-set library::       
* CSV tables::                  
* Simple HTML document construction::  
* Parsing input stream::        
* Transliterate characters::    
* Lazy text construction::      
* Determine isomorphism::       
* Queue::                       
* Topological sort::            
* CGI Utility::                 
@end menu

@node Library modules overview, Generic DBM interface, Library modules, Library modules
@section Library modules overview
@c NODE ライブラリモジュールの概要

@c EN
The modules are organized hierarchically.
Here's a table of general guideline.
@c JP
ライブラリモジュールは階層的にまとめられています。
今のところ、以下のように分類されています。
@c COMMON

@table @code
@item gauche.*
@c EN
Stuffs more or less considered as Gauche core features.
@c JP
Gauche本体の一部として考えられている機能。
@c COMMON
@item data.*
@c EN
Generic data structures.
@c JP
汎用的なデータ構造。
@c COMMON
@item dbm.*
@c EN
DBM interface
@c JP
DBMインタフェース
@c COMMON
@item file.*
@c EN
Manipulating files and directories.
@c JP
ファイルとディレクトリの操作。
@c COMMON
@item math.*
@c EN
Mathematics.
@c JP
数学。
@c COMMON
@item lang.*
@c EN
Language-related libraries (artificial and/or natural). 
@c JP
言語に関するライブラリ(人工的なものも自然言語関連も)。
@c COMMON
@item text.*
@c EN
Libraries dealing with text data.
@c JP
テキストデータを扱うライブラリ
@c COMMON
@item rfc.*
@c EN
Implementations of net protocols defined in RFC's.
@c JP
RFCで定義されているデータフォーマットやネットワークプロトコルの実装。
@c COMMON
@item www.*
@c EN
Implementations of various protocols and formats mainly used in WWW.
@c JP
WWWで主として使われるプロトコルやデータフォーマットの実装。
@c COMMON
@item srfi-*
@c EN
SRFI implementations.
@c JP
SRFIの実装
@c COMMON
@item util.*
@c EN
Generic implementations of various algorithms.
@c JP
汎用的なアルゴリズムの実装。
@c COMMON
@end table


@c ----------------------------------------------------------------------
@node Generic DBM interface, GDBM interface, Library modules overview, Library modules
@section @code{dbm} - Generic DBM interface
@c NODE 汎用DBMインタフェース, @code{dbm} - 汎用DBMインタフェース

@deftp {Module} dbm
@mdindex dbm
@c EN
DBM-like libraries provides an easy way to store values to a file,
indexed by keys.  You can think it as a persistent associative memory.
@c JP
DBM系のライブラリはキーでインデックスされた値をファイルに格納する簡単な方法を
提供します。一種の永続的な連想記憶と言えるでしょう。
@c COMMON

@c EN
This modules defines @code{<dbm>} abstract class, which has
a common interface to use various DBM-type database packages.
As far as you operate on the already opened database,
importing @code{dbm} module is enough.
@c JP
このモジュールが定義する抽象クラス@code{<dbm>}は、DBM系ライブラリへの
統一されたインタフェースを提供します。@code{dbm}モジュールだけをインポートすれば、
既にオープンされたデータベースを操作することができます。
@c COMMON

@c EN
To create or open a database, you need a concrete implementation
of the database.  Gauche currently has the following impelentations.
Each module defines its own low-level accessing functions
as well as the common interface.
Note that your system may not have one or more of those DBM libraries;
Gauche defines only what the system provides.
@c JP
データベースをオープンしたり作成したりするには、dbmインタフェースを実装した
モジュールが必要になります。今のところGaucheでは以下の実装が使えます。
それぞれのモジュールは、dbmインタフェース共通の手続きの他に、
直接実装を操作できる低レベルの手続きも提供します。
システムによっては以下のインタフェースの全てが実装されているわけではないことに
注意してください。Gaucheではシステムが提供する実装のみを定義します。
@c COMMON

@table @code
@item dbm.gdbm
@c EN
GDBM library (@xref{GDBM interface}).
@c JP
GDBMライブラリ (@xref{GDBM interface}).
@c COMMON

@item dbm.ndbm
@c EN
NDBM library (@xref{NDBM interface}).
@c JP
NDBMライブラリ (@xref{NDBM interface}).
@c COMMON

@item dbm.odbm
@c EN
DBM library  (@xref{Original DBM interface}).
@c JP
DBMライブラリ  (@xref{Original DBM interface}).
@c COMMON
@end table
@end deftp

@c EN
The following code shows a typical usage of the database.
@c JP
以下にdbmデータベースの使用例を示します。
@c COMMON

@example
(use dbm)         ; @r{dbm abstract interface}
(use dbm.gdbm)    ; @r{dbm concrete interface}

; @r{open the database}
(define *db* (dbm-open <gdbm> :path "mydb" :rw-mode :write))

; @r{put the value to the database}
(dbm-put! *db* "key1" "value1")

; @r{get the value from the database}
(define val (dbm-get *db* "key1"))

; @r{iterate over the database}
(dbm-for-each *db* (lambda (key val) (foo key val)))

; @r{close the database}
(dbm-close *db*)
@end example

@menu
* Opening and closing a dbm database::  
* Accessing a dbm database::    
* Iterating on a database::     
@end menu

@node Opening and closing a dbm database, Accessing a dbm database, Generic DBM interface, Generic DBM interface
@subsection Opening and closing a dbm database
@c NODE DBMデータベースのオープンとクローズ

@deftp {Class} <dbm>
@clindex dbm
@c EN
An abstract class for dbm-style database.  Defindes the common
database operations.   This class has the following instance slots.
They must be set before the database is actually opened by
@code{dbm-open}.

The concrete class may add more slots for finer control on the database,
such as locking.
@c JP
DBM系のデータベースのための抽象クラスです。データベースへの共通のオペレーションを
定義します。以下のインスタンススロットを持ちます。これらのスロットの値は
@code{dbm-open}によってデータベースがオープンされる前にセットされて
いなければなりません。

具体クラスは、データベースの操作をより細かく行うための追加のスロット(例えばロックを
行うかどうか)を持つかもしれません。
@c COMMON

@defivar <dbm> path
@c EN
Pathname of the dbm database.  Some dbm implementation may append
suffixes to this.
@c JP
データベースファイルのパス名。dbmの実装によっては、このパスにサフィックスが追加されます。
@c COMMON
@end defivar

@defivar <dbm> rw-mode
@c EN
Specifies read/write mode.  Can be either one of the following keywords:
@table @code
@item :read
The database will be opened in read-only mode.  The database file must
exist when @code{dbm-open} is called.  This is the default value.
@item :write
The database will be opened in Read-write mode.
If the database file does not exist, @code{dbm-open} creates one.
@item :create
The database will be created and opened in Read-write mode.
If the database file exists, @code{dbm-open} truncates it.
@end table
@c JP
読み書きのモードを指定します。以下の値のいずれかを取ります。
@table @code
@item :read
データベースは@code{dbm-open}によって読みだし専用モードでオープンされます。
オープンされる時点でデータベースは存在していなければなりません。
@item :write
データベースは@code{dbm-open}によって読み書き可能なモードでオープンされます。
データベースが存在しなければ、@code{dbm-open}は新しいデータベースを作成します。
@item :create
@code{dbm-open}によって新しいデータベースが作成され、読み書き可能なモードでオープンされます。
既にデータベースが存在していた場合、その内容はクリアされます。
@end table
@c COMMON
@end defivar

@defivar <dbm> file-mode
@c EN
Specifies the file permissions (as @code{sys-chmod}) to create the
database.  The default value is @code{#o664}.
@c JP
データベースが作成されるときのファイルパーミッションを指定します。
デフォルトは@code{#o664}です。
@c COMMON
@end defivar

@defivar <dbm> key-convert
@defivarx <dbm> value-convert
@c EN
By default, you can use only strings for both key and values.  With this
option, however, you can specify how to convert other Scheme values to/from
string to be stored in the database.   The possible values are the
followings:
@table @asis
@item @code{#f}
The default value.  Keys (values) are not converted.  They must be
a string.
@item @code{#t}
Keys (values) are converted to its string representation, using 
@code{write}, to store in the database, and converted
back to Scheme values, using @code{read}, to retrieve from the database.
The data must have an external representation that can be read back.
(But it is not checked when the data is written; you'll get an error
when you read the data).  The key comparison is done in the string
level, so the external representation of the same key must match.
@item a list of two procedures
Both procedure must take a single argument.  The first procedure must
receive a Scheme object and returns a string.  It is used to convert
the keys (values) to store in the database.  The second procedure
must receive a string and returns a Scheme object.  It is used to
convert the stored data in the database to a Scheme object.
The key comparison is done in the string
level, so the external representation of the same key must match.
@end table
@c JP
デフォルトでは、dbmデータベースはキーにも値にも文字列しか使うことはできません。
これらのスロットによって、それ以外のSchemeオブジェクトを取り扱う方法を指定することが
できます。以下の値のいずれかが可能です。
@table @asis
@item @code{#f}
デフォルトの値です。キーあるいは値は変換されません。それらは文字列でなければなりません。
@item @code{#t}
キーあるいは値は@code{write}を使って文字列に変換されデータベースに格納されます。
そして@code{read}を使って文字列からSchemeオブジェクトへと変換されます。
後で@code{read}で読みこめるようなキーあるいは値のみを扱うことができます。
(但し、dbmライブラリは書き込み時にそれが後で読み込めるかどうかのチェックは行いません)。
キーの比較は文字列に変換された後で行われるので、同じ値となるキーは同じ文字列表現を
持つ必要があります。
@item 二つの手続きのリスト
どちらの手続きも一つの引数を取ります。最初の手続きはSchemeオブジェクトを受け取り、
文字列を返します。キーあるいは値をデータベースに格納する時に呼ばれます。
二つ目の手続きは文字列を受け取りSchemeオブジェクトを返します。データベースから
キーあるいは値を取り出す時に呼ばれます。
キーの比較は文字列に変換された後で行われるので、同じ値となるキーは同じ文字列に
変換される必要があります。
@end table
@c COMMON
@end defivar
@end deftp

@deftp {Metaclass} <dbm-meta>
@clindex dbm-meta
@c EN
A metaclass of @code{<dbm>} and its subclasses.
@c JP
@var{<dbm>}クラス及びそのサブクラスのメタクラスです。
@c COMMON
@end deftp

@deffn {Method} dbm-open (dbm <dbm>)
@c EN
Opens a dbm database.  @var{dbm} must be an instance of
one of the concrete classes that derived from the @code{<dbm>} class,
and its slots must be set appropriately.   On success, it returns
the @var{dbm} itself.  On failure, it signals an error.
@c JP
DBMデータベースをオープンします。@var{dbm}は、@code{<dbm>}クラスを継承した
具体クラスのインスタンスでなければなりません。また、そのスロットには適切な値が
セットされている必要があります。オープンに成功したら@var{dbm}自身が返されます。
失敗した場合はエラーが報告されます。
@c COMMON
@end deffn

@deffn {Method} dbm-open (dbm-class <dbm-meta>) options @dots{}
@c EN
A convenient method that creates dbm instance and opens it.
It is defined as follows.
@c JP
DBMインスタンスを作成してオープンするための便利なメソッドです。
次のように定義されます。
@c COMMON
@example
(define-method dbm-open ((class <class>) . initargs)
  (dbm-open (apply make class initargs)))
@end example
@end deffn

@c EN
Database file is closed when it is garbage collected.
However, to ensure the modification is properly synchornized,
you should close the database explicitly.
@c JP
データベースファイルはガベージコレクトされる際にクローズされますが、
変更を正しくデータベースに反映するには、明示的にクローズした方が良いでしょう。
@c COMMON

@deffn {Method} dbm-close (dbm @code{<dbm>})
@c EN
Closes a database @var{dbm}.  Once the database is closed, any
operation to access the database content raises an error.
@c JP
データベース@var{dbm}をクローズします。データベースがクローズされると、
それ以降のアクセスオペレーションはエラーとなります。
@c COMMON
@end deffn

@deffn {Method} dbm-closed? (dbm @code{<dbm>})
@c EN
Returns true if a database @var{dbm} is already closed, false otherwise.
@c JP
データベース@var{dbm}が既にクローズされていたら@code{#t}を返します。
@c COMMON
@end deffn

@node Accessing a dbm database, Iterating on a database, Opening and closing a dbm database, Generic DBM interface
@subsection Accessing a dbm database
@c NODE DBMデータベースのアクセス

@c EN
Once a database is opened, you can use the following methods
to access individual key/value pairs.
@c JP
データベースがオープンされたら、以下のアクセスメソッドが使えます。
@c COMMON

@deffn {Method} dbm-put! (dbm @code{<dbm>}) key value
@c EN
Put a @var{value} with @var{key}.
@c JP
値@var{value}をキー@var{key}と関連付けて保存します。
@c COMMON
@end deffn

@deffn {Method} dbm-get (dbm @code{<dbm>}) key &optional default
@c EN
Get a value associated with @var{key}.  If no value exists for @var{key}
and @var{default} is specified, it is returned.  If no value exists for
@var{key} and @var{default} is not specified, an error is signalled.
@c JP
キー@var{key}に関連付けられた値を返します。もし値が存在しなければ、@var{default}が
与えられていればそれを返し、そうでなければエラーを報告します。
@c COMMON
@end deffn

@deffn {Method} dbm-exists? (dbm @code{<dbm>}) key
@c EN
Return true if a value exists for @var{key}, false otherwise.
@c JP
キー@var{key}に関連付けられた値が存在すれば@code{#t}を返します。
@c COMMON
@end deffn

@deffn {Method} dbm-delete! (dbm @code{<dbm>}) key
@c EN
Delete a value associated with @var{key}.  
@c JP
キー@var{key}に関連付けられた値を消去します。値が存在しない場合は何もしません。
@c COMMON
@end deffn


@node Iterating on a database,  , Accessing a dbm database, Generic DBM interface
@subsection Iterating on a dbm database
@c NODE DBMデータベース上の繰り返し処理

@c EN
To walk over the entire database, following methos are provided.
@c JP
全データベースを渡り歩く処理のために、以下のメソッドが用意されています。
@c COMMON

@deffn {Method} dbm-fold (dbm @code{<dbm>}) procedure knil
@c EN
The basic iterator.
For each key/value pair, @var{procedure} is called as
@code{(@var{procedure} @var{key} @var{value} @var{r})},
where @var{r} is @var{knil} for the fist call of @var{procedure},
and the return value of the previous call for subsequent calls.
Returns the result of the last call of @var{procedure}.
If no data is in the database, @var{knil} is returned.

The following method returns the sum of all the integer values.
@c JP
基本的な繰り返し処理です。データベース内の各キー／値のペアに関して、手続き
@var{procedure}が @code{(@var{procedure} @var{key} @var{value} @var{r})},
のように呼ばれます。ここで@var{r}は、最初の@var{procedure}の呼び出しの時には@var{knil}
が、以降の呼び出しの時にはその直前の@var{procedure}が返した値が渡されます。
最後の@var{procedure}の戻り値が@code{dbm-fold}の戻り値となります。
データベース中にデータがひとつもなければ@var{knil}がそのまま返されます。

次の例は、データベース中の整数の値を全て加算します。
@c COMMON
@example
(dbm-fold dbm (lambda (k v r) (if (integer? v) (+ v r) r) 0))
@end example
@end deffn

@deffn {Method} dbm-for-each (dbm @code{<dbm>}) procedure
@c EN
For each key/value pair in the database @var{dbm}, @var{procedure}
is called.  Two arguments are passed to @var{procedure}---a key and
a value.   The result of @var{procedure} is discarded.
@c JP
データベース内の各キー／値のペアに関して、手続き@var{procedure}を呼び出します。
@var{procedure}にはキーと値が渡されます。@var{procedure}の戻り値は捨てられます。
@c COMMON
@end deffn

@deffn {Method} dbm-map (dbm @code{<dbm>}) procedure
@c EN
For each key/value pair in the database @var{dbm}, @var{procedure}
is called.  Two arguments are passed to @var{procedure}---a key and
a value.   The result of @var{procedure} is accumulated to a list
which is returned as a result of @code{dbm-map}.
@c JP
データベース内の各キー／値のペアに関して、手続き@var{procedure}を呼び出します。
@var{procedure}にはキーと値が渡されます。@var{procedure}の戻り値はリストに
集められて@code{dbm-map}の戻り値となります。
@c COMMON
@end deffn


@c ----------------------------------------------------------------------
@node GDBM interface, NDBM interface, Generic DBM interface, Library modules
@section @code{dbm.gdbm} - GDBM interface

@deftp {Module} dbm.gdbm
@mdindex dbm.gdbm
@end deftp

@deftp {Class} <gdbm>
@clindex gdbm
Inherits @code{<dbm>}.  Provides an implementation for GDBM library.
This module is only installed when your system already has GDBM
(1.8.0 is preferred, but works with older 1.7.x with some limitations).

@defivar <gdbm> sync
@end defivar
@defivar <gdbm> nolock
@end defivar
@defivar <gdbm> bsize
@end defivar
@end deftp

Besides the unified DBM interface (@xref{Generic DBM interface}),
this module provides the following low-level functions that provides
direct access to the gdbm API.  See gdbm manual for details of these
APIs.

@defun gdbm-open path &optional size rwmode fmode error-callback

@defvar GDBM_READER
@end defvar

@defvar GDBM_WRITER
@end defvar

@defvar GDBM_WRCREAT
@end defvar

@defvar GDBM_NEWDB
@end defvar

@defvar GDBM_FAST
@end defvar

@defvar GDBM_SYNC
@end defvar

@defvar GDBM_NOLOCK
@end defvar
@end defun

@defun gdbm-close gdbm-object
@end defun

@defun gdbm-closed? gdbm-object
@end defun

@defun gdbm-store key value &optional flag


@defvar GDBM_INSERT
@end defvar

@defvar GDBM_REPLACE
@end defvar

@end defun


@defun gdbm-fetch gdbm-object key
@end defun


@defun gdbm-delete gdbm-object key
@end defun


@defun gdbm-firstkey gdbm-object
@end defun


@defun gdbm-nextkey gdbm-object key
@end defun


@defun gdbm-reorganize gdbm-object
@end defun


@defun gdbm-sync gdbm-object
@end defun


@defun gdbm-exists gdbm-object key
@end defun


@defun gdbm-strerror errno
@end defun


@defun gdbm-setopt gdbm-object option value

@defvar GDBM_CACHESIZE
@end defvar

@defvar GDBM_FASTMODE
@end defvar

@defvar GDBM_SYNCMODE
@end defvar

@defvar GDBM_CENTFREE
@end defvar

@defvar GDBM_COALESCEBLKS
@end defvar
@end defun

@defun gdbm-version
@end defun

@defun gdbm-errno
@end defun

@c ----------------------------------------------------------------------
@node NDBM interface, Original DBM interface, GDBM interface, Library modules
@section @code{dbm.ndbm} - NDBM interface

@deftp {Module} dbm.ndbm
@mdindex dbm.ndbm
@end deftp

@deftp {Class} <ndbm>
@clindex ndbm
Inherits @code{<dbm>}.  Provides an implementation for NDBM library.
This module is only installed when your system already has NDBM.
@end deftp

Besides the unified DBM interface (@xref{Generic DBM interface}),
this module provides the following low-level functions that provides
direct access to the ndbm API.  See ndbm manual for details of these
APIs.

@defun ndbm-open path flags mode
@end defun

@defun ndbm-close ndbm-object
@end defun

@defun ndbm-closed? ndbm-object
@end defun

@defun ndbm-store ndbm-object key content &optional flag
@end defun

@defun ndbm-fetch ndbm-object key
@end defun

@defun ndbm-delete ndbm-object key
@end defun

@defun ndbm-firstkey ndbm-object
@end defun

@defun ndbm-nextkey ndbm-object
@end defun

@defun ndbm-error ndbm-object
@end defun

@defun ndbm-clear-error ndbm-object
@end defun

@c ----------------------------------------------------------------------
@node Original DBM interface, Filtering file content, NDBM interface, Library modules
@section @code{dbm.odbm} - Original DBM interface

@deftp {Module} dbm.odbm
@mdindex dbm.odbm
@end deftp

@deftp {Class} <odbm>
@clindex odbm
Inherits @code{<dbm>}.  Provides an implementation for legacy DBM
library.
This module is only installed when your system already has DBM.

The biggest limitation of the legacy DBM is that you can only open
one database at a time.  You can create a multiple @code{<odbm>}
instances, but you can open at most one of it at a time, or
you'll get an error.
@end deftp

Besides the unified DBM interface (@xref{Generic DBM interface}),
this module provides the following low-level functions that provides
direct access to the dbm API.  See dbm manual for details of these
APIs.

@defun odbm-init path
@end defun

@defun odbm-close
@end defun

@defun odbm-store key value
@end defun

@defun odbm-fetch key
@end defun

@defun odbm-delete key
@end defun

@defun odbm-firstkey
@end defun

@defun odbm-nextkey key
@end defun


@c ----------------------------------------------------------------------
@c @node Pseudo DBM interface, Character code conversion, Original DBM interface, Library modules
@c @section @code{dbm.pdbm} - Pseudo DBM interface

@c ----------------------------------------------------------------------
@node Filtering file content, Character code conversion, Original DBM interface, Library modules
@section @code{file.filter} - Filtering file content
@c NODE ファイルのフィルタ, @code{file.filter} - ファイルのフィルタ

@defun {Module} file.filter
@mdindex file.filter
@c EN
This module provides utilities for a common pattern in
filter-type commands, that is, to take an input, to process
the content, and to write the result.   The common occurring
pattern is:

@itemize @bullet
@item
Input may be a specified file, or an input port
(the current input port by default).
@item
Output may be a specified file, or an output port
(the current output port by default).
@item
Output may be a temporary file, which will be renamed
upon completion of the processing.
@item
Output file may be removed when an error occurs
in the processing.
@end itemize
@c JP
このモジュールは、フィルター型のコマンド、
すなわち入力を読み込み、処理をして結果を書き出すような場合に
共通するパターンに使えるユーティリティ手続きを提供します。
共通するパターンとは：

@itemize @bullet
@item
入力は指定されたファイルかポートで、デフォルトはカレント入力ポート。
@item
出力は指定されたファイルかポートで、デフォルトはカレント出力ポート。
@item
出力は一時ファイルに書き出すこともできて、
その場合は処理が終了した時点で指定されたファイルにリネーム。
@item
処理途中でエラーが起こった場合に出力ファイルを削除
@end itemize
@c COMMON
@end defun

@defun file-filter proc &keyword input output temporary-file temporary-directory keep-output?
@c EN
Calls @var{proc} with two arguments, an input port and 
an output port.   Returns the result(s) of @var{proc}.
The input port and output port are chosen depending on the keyword arguments.
@c JP
二つの引数、入力ポートと出力ポートを引数として@var{proc}を呼び出し、
その結果を返します。
入力ポートと出力ポートはキーワード引数により決定されます。
@c COMMON

@table @code
@item input
@c EN
The argument must be either an input port or a string
that specifies a file name.
If it's an input port, it is passed to @var{proc} as is.
If it's a string, the named file is opened for input and the resulting
port is passed to @var{proc}, and the port is closed when @var{proc}
returns.
If this argument is omitted, the current input port is passed.
@c JP
この引数は入力ポートかファイル名を示す文字列でなければなりません。
入力ポートの場合、それはそのまま@var{proc}に渡されます。
文字列が渡された場合は、そのファイル名を持つファイルを入力用にオープンし、
そのポートが@var{proc}に渡され、またこのポートは@var{proc}が戻った時に閉じられます。
この引数が省略された場合は、現在の入力ポートが渡されます。
@c COMMON
@item output
@c EN
The argument must be either an output port or a string
that specifies a file name.
If it's an output port, it is passed to @var{proc} as is.
If it's a string, the named file is opened for output
(unless @var{temporary-file} is given, in that case
a temporary file is opened instead), and the resulting port
is passed to @var{proc}.  This port is closed when @var{proc} returns.
If this argument is omitted, the current output port is passed.
@c JP
この引数は入力ポートかファイル名を示す文字列でなければなりません。
出力ポートの場合、それはそのまま@var{proc}に渡されます。
文字列が渡された場合は、そのファイル名を持つファイルを出力用にオープンし、
そのポートが@var{proc}に渡されます (但し、@var{temporary-file}
引数が渡された時はそれに指定されるファイルが一時ファイルとしてオープンされます)。
オープンされたポートは@var{proc}が戻った時に閉じられます。
この引数が省略された場合は、現在の出力ポートが渡されます。
@c COMMON
@item temporary-file
@c EN
If a string file name is given to this argument, the named file
is opened for output during the processing, instead of the file
name as @var{output}.   The output port @var{proc} receives
is connected to this file.  When @var{proc}
returns normally, the file is renamed to the name given to @var{output}
keyword argument.

If the given file name begins with characters except @code{"/"}, @code{"./"}
or @code{"../"}, the directory of the file name given to @var{output} argument
is attached before it.
Furthermore, a unique is attached to the temporary file name
(the temporary file is opened by @code{sys-mkstemp}.)

This argument is ignored when @var{output} argument is not a string
file name.
@c JP
文字列でファイル名が渡された場合、処理の間の出力先として@var{output}に指定された
ファイルのかわりにそのファイルがオープンされます。
@var{proc}にはその一時ファイルへの出力ポートが渡されます。
@var{proc}が正常に返って来た時点で、一時ファイルは@var{output}に指定された
ファイルへとリネームされます。

もし一時ファイル名が@code{"/"}、@code{"./"}、@code{"../"}以外の
文字で始まっていた場合は、@var{output}に与えられたファイル名のディレクトリが
一時ファイルの前に追加されます。さらに、ユニークなサフィックスが一時ファイルの後に
追加されます(一時ファイルは@code{sys-mkstemp}を使ってオープンされます)。

この引数は、@var{output}にファイル名が与えられなかった場合は無視されます。
@c COMMON
@item keep-output?
@c EN
If a true value is given, the output is not deleted even
when @var{proc} signals an error.
By default, the output (or the temporary file when
@var{temporary-file} is given) will be deleted on error.
@c JP
真の値が与えられた場合、@var{proc}がエラーになった場合でも出力ファイルを削除しません。
デフォルトでは、出力ファイル(もしくは@var{temporary-file}が与えられた場合は
そのファイル)はエラーの場合には削除されます。
@c COMMON
@end table
@end defun

@c ----------------------------------------------------------------------
@node Character code conversion, Collection framework, Filtering file content, Library modules
@section @code{gauche.charconv} - Character Code Conversion
@c NODE 文字コード変換, @code{gauche.charconv} - 文字コード変換

@deftp {Module} gauche.charconv
@mdindex gauche.charconv
@c EN
This module defines a set of functions that converts character encoding
of the given data stream.
This module also overloads Gauche's file stream creating functions
(such as @code{open-input-file} and @code{call-with-output-file})
so that they accept @code{:encoding} keyword argument.
@c JP
与えられたデータストリームの文字エンコーディングを変換するための手続き群を提供する
モジュールです。また、このモジュールは@code{open-input-file}や
@code{call-with-output-file}等のファイルストリームを作成する手続きを
置き換え、@code{:encoding} キーワード引数を認識するようにします。
@c COMMON

@c EN
Internally, charconv module uses @code{iconv(3)} character code
conversion library.
The supported character encoding schemes (CES) are limited to what
the underlying @code{iconv} supports.   Unfortunately, there is no
standard way to query supported CES's from the system.  You have to
check the manual of your iconv system (try @code{man iconv}) to find
out what CES's are supported.
@c JP
charconvモジュールは@code{iconv(3)}ライブラリを利用して文字コードを変換します。
従って、変換可能な文字符号化方法(CES)は使用している@code{iconv}ライブラリが
サポートするものに制限されます。どのCESがサポートされているかをプログラムから知るための
APIは無いので、サポートされているCESを知るにはシステムのiconvのマニュアルを
参照してください。
@c COMMON

@c EN
A CES is represented by its name as a string (case insignificant).
There may be several aliases defined for a single encoding.
For example, both @code{"EUC-JP"} and @code{"EUCJP"} may work on the EUC-JP
encoding.  The iconv in glibc 2.1 or later recognizes following
names for the typical Japanese CES.
@c JP
CESの名前は文字列で指定します。大文字小文字の違いは無視されます。
同じCESにいくつかの名前がついていることがあります。例えば、@code{"EUC-JP"}と@code{"EUCJP"}
はともにEUC-JPエンコーディングを指定するのに使えるかもしれません。
glibc 2.1附属のiconvでは、次のようなCES名がよくある日本語のCESとして認識されるようです。
@c COMMON

@table @code
@item "EUC-JP", "EUCJP"
EUC-JP
@item "SJIS", "SHIFT-JIS"
Shift JIS
@item "UTF-8"
UTF-8
@item "CSISO2022JP"
ISO-2022-JP
@end table

@c EN
There are cases that you don't know the CES of the input, but
you know it is one of several possible encodings.
The charconv module has a mechanism
to guess the input encoding.  There can be multiple algorithms,
and each algorithm has the name.  Right now, there's only one
algorithm implemented:
@c JP
しばしば、入力のCESが未知であり、可能性のあるいくつかの候補から入力のCESを
推測しなければならない場合があります。推測するアルゴリズムはいくつも考えられるので、
それぞれに名前がついています。今のところ、一つのアルゴリズムしか実装されていません。
@c COMMON
@table @code
@item "*JP"
@c EN
To guess the character encoding from japanese text, among either
ISO-2022-JP, EUC-JP, ShiftJIS or UTF-8.
@c JP
日本語のテキストのCESを、ISO-2022-JP, EUC-JP, ShiftJIS または UTF-8の
いずれかであるとして推測する。
@c COMMON
@end table

@c EN
This name can be used in place of CES name for some conversion functions.
@c JP
このアルゴリズム名は、いくつかの変換関数においてCES名の代わりに使うことができます。
@c COMMON
@end deftp

@c EN
You can check whether the specific conversion is supported on
your system or not, by the following function.
@c JP
特定の変換がシステムでサポートされているかどうかは次の手続きで調べることができます。
@c COMMON

@defun ces-conversion-supported? from-ces to-ces
@c EN
Returns @code{#t} if conversion from the character encoding scheme
(CES) @var{from-ces} to @var{to-ces} is supported in this system.
@c JP
符号化方法@var{from-ces}から@var{to-ces}への変換がサポートされていれば@code{#t}を、
そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@c EN
And the followings are the conversion function.
@c JP
そして以下が変換手続きです。
@c COMMON

@defun open-input-conversion-port source from-code &keyword to-code buffer-size owner?
@c EN
Takes an input port @var{source}, which feeds characters
encoded in @var{from-code}, and returns another input port,
from which you can read characters encoded in @var{to-code}.
@c JP
文字が符号化方法@var{from-code}で符号化されているデータを読み出せる
入力ポート@var{source}を取り、符号化方法@var{to-code}で符号化されたデータを
読み出せるポートを作成して返します。
@c COMMON

@c EN
If @var{to-code} is omitted, the native CES is assumed.
@c JP
@var{to-code}が省略された場合はネイティブのCESと見なされます。
@c COMMON

@c EN
@var{buffer-size} is used to allocate internal buffer size for
conversion.  The default size is about 1 kilobytes and it's suitable
for typical cases.
@c JP
@var{buffer-size}は変換のための内部バッファのサイズを指定します。
省略時のサイズは1Kバイト程で、通常の使用には問題ないサイズです。
@c COMMON

@c EN
If you don't know the @var{source}'s CES, you can specify
CES guessing scheme, such as @code{"*JP"}, in place of @var{from-code}.
The conversion port tries to guess the encoding, by prefetching
the data from @var{source} up to the buffer size.  It signals an error
if the code guessing routine finds no appropriate CES.
If the guessing routine finds ambiguous input, however, it silently
assume one of possible CES's, in favor of the native CES.
Hence it is possible that the guessing is wrong if the buffer
size is too small.  The default size is usually enough for most
text documents, but it may fail if the large text contains mostly ASCII
characters and multibyte characters appear only at the very end of
the document.
To be sure for the worst case,
you have to specify the buffer size large enough to
hold entire text.
@c JP
入力のCESが不明な場合、@code{"*JP"}などのCES推測アルゴリズム名を@var{from-code}
として指定することができます。変換ポートは最高でバッファサイズまでのデータを先読みし、
CESを推測しようとします。そのアルゴリズムで推測されるどのCESにも該当しないデータが
検出された場合はエラーが報告されます。もし複数のCESが可能であるようなデータであった
場合は、Gaucheのネイティブエンコーディングが可能なCESに含まれていればそれが選ばれ、
そうでなければいずれかのCESが適当に選ばれます。従って、バッファサイズが小さすぎると
誤った判定をする可能性が高くなります。大抵のテキストドキュメントに対して、
既定のバッファサイズは十分ですが、大きなテキストのほとんどがASCII文字で最後だけ
マルチバイト文字が現われるようなテキストでは誤判定の可能性があります。
最悪の場合でも結果を保障するには、テキスト全体が格納できるバッファサイズを指定すると
良いでしょう。
@c COMMON

@c EN
By default, @code{open-input-conversion-port} leaves @var{source} open.
If you specify true value to @var{owner?}, the function closes
@var{source} after it reads EOF from the port.
@c JP
通常、@code{open-input-conversion-port}は変換が全て終了した後でも@var{source}
はオープンしたままにします。キーワード引数@var{owner?}に真の値を指定すると、
EOFが読まれた後で@var{source}はクローズされます。
@c COMMON

@c EN
For example, the following code copies a file @file{unknown.txt} to a file
@file{eucjp.txt}, converting unknown japanese CES to EUC-JP.
@c JP
例を示しましょう。以下のコードは未知のCES(但しEUC-JP, SJIS, ISO2022-JP, UTF8の
いずれかであることは分かっている)で書かれたテキストファイル@file{unknown.txt}を
読みだし、文字エンコーディングをEUC-JPに変換して@file{eucjp.txt}に書き出します。
@c COMMON
@example
(call-with-output-file "eucjp.txt"
  (lambda (out)
    (copy-port (open-input-conversion-port
                 (open-input-file "unknown.txt")
                 "*jp"             ;@r{guess code}
                 :to-code "eucjp"
                 :owner? #t)       ;@r{close unknown.txt afterwards}
               out)))
@end example
@end defun


@defun open-output-conversion-port sink to-code &keyword from-code buffer-size owner?
@c EN
Creates and returns an output port that converts
given characters from @var{from-code} to @var{to-code}
and feed to an output port @var{sink}.
If @var{from-code} is omitted, the native CES is assumed.
You can't specify a character guessing scheme (such as "*JP") to
neither @var{from-code} nor @var{to-code}.
@c JP
文字のエンコーディングを@var{from-code}から@code{to-code}に変換して
出力ポート@var{sink}に書き出すような出力変換ポートを作成して返します。
@var{to-code}が省略された場合はネイティブのCESと見なされます。
@var{from-code}にも@var{to-code}にも、CES推測アルゴリズム名を
使用することはできません。
@c COMMON

@c EN
@var{buffer-size} specifies the size of internal conversion buffer.
The characters put to the returned port may stay in the buffer,
until the port is explicity flushed (by @code{flush}) or
the port is closed.
@c JP
@var{buffer-size}は内部で変換に使われるバッファサイズを指定します。
出力変換ポートに書き出された文字は、@code{flush}を使って明示的に
フラッシュするか出力変換ポートが閉じられるまで、バッファ内に残っている可能性があります。
@c COMMON

@c EN
By default, the returned port doesn't closes @var{sink} when
itself is closed.  If a keyword argument @var{owner?} is provided
and true, however, it closes @var{sink} when it is closed.
@c JP
通常、出力変換ポートがクローズされても@var{sink}はクローズされません。
@var{owner?}に真の値を与えれば、出力変換ポートのクローズ時に@var{sink}を
クローズするようにできます。
@c COMMON
@end defun


@defun open-input-file filename &keyword encoding conversion-buffer-size @dots{}
@defunx call-with-input-file filename proc &keyword encoding conversion-buffer-size @dots{}
@defunx with-input-from-file filename thunk &keyword encoding conversion-buffer-size @dots{}
@defunx open-output-file filename &keyword encoding conversion-buffer-size @dots{}
@defunx call-with-output-file filename proc &keyword encoding conversion-buffer-size @dots{}
@defunx with-output-to-file filename thunk &keyword encoding conversion-buffer-size @dots{}
@c EN
These Gauche built-in procedures are extended to accept two extra
keyword arguments, @var{encoding} and @var{conversion-buffer-size}.
(@xref{File ports}, for their default behavior).

You can give a CES of the file @var{filename} to @var{encoding},
and the port automatically converts the file CES to the Gauche's
native CES.  You can use a CES guessing algorithm name for
input file port.

The keyword argument @var{conversion-buffer-size} has the same
meaning as @var{buffer-size} of @code{open-input-conversion-port}.
@c JP
これらのGauche組み込みの手続きは、@var{encoding}と@var{conversion-buffer-size}
という二つの追加のキーワード引数を取るように拡張されます。
(これらの手続きの元の動作については@ref{File ports}を参照して下さい)。

@var{filename}の文字エンコーディング名を@var{encoding}に渡すと、
ファイルを読む際に@var{encoding}からGaucheの内部エンコーディングへの変換が
行われます。入力の場合は@var{encoding}にCES推測アルゴリズム名を渡すこともできます。

@var{conversion-buffer-size}は@code{open-input-conversion-port}
における@var{buffer-size}と同じ意味を持ちます。
@c COMMON
@end defun

@defun ces-convert string from-code &optional to-code
@c EN
Convert @var{string}'s character encoding from @var{from-code}
to @var{to-code}, and returns the converted string.
The returned string may be a byte-string if @var{to-code}
is different from the native CES.
@c JP
@var{from-code}でエンコーディングされた文字列@var{string}を
@var{to-code}でエンコーディングされた文字列に変換します。
@var{to-code}がネイティブエンコーディングで無い場合、返される文字列は
バイト文字列(不完全な文字列)であるかもしれません。
@c COMMON

@c EN
@var{from-code} can be a name of character guessing scheme
(e.g. "*JP").  when @var{to-code} is omitted, the native CES is
assumed.
@c JP
@var{from-code}にはCES推測アルゴリズム名("*JP"など)を与えることができます。
@var{to-code}が省略された場合はネイティブエンコーディングと見なされます。
@c COMMON
@end defun

@defun ces-guess-from-string string scheme
@c EN
Guesses the CES of @var{string} by the character guessing scheme
@var{scheme} (e.g. "*JP").  Returns CES name that can be used
by other charconv functions.   It may return @code{#f} if the
guessing scheme finds no possible encoding in @var{string}.
Note that if there may be more than one possible encoding in
@var{string}, the guessing scheme returns one of them,
usually in favor of the native CES.
@c JP
文字列@var{string}のCESを、CES推測アルゴリズム@var{scheme} ("*JP"など)
を使って推測し、結果のCES名を返します。もしどのCESにも該当しないデータが
含まれていれば@code{#f}が返されます。複数のCESが可能である場合、
ネイティブエンコーディングが含まれていればそれを、そうでなければ可能なCESからどれか
ひとつが選んで返されます。
@c COMMON
@end defun



@c ----------------------------------------------------------------------
@node Collection framework, Low-level file operations, Character code conversion, Library modules
@section @code{gauche.collection} - Collection framework
@c NODE コレクションフレームワーク, @code{gauche.collection} - コレクションフレームワーク

@deftp {Module} gauche.collection
@mdindex gauche.collection
@c EN
This module provides a set of generic functions (GFs) that iterate over
various collections.   The Scheme standard [R5RS] has some iterative
primitives such as @code{map} and @code{for-each},
and SRFI-1 (@xref{List library} adds a rich set of such functions,
but they work only on lists.

Using the method dispatch of the object system, this module
efficiently extends those
functions for other collection classes such as vectors and hash tables.
It also provides a simple way for user-defined class to adapt
those opertaions.
So far, the following operations are defined.
@c JP
このモジュールは、様々なコレクションに対して繰り返し処理を行う総称関数を提供します。
Schemeの規格は@code{map}や@code{for-each}などの繰り返し手続きを定義しており、
またSRFI-1(@ref{List library}参照)は更に数多くの繰り返し手続きを提供しますが、
それらはリストに対してしか動作しません。

このモジュールはオブジェクトシステムのメソッドディスパッチを利用して、
これらの手続きをベクタやハッシュテーブルのような一般のコレクションタイプに対しても
効率良く動作するように拡張します。また、ユーザ定義のクラスにこれらの操作を実装するための
簡単な方法も提供します。今のところ、次のような総称関数が提供されています。
@c COMMON

@table @asis
@c EN
@item Mapping
@c JP
@item マッピング
@c COMMON
@code{fold}, @code{map}, @code{map-to}, @code{for-each}
@c EN
@item Selection and searching
@c JP
@item 選択と探索
@c COMMON
@code{find}, @code{filter}, @code{filter-to},
@code{remove}, @code{remove-to}, @code{partition}, @code{partition-to}
@c EN
@item Conversion
@c JP
@item 変換
@c COMMON
@code{coerce-to}
@c EN
@item Miscellaneous
@c JP
@item その他
@c COMMON
@code{size-of}, @code{lazy-size-of}
@c EN
@item Fundamental iterator creator
@c JP
@item 基礎的なイテレータ構築メソッド
@c COMMON
@code{call-with-iterator}, @code{call-with-builder},
@code{with-iterator}, @code{with-builder}, @code{call-with-iterators}.
@end table

@c EN
Those operations work on @emph{collections} and its subclass,
@emph{sequences}.  A collection is a certain form of a set
of objects that you can traverse all the object in it in a certain way.
A sequence is a collection that all its elements are ordered, so that
you can retrieve its element by index.
@c JP
これらの操作は、@emph{コレクション}とそのサブクラスである
@emph{シーケンス}に対して動作します。コレクションは、その要素を全て
訪れる方法が用意されているようなオブジェクトの集合です。
シーケンスは、要素間に全順序関係が定義されておりインデックスで要素を取り出すことが
できるようなコレクションです。
@c COMMON

@c EN
The following Gauche built-in objects are treated as collections and/or
sequences.
@c JP
次にあげるGaucheの組み込みオブジェクトはシーケンスあるいはコレクションとして動作します。
@c COMMON
@table @code
@item <list>
@c EN
A sequence.
@c JP
シーケンス
@c COMMON
@item <vector>
@c EN
A sequence.
@c JP
シーケンス
@c COMMON
@item <string>
@c EN
A sequence (of characters)
@c JP
文字のシーケンス
@c COMMON
@item <hash-table>
@c EN
A collection.  Each element is a pair of a key and a value.
@c JP
コレクション。各要素はキーと値のペア。
@c COMMON
@item <s8vector>, <u8vector>, @dots{} <f64vector>
@c EN
A sequence (methods defined in @code{srfi-4} module,
@xref{Homogeneous Vectors}).
@c JP
シーケンス。メソッドは@code{srfi-4}モジュール内で定義されます。
@ref{Homogeneous Vectors}参照。
@c COMMON
@end table

@c EN
@xref{Sequence framework}, for it adds more sequence specific
methods.
@c JP
@ref{Sequence framework}も参照してください。シーケンス特有のメソッドが
追加されます。
@c COMMON

@c EN
The methods that needs to return a set of objects, i.e. 
@code{map}, @code{filter}, @code{remove} and @code{partition}.
returns a list (or lists).  The corresponding ``-to'' variant
(@code{map-to}, @code{filter-to}, @code{remove-to} and @code{partition-to}.
takes a collection class argument and returns the collection of the class.
@c JP
オブジェクトの集合を返すようなメソッド、すなわち
@code{map}、@code{filter}、@code{remove}および@code{partition}は、
リストを返します。対応する``-to''がつくメソッド
(@code{map-to}、@code{filter-to}、@code{remove-to}、@code{partition-to})
はコレクションクラスも引数に取り、そのクラスのコレクションを返します。
@c COMMON
@end deftp

@menu
* Mapping over collection::     
* Selection and searching in collection::  
* Miscellaneous operations on collection::  
* Fundamental iterator creators::  
* Implementing collections::    
@end menu

@node Mapping over collection, Selection and searching in collection, Collection framework, Collection framework
@subsection Mapping over collection
@c NODE コレクションに対するマッピング

@deffn {Generic function} fold proc knil coll coll2 @dots{}
@c EN
This is a natural extension of @var{fold} in SRFI-1 (@xref{SRFI-1 Fold}).
@c JP
SRFI-1で定義される@var{fold} (@ref{SRFI-1 Fold}参照) の自然な拡張です。
@c COMMON

@c EN
For each element @var{Ei} in the collection @var{coll}, @var{proc} is
called as (@var{proc} @var{Ei} @var{Ri-1}), where @var{Ri-1} is the 
result of (@var{i}-1)-th invocation of @var{proc} for @var{i} > 0, 
and @var{R0} is @var{knil}.  Returns the last invocation of @var{proc}.
@c JP
コレクション@var{coll}の各要素@var{Ei}に対して、手続き@var{proc}が
(@var{proc} @var{Ei} @var{Ri-1}) のように呼ばれます。ここで、
@var{Ri-1} は @var{i} > 0 に対しては (@var{i}-1)番目の@var{proc}の呼び出しの
結果であり、@var{R0}は@var{knil}です。最後の@var{proc}の戻り値を返します。
@c COMMON
@example
(fold + 0 '#(1 2 3 4)) @result{} 10
(fold cons '() "abc")  @result{} (#\c #\b #\a)
@end example

@c EN
If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c COMMON

@c EN
You can fold more than one collection, although it doesn't make
much sense unless all of the collections are sequences.
Suppose @var{E(k, i)} for @var{i}-th element
of @var{k}-th collection.  @var{proc} is called as
@c JP
複数のコレクションを@code{fold}に渡すこともできます (但し、その全てがシーケンスで
なければあまり意味のある操作では無いでしょう)。
@var{k}番目のコレクションの@var{i}番目の要素を@var{E(k, i)}とするとき、
@var{proc}は以下のように呼ばれます。
@c COMMON
@example
(@var{proc} @var{E(0,i)} @var{E(1,i)} @dots{} @var{E(K-1,i)} @var{Ri-1})
@end example

@c EN
Different types of collections can be mixed together.
@c JP
異なる型のコレクションを混ぜて扱うことができます。
@c COMMON

@example
(fold acons '() "abc" '#(1 2 3))
  @result{} ((#\c 3) (#\b 2) (#\a 1))

@c EN
;; @r{calculates dot product of two vectors}
@c JP
;; @r{二つのベクタの内積を計算}
@c COMMON
(fold (lambda (a b r) (+ (* a b) r)) 0
      '#(3 5 7) '#(2 4 6))
  @result{} 68
@end example

@c EN
When more than one collection is given, @code{fold} terminates
as soon as at least one of the collections exhausted.
@c JP
複数のコレクションが与えられた場合、@code{fold}は少なくともひとつのコレクションが
終了した時点で終了します。
@c COMMON
@end deffn

@deffn {Generic function} map proc coll coll2 @dots{}
@c EN
This extends the built-in @code{map} (@xref{Procedures}).
Apply @var{proc} for each element in the collection @var{coll}, and
returns a list of the results.
@c JP
組み込み手続き@code{map} (@ref{Procedures}参照) を拡張します。
コレクション@var{coll}の各要素に手続き@var{proc}を適用し、その結果をリストにして
返します。
@c COMMON

@c EN
If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c COMMON

@c EN
If more than one collection is passed, @var{proc} is called with
elements for each collection.  In such case, @code{map} terminates
as soon as at least one of the collection is exhausted.  Note that passing
more than one collection doesn't make much sense unless
all the collections are sequences.
@c JP
複数のコレクションが与えられた場合、@var{proc}は各コレクションからの要素を引数として
呼び出されます。@code{map}はひとつでもコレクションの最後に到達したら終了します。
複数のコレクションを渡すのは、コレクションの全てがシーケンスでないとあまり意味がないでしょう。
@c COMMON

@example
(map (lambda (x) (* x 2)) '#(1 2 3))
  @result{} #(2 4 6)

(map char-upcase "abc")
  @result{} (#\A #\B #\C)

(map + '#(1 2 3) '#(4 5 6))
  @result{} (5 7 9)
@end example

@c EN
@code{map} @emph{always} returns a list.  If you want to get the result
in a different type of collection, use @code{map-to} described below.
If you wonder why @code{(map char-upcase "abc")} doesn't return
@code{"ABC"}, read the discussion in the bottom of this subsection.
@c JP
@code{map}は常にリストを返します。別のコレクション型で結果を得たい場合は、
次に示す@code{map-to}を使って下さい。何故@code{(map char-upcase "abc")}が
@code{"ABC"}を返さないのか疑問なら、この最後にあるディスカッションを参照してください。
@c COMMON
@end deffn

@deffn {Generic function} map-to class proc coll coll2 @dots{}
@c EN
This works the same as @code{map}, except the result is returned
in a collection of class @var{class}.   @code{Class} must be a
collection class and have a builder interface
(@xref{Fundamental iterator creators}).
@c JP
@code{map}と同じように動作しますが、結果はクラス@var{class}のインスタンスとして返されます。
@var{class}はコレクションクラスでなければなりません。
また、ビルダーインタフェースを持っている必要があります
(@ref{Fundamental iterator creators}参照).
@c COMMON

@example
(map-to <vector> + '#(1 2 3) '#(4 5 6))
  @result{} #(5 7 9)

(map-to <string> char-upcase "def")
  @result{} "DEF"

(map-to <vector> char=? "bed" "pet")
  @result{} #(#f #t #f)
@end example
@end deffn

@deffn {Generic function} for-each proc coll coll2 @dots{}
@c EN
Extension of built-in @code{for-each} (@xref{Procedures}).
Applies @var{proc} for each elements in the collection(s).
The result of @var{proc} is discarded.  The return value of
@code{for-each} is undefined.
@c JP
組み込み手続き@code{for-each} (@ref{Procedures}参照) を拡張します。
コレクション@var{coll}の各要素に手続き@var{proc}を適用します。
@var{proc}の結果は捨てられます。@code{for-each}の結果は未定義です。
@c COMMON

@c EN
If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c COMMON

@c EN
If more than one collection is passed, @var{proc} is called with
elements for each collection.  In such case, @code{for-each} terminates
as soon as one of the collection is exhausted.  Note that passing
more than one collection doesn't make much sense unless
all the collections are sequences.
@c JP
複数のコレクションが与えられた場合、@var{proc}は各コレクションからの要素を引数として
呼び出されます。@code{for-each}はひとつでもコレクションの最後に到達したら終了します。
複数のコレクションを渡すのは、コレクションの全てがシーケンスでないとあまり意味がないでしょう。
@c COMMON
@end deffn

@c EN
@emph{Discussion:}  It is debatable what type of collection @code{map}
should return when it operates on the collections other than lists.
It may seem more ``natural'' if @code{(map * '#(1 2) '#(3 4))}
returns a vector, and @code{(map char-upcase "abc")} returns a string.
@c JP
@emph{Discussion:}  @code{map}がリスト以外に対して適用されたとき、どういう
コレクション型を返すべきでしょう。
@code{(map * '#(1 2) '#(3 4))} がベクタを返し、
@code{(map char-upcase "abc")} が文字列を返すようにするほうが「自然」でしょうか。
@c COMMON

@c EN
Although such interface seems work for simple cases, it'll become
problematic for more general cases.  What type of collection should
be returned if a string and a vector are passed?  Furthermore,
some collection may only have iterator interface but no builder
interface, so that the result can't be coerced to the argument type
(suppose you're mapping over database records, for example).
And Scheme programmers are used to think @code{map} returns a list,
and the result of @code{map} are applied to the procedures that
takes list everywhere.
@c JP
そのようなインタフェースは単純な場合には動作するように思えますが、
一般的な拡張は困難です。文字列とベクタが同時に渡されたらどうします?
更に、コレクションクラスによっては繰り返しインタフェースは持っていても
ビルダーインタフェースを持っていない場合があり、結果をそのコレクションクラスとして
返せない場合もあります (データベースレコードのコレクションに対してマップする、
といった用法を考えてみて下さい)。また、Schemeプログラマは@code{map}が
リストを返すという事実に慣れ親しんでおり、既存のコードも@var{map}の戻り値を
リストを受け取る手続きに渡すことがよく行われています。
@c COMMON

@c EN
So I decided to add another method, @code{map-to}, to specify
the return type explicitly
The idea of passing the return type is taken from CommonLisp's @code{map}
function, but taking a class metaobject, @code{map-to} is much flexible
to extend using method dispatch.
This protocol (``-to'' variant takes a class metaobject
for the result collection) is used thoughout the collection framework.
@c JP
そこで、結果の型を明示的に指定する@code{map-to}という別のメソッドを定義しました。
結果の型を渡すのは、CommonLispの@code{map}関数にならっていますが、
Gaucheではクラスメタオブジェクトを渡すようにしたため、メソッドディスパッチを使って
拡張することが容易です。``-to'' のつくメソッドは結果のコレクションのクラスを
取るというインタフェースはコレクションフレームワーク中で統一的に使われています。
@c COMMON

@node Selection and searching in collection, Miscellaneous operations on collection, Mapping over collection, Collection framework
@subsection Selection and searching in collection
@c NODE コレクションからの選択と探索

@deffn {Generic function} find pred coll
@c EN
Applies @var{pred} for each element of a collection @var{coll} until
@var{pred} returns a true value.  Returns the element on which @var{pred}
returned a true value, or @code{#f} if no element satisfies @var{pred}.
@c JP
@var{pred}をコレクション@var{coll}の要素に適用してゆきます。@var{pred}が
真の値を返したらそこで打ち切り、その要素を返します。@var{pred}が真の値を返す
要素が無かった場合は@code{#f}を返します。
@c COMMON

@c EN
If @var{coll} is a sequence, it is guaranteed that @var{pred} is
applied in order.  Otherwise the order of application is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c cOMMON

@example
(find char-upper-case? "abcDe") @result{} #\D
(find even? '#(1 3 4 6)) @result{} 4
(find even? '(1 3 5 7))  @result{} #F
@end example
@end deffn

@deffn {Generic function} filter pred coll
@c EN
Returns a list of elements of collection @var{coll} that satisfies
the predicate @var{pred}.   If the collection is a sequence,
the order is preserved in the result.
@c JP
コレクション@var{coll}中の要素のうち、述語手続き@var{pred}が真の値を返したものの
リストを返します。コレクションがシーケンスであれば、結果の要素の順序は元のシーケンスの
順序と同じになります。
@c COMMON

@example
(filter char-upper-case? "Hello, World")
  @result{} (#\H #\W)
(filter even? '#(1 2 3 4)) @result{} (2 4)
@end example
@end deffn

@deffn {Generic function} filter-to class pred coll
@c EN
Same as @code{filter}, but the result is returned 
as a collection of class @var{class}.
@c JP
@code{filter}と同じですが、結果のコレクションが@var{class}のインスタンスで
返されます。
@c COMMON

@example
(filter-to <vector> even? '#(1 2 3 4)) @result{} #(2 4)
(filter-to <string> char-upper-case? "Hello, World") 
  @result{} "HW"
@end example
@end deffn

@deffn {Generic function} remove pred coll
@c EN
Returns a list of elements of collection @var{coll} that does not
satisfy the predicate @var{pred}.   If the collection is a sequence,
the order is preserved in the result.
@c JP
コレクション@var{coll}中の要素のうち、述語手続き@var{pred}が偽の値を返したものの
リストを返します。コレクションがシーケンスであれば、結果の要素の順序は元のシーケンスの
順序と同じになります。
@c COMMON

@example
(remove char-upper-case? "Hello, World")
  @result{} (#\e #\l #\l #\o #\, #\space #\o #\r #\l #\d)
(remove even? '#(1 2 3 4)) @result{} (1 3)
@end example
@end deffn

@deffn {Generic function} remove-to class pred coll
@c EN
Same as @code{remove}, but the result is returned 
as a collection of class @var{class}.
@c JP
@code{remove}と同じですが、結果のコレクションが@var{class}のインスタンスで
返されます。
@c COMMON

@example
(remove-to <vector> even? '#(1 2 3 4)) @result{} #(1 3)
(remove-to <string> char-upper-case? "Hello, World") 
  @result{} "ello, orld"
@end example
@end deffn

@deffn {Generic function} partition pred coll
@c EN
Does @code{filter} and @code{remove} the same time.
Returns two lists, the first consists of elements of the collection
@var{coll} that satisfies the predicate @var{pred}, and the second
consists of elements that doesn't.
@c JP
@code{filter}と@code{remove}を同時に行います。
二つのリストを返します。最初のリストはコレクション@var{coll}の要素のうち
述語手続き@var{pred}が真の値を返したものから構成され、二つ目のリストは
そうでない要素から構成されます。
@c COMMON

@example
(partition char-upper-case? "PuPu")
  @result{} (#\P #\P) @r{and} (#\u #\u)
(partition even? '#(1 2 3 4))
  @result{} (2 4) @r{and} (1 3)
@end example
@end deffn

@deffn {Generic function} partition-to class pred coll
@c EN
Same as @code{partition}, except the results are returned
in the collections of class @var{class}.
@c JP
@code{partition}と同じですが、結果がクラス@var{class}のコレクションとして
返されます。
@c COMMON

@example
(partition-to <string> char-upper-case? "PuPu")
  @result{} "PP" @r{and} "uu"
(partition-to <vector> even? '#(1 2 3 4))
  @result{} #(2 4) @r{and} #(1 3)
@end example
@end deffn

@node Miscellaneous operations on collection, Fundamental iterator creators, Selection and searching in collection, Collection framework
@subsection Miscellaneous operations on collection
@c NODE コレクションに対する様々な操作

@deffn {Generic function} size-of coll
@c EN
Returns the number of elements in the collection.  Default method iterates over
the collection to calculate the size, which is not very efficient
and may diverge if the collection is infinite.
Some collection classes overload the method for faster calculation.
@c JP
コレクションの要素数を返します。
デフォルトのメソッドは、コレクション中の要素をすべて数え上げるものですが、
あまり効率は良くないでしょう。また、無限個の要素を持つコレクションでは
帰ってきません。多くのコレクションクラスはより効率の良い方法でこのメソッドを定義しています。
@c COMMON
@end deffn

@deffn {Generic function} lazy-size-of coll
@c EN
Returns either the size of the collection, or a promise to
calculate it.  The intent of this method is to avoid
size calculation if it is expensive.  In some cases, the caller
wants to have size just for optimization, and it is not desirable
to spend time to calculate the size.  Such caller uses this method
and just discards the information if it is a promise.
@c JP
コレクションの要素数か、もしくはそれを計算するプロミスを返します。
このメソッドの目的は、要素数の計算が高価な場合にそれを避けることにあります。
しばしば、呼び出し側では最適化のための参考値として要素数が欲しい場合があり、
そういった場合は要素数を計算するために時間を費すのは望ましくありません。
このメソッドを代わりに呼び出して、結果がプロミスであればそれを使わない、
という選択ができます。
@c COMMON
@end deffn

@deffn {Generic function} coerce-to class coll
@c EN
Convert a collection @var{coll} to another collection
which is an instance of @var{class}.
If @var{coll} is a sequence and @var{class} is a sequence class,
the order is preserved.
@c JP
コレクション@var{coll}を、クラス@var{class}のインスタンスである
別のコレクションへと変換します。@var{coll}がシーケンスであり、
@var{class}がシーケンスクラスであれば、元のシーケンスの順序は保存されます。
@c COMMON

@example
(coerce-to <vector> '(1 2 3 4))
  @result{} #(1 2 3 4)

(coerce-to <string> '#(#\a #\b #\c))
  @result{} "abc"
@end example
@end deffn

@node Fundamental iterator creators, Implementing collections, Miscellaneous operations on collection, Collection framework
@subsection Fundamental iterator creators
@c NODE 基礎的なイテレータ構築メソッド

@c EN
These are fundamental methods on which all the rest of
iterative method are built.  The method interface is not intended
to be called from general code, but suitable for building
other iterator construct.   The reason why I chose this interface
as fundamental methods are explained at the bottom of this subsection.
@c JP
ここに挙げるメソッドは、他のコレクションメソッドの基礎となるものです。
メソッドのインタフェースは一般のコードで使われることよりも、
効率良く他の繰り返しメソッドを記述するのに便利なように設計されています。
何故このインタフェースを基礎のメソッドとして選んだかについてはこの章の最後に説明します。
@c COMMON

@deffn {Generic function} call-with-iterator collection proc &keyword start
@c EN
A fundamental iterator creator.   This creates two procedures
from @var{collection}, both take no argument, and then call
@var{proc} with those two procedures.   The first procedure is
terminate predicate, which returns @code{#t} if the iteration
is exhausted, or @code{#f} if there are still elements to be visited.
The second procedure is an incrementer,
which returns one element from the collection and sets the
internal pointer to the next element.
The behavior is undefined if you call the incrementer after
the terminate predicate returns @code{#t}.
@c JP
基礎となるイテレータ構築メソッドです。このメソッドはコレクション@var{collection}
から繰り返しのための二つの手続きを作成し、それらを引数として手続き@var{proc}を
呼びます。作られる最初の手続きは終了判定手続きで、引数無しで呼び出され、繰り返しが
終了していれば@code{#t}を、まだ要素が残っていれば@code{#f}を返します。
作られる二番目の手続きはインクリメント手続きで、呼ばれる度に現在の要素を返し、
内部のポインタを次の要素へと進めます。終了判定手続きが@code{#t}を返した後に
インクリメント手続きを呼んだ場合の動作は未定義です。
@c COMMON

@c EN
If the collection is actually a sequence, the incrementer is guaranteed
to return elements in order, from 0-th element to the last element.
If a keyword argument @var{start} is given, however, the iteration
begins from @var{start}-th element and ends at the last element.
If the collection is not a sequence, the iteration order is
arbtrary, and @var{start} argument has no effect.
@c JP
コレクションがシーケンスでもある場合、インクリメント手続きはシーケンスの順番に要素を取り出します。
キーワード引数@var{start}が与えられていればイテレーションの範囲は
@var{start}番目の要素から最後の要素までとなります。シーケンスでないコレクションに
対しては@var{start}引数は意味を持ちません。
@c COMMON

@c EN
An implementation of @var{call-with-iterator} method may
limit the extent of the iterator inside the dynamic scope of the method.
For example, it allocates some resource (e.g. connect to a database)
before calling @var{proc}, and deallocates it (e.g. disconnect from a database)
after @var{proc} returns.
@c JP
@var{call-with-iterator}のメソッド実装は、イテレータのエクステントを
そのメソッドのダイナミックスコープ内に限ることを許されます。例えば、
メソッドは@var{proc}を呼ぶ前に何らかのリソースを確保し(データベースへのコネクションなど)、
@var{proc}から戻った後でそれを解放するということができます。
@c COMMON

@c EN
This method returns the value(s) @var{proc} returns.
@c JP
このメソッドは @var{proc} が返した値をそのまま返します。
@c COMMON

@example
(call-with-iterator '(1 2 3 4 5)
  (lambda (end? next)
    (do ((odd-nums 0))
        ((end?) odd-nums)
      (when (odd? (next)) (inc! odd-nums)))))
 @result{} 3
@end example

@c EN
See also @code{with-iterator} macro below, for it is easier to use.
@c JP
下に示す@code{with-iterator}マクロも参照してください。
@c COMMON
@end deffn

@deffn {Macro} with-iterator (collection end? next args @dots{}) body @dots{}
@c EN
A convenience macro to call @code{call-with-iterator}.
@c JP
@code{call-with-iterator}を簡潔に呼び出すマクロです。
@c COMMON
@example
(with-iterator (coll end? next args @dots{}) body @dots{})
 @equiv{}
(call-with-iterator coll
  (lambda (end? next) body @dots{})
   args @dots{})
@end example
@end deffn

@defun call-with-iterators collections proc
@c EN
A helper function to write n-ary iterator method.
This function applies @code{call-with-iterator} for each @var{collection}s,
and makes two lists, the first consists of terminate predicates
and the second of incrementers.  Then @var{proc} is called
with those two lists.  Returns whatever @var{proc} returns.
@c JP
N-aryのイテレータメソッドを書くのに便利な手続きです。
この手続きはコレクションのリスト@var{collections}の各コレクションに対して
@code{call-with-iterator}を呼び、二つのリストを作ります。最初のリストには
終了判定手続きが順に集められており、二つ目のリストにはインクリメント手続きが
順に集められています。そして、これらのリストを引数として@var{proc}を呼び出します。
@var{proc}が返した値を返します。
@c COMMON
@end defun

@deffn {Generic function} call-with-builder collection-class proc &keyword size
@c EN
A fundamental builder creator.  Builder is a way to construct
a collection incrementally.  Not all collection classes provide
this method.
@c JP
基礎的なビルダー構築メソッドです。ビルダーはコレクションをインクリメンタルに
作成する方法です。コレクションクラスによってはこの手続きを提供しないものもあります。
@c COMMON

@c EN
@var{Collection-class} is a class of the collection to be built.
This method creates two procedures, adder and getter, then calls
@var{proc} with those procedures.
Adder procedure takes one argument and adds it to the collection
being built.  Getter takes no argument and returns a built collection object.
The effect is undefined if adder is called after getter is called.
@c JP
@var{Collection-class}は作成されるコレクションのクラスです。
このメソッドは、追加手続きと結果手続きの二つの手続きを作成し、それらを
引数として@var{proc}を呼びます。追加手続きは一つ引数を取り、それを作成中の
コレクションに追加します。結果手続きは引数を取らず、作成されたコレクションを返します。
結果手続きが呼ばれた後で追加手続きを呼んだ場合の動作は未定義です。
@c COMMON

@c EN
A keyword argument @var{size} may be specified if the size of
the result collection is known.  Certain collections may be
built much more efficiently if the size is known; other collections
may just ignore it.   The behavior is undefined if more than
@var{size} elements are added, or the collection is retrieved before
@var{size} elements are accumulated.
@c JP
作られるコレクションのサイズが分かっている場合、キーワード引数@var{size}を与える
ことができます。コレクションクラスによってはその情報を使って効率的にコレクションを
作成することができます。その情報を単に無視するコレクションクラスもあります。
@var{size}個より多くの要素が追加されたり、@var{size}個の要素が追加される前に
結果手続きが呼ばれたりした場合の動作は未定義です。
@c COMMON

@c EN
If the collection class is actually a sequence class,
adder is guaranteed to add elements in order.  Otherwise,
the order of elements are insignificant.
@c JP
コレクションクラスがシーケンスクラスであった場合、追加手続きは要素を
シーケンスの順に追加してゆきます。
@c COMMON

@c EN
Some collection class may take more keyword arguments to
initialize the collection.
@c JP
コレクションクラスによっては、コレクションオブジェクトの初期化のために
他のキーワード引数を取るかもしれません。
@c COMMON

@c EN
This method returns the value(s) @var{proc} returned.
@c JP
このメソッドは@var{proc}が返す値を返します。
@c COMMON

@example
(call-with-builder <list>
  (lambda (add! get)
    (add! 'a) (add! 'b) (add! 'c) (get)))
 @result{} (a b c)

(call-with-builder <vector>
  (lambda (add! get)
    (add! 'a) (add! 'b) (add! 'c) (get)))
 @result{} #(a b c)
@end example

@c EN
See also @code{with-builder} macro below, for it is much easier to use.
@c JP
下に示す@code{with-builder}マクロも参照してください。
@c COMMON
@end deffn

@deffn {Macro} with-builder (collection add! get args @dots{}) body @dots{}
@c EN
A convenience macro to call @code{call-with-builder}.
@c JP
@code{call-with-builder}を簡潔に呼び出すマクロです。
@c COMMON
@example
(with-builder (coll add! get args @dots{}) body @dots{})
 @equiv{}
(call-with-builder coll
  (lambda (add! get) body @dots{})
  args @dots{})
@end example
@end deffn

@emph{Discussion}:
@c EN
Other iterator methods are built on top of call-with-iterator and
call-with-builder.
By implementing those methods, you can easily adapt your own collection
class to all of those iterative
operations.   Optionally you can overload some of higher-level
methods for efficiency.
@c JP
他のイテレータメソッドは全てこのcall-with-iteratorとcall-with-builderの上に構築可能です。
最低限これらのメソッドを定義すれば、そのクラスはコレクションとして振舞うことができます。
もちろん最適化のために他のイテレータメソッドを定義しても構いませんが。
@c COMMON

@c EN
It is debatable that which set of operations should be primitives.
I chose call-with-iterator style for efficiency of the applications
I see most.   The following is a discussion of other possible
primitive iterators.
@c JP
どの操作を基礎的なメソッドとするかには議論の余地があります。
Gaucheでは、作者がよく見るパターンで最も効率が良くなるように考えて現在のスタイルを
選びました。以下に、他の基礎的なメソッドの可能性を検討します。
@c COMMON

@table @asis
@item @code{fold}
@c EN
It is possible to make @code{fold} a primitive method, and
build other iterator method on top of it.
Collection-specific iterating states can be kept in the
stack of @code{fold}, thus it runs efficiently.  The method
to optimize a procedure that uses @code{fold} as a basic
iterator construct.
However, it is rather cumbersome to derive
generator-style interface from it.   It is also tricky
to iterate irregulary over more than one collections.
@c JP
@code{fold}を最も基礎的なメソッドとして、他のイテレータメソッドをその上に
構築することも可能です。繰り返しの状態はスタックに置かれるので効率良く走ります。
@code{fold}を基礎とした繰り返し関数を最適化する方法は良く知られています。
しかし、@code{fold}を元にしてジェネレータスタイルのインタフェースを
作成するのは複雑です。また、複数のコレクションに対しての繰り返しを書くのも
面倒です。
@c COMMON

@item CPS
@c EN
Passes iteratee the continuation procedure that continues
the iteration.   The iteratee just returns when it want
to terminate the iteration.
It has resource management problem described in
Oleg Kiselyov's article (@ref{oleg2,,OLEG2}).
@c JP
繰り返しの中身の手続きに対し、繰り返しを続けるための継続手続きを渡す方法です。
繰り返しを続けたくなければ、手続きは継続を呼ばすにそのまま戻ります。
Oleg Kiselyovの記事(@ref{oleg2,,OLEG2})に指摘されているような、
リソース管理の問題があります。
@c COMMON

@item Iterator object
@c EN
Like C++ iterator or Common Lisp generator.
Easy to write loop.   The problem is that every call of
checking termination or getting next element must be dispatched.
@c JP
C++のイテレータやCommon Lispのジェネレータのようなオブジェクトを使う方法です。
ループを書くのは容易ですが、終了判定や要素取り出しの度にメソッドディスパッチが
起こってしまいます。
@c COMMON

@item Series
@c EN
Common Lisp's series can be very efficient if the compiler can statically
analyze the usage of series.  Unfortunately it is not the case in
Gauche.  Even if it could, the extension mechanism doesn't blend well
with Gauche's object system.
@c JP
Common Lispのシリーズはコンパイラがシリーズの使われかたを追跡できれば
非常に効率の良いコードに変換できます。Gaucheのコンパイラはそこまでのデータフロー解析を
行っていません。また、それをやったとしても、コレクションクラスを拡張するための方法が
Gaucheのオブジェクトシステムとはうまく調和しません。
@c COMMON

@item Macros
@c EN
Iterator can be implemented as macros, and that will be very efficient;
e.g. Scheme48's iterator macro.  It uses macros to extend, however,
and that doesn't blend well with Gauche's object system.
@c JP
効率を気にするなら、イテレータをマクロで書いてしまう方法もあります
(例えばScheme48の@code{iterator}マクロなど)。
効率は良いのですが、拡張するにはマクロを書くことが必要となり、
Gaucheのオブジェクトシステムとうまく調和しません。
@c COMMON
@end table

@c EN
The current implementation is close to the iterator object approach,
but using closures instead of iterator objects so that avoiding
dispatching in the inner loop.  Also it allows the iterator
implementator to take care of the resource problem.
@c JP
現在の実装はイテレータオブジェクトアプローチに近いですが、イテレータオブジェクトを
作る代わりにクロージャを使うことで内部のループでのメソッドディスパッチを
避けています。また、現在のインタフェースはリソース管理の問題を解決しています。
@c COMMON

@node Implementing collections,  , Fundamental iterator creators, Collection framework
@subsection Implementing collections
@c NODE コレクションの実装

The minimum requirements of the collection class implementation
is as follow:
@itemize @bullet
@item
The class inherits @code{<collection>} abstract class.
@item
A method @code{call-with-iterator} is implemented.
@end itemize

This makes iterator methods such as @code{map}, @code{for-each},
@code{find} and @code{filter} to work.

In order to make the constructive methods (e.g. @code{map-to} to
create your collection), you have to implement @code{call-with-builder}
method as well.  Note that @code{call-with-builder} method must work
a sort of class method, dispatched by class, rather than normal method
dispatched by instance.   In Gauche, you can implement it by using a
metaclass.   Then the minimal code will look like this:

@example
(define-class <your-collection-meta> (<class>) ())

(define-class <your-collection> (<collection>)
 (...) ;; @r{slots}
 :metaclass <your-collection-meta>)

(define-method call-with-iterator
    ((coll <your-collection>) proc . options)
  @dots{}
  )

(define-method call-with-builder
     ((coll <your-collection-meta>) proc . options)
  @dots{}
  )
@end example

Optionally, you can overload other generic functions to optimize
performance.

@c ----------------------------------------------------------------------
@node Low-level file operations, Interactive session, Collection framework, Library modules
@section @code{gauche.fcntl} - Low-level file operations
@c NODE 低レベルファイル操作, @code{gauche.fcntl} - 低レベルファイル操作

@deftp {Module} gauche.fcntl
@mdindex gauche.fcntl
Provides an interface to @code{fcntl(2)}, including
advisory file locking.
@end deftp

@defun sys-fcntl port-or-fd operation &optional arg
Performs certain operation on the file specfied by @var{port-or-fd},
which should be a port object or an integer
that specifies a system file descriptor.  If it is a port, it must
be associated to the opened file.

The operation is specified by an integer @var{operation}.
Several variables are defined for valid @var{operation}.

@table @code
@item F_GETFD
@vindex F_GETFD
@vindex FD_CLOEXEC
Returns flags associated to the file descriptor of @var{port-or-fd}.
The optional argument @var{arg} is not used.   The return value is 
an integer whose definition is system specific, except one flag,
@code{FD_CLOEXEC}, which indicates the file descriptor should be
closed on @code{exec}.

@item F_SETFD
@vindex F_SETFD
Sets the file descriptor flags given as @var{arg} to @var{port-or-fd}.
For example, the portable way of setting @code{FL_CLOEXEC} flag is
as follows:
@example
(sys-fcntl port F_SETFD
          (logior FD_CLOEXEC
                  (sys-fcntl port F_GETFD)))
@end example

@item F_GETFL
@vindex F_GETFL
Returns flags associated to the open files specified by @var{port-or-fd}.
The flags includes the following information:

@itemize @bullet
@item
@vindex O_ACCMODE
@vindex O_RDONLY
@vindex O_WRONLY
@vindex O_RDWR
File access mode.  When masked by @code{O_ACCMODE}, 
it's either one of @code{O_RDONLY}, @code{O_WRONLY} or @code{O_RDWR}.
@item
@vindex O_CREAT
@vindex O_EXCL
@vindex O_TRUNC
File creation options.  @code{O_CREAT}, @code{O_EXCL} and/or
@code{O_TRUNC}.
@item
@vindex O_APPEND
Whether appending is allowed or not, by @code{O_APPEND}
@item
@vindex O_NONBLOCK
Whether I/O is blocking or non-blocking, by @code{O_NONBLOCK}.
@item
@vindex O_NOCTTY
Whether it grabs terminal control, by @code{O_NOCTTY}.
@end itemize

The system may define system-specific flags.

@item F_SETFL
@vindex F_SETFL
Sets flags to the open files specified by @var{port-or-fd}.
Among the flags listed above, only @code{O_NONBLOCK} and @code{O_APPEND}
can be changed.

Note that @code{F_GETFD}/@code{F_SETFD} concern flags associated
to the file descriptor itself, while @code{F_GETFL}/@code{F_SETFL}
concern flags associated to the opened file itself.  This makes difference
when more than one file descriptor points to the same opened file.

@item F_DUPFD
@vindex F_DUPFD
Creates new file descriptor that points to the same file referred by
@var{port-or-fd}.
An integer must be provided as @var{arg}, and that specifies
the minimum value of file descriptor to be assigned.

@item F_GETLK
@vindex F_GETLK
The third argument must be provided and be an instance of @code{<sys-flock>}
object described below.  It searches the lock information specified by
@var{arg}, and modifies @var{arg} accordingly.

@item F_SETLK
@itemx F_SETLKW
@vindex F_SETLK
@vindex F_SETLKW
The third argument must be provided and be an instance of @code{<sys-flock>}
object described below.  Sets the advisory file lock according to 
@var{arg}.   If the lock is successfully obtained, @code{#t} is returned.
If the other process has the lock conflicting the request,
@code{F_SETLK} returns @code{#f}, while @code{F_SETLKW} waits until
the lock is available.
@end table

Other value for @var{operation} causes an error.
@end defun

@deftp {Builtin Class} <sys-flock>
@clindex sys-flock
A structure represents POSIX advisory record locking.
Advisory record locking means the system may not prevents the process
from operating on files that it doesn't have an appropriate lock.
All the processes are expected to use @code{fcntl} to check locks
before it operates on the files that may be shared.

The following slots are defined.

@defivar {<sys-flock>} type
An integer represents lock type.  Following variables are predefined
for the valid values:
@table @code
@item F_RDLCK
@vindex F_RDLCK
Read locking
@item F_WRLCK
@vindex F_WRLCK
Write locking
@item F_UNLCK
@vindex F_UNLCK
To remove a lock by @code{F_SETLK}, or to indicate the record is not
locked by @code{F_GETLK}.
@end table
@end defivar

@defivar {<sys-flock>} whence
Indicates from where @code{start} is measured.
@end defivar

@defivar {<sys-flock>} start
The offset of beginning of the locked region.
@end defivar

@defivar {<sys-flock>} len
The number of bytes to lock.  Zero means ``until EOF''.
@end defivar

@defivar {<sys-flock>} pid
An integer process id that holding the lock; used only by @code{F_GETLK}.
@end defivar
@end deftp

@c ----------------------------------------------------------------------
@node Interactive session, User-level logging, Low-level file operations, Library modules
@section @code{gauche.interactive} - Utilities for interactive session
@c NODE インタラクティブセッション, @code{gauche.interactive} - インタラクティブセッション

@deftp {Module} gauche.interactive
@mdindex gauche.interactive
@c EN
Provides useful utilities for the interactive session.

This module is automatically loaded when you run @code{gosh}
interactively.
@c JP
インタラクティブセッションで便利なユーティリティ手続きを提供します。

@code{gosh}をインタラクティブモードで起動した場合、このモジュールは自動的にロードされます。
@c COMMON
@end deftp

@defmac apropos pattern &optional module
@c EN
Show a list of defined variables whose name matches @var{pattern}.
If you give a module or a module name @var{module}, only the variables
defined in that module are listed.  Without @var{module},
the variables "visible" from the current module are listed.
@c JP
名前が@var{pattern}にマッチするような定義された変数のリストを表示します。
@var{module}にモジュールオブジェクトまたはモジュール名を与えた場合は、
そのモジュール内で定義されている変数のみが表示されます。@var{module}が
省略された場合は、カレントモジュールから「見える」変数が全て表示されます。
@c COMMON

@c EN
@var{pattern} may be a symbol or a regexp object.
If it is a symbol, the variables whose name contains the
substring that matches the symbol's name are listed.
If it is a regexp object, the variables whose name matches
the regexp are listed.
@c JP
@var{pattern}はシンボルか正規表現オブジェクトでなければなりません。
シンボルの場合、そのシンボル名を部分文字列として名前に含むような変数が
リストされます。正規表現オブジェクトの場合は、その正規表現にマッチする
名前を持つ変数がリストされます。
@c COMMON

@c EN
Some examples:
@c JP
いくつか例を示します。
@c COMMON
@example
@c EN
;; @r{List variables that contains "string" in their name}
@c JP
;; @r{"string"を名前に含む変数を表示}
@c COMMON
(apropos 'string)

@c EN
;; @r{Search in srfi-14 module}
@c JP
;; @r{srfi-14モジュールの中のみを検索}
@c COMMON
(apropos 'char 'srfi-14)
@end example
@end defmac

@deffn {Generic Function} describe obj
@deffnx {Generic Function} d obj
@c EN
Prints the detail information about a Scheme object @var{obj}.
The default method shows @var{obj}'s class, and if it has
any slots, the list of slot names and their values.
You can specialize this method for customized display.
@c JP
Schemeオブジェクト@var{obj}の詳細情報を表示します。
既定メソッドは@var{obj}のクラスを表示し、さらに@var{obj}がスロットを
持っていればその名前と内容をリストします。
このメソッドをスペシャライズすることによりクラス毎に表示をカスタマイズできます。
@c COMMON
@end deffn

@c ----------------------------------------------------------------------
@node User-level logging, Networking, Interactive session, Library modules
@section @code{gauche.logger} - User-level logging
@c NODE ユーザレベルのロギング, @code{gauche.logger} - ユーザレベルのロギング

@deftp {Module} gauche.logger
@mdindex gauche.logger
Provides a simple interface to log the program's activity.
It writes the information directly to the specified file,
instead of using syslog(2).  A syslog-like prefix string is added
to each message, which is configurable.  It also takes care of
locking of the file.
@end deftp

@deftp {Class} <log-drain>
@clindex log-drain
Represents the destination of log messages.
There's one implicit global @code{<log-drain>} instance, which is
used by default.  However, you can create as many instances
by @code{make} method as you want, in case if you want to log
to more than one destination.

@defivar {<log-drain>} path
Path of the log file.  It can be also @code{#t}, which means 
the current error port, or @code{#f}, which makes @code{log-format}
to return the formatted message but not write to any log files.

By default, this slot is @code{#f}.
@end defivar

@defivar {<log-drain>} prefix
Specifies the prefix string that is attached to the beginning of every
message.  If the message spans to several lines, the prefix is
attached to each line.   In the prefix, the following character sequences
have special meanings and replaced by @code{log-format} for appropriate
information when written out.

@table @code
@item ~T
Current time, in the format of ``Mmm DD hh:mm:ss'' where ``Mmm'' is
an abbreviated month, ``DD'' is the day of month, ``hh'', ``mm'' and
``ss'' are hours (in 24 hour basis), minuts and seconds, respectively.
This format is compatible with system logs.

@item ~Y
Current 4-digit year.

@item ~P
The program name.  The default value is the basename of
@code{*program-name*}, but you can change it by the @code{program-name}
slot described below.

@item ~$
The process id of this program.

@item ~U
The name of the effective user of the process.

@item ~H
The hostname the process is running.
@end table

The default value of this slot is ``@code{~T ~P[~$]: }''.  For example,
if a string ``this is a log message.\nline 2\nline 3'' is given as the
message, it produces something like the following log entry.

@example
Sep  1 17:30:23 myprogram[441]: this is a log message
Sep  1 17:30:23 myprogram[441]: line 2
Sep  1 17:30:23 myprogram[441]: line 3
@end example

@end defivar

@defivar {<log-drain>} program-name
Specifies the program name written by @code{~P} directive of
the prefix slot.
@end defivar
@end deftp


@defun log-open path &keyword prefix program-name
Sets the destination of the default log message to the path @var{path}.
It can be a string or a boolean, as described above.
You can also set prefix and program name by corresponding keyword 
arguments.

Despite its name, this function doesn't open the specified file
immediately.  The file is opened and closed every time @code{log-format}
is called.
@end defun

@deffn {Method} log-format (format <string>) arg @dots{}
@deffnx {Method} log-format (drain <log-drain>) (format <string>) arg @dots{}
Formats a log message by @var{format} and @var{arg @dots{}}, by using
@code{format} (@xref{Output}).    In the first form, the output goes
to the default destination.  In the second form, the output goes to
the specfied drain.

The file is opened and closed every time.  You can safely move
the log file while your program that touches the log file is running.
Also @code{log-format} acquires a write lock of the log file by
@code{sys-fcntl} (@xref{Low-level file operations}).
@end deffn

@c ----------------------------------------------------------------------
@node Networking, Parsing command-line options, User-level logging, Library modules
@section @code{gauche.net} - Networking
@c NODE ネットワーキング, @code{gauche.net} - ネットワーキング

@deftp {Module} gauche.net
@mdindex gauche.net
Provides a set of functions necessary for network communications
based on BSD socket interface.

The API is provided in two different levels.  Lower level routines
reflect traditional BSD socket interface, such as @code{bind(2)}.
Higher level routines provides more convenient way to create
typical connection-oriented server/client sockets.

This module also provides APIs to obtain various information
about hostnames, service ports, and protocols.
@end deftp


@menu
* Socket address::              
* High-level functions::        
* Low-level socket interface::  
* Netdb interface::             
@end menu

@node Socket address, High-level functions, Networking, Networking
@subsection Socket address

@deftp {Builtin Class} <sockaddr>
@clindex sockaddr
An abstract base class of socket addresses.  Each socket address family
is implemented as a subclass of this class.

Although socket addresses are built-in classes, you can use
@code{make} method to create an instance of a
specific socket address family.
@end deftp

@deffn {Generic Function} sockaddr-family addr
Returns a symbol that indicates the family of the socket address
@var{addr}.
@end deffn

@deffn {Generic Function} sockaddr-name addr
Returns a string which represents the content of the socket address
@var{addr}.
@end deffn

@deftp {Builtin Class} <sockaddr-in>
@clindex sockaddr-in
AF_INET family socket address.  To create an instance of this class,
use @code{make} method as follows:
@example
(make <sockaddr-in> :host @var{host} :port @var{port})
@end example
@var{host} can be a string, or one of the keywords
@code{:any}, @code{:broadcast}, @code{:none} or @code{:loopback}.
If it is a string, it is either a host name or a dotted IP notation.
Gauche uses @code{gethostbyname(3)} to obtain the actual IP address from
@var{host} parameter.  If it is a keyword @code{:any}, 
or @code{:broadcast}, the address
uses @code{INADDR_ANY}, or @code{INADDR_BROADCAST}
respectively.  The keyword @code{:loopback} is a synonym to the
IPv4 loopback address "127.0.0.1".

@var{port} must be a positive integer indicating the port number.
@end deftp

@deffn {Method} sockaddr-family (addr <sockaddr-in>)
Returns a symbol @code{inet}.
@end deffn

@deffn {Method} sockaddr-name (addr <sockaddr-in>)
Returns a string in the form "@var{a}.@var{b}.@var{c}.@var{d}:@var{port}",
 where "@var{a}.@var{b}.@var{c}.@var{d}" is dotted decimal notion of
the IP address and @var{port} is the port number.
@end deffn

@deftp {Builtin Class} <sockaddr-un>
@clindex sockaddr-un
AF_UNIX family socket address.  To create an instance of this class,
use @code{make} method as follows:
@example
(make <sockaddr-un> :path @var{path})
@end example
@var{path} must be a string specifying pathname of the socket.
@end deftp

@deffn {Method} sockaddr-family (addr <sockaddr-un>)
Returns a symbol @code{unix}.
@end deffn

@deffn {Method} sockaddr-name (addr <sockaddr-un>)
Returns a pathname of the socket address.
@end deffn


@node High-level functions, Low-level socket interface, Socket address, Networking
@subsection High-level functions

@deftp {Builtin Class} <socket>
@clindex socket
Abstracts a socket, a communication endpoint.

For a connection-oriented socket, you can access the communication
channel by two ports associated to the socket, one for input and
another for output.  @code{socket-input-port} and @code{socket-output-port}
returns those ports, respectively.
@end deftp

The following two functions are convenient ways to create
a connection-oriented socket.  Those functions
are to provide an easy methods for typical cases,
but have less control.  If you need more than these functions
provide, use low-level interface.

@defun make-client-socket &optional address-spec @dots{}
Creates and returns a client socket, connected to the address
specified by @var{address-spec} @dots{}.

@table @code
@item (make-client-socket 'unix @var{path})
The client socket is connected to the unix domain server socket
of addreess @var{path}.
@item (make-client-socket 'inet @var{host} @var{port})
The client socket is connected to the inet domain server socket
with hostname @var{host} and port @var{port}.   TCP protocol is
assumed.   @var{host} can be either a dotted decimal notation of
IPv4 address, or a hostname.  @var{port} must be an exact integer.
@item (make-client-socket @var{host} @var{port})
This works the same as above.  This form is for compatibility with STk.
@end table

This function raises an error if it cannot create a socket,
or cannot connect to the specified address.

@example
(make-client-socket 'inet "www.w3.com" 80)
  @result{} ;@r{a socket connected to www.w3.com, port 80}
(make-client-socket "127.0.0.1" 23)
  @result{} ;@r{a socket connected to localhost, port 23}
(make-client-socket 'unix "/tmp/.sock"
  @result{} ;@r{a socket connected to a unix domain socket "/tmp/.sock"}
@end example
@end defun

@defun make-server-socket &optional address-spec @dots{}
Creates and returns a server socket, listening the address
specified by @var{address-spec}.

@table @code
@item (make-server-socket 'unix @var{path})
The socket is bound to a unix domain socket with a name @var{path}.
@item (make-server-socket 'inet @var{port} [:reuse-addr? @var{flag}])
The socket is bound to an inet domain TCP socket, listening
port @var{port}, which is a positive exact integer.
If a keyword argument @var{reuse-addr?} is given and true,
@code{so_reuseaddr} option is set to the socket before bound to
the port.  This allows the process to bind the server socket
immediately after other process releases the port.
@item (make-server-socket @var{port} [:reuse-addr? @var{flag}])
This is a synonym to the above form.  This form is backward-compatible
with STk's @code{make-server-socket}.
@end table

@example
(make-server-socket 'inet 8080)
  @result{} ;@r{a TCP socket listening port 8080}
(make-server-socket 8080)
  @result{} ;@r{a TCP socket listening port 8080}
(make-server-socket 'unix "/tmp/.sock")
  @result{} ;@r{a socket listening unix socket /tmp/.sock}
@end example
@end defun

Several accessors are available on the returned socket object.

@defun socket-address socket
Returns a socket address associated with @var{socket}.
If no address has been associated to the socket, @code{#f} is returned.
@end defun

@defun socket-input-port socket &keyword (buffered? #t)
Returns an input port associated with @var{socket}.
The port can be used to receive information from the remote process
connected to the socket.

If the keyword argument @var{buffered?} is given and false,
the input port is created as an unbuffered input port
(i.e. it uses @code{read(2)}, instead of @code{fread(3)} family, to 
read from the socket).
@end defun

@defun socket-output-port socket &keyword (buffered? #t)
Returns an output port associated with @var{socket}.
The port can be used to send information to the remote process
connected to the socket.

If the keyword argument @var{buffered?} is given and false,
the output port is created as an unbuffered output port
(i.e. it uses @code{write(2)}, instead of @code{fwrite(3)} family, to 
write to the socket).
@end defun

@defun socket-close socket
Closes @var{socket}.  All the ports associated to
@var{socket} are closed as well.   If the socket is connected,
it is shut down before closing.
@end defun

@defun call-with-client-socket socket proc
@var{socket} is a connected client socket.  @var{proc} is called
with two arguments, an input port that reads from the socket
and an output port that writes to the socket.
The socket is closed after @var{proc} returns or @var{proc}
raises an error.
@end defun

This is an example of usage of high-level socket functions,
a very simple www client.

@example
#!/usr/bin/env gosh
(use gauche.regexp)
(use gauche.net)

(define (usage)
  (display "Usage: swget url\n" (current-error-port))
  (exit 1))

;; Returns three values: host, port, and path.
(define (parse-url url)
  (rxmatch-let (rxmatch #/^http:\/\/([-A-Za-z\d.]+)(:(\d+))?(\/.*)?/ url)
      (#f host #f port path)
    (values host port path)))

(define (get url)
  (receive (host port path) (parse-url url)
    (call-with-client-socket
        (make-client-socket 'inet host (string->number (or port "80")))
      (lambda (in out)
        (format out "GET ~a HTTP/1.0\r\n" path)
        (format out "host: ~a\r\n\r\n" host)
        (flush out)
        (copy-port in (current-output-port))))))

(define (main args)
  (if (= (length args) 2)
      (get (cadr args))
      (usage))
  0)
@end example


@node Low-level socket interface, Netdb interface, High-level functions, Networking
@subsection Low-level socket interface

These functions provide APIs similar to the system calls.
Those who are familiar to programming with socket APIs will
find these functions useful since you can have more detailed control over
the sockets.

@defun make-socket domain type &optional protocol
Returns a socket with specified parameters.
@end defun

@defvar PF_UNIX
@defvarx PF_INET
These variables are bound to @code{PF_UNIX} and @code{PF_INET}.
@end defvar

@defvar AF_UNIX
@defvarx AF_INET
These variables are bound to @code{AF_UNIX} and @code{AF_INET}.
@end defvar

@defvar SOCK_STREAM
@defvarx SOCK_DGRAM
@defvarx SOCK_RAW
These variables are bound to @code{SOCK_STREAM}, @code{SOCK_DGRAM}
and @code{SOCK_RAW}.
@end defvar

@defun socket-fd socket
Returns an integer system file descriptor of the underlying socket.
@end defun


@defun socket-status socket
Returns a internal status of @var{socket}, by one of the following
symbols.
@multitable {aaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item none
@tab The socket is just created.
@item bound
@tab The socket is bound to an address by @code{socket-bind}
@item listening
@tab The socket is listening a connection by @code{socket-listen}
@item connected 
@tab The socket is connected by @code{socket-connect} or @code{socket-accept}.
@item shutdown
@tab The socket is shutdown by @code{socket-shutdown}
@item closed
@tab The socket is closed by @code{socket-close}.
@end multitable
@end defun

@defun socket-bind socket address
Binds @var{socket} to the local network address @var{address}.
It is usually used to associate specific address to the server port.
If binding failed, an error is signalled (most likely the address is
already in use).
@end defun

@defun socket-listen socket backlog
Listens @var{socket}.  The socket must be already bound to some
address.  @var{backlog} specifies maximum number of connection
requests to be queued.
@end defun

@defun socket-accept socket
Accepts a connection request coming to @var{socket}.
Returns a new socket that is connected to the remote entity.
The original @var{socket} keeps waiting for further connections.
If there's no connection requests, this call waits for one to come.

You can use @code{sys-select} to check if there's a pending connection
request.
@end defun

@defun socket-connect socket address
Connects @var{socket} to the remote address @var{address}.
This is the way for a client socket to connect to the remote entity.
@end defun

@defun socket-shutdown socket how
Shuts down connection of @var{socket}.  If @var{how} is 0, the receive
channel of @var{socket} is disallowed.  If @var{how} is 1, the send
channel of @var{socket} is disallowed.  If @var{how} is 2, both
receive and send channels are disallowed.
It is an error to call this function on a non-connected socket.

If you shut down the send channel of the socket, the remote peer
sees EOF from its receive channel.  This is useful if the remote peer
expects EOF before sending something back to you.

Other than this kind of special cases, you don't usually need to
call @code{socket-shutdown} explicitly; @code{socket-close} calls it anyway.
@end defun

Further control over sockets and protocol layers is possible
by getsockopt/setsockopt interface, as described below.

@defun socket-setsockopt socket level option value
@defunx socket-getsockopt socket level option rsize
These are the interface to setsockopt() and getsockopt() calls.
The interface is a bit clumsy, in order to allow full access to
those low-level calls.

@var{socket} must be a non-closed socket object.
@var{level} and @var{option} is an exact integer to specify
the level of protocol stack and the option you want to deal with.
There are several variables pre-bound to system constants listed below.

To set the socket option, you can pass either an exact integer or
a string to @var{value}.  If it is an integer, the value is passed
to setsockopt(2) as C @code{int} value.  If it is a string, the
byte sequence is passed as is.  The required type of value depends on
the option, and Gauche can't know if the value you passed is expected
by setsockopt(2); it is your responsibility to pass the correct values.

To get the socket option, you need to tell the maximum length of expected
result by @var{rsize} parameter, for Gauche doesn't know the amount
of data each option returns.
@code{socket-getsockopt} returns the option value as a byte string.
If you know the option value is an integer, you can pass 0 to @var{rsize};
in that case @code{socket-getsockopt} returns the value as an exact integer.

Note about the name: I tempted to name these function socket-@{set|get@}opt
or socket-@{set|get@}-option,
but I rather took the naming consistency.  Hence duplicated "sock"s.

@end defun

The following predefined variables are provided.
Note that some of them are not available on all platforms.
See manpages @code{socket(7)}, @code{tcp(7)} or @code{ip(7)} of
your system to find out exact specification of those values.

For ``level'' argument:
@defvar SOL_SOCKET
@defvarx SOL_TCP
@defvarx SOL_IP
These variables are bound to @code{SOL_SOCKET}, @code{SOL_TCP} and
@code{SOL_IP}, respectively.
@end defvar

For ``option'' argument:
@defvar SO_KEEPALIVE
Expects integer value.  If it is not zero, enables sending  of
keep-alive messages on connection-oriented sockets.
@end defvar

@defvar SO_OOBINLINE
Expects integer value.  If it is not zero, out-of-band data is
directly placed into the receive data stream.  Oth-A$)B
erwise  out-of-band  data  is  only passed when the
MSG_OOB flag is set during receiving.
@end defvar

@defvar SO_REUSEADDR
Expects integer value.  If it is not zero, @code{socket-bind}
allows to reuse local addresses, unless an active listening
socket bound to the address.
@end defvar

@defvar SO_TYPE
Gets the socket type as an integer (like @code{sock_stream}).
Can be only used with @code{socket-getsockopt}.
@end defvar

@defvar SO_BROADCAST
Expects integer value.  If it is not zero, datagram sockets
are allowed to send/receive broadcast packets.
@end defvar

@defvar SO_PRIORITY
Expects integer value, specifying the protocol-defined priority
for all packets to be sent on this socket.
@end defvar

@defvar SO_ERROR
Gets and clears the pending socket error as an integer.
Can be only used with @code{socket-getsockopt}.
@end defvar

@node Netdb interface,  , Low-level socket interface, Networking
@subsection  Netdb interface

@deftp {Builtin Class} <sys-hostent>
@clindex sys-hostent
A class of objects for network hosts.  Corresponding to
@code{struct hostent}.  The following slots are available read-only.

@defivar {<sys-hostent>} name
The formal name of the host (string).
@end defivar
@defivar {<sys-hostent>} aliases
A list of alias names of the host (list of strings).
@end defivar
@defivar {<sys-hostent>} addresses
A list of addresses (list of strings).  Only ipv4 address is 
supported currently.  Each address is represented by dotted decimal
notation.
@end defivar
@end deftp

@defun sys-gethostbyname name
Looks up a host named @var{name}.
If found, returns a @code{<sys-hostent>} object.
Otherwise, returns @code{#f}.
@example
(let ((host (sys-gethostbyname "www.w3c.org")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'addresses)))
  @result{} ("www.w3.org" ("www.w3c.org") ("18.29.1.34" "18.29.1.35"))
@end example
@end defun

@defun sys-gethostbyaddr addr proto
Looks up a host that has an address @var{addr} of protocol @var{proto}.
@var{addr} is a natural string representation of the address;
for ipv4, it is a dotted decimal notation.  @var{proto} is a
protocol number; only @code{AF_INET} is supported currently.
If the host is found, returns a @code{<sys-hostent>} object.
Otherwise, returns @code{#f}.
@example
(let ((host (sys-gethostbyaddr "127.0.0.1" AF_INET)))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'addresses))
  @result{} ("localhost" ("localhost.localdomain") ("127.0.0.1"))
@end example
@end defun

@deftp {Builtin Class} <sys-servent>
@clindex sys-servent
An entry of the network service database.  Corresponding to
@code{struct servent}.  The following slots are available read-only.

@defivar {<sys-servent>} name
The formal name of the service (string).
@end defivar
@defivar {<sys-servent>} aliases
A list of alias names of the service (list of strings).
@end defivar
@defivar {<sys-servent>} port
A port number registered for this service (exact integer).
@end defivar
@defivar {<sys-servent>} proto
A protocol name for this service (string).
@end defivar
@end deftp

@defun sys-getservbyname name proto
Looks up the network service database with a service name @var{name} and
a protocol @var{proto}.  Both @var{name} and @var{proto} must be a string.
If a service is found, an instance of @code{<sys-servent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((serv (sys-getservbyname "http" "tcp")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'port)
        (slot-ref host 'proto)))
  @result{} ("http" () 80 "tcp")
@end example
@end defun

@defun sys-getservbyport port proto
Looks up the network service database with a service port @var{port} and
a protocol @var{proto}.  @var{port} must be an exact integer, and
@var{proto} must be a string.
If a service is found, an instance of @code{<sys-servent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((serv (sys-getservbyport 6000 "tcp")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'port)
        (slot-ref host 'proto)))
  @result{} ("x-server" () 6000 "tcp")
@end example
@end defun

@deftp {Builtin Class} <sys-protoent>
@clindex sys-protoent
An entry of the protocol database.   Corresponds to @code{struct protoent}
in C.   The following slots are available read-only.

@defivar {<sys-servent>} name
The formal name of the protocol (string).
@end defivar
@defivar {<sys-servent>} aliases
A list of alias names of the protocol (list of strings).
@end defivar
@defivar {<sys-servent>} proto
A protocol number (exact integer).
@end defivar
@end deftp

@defun sys-getprotobyname name
Looks up the network protocol database with a name @var{name},
which must be a string.
If a protocol is found, an instance of @code{<sys-protoent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((proto (sys-getprotobyname "icmp")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'proto)))
  @result{} ("icmp" ("ICMP") 1)
@end example
@end defun

@defun sys-getprotobynumber number
Looks up the network protoice database with a protocol number @var{number},
which must be an exact integer.
If a protocol is found, an instance of @code{<sys-protoent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((proto (sys-getprotobynumber 17)))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'proto)))
  @result{} ("udp" ("UDP") 17)
@end example
@end defun

@c ----------------------------------------------------------------------
@node Parsing command-line options, High Level Process Interface, Networking, Library modules
@section @code{gauche.parseopt} - Parsing command-line options
@c NODE コマンドライン引数の解析, @code{gauche.parseopt} - コマンドライン引数の解析

@deftp {Module} gauche.parseopt
@mdindex gauche.parseopt
This module defines a convenient way to parse command-line options.
The interface is hinted by Perl, and conveniently handles long-format
options with mutiple option arguments.

Note that you can also use the standard @code{getopt} interface by SLIB,
if you prefer.
@end deftp

@defmac parse-options args (option-clause @dots{})
@var{args} is an expression that contains a list of command-line arguments.
This macro scans the command-line options (an argument that begins with
`@code{-}') and processes it as specified in @var{option-clause}s, then
returns the remaining arguments.

Unlike typical @code{getopt} or @code{getopt_long} implementation in C,
@code{parse-options} does not permute the given command-line arguments.
It stops parsing when it encounters a non-option argument (argument without
starting with a minus sign).

If the parser encounters an argument with only two minus signs `@code{--}',
it stops argument parsing and returns a list of arguments after `@code{--}'.

Each @var{option-clause} is consisted by a pair of @var{option-spec}
and its action.

@var{option-spec} is a string that specifies the name of the option and
how the option takes the arguments.  An alphanumeric characters, underscore,
plus and minus sign is allowed for option's names, except that
minus sign can't be the first character, i.e. the valid option name
matches a regexp @code{#/[\w_+][-\w_+]*/}.
If the option takes argument(s), it can be specified by attaching 
equal character and the type of the argument after the name.  The option
can take more than one arguments.

@table @code
@item "@var{name}"
Specifies option @var{name}, that doesn't take any argument.

@item "@var{name}=s"
Option @var{name} takes one argument, and it is passed as a string.

@item "@var{name}=i"
Option @var{name} takes one argument, and it is passed as an exact integer.
If the given argument is not valid string for an exact integer,
an error is signalled.

@item "@var{name}=f"
Option @var{name} takes one argument, and it is passed as a real number.
If the given argument is not valid string for a real number,
an error is signalled.

@item "@var{name}=ss"
Option @var{name} takes two arguments, both string.

@item "@var{name}=iii"
Option @var{name} takes three integer arguments.

@item "@var{name}=sf"
Option @var{name} takes two arguments, the first is a string and the
second is a number.
@end table

In the command line, the option may appear with preceding
single or double minus signs.  The option's argument may be comibined
by the option itself with an equal sign.  For example, all the following
command line arguments match an option spec @code{"prefix=s"}.
@example
-prefix /home/shiro
-prefix=/home/shiro
--prefix /home/shiro
--prefix=/home/shiro
@end example

If a given command-line option matches one of @var{option-spec}, then
the associated action is evaluated.  An action can be one of the
following forms.

@table @code
@item @var{bind-spec} @var{body} @dots{}
@var{bind-spec} is a proper or dotted list of variables like lambda-list.
The option's arguments are bound to @var{bind-spec}, then
then @var{body} @dots{} is evaluated. 

@item => @var{proc}
If a command-line option matches @var{option-spec}, calls a procedure
@var{proc} with a list of the option's arguments.
@end table

Examples:
@example
(parse-options '("-file" "foo")
  (("file=s" (file)
     (format #t "file is ~s\n"))))
 @result{} ;@r{``@code{file is "foo"}'' is printed}

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" (xscale yscale)
     (format #t "scale is ~sx~s\n" xscale yscale)
 @result{} ;@r{``@code{scale is 1.5x2.2}'' is printed}

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" scales
     (format #t "scale is ~s\n" scales))))
 @result{} ;@r{``@code{scale is (1.5 2.2)}'' is printed}

(define (scales x y)
  (format #t "scale is ~sx~s\n" x y))

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" => scales)))
 @result{} ;@r{``@code{scale is 1.5x2.2}'' is printed}
@end example

If a symbol @code{else} is at the position of @var{option-spec},
the clause is selected when no other option clause matches a given
command-line option.  Three ``arguments'' are associated to
the clause; the unmatched option, the rest of arguments, and
a procedure that represents the option parser.

@example
(parse-options args
  (("file=s" => process-file)
   (else (option . _)  (error "unrecognized option:" option))))
@end example

Unlike other clause, the else clause returns to the caller of
@code{parse-options}, without looping further.  In order to
continue looping, you have to call the third argument of the else
clause with the remaining arguments.  This can be used
to implement your own sub-parser.  The following example
just skips unrecognized option, with printing a warning,
and continues parsing:

@example
(parse-options args
  (("file=s" => process-file)
   (else (option args continue)
     (format #t "warning: ignoring unrecognized option: ~a" option)
     (continue args))))
@end example

@end defmac

@defmac make-option-parser (option-clause @dots{})
This is a lower-level interface.  @var{option-clause}s are the
same as @code{parse-options}.  This macro returns a procedure
that can be used later to parse the command line options.

The returned procedure takes one required argument and one
optional argument.  The required argument is a list of strings,
for given command-line arguments.  The optional argument may
be a procedure that takes more than three arguments, and if given,
the procedure is used as if it is the body of @code{else} option clause.
@end defmac

@c ----------------------------------------------------------------------
@node High Level Process Interface, Regular expression utilities, Parsing command-line options, Library modules
@section @code{gauche.process} - High Level Process Interface
@c NODE 高レベルプロセスインタフェース, @code{gauche.process} - 高レベルプロセスインタフェース

@deftp {Module} gauche.process
@mdindex gauche.process
This module provides a higher-level API of Unix process control,
implemented on top of low-level system calls such as @code{sys-fork}
and @code{sys-exec}.  The interface is mostly compatible with
STk's process library.  This module also provides ``process ports'', 
a convenient way to send/receive information to/from subprocesses.

To use this module, say @code{(use gauche.process)}.
@end deftp

@menu
* Process object::              
* Process ports::               
@end menu

@node Process object, Process ports, High Level Process Interface, High Level Process Interface
@subsection Process object

@deftp {Class} <process>
@clindex process
An object to keep the status of a child process.  You can create
the process object by @code{run-process} procedure described below.
@end deftp

@defun run-process command arg @dots{}
Run @var{command} with @var{arg} in a subprocess, and returns a
@code{<process>} object.   @var{command} is searched from the
command search path.

Command line arguments @var{arg}s can include the following keyword
arguments which specify special handling of the child process:
@table @code
@item :input @var{file}
@itemx :output @var{file}
@itemx :error @var{file}
These arguments controls the subprocess' standard i/o.
@var{file} may be either a string or a keyword @code{:pipe}.
If it is a string, the process' standard input, output, or error goes
to the named file.   If it is @code{:pipe}, the process'
corresponding standard i/o is connected to a pipe, 
and the other side of the pipe is available for the calling process.

@item :wait @var{flag}
If @var{flag} is true, @code{run-process} waits until the
subprocess terminates.  Othewise the subprocess runs asynchronously
and @code{run-process} returns immediately, which is the default behavior.
Note that if the subprocess is running asynchronously, it is the
caller's responsibility to call @code{process-wait} at certain
timing to correct its exit status.

@item :fork @var{flag}
If @var{flag} is true, @code{run-process} forks to run
the subprocess, which is the default behavior.  If @var{flag} is
false, @code{run-process} directly calls @code{sys-exec}, so
it never returns.
@end table

@end defun

@defun process? obj
@equiv{} @code{(is-a? @var{obj} <process>)}
@end defun

@deffn {Method} process-pid (process <process>)
Returns the process ID of the subprocess @var{process}.
@end deffn

@deffn {Method} process-command (process <process>)
Returns the command invoked in the subprocess @var{process}.
@end deffn

@deffn {Method} process-input (process <process>)
@deffnx {Method} process-output (process <process>)
@deffnx {Method} process-error (process <process>)
If the process' standard input, output or error is connected to
a pipe, returns another end of the pipe, i.e. @code{process-input}
returns an output port that can feed data to @var{process}' stdin,
@code{process-output} an input port that can read data from
@var{process}' stdout, and @code{process-error} an input port that
can read data from @code{process}' stderr.
If the corresponding i/o is not connected to the pipe,
the function returns @code{#f}.

@example
(let* ((process (run-process "date" :output :pipe))
       (line (read-line (process-output process))))
  (process-wait process)
  line)
 @result{} "Fri Jun 22 22:22:22 HST 2001"
@end example
@end deffn

@defun process-alive? process
Returns true if @var{process} is alive.  Note that Gauche can't
know the subprocess' status until it is explicitly checked by
@code{process-wait}.
@end defun

@defun process-list
Returns a list of active processes.  The process remains active
until its exit status is explicitly collected by @code{process-wait}.
@end defun

@defun process-wait process
Obtains exit status of the subprocess @var{process}.
This suspends execution until @var{process} exits.
@end defun

@defun process-send-signal process signal
Sends a signal @var{signal} to the subprocess @var{process}.
@var{signal} must be an exact integer for signal number.
@xref{Signal}, for predefined variables of signals.
@end defun

@defun process-kill process
@defunx process-stop process
@defunx process-continue process
Sends SIGKILL, SIGSTOP and SIGCONT to @var{process}, respectively.
@end defun

@node Process ports,  , Process object, High Level Process Interface
@subsection Process ports

@defun open-input-process-port command
Runs @var{command} via @code{/bin/sh} asynchronously.
An input port is returned, which is connected to the
stdout of @var{command}.   The stdin and stderr of @var{command}
is redirected from/to @code{/dev/null}.  If you need to get
an error output, you can use shell's redirection.
@example
(define port (open-input-process-port "ls -l Makefile"))
(read-line port)
 @result{} "-rw-r--r--   1 shiro    users        1013 Jun 22 21:09 Makefile"

(open-input-process-port "command 2>&1")
 @result{} ;@r{the port reads both stdout and stderr}

(open-input-process-port "command 2>&1 1>/dev/null")
 @result{} ;@r{the port reads stderr}
@end example
Metacharacters are interpreted by shell.
You have to be careful if you pass the string provided from
the outside world, for it may make a security flaw.

The exit status of subprocess is not automatically collected.
It is the caller's responsibility to issue @code{process-wait},
or the subprocess remains in a zombie state.  If it bothers you,
you can use one of the following functions.
@end defun

@defun call-with-input-process command proc
Runs @var{command} via @code{/bin/sh} and pipes its stdout
to an input port, then call @var{proc} with the port as an argument.
When @var{proc} returns, it collects its exit status,
then returns the result @var{proc} returned.
The cleanup is done even if @var{proc} raises an error.
@example
(call-with-input-process "ls -l *"
  (lambda (p) (read-line p)))
@end example
@end defun

@defun with-input-from-process command thunk
Runs @var{command} via @code{/bin/sh}, and calls @var{thunk}
with its current input port connected to the command's stdout.
The command is terminated and its exit status is collected
when @var{thunk} returns, or it raises an error.
@example
(with-input-from-process "ls -l *" read-line)
@end example
@end defun

@defun open-output-process-port command
Runs @code{command} via @code{/bin/sh}, and returns an output
port which is connected to the stdin of the command.
The stdout and stderr of the command is redirected to @var{/dev/null}.

The exit status of the subprocess is not automatically collected.
The caller should call @code{process-wait} on the subprocess
at appropriate time.
@end defun

@defun call-with-output-process command proc
Runs @code{command} via @code{/bin/sh}, and calls @var{proc} 
with an output port which is conected to the stdin of the command.
The exit status of the command is collected after @var{proc}
returns, or it raises an error.

@example
(call-with-output-process "/usr/sbin/sendmail"
  (lambda (out) (display mail-body out)))
@end example
@end defun

@defun with-output-to-process command thunk
Same as @code{call-with-output-process}, except that the
output port which is connected to the stdin of the command
is set to the current output port while executing @var{thunk}.
@end defun

@defun call-with-process-io command proc
Runs @var{command} via @code{/bin/sh}, and calls @var{proc}
with two arguments; the first argument is an input port which
is connected to the command's stdout, and the second is an output
port connected to the command's stdin.  The error output from
the command is redirected to @code{/dev/null}.

The exit status of the command is collected when @var{proc}
returns or raises an error.
@end defun

@defun process-output->string command
@defunx process-output->string-list command
Runs @var{command} and collects its output (to stdout) to return them.
@code{process-output->string} concatenates all the output from @var{command}
to one string, replacing any sequence of whitespace characters to
single space.   The action is similar to ``command substitution''
in shell scripts.
@code{process-output->string-list} collects the output from
@var{command} line-by-line and returns the list of them.  Newline
characters are stripped.

Internally, @var{command} is run by @code{call-with-input-process}.

@example
(process-output->string "uname -smp")
  @result{} "Linux i686 unknown"

(process-output->string "ls")
  @result{} "a.out foo.c foo.c~ foo.o"

(process-output->string-list "ls")
  @result{} ("a.out" "foo.c" "foo.c~" "foo.o")
@end example

@end defun

@c ----------------------------------------------------------------------
@node Regular expression utilities, Simple dispatcher, High Level Process Interface, Library modules
@section @code{gauche.regexp} - Regular expression utilities
@c NODE 正規表現ユーティリティ, @code{gauche.regexp} - 正規表現ユーティリティ

@deftp {Module} gauche.regexp
@mdindex gauche.regexp
This module defines some macros and utilities useful in regexp match.
See @ref{Regular expression} for builtin regexp features.

As of release 0.4.11, this module is set to be autoloaded in @code{gosh},
so you don't usually need to say @code{(use gauche.regexp)}.

The interface of some of the macros is borrowed from scsh
(@code{if-match}, @code{let-match} and @code{match-cond}),
but I changed the name of
macros since scsh's @code{match-cond} can be confusing
(e.g. Bigloo has @code{match-lambda} and @code{match-case} in
pattern match library, that sounds too similar).
@end deftp

In the following macros, @var{match-expr} is an expression
which produces a match object or @code{#f}. Typically
it is a call of @code{rxmatch}, but it can be any expression.

@defmac rxmatch-let match-expr (var @dots{}) form @dots{}

Evaluates @var{match-expr}, and if matched, binds @var{var @dots{}}
to the matched strings, then evaluates @var{form}s.
The first @var{var} receives the entire match, and subsequent
variables receive submatches.  If the number of submatches are
smaller than the number of variables to receive them, the rest
of variables will get @code{#f}.

It is possible to put @code{#f} in variable position, which says
you don't care that match.

@example
(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (time hh mm ss)
  (list time hh mm ss))
 @result{} ("23:59:58" "23" "59" "58")

(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (#f hh mm)
  (list hh mm))
 @result{} ("23" "59")
@end example

This macro corresponds to scsh's @code{let-match}.
@end defmac

@defmac rxmatch-if match-expr (var @dots{}) then-form else-form
Evaluates @var{match-expr}, and if matched, binds @var{var} @dots{}
to the matched strings and evaluate @var{then-form}.
Otherwise evaluates @var{else-form}.
The rule of binding @var{var}s is the same as @code{rxmatch-let}.

@example
(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11:22:33")
    (time)
  (format #f "time is ~a" time)
  "unknown time)
 @result{} "time is 11:22"

(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11-22-33")
    (time)
  (format #f "time is ~a" time)
  "unknown time)
 @result{} "unknown time"
@end example

This macro corresponds to scsh's @code{if-match}.
@end defmac

@defmac rxmatch-cond clause @dots{}
Evaluate condition in @var{clause}s one by one.
If a condition of a clause satisfies, rest portion of the clause
is evaluated and becomes the result of @code{rxmatch-cond}.
@var{Clause} may be one of the following pattern.

@table @code
@item (@var{match-expr} (@var{var} @dots{}) @var{form} @dots{})
Evaluate @var{match-expr}, which may return a regexp match
object or @code{#f}.  If it returns a match object, the matches
are bound to @var{var}s, like @var{rxmatch-let}, and @var{form}s
are evaluated.

@item (test @var{expr} @var{form} @dots{})
Evaluates @var{expr}.  If it yields true, evaluates @var{form}s.

@item (test @var{expr} => @var{proc})
Evaluates @var{expr} and if it is true,
calls @var{proc} with the result of @var{expr} as the only argument.

@item (else @var{form} @dots{})
If this clause exists, it must be the last clause.
If other clauses fail, @var{form}s are evaluated.
@end table

If no @code{else} clause exists, and no other clause matched the
@var{string-expr}, an undefined value is returned.

@example
;; @r{parses several possible date format}
(define (parse-date str)
  (rxmatch-cond
    ((rxmatch #/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ str)
        (#f mm dd yyyy)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ str)
        (#f yyyy mm dd)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^\d+\/\d+\/\d+$/ str)
        (#f)
     (error "ambiguous: ~s" str))
    (else (error "bogus: ~s" str))))

(parse-date "2001/2/3") @result{} (2001 2 3)
(parse-date "12/25/1999") @result{} (1999 12 25)
@end example

This macro corresponds to scsh's @code{match-cond}.
@end defmac

@defmac rxmatch-case string-expr clause @dots{}
@var{String-expr} is evaluated, and @var{clause}s are interpreted
one by one.  A @var{clause} may be one of the following pattern.

@table @code
@item (@var{re} (@var{var} @dots{}) @var{form} @dots{})
@var{Re} must be either a literal string describing a
regexp, or a regexp object.  If it matches with the result
of @var{string-expr}, the match result is bound to @var{var}s
and @var{form}s are evaluated, and @code{rxmatch-case} returns
the result of the last @var{form}.

If @var{re} doesn't match the result of @var{string-expr},
@var{string-expr} yields non-string value, the interpretation proceeds
to the next clause.

@item (test @var{proc} @var{form} @dots{})
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{form}s are evaluated, and
@code{rxmatch-case} returns the result of the last @var{form}.

If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.

@item (test @var{proc} => @var{proc2})
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{proc2} is applied on the result,
and its result is returned as the result of @code{rxmatch-case}.

If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.

@item (else @var{form} @dots{})
This form must appear at the end of @var{clause}s, if any.
If other clauses fail, @var{form}s are evaluated,
and the result of the last @var{form} becomes the result of
@code{rxmatch-case}.
@end table

If no @code{else} clause exists, and no other clause matched the
@var{string-expr}, an undefined value is returned.

The @code{parse-date} example above becomes simpler if you use
@code{rxmatch-case}
@example
(define (parse-date2 str)
  (rxmatch-case str
    (test (lambda (s) (not (string? s))) #f)
    (#/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ (#f mm dd yyyy)
     (map string->number (list yyyy mm dd)))
    (#/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ (#f yyyy mm dd)
     (map string->number (list yyyy mm dd)))
    (#/^\d+\/\d+\/\d+$/                (#f)
     (error "ambiguous: ~s" str))
    (else (error "bogus: ~s" str))))
@end example
@end defmac


@defun regexp-replace regexp string substitution
@defunx regexp-replace-all regexp string substitution
Replaces the part of @var{string} that matched to @var{regexp}
for @var{substitution}.  @code{regexp-replace} just replaces
the first match of @var{regexp}, while @code{regexp-replace-all}
repeats the replacing throughout entire @var{string}.

@var{substitution} may be a string or a procedure.  If it is a string,
it can contain a digit sequence preceded by a backslash
(e.g. @code{\2}) that refers the submatch.  @code{\0} refers to the
entire match.  Note that you need two backslashes to include
backslash character in the literal string; if you want to include a backslash
character itself in the @var{substitution}, you need four backslashes.

@example
(regexp-replace #/def|DEF/ "abcdefghi" "...")
  @result{} "abc...ghi"
(regexp-replace #/def|DEF/ "abcdefghi" "|\\0|")
  @result{} "abc|def|ghi"
(regexp-replace #/def|DEF/ "abcdefghi" "|\\\\0|")
  @result{} "abc|\\0|ghi"
(regexp-replace #/c(.*)g/ "abcdefghi" "|\\1|")
  @result{} "ab|def|hi"
@end example

If @var{substitution} is a procedure, for every match in @var{string}
it is called with one argument, regexp-match object.  The returned
value from the procedure is inserted to the output string using
@code{display}.

@example
(regexp-replace #/c(.*)g/ "abcdefghi" 
                (lambda (m)
                  (list->string
                   (reverse
                    (string->list (rxmatch-substring m 1))))))
 @result{} "abfedhi"
@end example

@end defun

@c ----------------------------------------------------------------------
@node Simple dispatcher, Sequence framework, Regular expression utilities, Library modules
@section @code{gauche.selector} - Simple dispatcher
@c NODE 簡単なディスパッチャ, @code{gauche.selector} - 簡単なディスパッチャ

@deftp {Module} gauche.selector
@mdindex gauche.selector
This module provides a simple interface to dispatch I/O events to
registered handlers, based on @code{sys-select} (@xref{I/O multiplexing}).
@end deftp

@deftp {Class} <selector>
@clindex selector
A dispatcher instance that keeps watching I/O ports with associated
handlers.  A new instance can be created by @code{make} method.
@end deftp


@deffn {Method} selector-add! (self <selector>) port-or-fd proc flags
Add a handler @var{proc} to the selector.  @var{proc} is called
when @var{port-or-fd}, which should be a port object or an integer
that specifies a system file descriptor,  meets a certain condition
specified by @var{flags}.
@var{flags} must be a list of one or more of the following symbols.
@table @code
@item r
Calls @var{proc} when data is available at @var{port-or-fd} to read.
@item w
Calls @var{proc} when @var{port-or-fd} is ready to be written.
@item x
Calls @var{proc} when an exceptional condition occurs on @var{port-or-fd}.
@end table

@var{proc} is called with two arguments.  The first one is @var{port-or-fd}
itself, and the second one is a symbol @code{r}, @code{w} or @code{x},
indicating the condition.

If a handler is already associated with @var{port-or-fd} under the
same condition, the previous handler is replaced by @var{proc}.
@end deffn

@deffn {Method} selector-delete! (self <selector>) port-or-fd proc flags
Deletes the handler entries that matches @var{port-or-fd}, @var{proc}
and @var{flags}.   One or more of the arguments may be @code{#f},
meaning ``don't care''.  For example,
@example
(selector-delete! selector the-port #f #f)
@end example
deletes all the handlers associated to @var{the-port}, and
@example
(selector-delete! selector #f #f '(w))
@end example
delets all the handlers waiting for writable condition.
@end deffn


@deffn {Method} selector-select (self <selector>) &optional (timeout #f)
Dispatcher body.  Waits for the conditions registered in @var{self},
and when it occurs, calls the associated handler.

If the @var{timeout} argument is omitted or false, this method waits
indefinitely.  Alternatively you can give a timeout value, that can
be a real number in microseconds, or a list of two integers that
represents seconds and microseconds.

Returns the number of handlers called.  Zero means the selector has been
timed out.

It is safe to modify @var{self} inside handler.  The change will be
effective from the next call of @code{selector-select}
@end deffn

This is a simple example of "echo" server:

@example
(use gauche.net)
(use gauche.selector)

(define (echo-server port)
  (let ((selector (make <selector>))
        (server   (make-server-socket 'inet port :reuse-addr? #t)))

    (define (accept-handler sock flag)
      (let* ((client (socket-accept server))
             (output (socket-output-port client)))
        (selector-add! selector
                       (socket-input-port client :buffered? #f)
                       (lambda (input flag)
                         (echo client input output))
                       '(r))))

    (define (echo client input output)
      (let ((str (read-block 4096 input)))
        (if (eof-object? str)
            (begin (selector-delete! selector input #f #f)
                   (socket-close client))
            (begin (display str output)
                   (flush output)))))

    (selector-add! selector
                   (socket-fd server)
                   accept-handler
                   '(r))
    (do () (#f) (selector-select selector))))
@end example

@c ----------------------------------------------------------------------
@node Sequence framework, Singleton, Simple dispatcher, Library modules
@section @code{gauche.sequence} - Sequence framework
@c NODE シーケンスフレームワーク, @code{gauche.sequence} - シーケンスフレームワーク

@deftp {Module} gauche.sequence
@mdindex gauche.sequence
Provides a generic opertaions on @emph{sequences}.  A sequence is
a collection in which elements can be accessed by integer index,
starting with zero.

Since a sequence is also a collection, all the collection generic
operations (@xref{Collection framework}) can be applied to a sequence.
This module defines other operations that are meaningful only for
sequences.

Among Gauche builtin class, lists, vectors and strings are sequences
and the specialized methods are defined for them.   Other extension
types, such as SRFI-4 uniform vector, have the methods as well.
@end deftp

@menu
* Fundamental sequence accessors::  
* Slicing sequence::            
* Implementing sequence::       
@end menu

@node Fundamental sequence accessors, Slicing sequence, Sequence framework, Sequence framework
@subsection Fundamental sequence accessors

@deffn {Generic function} ref (seq <sequence>) index &optional fallback
@example
(ref '(a b c) 1)  @result{} b
(ref '#(a b c) 1) @result{} b
(ref "abc" 1)     @result{} #\b
@end example
@end deffn

@deffn {Generic function} {(setter ref)} (seq <sequence>) index value
@example
(let ((x (list a b c)))
  (set! (ref x 1) 'z)
  x) @result{} (a z c)

(let ((x (vector a b c)))
  (set! (ref x 1) 'z)
  x) @result{} #(a z c)

(let ((x (string #\a #\b #\c)))
  (set! (ref x 1) #\z)
  x) @result{} "azc"
@end example
@end deffn

@deffn {Generic function} referencer (seq <sequence>)
@end deffn

@deffn {Generic function} modifier (seq <sequence>)
@end deffn

@node Slicing sequence, Implementing sequence, Fundamental sequence accessors, Sequence framework
@subsection Slicing sequence

@deffn {Generic function} subseq (seq <sequence>) &optional start end
@example
(subseq '(a b c d e) 1 4)   @result{} (b c d)
(subseq '#(a b c d e) 1 4)  @result{} #(b c d)
(subseq "abcde" 1 4)        @result{} "bcd"
@end example
@end deffn

@node Implementing sequence,  , Slicing sequence, Sequence framework
@subsection Implementing sequence



@c ----------------------------------------------------------------------
@c @node Serializer, Termios, Simple dispatcher, Library modules
@c @section @code{gauche.serializer} - Serializer

@c @deftp {Module} gauche.serializer
@c @mdindex gauche.serializer
@c @end deftp

@c ----------------------------------------------------------------------
@node Singleton, Termios, Sequence framework, Library modules
@section @code{gauche.singleton} - Singleton

@deftp {Module} gauche.singleton
@mdindex gauche.singleton
Provides a metaclass to define a singleton class.
@end deftp

@deftp {Class} <singleton-meta>
@clindex singleton-meta
Creates a singleton class.  A singleton class is a class that is
guaranteed to create only one instance.
The first invocation of @code{make} creates the single instance,
and further attempt of creation returns the same instance.

@example
(define-class single () () :metaclass <singleton-meta>)

(define a (make single))
(define b (make single))

(eq? a b) @result{} #t
@end example

The slots of the instance are initialized at the first invocation
of @code{make}.  Initargs of @code{make} are effective only in the
fist invocation, and ignored in the subsequent invocation.
@end deftp

@deffn {Method} instance-of (class <singleton-meta>) &rest initargs
This method just calls @code{make} with the passed arguments.
It is more obvious in the program that you're dealing with singleton.
@end deffn


@c ----------------------------------------------------------------------
@node Termios, Unit Testing, Singleton, Library modules
@section @code{gauche.termios} - Termios
@c NODE Termios, @code{gauche.termios} - Termios

@deftp {Module} gauche.termios
@mdindex gauche.termios
This module defines POSIX termios interface, which
controls serial ports.
@end deftp

@deftp {Builtin Class} <sys-termios>
@clindex sys-termios
POSIX termios(7) structure.

@defivar {<sys-termios>}  iflag
@end defivar
@defivar {<sys-termios>}  oflag
@end defivar
@defivar {<sys-termios>}  cflag
@end defivar
@defivar {<sys-termios>}  lflag
@end defivar

@end deftp

Throughout this section, argument @var{port-or-fd} refers to
either a port object or a small integer representing system's file 
descriptor.  If @var{port} is not associated
to the system terminal, an error is signalled.  (You can check if @var{port}
has an associated terminal by @code{sys-isatty?}.
@xref{Other file operations}).

@defun sys-tcgetattr port-or-fd
Returns terminal parameters in a @code{<sys-termios>} object,
associated to @var{port-or-fd}.
@end defun

@defun sys-tcsetattr port-or-fd when termios
Sets terminal parameters associated to @var{port-or-fd} by @var{termios},
which must be an instance of @code{<sys-termios>}.

An integer argument @var{when} specifies when the changes take effect.
Three variables are pre-defined for the argument:
@table @code
@item TCSANOW
@vindex TCSANOW 
The change is reflected immediately.
@item TCSADRAIN
@vindex TCSADRAIN
The change is reflected after all pending output is flushed.
@item TCSAFLUSH
@vindex TCSAFLUSH
The change is reflected after all pending output is flushed,
and all pending input is discarded.
@end table
@end defun

@defun sys-tcsendbreak port-or-fd duration
Transmits a zero stream for the specified duration
to the terminal associated to @var{port-or-fd}.
The unit of duration depends on the system; see man tcsendbreak(3) of
your system for details.
@end defun

@defun sys-tcdrain port-or-fd
Waits until all output written to @var{port-or-fd} is transmitted.
@end defun

@defun sys-tcflush port-or-fd queue
Discards data in the buffer of @var{port-or-fd}, specified by 
@var{queue}, which may be one of the following values.
@table @code
@item TCIFLUSH
@vindex TCIFLUSH
Discards data received but not read.
@item TCOFLUSH
@vindex TCOFLUSH
Discards data written but not transmitted.
@item TCIOFLUSH
@vindex TCIOFLUSH
Do both @code{TCIFLUSH} and @code{TCOFLUSH} action.
@end table
@end defun

@defun sys-tcflow port-or-fd action
Controls data flow of @var{port-or-fd} by @var{action}, which may be
one of the following values:
@table @code
@item TCOOFF
@vindex TCOOFF
Suspends output transmission.
@item TCOON
@vindex TCOON
Restarts output transmission.
@item TCIOFF
@vindex TCIOFF
Transmits a STOP character to make the terminal device stop transmitting
data to the system.
@item TCION
@vindex TCION
Transmits a START character to make the terminal device resume transmitting
data to the system.
@end table
@end defun

@defun sys-tcgetpgrp port-or-fd
Returns process group ID of the terminal associated to @var{port-or-fd}.
@end defun

@defun sys-tcsetpgrp port-or-fd pgrp
Sets process group ID of the terminal associated to @var{port-or-fd}
to @var{pgrp}.
@end defun

@defun sys-cfgetispeed termios
@defunx sys-cfsetispeed termios speed
@defunx sys-cfgetospeed termios
@defunx sys-cfsetospeed termios speed
Gets/sets input/output speed (baud rate) parameter stored in @var{termios}
object.   Speed is represented by the following predefined numbers:
@code{B0}, @code{B50}, @code{B75}, @code{B110}, @code{B134}, 
@code{B150}, @code{B200}, @code{B300}, @code{B600}, @code{B1200}, 
@code{B1800}, @code{B2400}, @code{B4800}, @code{B9600},
@code{B19200}, @code{B38400}.
Some system may support higher baud rate, such as @code{B57600},
@code{B115200} or @code{B230400}.  You can use @code{symbol-bound?}
to check these options are defined.  @code{B0} is used to
terminate the connection.
@end defun

The following example shows how to get a password from the user
without echoing:

@example
(use gauche.termios)

(define (get-password prompt)
  (let* ((port (current-input-port))
         (attr (sys-tcgetattr port))
         (lflag (slot-ref attr 'lflag)))
    ;; Show prompt
    (display prompt)
    (flush)
    ;; Turn off echo during reading.
    (dynamic-wind
     (lambda ()
       (slot-set! attr 'lflag (logand lflag (lognot ECHO)))
       (sys-tcsetattr port TCSAFLUSH attr))
     (lambda ()
       (read-line port))
     (lambda ()
       (slot-set! attr 'lflag lflag)
       (sys-tcsetattr port TCSANOW attr)))))
@end example

@c ----------------------------------------------------------------------
@node Unit Testing, Slot with validator, Termios, Library modules
@section @code{gauche.test} - Unit Testing
@c NODE 単体テスト, @code{gauche.test} - 単体テスト

@deftp {Module} gauche.test
@mdindex gauche.test
@c EN
Defines a set of functions to write test scripts.
A test script will look like this:
@lisp
(use gauche.test)
(test-start "my feature")
(load "my-feature")  ; @r{load your program}
(import my-feature)  ; @r{if your program defines a module.}

(test-section "feature group 1")
(test "feature 1-1" EXPECT (lambda () TEST-BODY))
(test "feature 1-2" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-section "feature group 2")
(define test-data ...)
(test "feature 2-1" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-end)
@end lisp
@c JP
テストスクリプトを書くための手続きを提供します。
テストスクリプトは次のような形になります。
@lisp
(use gauche.test)
(test-start "my feature")
(load "my-feature")  ; @r{テストすべきプログラムをロード}
(import my-feature)  ; @r{モジュールを定義している場合はインポート}

(test-section "feature group 1")
(test "feature 1-1" EXPECT (lambda () TEST-BODY))
(test "feature 1-2" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-section "feature group 2")
(define test-data ...)
(test "feature 2-1" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-end)
@end lisp
@c COMMON

@c EN
With this convention, you can run test both interactively or
in batch.   To run a test interactively, just load the file
and it reports a result of each test, as well as the summary
of failed test at the end.  To run a test in batch, it is
convenient to redirect the stdout to some file
If stdout is redirected to other than tty, all the verbose logs will go
there, and only a small amount of messages go to stderr.
@c JP
このテストスクリプトは、バッチ処理でもインタラクティブセッションからでも
実行できます。インタラクティブセッションの場合はこのテストスクリプトを
ただロードすれば、各テストの結果とサマリーが報告されます。
バッチテストの場合は、標準出力を別のファイルにリダイレクトしておくと良いでしょう。
標準出力が端末でない場合、テスト手続きは詳しい結果をstdoutに出力し、簡単な
メッセージを標準エラー出力に書き出します。
@c COMMON

@c EN
It is recommended to have a "test" target always in Makefile
of your module/program, so that the user of your program can run a
test easily.  The rule may look like this:
@c JP
モジュールやプログラムを書いたら、Makefileに"test"ターゲットを作ることを
お薦めします。ルールはこんな感じになるでしょう：
@c COMMON

@example
test :
        gosh my-feature-test.scm > test.log
@end example

@end deftp

@defun test name expected thunk &optional =
@c EN
Calls @var{thunk}, and compares its result with @var{expected}.
The comparison predicate is @code{equal?} by default, but you can
specify your own predicate by the argument @var{=}.
@var{Name} is a name of the test, for logging purpose.
@c JP
@var{thunk}を呼び、その結果を@var{expected}と比較します。
比較手続きには、引数@var{=}が与えられていればそれを用い、そうでなければ@code{equal?}
を用います。@var{name}はログに残すためのテストの名前です。
@c COMMON
@end defun

@defun test-start module-name
@c EN
Initializes internal state and prints a log header.
This should be called before any tests.
@var{Module-name} is used only for logging purpose.
@c JP
テストの状態を初期化して、ヘッダをログに書き出します。テストを呼ぶ前に呼んで下さい。
@var{module-name}はログのために使われる文字列です。
@c COMMON
@end defun

@defun test-section section-name
@c EN
Marks beginning of the group of tests.  This is just for logging.
@c JP
一群のテストの開始をマークします。単にログに使われるだけです。
@c COMMON
@end defun

@defun test-end
@c EN
Prints out list of failed tests.
@c JP
失敗したテストのリストを報告します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Slot with validator, Comparing version numbers, Unit Testing, Library modules
@section @code{gauche.validator} - Slot with validator
@c NODE Validator付きスロット, @code{gauche.validator} - Validator付きスロット

@deftp {Module} gauche.validator
@mdindex gauche.validator
@c EN
Provides a metaclass that adds @code{:validator} slot option.
@c JP
@code{:validator}スロットオプションを追加するメタクラスを提供するモジュールです。
@c COMMON
@end deftp

@deftp {Class} <validator-meta>
@clindex validator-meta
@c EN
This metaclass adds a feature that the class can validate a value
before being set to the slot.   For example, if you want to guarantee
that a certain slot always holds a string value, you can make a procedure
be called before the slot is modified, either by @code{slot-ref} or
by a setter method.  In the procedure you can either rejects a
value except string, or coerce the value to a string.

The validator procedure can be set per each slot by using @code{:validator}
slot option.  The procedure takes two values, the instance and
the value to be set.  Whatever the procedure returns is set to
the actual slot value.
See the following example:
@c JP
このメタクラスは、スロットに対して値がセットされようとする時にその値の正当性を
検査する手続きを指定する機能を提供します。例えば、あるスロットに常に文字列のみが
セットされているようにしたい場合、そのスロットに、@code{slot-ref}経由であれ
アクセサメソッド経由であれ値がセットされようとした時に指定の手続きが呼ばれるように
し、その手続きの中で、値が文字列でなかったらエラーとするか、強制的に値を
文字列に変換してしまうことができます。その手続きが返した値が実際にスロットに
セットされます。

検査手続きは@code{:validator}スロットオプションによってスロット毎に指定できます。
手続きは、インスタンスとセットされようとしている値の二つを引数に取ります。
その手続きが返した値が実際にスロットにセットされる値となります。
下の例を参照して下さい。
@c COMMON

@example
(define-class <v> ()
  ((a :accessor a-of
      :validator (lambda (obj value) (x->string value)))
   (b :accessor b-of
      :validator (lambda (obj value)
                   (if (integer? value)
                       value
                       (error "integer required for slot b")))))
  :metaclass <validator-meta>)

(define v (make <v>))
(slot-set! v 'a 'foo)
(slot-ref v 'a) @result{} "foo"

(set! (a-of v) 1234)
(a-of v) @result{} "1234"

(slot-set! v 'b 55)
(slot-ref v 'b) @result{} 55

(slot-set! v 'b 3.4) @result{} @r{error}
(set! (b-of v) 3.4)  @result{} @r{error}
@end example

@c EN
You can specify default slot value (@code{:init-value} etc.) with
@code{:validator}.  In that case, the initialization method of the
instance calls the validator with the specified default value,
if :init-keyword is not given.
@c JP
@code{:validator} が指定されたスロットにも、@code{:init-value}等を
使って既定の初期値を指定しておくことができます。その場合、インスタンスの初期化ルーチンは、
init-keywordによる初期値指定が無ければ既定の初期値を引数としてvalidator手続きを
呼び出します。
@c COMMON

@example
(define-class <v> ()
  ((a :initform 'foo :init-keyword :a
      :validator (lambda (obj value) (x->string value)))))

(slot-ref (make <v>) 'a)        @result{} "foo"
(slot-ref (make <v> :a 555) 'a) @result{} "555"
@end example

@c EN
It looks similar to the virtual slot, but note that a slot with
validator has an actual storage in the instance, while a virtual
slot doesn't.

It is also a good example of customizing how the slots are accessed
using the metaobject protocol.  This feature is implemented by
only a dozen lines of code.
@c JP
仮想スロットに似ていますが、validatorを持つスロットはインスタンス内に実際に
値を格納している点が異なります。

このモジュールはまた、スロットのアクセスをメタオブジェクトプロトコルを使って
カスタマイズする例でもあります。この機能はほんの12行ほどのコードで実現されています。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node Comparing version numbers, RFC822 Message parsing, Slot with validator, Library modules
@section @code{gauche.version} - Comparing version numbers
@c NODE バージョン番号の比較, @code{gauche.version} - バージョン番号の比較

@deftp {Module} gauche.version
@mdindex gauche.version
@c EN
This module provides a convenient procedure to compare
@emph{version numbers} or @emph{revision numbers},
such as "@code{0.5.1}", "@code{3.2-3}" or "@code{8.2pl1}".
Usually each release of software component has
a version number, and you can define order between them.
For example, version "1.2.3" is newer than "1.2" and
older than "2.1".   You can compare those version numbers like this:
@c JP
このモジュールは、バージョン番号(リリース番号)を比較する便利な手続きを提供します。
ここでのバージョン番号とはソフトウェアのリリースにつけられる
"@code{0.5.1}"、"@code{3.2-3}"、"@code{8.2pl1}"といった文字列で、
通常これらの番号間には順序関係が定義できます。
例えば "1.2.3" は "1.2" より新しいが "2.1" より古い、といった具合です。
以下のようにこれらの文字列の順序を比較することができるようになります。
@c COMMON

@example
(version<? "2.2.3" "2.2.11")     @result{} #t
(version<? "2.3.1" "2.3")        @result{} #f
(version<? "2.3.1-1" "2.3.1-10") @result{} #t
(version<? "13a" "5b")           @result{} #f
@end example

@c EN
There are no standard way to name versions, so I chose
one convention.   This won't work for all possible
variations, but I think it covers typical cases.
@c JP
バージョン番号の付け方には特に標準というものはありませんが、
よく使われている方法を採用しました。全ての場合に使えるとはいきませんが、
大抵の場合はカバーできるのではないかと思います。
@c COMMON

@c EN
Strictly speaking, you can only define partial order between
version numbers, for there can be branches.   This module
uses simple measure and just assumes the version numbers
can be fully ordered.
@c JP
厳密に言えば、分岐などの場合があるのでバージョン番号間の関係は半順序関係にしかなりません。
このモジュールでは単純な定義を使って、全順序関係があるものとして扱います。
@c COMMON

@c EN
The version number here is defined by the following syntax.
@c JP
まず、ここでのバージョン番号は以下の構文に従うものとします。
@c COMMON
@example
 <version> : <principal-release>
           | <version> <post-subrelease>
           | <version> <pre-subrelease>
 <principal-release> : <relnum>
 <post-subrelease>   : [.-] <relnum>
 <pre-subrelease>    : _ <relnum>
 <relnum>            : [0-9A-Za-z]+
@end example

@c EN
Typically @code{<relnum>} is composed by numeric part and extension part.
For example, "23a" is composed by an integer 23 and extension "a".
If @code{<relnum>} doesn't begins with digits, we assume its
numeric part is -1.
@c JP
通常@code{<relnum>}は数字部分と、それに続く省略可能な拡張部分とからなります。
例えば "@code{23a}" は数字部分23と拡張部分"@code{a}"からなります。
もし@code{<relnum>}が数字で始まらない場合、その数字部分は-1であると考えることにします。
@c COMMON

@c EN
Then, the order of @code{<relnum>} is defined as follows:
@c JP
@code{<relnum>}の順序関係を次のように定義します。
@c COMMON
@enumerate
@item
@c EN
If relnum A and relnum B have different numeric part, we ignore the
extension and order them numerically, e.g.  "@code{3b}" < "@code{4a}".
@c JP
relnum Aとrelnum Bが異なる数字部分を持っている場合、拡張部分を無視して
数字部分を数値として比較します。例："@code{3b}" < "@code{4a}"。
@c COMMON
@item
@c EN
If relnum A and relnum B have the same numeric part, we compare
extension by alphabetically, e.g.  "@code{4c}" < "@code{4d}"
and "@code{5}" < "@code{5a}".
@c JP
relnum Aとrelnum Bの数字部分が等しい場合、拡張部分を辞書順に比較します。
例："@code{4c}" < "@code{4d}"、"@code{5}" < "@code{5a}"。
@c COMMON
@end enumerate

@c EN
Given the order of @code{<relnum>}, the order of version numbers
are defined as follows:
@c JP
@code{<relnum>}間の順序が定義できたところで、バージョン番号の順序を次のように定義します。
@c COMMON
@enumerate
@item
Decompose each version number into a list of @code{<principal-release>} and
subsequence subrelease components.   We call each element of
the list "release components".
@item
If the first release component of both lists are the same,
remove it from both.  Repeat this until the head of the lists differ.
@item
Now we have the following cases.
@enumerate
@item
Both lists are empty: versions are the same.
@item
One list (A) is empty and the other list (B) has post-subrelease
at head: A is prior to B
@item
One list (A) is empty and the other list (B) has pre-subrelease
at head: B is prior to A
@item
List A's head is post-subrelease and list B's head is
pre-subrelease: B is prior to A
@item
Both lists have post-subrelease or pre-subrelease at head:
compare their relnums.
@end enumerate
@end enumerate

Here are some examples:
@example
"1" < "1.0" < "1.1" < "1.1.1" < "1.1.2" < "1.2" < "1.11"
"1.2.3" < "1.2.3-1" < "1.2.4"
"1.2.3" < "1.2.3a" < "1.2.3b"
"1.2_rc0" < "1.2_rc1" < "1.2" < "1.2-pl1" < "1.2-pl2"
"1.1-patch112" < "1.2_alpha"
@end example

The reason of having @code{<pre-subrelease>} is to allow
"release candidate" or "pre-release" version.
@end deftp

@defun version=? ver1 ver2
@defunx version<? ver1 ver2
@defunx version<=? ver1 ver2
@defunx version>? ver1 ver2
@defunx version>=? ver1 ver2
Returns a boolean value depending on the order of two version number
string @var{ver1} and @var{ver2}.  If the arguments contain invalid
strings as the defined version number, an error is signalled.
@end defun

@defun version-compare ver1 ver2
Compares two version number strings @var{ver1} and @var{ver2},
and returns either -1, 0, or 1, depending whether @var{ver1} is
prior to @var{ver2}, @var{ver1} is the same as @var{ver2}, or
@var{ver1} is after @var{ver2}, respectively.
@end defun

@defun relnum-compare rel1 rel2
This is lower-level procedure of @code{version-compare}.  Compares
two release numbers (relnums) @var{rel1} and @var{rel2}, 
and returns either -1, 0, or 1 depending whether  @var{rel1} is
prior to @var{rel2}, @var{rel1} is the same as @var{rel2}, or
@var{rel1} is after @var{rel2}, respectively.
@end defun

@c ----------------------------------------------------------------------
@node RFC822 Message parsing, Base64 encoding/decoding, Comparing version numbers, Library modules
@section @code{rfc.822} - RFC822 message parsing
@c NODE RFC822メッセージ形式, @code{rfc.822} - RFC822メッセージ形式

@deftp {Module} rfc.822
@mdindex rfc.822
Defines a set of functions that parses and constructs the ``Internet
Message Format'', a text format used to exchange e-mails.
The most recent specification can be found in
RFC2822 (@ref{rfc2822,[RFC2822],RFC2822}).
The format was originally defined in RFC 822, and people still 
call it ``RFC822 format'', hence I named this module.
In the following document, I also refer to the format as ``RFC822 format''.

Say @code{(use rfc.822)} to use this module.
@end deftp

@defun rfc822-header->list iport &optional strict?
Reads RFC822 format message from an input port @var{iport},
until it reaches the end of the message header.
The header fields are unfolded, and broken into a list of the following
format:
@example
((name body) @dots{})
@end example
@var{Name} @dots{} are the field names, and @var{body} @dots{} are
the corresponding field body, both as strings.
Field names are converted to lower-case characters.
Field bodies are not modified, except the folded line is concatenated,
CRLFs removed.
The order of fields are preserved.
@end defun

@defun rfc822-parse-date string
Takes RFC-822 type date string, and returns eight values:
@example
year, month, day-of-month, hour, minutes, seconds, timezone, day-of-week.
@end example

@emph{Timezone} is an offset from UT in minutes.
@emph{Day-of-week} is a day from sunday,
and may be #f if that information is not available.
If the string is not parsable, all the elements are #f.

Note: This function follows the new definition of date format in RFC2822,
but may fail to recognize "obsolete" format, which allows arbitrary
comments appear between words.
@end defun

@c ----------------------------------------------------------------------
@node Base64 encoding/decoding, HTTP cookie handling, RFC822 Message parsing, Library modules
@section @code{rfc.base64} - Base64 encoding/decoding
@c NODE Base64エンコーディング, @code{rfc.base64} - Base64エンコーディング

@deftp {Module} rfc.base64
@mdindex rfc.base64
This module defines a few functions to encode/decode Base64 format,
defined in RFC 2045 (@ref{rfc2045, [RFC2045], RFC2045}), section 6.3.
@end deftp

@defun base64-encode
Reads byte stream from the current input port, encodes it in Base64
format and writes the result character stream to the current output port.
The conversion ends when it reads EOF from the current input port.
@end defun

@defun base64-encode-string string
Converts contents of @var{string} to Base64 encoded format.
Input string can be either complete or incomplete string;
it is always interpreted as a byte sequence.
@end defun

@defun base64-decode
Reads character stream from the current input port, decodes it from Base64
format and writes the result byte stream to the current output port.
The conversion ends when it reads EOF or the termination character
(@code{=}).  The characters which does not in legal Base64 encoded character
set are silently ignored.
@end defun

@defun base64-decode-string string
Decodes a Base64 encoded string @var{string} and returns
the result as a string.
The conversion terminates at the end of @var{string} or
the termination character (@code{=}).
The characters which does not in legal Base64 encoded character
set are silently ignored.
@end defun

@c ----------------------------------------------------------------------
@node HTTP cookie handling, URI parsing and construction, Base64 encoding/decoding, Library modules
@section @code{rfc.cookie} - HTTP cookie handling
@c NODE HTTPクッキー, @code{rfc.cookie} - HTTPクッキー

@deftp {Module} rfc.cookie
@mdindex rfc.cookie
Defines a set of functions to parse and construct a ``cookie'' information
defined in RFC 2965 (@ref{rfc2965,,RFC2965}).
@end deftp

@defun parse-cookie-string string &optional version
Parse a cookie string @var{string}, which is the value of ``Cookie''
request header.  Usually, the same information is available to CGI
program via the environemnt variable @code{HTTP_COOKIE}.

If the cookie version is known, via ``Cookie2'' request header,
the integer version must be passed to @var{version}.  Otherwise,
@code{parse-cookie} figures out the version from @var{string}.

The result has the following format.
@example
((<name> <value> [:path <path>] [:domain <domain>] [:port <port>])
 @dots{})
@end example
where @var{<name>} is the attribute name, and @var{<value>} is
the corresponding value.  If the attribute doesn't have value,
@var{<value>} is @code{#f}.  (Note that it differs from the attribute
having null value, @code{""}.)
If the attribute has path, domain or port options, it is given
as a form of keyword-value pair.
@end defun

@defun construct-cookie-string specs &optional version
Given list of cookie specs, creates a cookie string suitable for
@code{Set-cookie2} or @code{Set-cookie} header.

Optional @var{version} argument specifies cookie protocol version.
0 for the old Netscape style format, and 1 for RFC2965 style format.
When omitted, version 1 is assumed.

Each cookie spec has the following format.
@example
(<name> <value> [:comment <comment>] [:comment-url <url>]
                [:discard <bool>] [:domain <domain>]
                [:max-age <age>] [:path <path>]
                [:port <port-list>] [:secure <bool>]
                [:version <version>] [:expires <date>])
@end example
Where,
@table @code
@item <name>
A string.  Name of the cookie.
@item <value>
Value of the cookie.  May be a string, or @code{#f} if no value is needed.
@item <comment> <url> <domain> <path> <port-list>
Strings.
@item <bool>
Boolean value
@item <age> <version>
Integers
@item <date>
Either an integer (seconds since Epoch) or a formatted date string
following the netscape cookie specification.
@end table

The attribute values are quoted appropriately.  If the specified attribute
is irrelevant for the @var{version}, it is ignored.  So you can pass
the same specs to generate both old-style and new-style cookie strings.

Return value is a list of cookie strings, each of which stands for
each cookie.  For old-style protocol (using @code{Set-cookie} header)
you must send each of them by individual header.  For new-style
protocol (using @code{Set-cookie2} header), you can join them
with comma and send it at once.  See RFC2965 for further details.

Some examples:
@example
(construct-cookie-string
   '(("name" "foo" :domain "foo.com :path "/"
                   :expires (+ (sys-time) 86400) :max-age 86400)))
 @result{} ("name=foo;Domain=foo.com;Path=/;Max-age=86400")

(construct-cookie-string
   '(("name" "foo" :domain "foo.com :path "/"
                   :expires (+ (sys-time) 86400) :max-age 86400))
   0)
 @result{}
 ("name=foo;Domain=foo.com;Path=/;Expires=Sun, 09-Sep-2001 01:46:40 GMT")
@end example
@end defun

@c ----------------------------------------------------------------------
@node URI parsing and construction, SLIB, HTTP cookie handling, Library modules
@section @code{rfc.uri} - URI parsing and construction
@c NODE URIの解析と作成, @code{rfc.uri} - URIの解析と作成

@deftp {Module} rfc.uri
@mdindex rfc.uri
Provides a set of functions to parse Uniform Resource Identifiers
defined in RFC 2396 (@ref{rfc2396, [RFC2396], RFC2396}).
@end deftp

@defun uri-scheme&specific uri
@defunx uri-decompose-hierarchical specific
@defunx uri-decompose-authority authority
General parser of URI.  These functions does not decode
URI encoding.

@code{uri-scheme&specific} takes a URI @var{uri}, and
returns two values, its scheme part and its scheme-specific part.
If @var{uri} doesn't have a scheme part, @var{#f} is returned for it.
@example
(uri-scheme&specific "mailto:sclaus@@north.pole")
  @result{} "mailto" @r{and} "sclaus@@north.pole"
(uri-scheme&specific "/icons/new.gif")
  @result{} #f @r{and} "/icons/new.gif"
@end example

If the URI scheme uses hierarchical notation, i.e.
``@code{//@var{authority}/@var{path}?@var{query}#@var{fragment}}'',
you can pass
the scheme-specific part to @code{uri-decompose-hierarchical}
and it returns four values, @var{authority}, @var{path}, @var{query}
and @var{fragment}.
@example
(uri-decompose-hierarchical "//www.foo.com/about/company.html")
  @result{} "www.foo.com"@r{,} "/about/company.html"@r{,} #f @r{and} #f
(uri-decompose-hierarchical "//zzz.org/search?key=%3fhelp")
  @result{} "zzz.org"@r{,} "/search"@r{,} "key=%3fhelp" @r{and} #f
(uri-decompose-hierarchical "//jjj.jp/index.html#whatsnew")
  @result{} "jjj.jp"@r{,} "/index.html"@r{,} #f @r{and} "whatsnew"
(uri-decompose-hierarchical "my@@address")
  @result{} #f@r{,} #f@r{,} #f @r{and} #f
@end example

Furthermore, you can parse @var{authority} part of the
hierarchical URI by @code{uri-decompose-authority}.
It returns @var{userinfo}, @var{host} and @var{port}.
@example
(uri-decompose-authority "yyy.jp:8080")
  @result[] #f@r{,} "yyy.jp" @r{and} "8080"
(uri-decompose-authority "mylogin@@yyy.jp")
  @result[] "mylogin"@r{,} "yyy.jp" @r{and} #f
@end example
@end defun

@defun uri-decode &keyword :cgi-decode
@defunx uri-decode-string string &keyword :cgi-decode
Decodes ``URI encoding'', i.e. @code{%}-escapes.
@code{uri-decode} takes input from the current input port,
and writes decoded result to the current output port.
@code{uri-decode-string} takes input from @var{string} and
returns decoded string.

If @var{cgi-decode} is true, also replaces @code{+} to a space character.
@end defun

@defun uri-encode &keyword :noescape
@defunx uri-encode-string string &keyword :noescape
Encodes unsafe characters by @code{%}-escape.  @code{uri-encode}
takes input from the current input port and writes the result to
the current output port.  @code{uri-encode-string} takes input
from @var{string} and returns the encoded string.

By default, characters that are not specified ``unreserved'' in
RFC2396 are escaped.  You can pass different character set
to @var{noescape} argument to keep from being encoded.

The multibyte characters are encoded as the octed stream of Gauche's
native multibyte representation.
@end defun

@c ----------------------------------------------------------------------
@node SLIB, Feature Conditional, URI parsing and construction, Library modules
@section @code{slib} - SLIB interface
@c NODE SLIB, @code{slib} - SLIB

@deftp {Module} slib
@mdindex slib
This module is the interface to the Aubrey Jaffer's SLIB.
To use SLIB, say @code{(use slib)}.   SLIB itself is not included
in Gauche distribution.   If you don't have it on your system,
get it from @uref{http://www-swiss.ai.mit.edu/~jaffer/SLIB.html}.

This module redefines @code{require}, shadowing the Gauche's original
@code{require}.  If it gets a symbol as an argument, it works as
SLIB's @code{require}, while if it gets a string, it works as
Gauche's @code{require}.   The same applies to @code{provide} and
@code{provided?}.

All SLIB symbol bindings, loaded by @code{require}, stay in the
module @code{slib}.
@end deftp

@c ----------------------------------------------------------------------
@node Feature Conditional, List library, SLIB, Library modules
@section @code{srfi-0} - Feature Conditional

@deftp {Module} srfi-0
@mdindex srfi-0
@end deftp

@defmac cond-expand (feature-requirement command-or-definition @dots{}) @dots{}
[SRFI-0]
@end defmac

@c ----------------------------------------------------------------------
@node List library, And-let*, Feature Conditional, Library modules
@section @code{srfi-1} - List library

@deftp {Module} srfi-1
@mdindex srfi-1
SRFI-1 is a rich collection of list manipulation library
(@ref{srfi-1,[SRFI-1],SRFI-1}).
It is available by saying @code{(use srfi-1)}.
The implementation is based on Olin Shivers's reference implementation.
I splitted it into number of subfiles that will be autoloaded on demand.

Detailed specificaion of SRFI-1 is available at
@end deftp

@menu
* SRFI-1 List constructors::    
* SRFI-1 List predicates::      
* SRFI-1 List selectors::       
* SRFI-1 List miscellaneous routines::  
* SRFI-1 Fold::                 
* SRFI-1 Filterling & partitioning::  
* SRFI-1 Searching::            
* SRFI-1 Deletion::             
* SRFI-1 Association lists::    
* SRFI-1 set operations::       
@end menu

@node SRFI-1 List constructors, SRFI-1 List predicates, List library, List library
@subsection List constructors

@defun xcons cd ca
[SRFI-1] Equivalent to @code{(cons ca cd)}.  Useful to pass to
higher-order procedures.
@end defun

@defun cons* elt1 elt2 @dots{}
[SRFI-1] Like @code{list}, but the last argument provides the tail of
the constructed list.  This is just a synonym of Gauche built-in procedure
@code{list*}.
@example
(cons* 1 2 3 4) @result{} (1 2 3 . 4)
(cons* 1) @result{} 1
@end example
@end defun

@defun list-tabulate n init-proc
[SRFI-1] Constructs an @var{n}-element list, in which
each element is generated by @code{(@var{init-proc} @i{i})}.
@example
(list-tabulate 4 values) @result{} (0 1 2 3)
@end example
@end defun

@defun circular-list elt1 elt2 @dots{}
[SRFI-1] Constructs a circular list of the elements.
@example
(circular-list 'z 'q) @result{} (z q z q z q @dots{})
@end example
@end defun

@defun iota count &optional (start 0) (step 1)
[SRFI-1] Returns a list of numbers, starting from @var{start},
increasing by @var{step}.
@example
(iota 5) @result{} (0 1 2 3 4)
(iota 5 0 -0.1) @result{} (0 -0.1 -0.2 -0.3 -0.4)
@end example
@end defun

@node SRFI-1 List predicates, SRFI-1 List selectors, SRFI-1 List constructors, List library
@subsection List predicates

@defun proper-list? x
[SRFI-1] Returns @code{#t} if x is a proper list.
@end defun

@defun circular-list? x
[SRFI-1] Returns @code{#t} if x is a circular list.
@end defun

@defun dotted-list? x
[SRFI-1] Returns @code{#t} if x is a finite, non-nil-terminated list.
This includes non-pair, non-() values (e.g. symbols, numbers),
which are considered to be dotted lists of length 0.
@end defun

@defun null-list? list
[SRFI-1] Returns @code{#t} if @var{list} is the empty list @code{()},
and @var{#f} if @var{list} is a non-null, proper or circular list.
This procedure signals an error if @var{list} is not a proper
or circular list.
@end defun

@defun not-pair? x
[SRFI-1] @code{(lambda (x) (not (pair? x)))}.

SRFI-1 says: Provided as a procedure as it can be useful as
the termination condition for list-processing procedures that wish to
handle all finite lists, both proper and dotted. 
@end defun

@defun list= elt= list @dots{}
[SRFI-1] Determines list equality by comparing every n-th element
of given lists by the procedure @var{elt=}.

It is an error to apply @code{list=} to anything except proper lists.

The equality procedure must be consistent with @code{eq?}, i.e.
@example
(eq? x y) @result{} (elt= x y).
@end example
@end defun

@node SRFI-1 List selectors, SRFI-1 List miscellaneous routines, SRFI-1 List predicates, List library
@subsection List selectors

@defun  first pair
@defunx second pair
@defunx third pair
@defunx fourth pair
@defunx fifth pair
@defunx sixth pair
@defunx seventh pair
@defunx eighth pair
@defunx ninth pair
@defunx tenth pair
[SRFI-1] Returns n-th element of the (maybe improper) list.
@end defun

@defun car+cdr pair
[SRFI-1] Returns two values, @code{(car pair)} and @code{(cdr pair)}.
@end defun

@defun take x i
@defunx drop x i
[SRFI-1] @code{take} returns the first i elements of list x.
@code{drop} returns all but the first i elements of list x. 
@example
(take '(a b c d e)  2) => (a b)
(drop '(a b c d e)  2) => (c d e)
@end example
@var{x} may be any value:
@example
(take '(1 2 3 . d) 2) => (1 2)
(drop '(1 2 3 . d) 2) => (3 . d)
(drop '(1 2 3 . d) 3) => d
@end example
@code{drop} is exactly equivalent to performing @var{i} cdr operations
on @var{x}.  The returned value shares a common tail with @var{x}.
On the other hand, take always allocates a new list 
for result if the argument is a list of non-zero length.
@end defun

@defun take-right flist i
@defunx drop-right flist i
[SRFI-1] @code{take-right} returns the last @var{i} elements of @var{flist}.
@code{drop-right} returns all but the last @var{i} elements of @var{flist}. 
@example
(take-right '(a b c d e) 2) => (d e)
(drop-right '(a b c d e) 2) => (a b c)
@end example
@var{flist} may be any finite list.
@example
(take-right '(1 2 3 . d) 2) => (2 3 . d)
(drop-right '(1 2 3 . d) 2) => (1)
(take-right '(1 2 3 . d) 0) => d
(drop-right '(1 2 3 . d) 0) => (1 2 3)
@end example
@code{take-right}'s return value always shares a common
tail with @var{flist}.
@code{drop-right} always allocates a new list
if the argument is a list of non-zero length.
@end defun

@defun take! x i
@defunx drop-right! x i
[SRFI-1]  Linear update variants of @var{take} and @var{drop-right}.
Those procedures may destructively modifies @var{x}.

If @var{x} is circular, @code{take!} may return a list
shorter than expected.
@end defun

@defun split-at x i
@defunx split-at! x i
[SRFI-1] @code{split-at} splits the list @var{x} at index @var{i},
returning a list of the first @var{i} elements, and the remaining tail.
@example
(split-at '(a b c d e) 2) @result{} (a b) (c d e)
@end example
@code{split-at!} is the linear-update variant. It may destructively
modifes @var{x} to produce the result. 
@end defun

@defun last pair
[SRFI-1] Returns the last element of the non-empty, finite list @var{pair}.
It is equivalent to @code{(car (last-pair pair))}.
Note that @code{last-pair} is Gauche built-in procedure.
@end defun

@node SRFI-1 List miscellaneous routines, SRFI-1 Fold, SRFI-1 List selectors, List library
@subsection List miscellaneous routines

@defun length+ x
[SRFI-1] If @var{x} is a proper list, returns its length.
Otherwise, returns @code{#f}.
@end defun

@defun concatenate list-of-lists
@defunx concatenate! list-of-lists!
[SRFI-1] Equivalent to @code{(apply append @var{list-of-lists})} and
@code{(apply append! @var{list-of-lists})}, respectively.
@end defun

@defun append-reverse rev-head tail
@defunx append-reverse! rev-head tail
[SRFI-1] @code{append-reverse} returns @code{(append (reverse rev-head) tail)}.
@code{append-reverse!} is the linear-update variant.
@end defun

@defun zip clist1 clist2 @dots{}
[SRFI-1] Equivalent to @code{(map list clist1 clist2 @dots{})}.
If @code{zip} is passed @var{n} lists, it returns a list as long as
the shortest of these lists, each element of which is an @var{n}-element list
comprised of the corresponding elements from the parameter lists. 
@example
(zip '(one two three) 
     '(1 2 3)
     '(odd even odd even odd even odd even))
     @result{} ((one 1 odd) (two 2 even) (three 3 odd))

(zip '(1 2 3)) @result{} ((1) (2) (3))
@end example
At least one of the argument lists must be finite: 
@example
(zip '(3 1 4 1) (circular-list #f #t)) 
     @result{} ((3 #f) (1 #t) (4 #f) (1 #t))
@end example
@end defun

@defun unzip1 list
@defunx unzip2 list
@defunx unzip3 list
@defunx unzip4 list
@defunx unzip5 list
[SRFI-1] @code{unzip1} takes a list of lists, where every list must
contain at least one element, and returns a list containing the
initial element of each such list.
@code{unzip2} takes a list of lists, where every list
must contain at least two elements, and returns two values:
a list of the first elements, and a list of the second
elements. @code{unzip3} does the same for the first
three elements of the lists, and so on.
@example
(unzip2 '((1 one) (2 two) (3 three))) @result{}
   (1 2 3) @r{and}
   (one two three)
@end example
@end defun

@defun count pred clist1 clist2 @dots{}
[SRFI-1] A procedure @var{pred} is applied to the @var{n}-th element
of given lists, from @var{n} is zero to the length of the
the shortest finite list in the given lists,
and the count of times @var{pred} returned true is returned.
@example
(count even? '(3 1 4 1 5 9 2 5 6)) @result{} 3
(count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) @result{} 3
@end example
At least one of the argument lists must be finite: 
@example
(count < '(3 1 4 1) (circular-list 1 10)) @result{} 2
@end example
@end defun

@node SRFI-1 Fold, SRFI-1 Filterling & partitioning, SRFI-1 List miscellaneous routines, List library
@subsection List fold, unfold & map

@defun fold kons knil clist1 clist2 @dots{}
[SRFI-1] The fundamental list iterator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@example
(@var{kons} @var{en} @dots{} (@var{kons} @var{e2} (@var{kons} @var{e1} @var{knil})) @dots{} ) 
@end example

If @var{n} list arguments are provided, then the @var{kons}
function must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples:
@example
(fold + 0 '(3 1 4 1 5 9)) @result{} 23 ;@r{sum up the elements}
(fold cons '() '(a b c d e)) @result{} (e d c b a) ;@r{reverse}
(fold cons* '() '(a b c) '(1 2 3 4 5))
    @result{} (c 3 b 2 a 1) ;@r{n-ary case}
@end example
@end defun

@defun fold-right kons knil clist1 clist2 @dots{}
[SRFI-1] The fundamental list recursion operator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@example
(@var{kons} @var{e1} (@var{kons} @var{e2} @dots{} (@var{kons} @var{en} @var{knil})))
@end example

If @var{n} list arguments are provided, then the @var{kons} function
must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples: 
@example
(fold-right cons '() '(a b c d e))
   @result{} (a b c d e) ;@r{copy list}
(fold-right cons* '() '(a b c) '(1 2 3 4 5))
   @result{} (a 1 b 2 c 3) ;@r{n-ary case}
@end example
@end defun

@defun pair-fold kons knil clist1 clist2 @dots{}
[SRFI-1] 
@end defun

@defun pair-fold-right kons knil clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun reduce f ridentity list
[SRFI-1]
@end defun

@defun reduce-right f ridentity list
[SRFI-1]
@end defun

@defun unfold p f g seed &optional tail-gen
[SRFI-1]
@end defun

@defun unfold-right p f g seed &optional tail
[SRFI-1]
@end defun

@defun append-map f clist1 clist2 @dots{}
@defunx append-map! f clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun map! f list1 clist2 @dots{}
[SRFI-1]
@end defun

@defun map-in-order f clist1 clist2 @dots{}
[SRFI-1] A variant of @code{map}, but it guarantees to apply @var{f}
on each elements of arguments in a left-to-right order.
Since Gauche's @code{map} implementation follows the same order,
this function is just a synonym of @code{map}.
@end defun

@defun pair-for-each f clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun filter-map  f clist1 clist2 @dots{}
[SRIF-1]
@end defun

@node SRFI-1 Filterling & partitioning, SRFI-1 Searching, SRFI-1 Fold, List library
@subsection List filtering & partitioning

@defun filter pred list
@defunx filter! pred list
[SRFI-1] A procedure @var{pred} is applied on each element of @var{list},
and a list of elements that @var{pred} returned true on it is returned.
@example
(filter odd? '(3 1 4 5 9 2 6)) @result{} (3 1 5 9)
@end example
@code{filter!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@defun remove pred list
@defunx remove! pred list
[SRFI-1] A procedure @var{pred} is applied on each element of @var{list},
and a list of elements that @var{pred} returned false on it is returned.
@example
(remove odd? '(3 1 4 5 9 2 6)) @result{} (4 2 6)
@end example
@code{remove!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@defun partition pred list
@defunx partition! pred list
[SRFI-1] @code{filter} and @code{remove} simultaneously, i.e. 
returns two lists, the first is the result of filtering elements of
@var{list} by @var{pred}, and the second is the result of
removing elements of @var{list} by @var{pred}.
@example
(partition odd? '(3 1 4 5 9 2 6))
  @result{} (3 1 5 9) (4 2 6)
@end example
@code{partition!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@node SRFI-1 Searching, SRFI-1 Deletion, SRFI-1 Filterling & partitioning, List library
@subsection List searching

@defun find pred clist
[SRFI-1] Applies @var{pred} for each elements of @var{clist}, from 
left to right, and returns the first element that @var{pred} returns
true on.
@end defun

@defun find-tail pred clist
[SRFI-1]
@end defun

@defun take-while pred clist
@defunx take-while! pred list
[SRFI-1]
@end defun

@defun drop-while pred clist
[SRFI-1]
@end defun

@defun span pred clist
@defunx span! pred list
@defunx break pred clist
@defunx break! pred list
[SRFI-1]
@end defun

@defun any pred clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun every pred clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun list-index pred clist1 clist2 @dots{}
[SRFI-1]
@end defun

@node SRFI-1 Deletion, SRFI-1 Association lists, SRFI-1 Searching, List library
@subsection List deletion

@defun delete x list &optional elt=
@defunx delete! x list &optional elt=
[SRFI-1]
@end defun

@defun delete-duplicates list &optional elt=
@defunx delete-duplicates! list &optional elt=
[SRFI-1]
@end defun

@node SRFI-1 Association lists, SRFI-1 set operations, SRFI-1 Deletion, List library
@subsection Association lists

@defun alist-cons key datum alist
[SRFI-1] Returns @code{(cons (cons @var{obj1} @var{obj2}) @var{obj3})}.
This is an alias of the Gauche builtin procedure @code{acons}.
@end defun

@defun alist-copy alist
[SRFI-1] Returns a fresh copy of @var{alist}.
@end defun

@defun alist-delete key alist &optional =
@defunx alist-delete! key alist &optional =
[SRFI-1]
@end defun

@node SRFI-1 set operations,  , SRFI-1 Association lists, List library
@subsection Lists as sets

@defun lset@code{<=} elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset= elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-adjoin elt= list elt @dots{}
[SRFI-1]
@end defun

@defun lset-union elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset-intersection elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-difference elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-xor elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset-diff+intersection elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-union! elt= list @dots{}
@defunx lset-intersection! elt= list1 list2 @dots{}
@defunx lset-difference! elt= list1 list2 @dots{}
@defunx lset-xor! elt= list1 @dots{}
@defunx lset-diff+intersection! elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@c ----------------------------------------------------------------------
@node And-let*, Homogeneous Vectors, List library, Library modules
@section @code{srfi-2} - And-let*

@deftp {Module} srfi-2
@mdindex srfi-2
@end deftp

@defmac and-let* (bindings @dots{}) body @dots{}
@end defmac

@c ----------------------------------------------------------------------
@node Homogeneous Vectors, SRFI String ports, And-let*, Library modules
@section @code{srfi-4} - Homogeneous Vectors
@c NODE 単一型のベクタ, @code{srfi-4} - 単一型のベクタ

@deftp {Module} srfi-4
@mdindex srfi-4
@c EN
Provides classes for vectors whose elements are of the same
numeric type.

Gauche's implementation extends SRFI-4 specification in two ways:
@itemize @bullet
@item
Additional functions: @code{@var{TAG}vector-copy},
@code{@var{TAG}vector-copy!}, @code{@var{TAG}vector->vector},
@code{vector->@var{TAG}vector}.
@item
Implements the collection framework (@xref{Collection framework})
and the sequence framework (@xref{Sequence framework}).  So the
methods like @code{map}, @code{for-each}, @code{ref} or @code{subseq}
can be used on the SRFI-4 vector types.
@end itemize
@c JP
要素が同一の数値型であるようなベクタのクラスを提供します。

Gaucheの実装は、SRFI-4の仕様を次のように拡張しています。
@itemize
@item
追加の手続き： @code{@var{TAG}vector-copy},
@code{@var{TAG}vector-copy!}, @code{@var{TAG}vector->vector},
@code{vector->@var{TAG}vector}.
@item
コレクションフレームワーク (@ref{Collection framework}参照)と
シーケンスフレームワーク (@ref{Sequence framework}参照)の実装。
例えば @code{map}, @code{for-each}, @code{ref}, @code{subseq}等の
メソッドがSRFI-4ベクタに対して使えます。
@end itemize
@c COMMON
@end deftp

@c EN
The following ten types of vectors are defined.
@table @emph
@item s8vector
Elements are exact integers in the range between -2^7 and 2^7-1
@item u8vector
Elements are exact integers in the range between 0 and 2^8-1
@item s16vector
Elements are exact integers in the range between -2^15 and 2^15-1
@item u16vector
Elements are exact integers in the range between 0 and 2^16-1
@item s32vector
Elements are exact integers in the range between -2^31 and 2^31-1
@item u32vector
Elements are exact integers in the range between 0 and 2^32-1
@item s64vector
Elements are exact integers in the range between -2^63 and 2^63-1
@item u64vector
Elements are exact integers in the range between 0 and 2^64-1
@item f32vector
Elements are inexact real numbers representable in the @code{float} of
C compiler that compiles Gauche.  Usually it is a single precision
IEEE floating point number.
@item f64vector
Elements are inexact real numbers representable in the @code{double} of
C compiler that compiles Gauche.  Usually it is a double precision
IEEE floating point number.
@end table
@c JP
以下の10タイプのベクタが定義されます。
@table @emph
@item s8vector
要素が -2^7 から 2^7-1 の間の正確な整数であるベクタ
@item u8vector
要素が 0 から 2^8-1 の間の正確な整数であるベクタ
@item s16vector
要素が -2^15 から 2^15-1 の間の正確な整数であるベクタ
@item u16vector
要素が 0 から 2^16-1 の間の正確な整数であるベクタ
@item s32vector
要素が -2^31 から 2^31-1 の間の正確な整数であるベクタ
@item u32vector
要素が 0 から 2^32-1 の間の正確な整数であるベクタ
@item s64vector
要素が -2^63 から 2^63-1 の間の正確な整数であるベクタ
@item u64vector
要素が 0 から 2^64-1 の間の正確な整数であるベクタ
@item f32vector
要素が、GaucheをコンパイルしたCコンパイラの@code{float}で表現し得るような
不正確な実数(通常IEEE単精度浮動少数点数)であるベクタ
@item f64vector
要素が、GaucheをコンパイルしたCコンパイラの@code{double}で表現し得るような
不正確な実数(通常IEEE倍精度浮動少数点数)であるベクタ
@end table
@c COMMON

@c EN
In the following description, @code{@var{TAG}} can be replaced
for any of @code{s8}, @code{u8}, @code{s16}, @code{u16}, 
@code{s32}, @code{u32}, @code{s64}, @code{u64}, @code{f32}, @code{f64}.
@c JP
以下の記述では、@code{@var{TAG}}は
@code{s8}, @code{u8}, @code{s16}, @code{u16}, 
@code{s32}, @code{u32}, @code{s64}, @code{u64}, @code{f32}, @code{f64}
のいずれにも置き換えて読むことができるものとします。
@c COMMON

@deftp {Builtin Class} <@var{TAG}vector>
@clindex s8vector
@clindex u8vector
@clindex s16vector
@clindex u16vector
@clindex s32vector
@clindex u32vector
@clindex s64vector
@clindex u64vector
@clindex f32vector
@clindex f64vector
@c EN
A class for @var{TAG}vector.  It inherits @code{<sequence>}.
@c JP
@var{TAG}vectorのクラス。@code{<sequence>}を継承します。
@c COMMON
@end deftp

@deftp {Reader Syntax} @code{#@var{TAG}(@var{n} @dots{})}
@c EN
Denotes a literal homogeneous vector.
@c JP
リテラルの単一型のベクタを記述します。
@c COMMON
@example
#s8(3 -2 4)
#u32(4154 88357 2 323)
#f32(3.14 0.554525 -3.342)
@end example
@end deftp

@deftp {Function} {@var{TAG}vector?} @r{@var{obj}}
@findex s8vector?
@findex u8vector?
@findex s16vector?
@findex u16vector?
@findex s32vector?
@findex u32vector?
@findex s64vector?
@findex u64vector?
@findex f32vector?
@findex f64vector?
[SRFI-4]
@c EN
Returns @code{#t} if @var{obj} is a @var{TAG}vector, @code{#f} otherwise.
@c JP
@var{obj}が@var{TAG}vectorなら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end deftp

@deftp {Function} {@var{TAG}vector} @r{@var{x} @dots{}}
@findex s8vector 
@findex u8vector
@findex s16vector
@findex u16vector
@findex s32vector
@findex u32vector
@findex s64vector
@findex u64vector
@findex f32vector
@findex f64vector
[SRFI-4]
@c EN
Constructs @var{TAG}vector whose elements are numbers @var{x} @dots{}.
The numbers must be exact integer for exact integer vectors, 
and in the valid range of the vector.
@c JP
数値@var{x} @dots{} を要素に持つ@var{TAG}vectorを作成して返します。
正確な整数のベクタに対しては、数値は正確な整数でなければならず、
また有効な範囲内の値でなければなりません。
@c COMMON
@example
(s8vector 1 2 3) @result{} #s8(1 2 3)
@end example
@end deftp

@deftp {Function} make-@var{TAG}vector @r{@var{len} @var{&optional} @var{fill}}
@findex make-s8vector
@findex make-u8vector
@findex make-s16vector
@findex make-u16vector
@findex make-s32vector
@findex make-u32vector
@findex make-s64vector
@findex make-u64vector
@findex make-f32vector
@findex make-f64vector
[SRFI-4]
@c EN
Constructs a @var{TAG}vector of length @var{len}.  The elements are
initialized by a number @var{fill}.   For exact integer vectors,
@var{fill} must be an exact integer and in the valid range.
If @var{fill} is omitted, the content of the vector is undefined.
@c JP
長さ@var{len}の@var{TAG}vectorを作成して返します。各要素は@var{fill}で
初期化されます。正確な整数のベクタに対しては、@var{fill}は正確な整数でなければならず、
また有効な範囲内の値でなければなりません。
@var{fill}が省略された場合、各要素の初期値は不定です。
@c COMMON
@example
(make-u8vector 4 0) @result{} #u8(0 0 0 0)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-length @r{@var{vec}}
@findex s8vector-length 
@findex u8vector-length
@findex s16vector-length
@findex u16vector-length
@findex s32vector-length
@findex u32vector-length
@findex s64vector-length
@findex u64vector-length
@findex f32vector-length
@findex f64vector-length
[SRFI-4]
@c EN
Returns the length of the @var{TAG}vector @var{vec}.

Note that the generic function @code{size-of} can be used 
to obtain the length of @var{vec} as well,
if you import @code{gauche.collection}
(@xref{Collection framework}).
@c JP
@var{TAG}vector @var{vec}の長さを返します。

モジュール@code{gauche.collection}をインポートしていれば、
@var{vec}の長さを知るのに、総称関数@code{size-of}を使うこともできます
(@ref{Collection framework}参照)。
@c COMMON
@example
(s16vector-length '#s16(111 222 333)) @result{} 3

(use gauche.collection)
(size-of '#s16(111 222 333)) @result{} 3
@end example
@end deftp

@deftp {Function} @var{TAG}vector-ref @r{@var{vec} @var{k}}
@findex s8vector-ref
@findex u8vector-ref
@findex s16vector-ref
@findex u16vector-ref
@findex s32vector-ref
@findex u32vector-ref
@findex s64vector-ref
@findex u64vector-ref
@findex f32vector-ref
@findex f64vector-ref
[SRFI-4]
@c EN
Returns the @var{k}-th element of @var{TAG}vector @var{vec}.

Note that the generic function @code{ref} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}の@var{k}番目の要素を返します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{ref}を使うこともできます。
@c COMMON

@example
(u16vector-ref '#u16(111 222 333) 1) @result{} 222

(use gauche.collection)
(ref '#u16(111 222 333) 1) @result{} 222
@end example
@end deftp

@deftp {Function} @var{TAG}vector-set! @r{@var{vec} @var{k} @var{n}}
@findex s8vector-set!
@findex u8vector-set!
@findex s16vector-set!
@findex u16vector-set!
@findex s32vector-set!
@findex u32vector-set!
@findex s64vector-set!
@findex u64vector-set!
@findex f32vector-set!
@findex f64vector-set!
[SRFI-4]
@c EN
Sets a number @var{n} to the @var{k}-th element of @var{TAG}vector @var{vec}.
@var{n} must be an exact integer for exact integer vectors, and
in a valid range.

Note that the setter of the generic function @code{ref} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}の@var{k}番目の要素に数値@var{n}をセットします。
正確な整数のベクタに対しては@var{n}は正確な整数でなければならず、また正しい範囲内で
なければなりません。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{ref}のsetter手続きを使うこともできます。
@c COMMON
@example
(let ((v (s32vector -439 852 8933)))
  (s32vector-set! v 1 4)
  v)
 @result{} #s32vector(-439 4 8933)

(use gauche.collection)
(let ((v (s32vector -439 852 8933)))
  (set! (ref v 1) 4)
  v)
 @result{} #s32vector(-439 4 8933)
@end example
@end deftp

@deftp {Function} @var{TAG}vector->list @r{@var{vec}}
@findex s8vector->list
@findex u8vector->list
@findex s16vector->list
@findex u16vector->list
@findex s32vector->list
@findex u32vector->list
@findex s64vector->list
@findex u64vector->list
@findex f32vector->list
@findex f64vector->list
[SRFI-4]
@c EN
Converts @var{TAG}vector @var{vec} to a list.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}をリストに変換します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(u32vector->list '#u32(9 2 5)) @result{} (9 2 5)

(use gauche.collection)
(coerce-to <list> '#u32(9 2 5)) @result{} (9 2 5)
@end example
@end deftp

@deftp {Function} list->@var{TAG}vector @r{@var{list}}
@findex list->s8vector
@findex list->u8vector
@findex list->s16vector
@findex list->u16vector
@findex list->s32vector
@findex list->u32vector
@findex list->s64vector
@findex list->u64vector
@findex list->f32vector
@findex list->f64vector
[SRFI-4]
@c EN
Converts a list @var{list} to a @var{TAG}vector.
All the elements in @var{list} must be a valid number for an element
of @var{TAG}vector.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
リスト@var{list}を@var{TAG}vectorに変換します。
リスト内の全ての要素は、@var{TAG}vectorの要素として正当な数値でなければなりません。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(list->s64vector '(9 2 5)) @result{} #s64(9 2 5)

(use gauche.collection)
(coerce-to <s64vector> '(9 2 5)) @result{} #s64(9 2 5)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-copy @r{@var{vec}}
@findex s8vector-copy
@findex u8vector-copy
@findex s16vector-copy
@findex u16vector-copy
@findex s32vector-copy
@findex u32vector-copy
@findex s64vector-copy
@findex u64vector-copy
@findex f32vector-copy
@findex f64vector-copy
@c EN
@c JP
@c COMMON
@end deftp

@deftp {Function} @var{TAG}vector-copy! @r{@var{dstvec} @var{srcvec}}
@findex s8vector-copy!
@findex u8vector-copy!
@findex s16vector-copy!
@findex u16vector-copy!
@findex s32vector-copy!
@findex u32vector-copy!
@findex s64vector-copy!
@findex u64vector-copy!
@findex f32vector-copy!
@findex f64vector-copy!
@c EN
@c JP
@c COMMON
@end deftp

@deftp {Function} @var{TAG}vector->vector @r{@var{vec}}
@findex s8vector->vector
@findex u8vector->vector
@findex s16vector->vector
@findex u16vector->vector
@findex s32vector->vector
@findex u32vector->vector
@findex s64vector->vector
@findex u64vector->vector
@findex f32vector->vector
@findex f64vector->vector
@c EN
Converts @var{TAG}vector @var{vec} to a vector.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}をベクタに変換します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(f32vector->vector '#f32(9.3 2.2 5.5)) @result{} (9.3 2.2 5.5)

(use gauche.collection)
(coerce-to <vector> '#f32(9.3 2.2 5.5)) @result{} (9.3 2.2 5.5)
@end example
@end deftp

@deftp {Function} vector->@var{TAG}vector @r{@var{vec}}
@findex vector->s8vector
@findex vector->u8vector
@findex vector->s16vector
@findex vector->u16vector
@findex vector->s32vector
@findex vector->u32vector
@findex vector->s64vector
@findex vector->u64vector
@findex vector->f32vector
@findex vector->f64vector
@c EN
Converts a vector @var{vec} to a @var{TAG}vector.
All the elements in @var{vec} must be a valid number for an element
of @var{TAG}vector.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
ベクタ@var{vec}を@var{TAG}vectorに変換します。
ベクタ内の全ての要素は、@var{TAG}vectorの要素として正当な数値でなければなりません。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(vector->f64vector '#(3.1 5.4 3.2)) @result{} #f64(3.1 5.4 3.2)

(use gauche.collection)
(coerce-to <f64vector> '#(3.1 5.4 3.2)) @result{} #f64(3.1 5.4 3.2)
@end example
@end deftp

@c EN
Using collection and sequence framework, you can perform
various operations on the homogeneous vectors.
@c JP
コレクションやシーケンスフレームワークを使うと、さらに様々な操作を
行うことができます。
@c COMMON

@example
(use gauche.collection)
(use gauche.sequence)

(fold + 0 '#s32(1 2 3 4)) @result{} 10

(map-to <f32vector> * '#f32(3.2 1.1 4.3) '#f32(-4.3 2.2 9.4))
  @result{} #f32(-13.760001 2.420000 40.420002)

(subseq #u32(1 4 3 4 5) 2 4) @result{} #u32(3 4)
@end example

@c ----------------------------------------------------------------------
@node SRFI String ports, Syntax to receive multiple values, Homogeneous Vectors, Library modules
@section @code{srfi-6} - String ports

@deftp {Module} srfi-6
@mdindex srfi-6
String ports, defined in SRFI-6, are builtin feature of Gauche.
The form @code{(use srfi-6)} doesn't do anything.
@end deftp

@c ----------------------------------------------------------------------
@node Syntax to receive multiple values, Record types, SRFI String ports, Library modules
@section @code{srfi-8} - Syntax to receive multiple values

@deftp {Module} srfi-8
@mdindex srfi-8
Syntax @code{receive}, defined in SRFI-8, is builtin feature of Gauche.
The form @code{(use srfi-8)} doesn't do anything.
@end deftp


@c ----------------------------------------------------------------------
@node Record types, Let-values, Syntax to receive multiple values, Library modules
@section @code{srfi-9} - Record types

@deftp {Module} srfi-9
@mdindex srfi-9
Contains a macro to use record types.  A record type is implemented on
top of Gauche's object system.

The SRFI-9 record type is not as powerful as the object system, but
it will be useful if you want your program to be portable.
@end deftp

@defmac define-record-type name (constructor init-tag @dots{}) predicate (field accessor [modifier]) @dots{}
Creates a record type and binds it to @var{name}.
In Gauche, a record type is just a subclass of @code{<record>}.

@var{constructor} is bound to a procedure that creates an instance
of the record type,
which takes as many arguments as @var{init-tag} @dots{}.  Each
@var{init-tag} corresponds to one of the field name, and the fields
of the created record instance is initialized accordingly.  Not all
of fields need to appear in @var{init-tag}; uninitialized fields remain
unbound.

@var{predicate} is bound to a procedure that takes one argument, and
returns #t if the argument is an instance of the defined record type,
#f otherwise.

Followings are field specifications.  The record has fields
@var{field} @dots{}, and each field can be accessed by a method
@var{accessor}.  If @var{modifier} is given to the field, it is bound
to a method that sets the value to the field.

Example:
@example
(define-record-type pare
  (kons x y) pare?
  (x kar set-kar!)
  (y kdr))
 @result{} #<class pare>

(pare? (kons 2 3)) @result{} #t
(pare? (cons 2 3)) @result{} #f

(kar (kons 2 3)) @result{} 2
(kdr (kons 2 3)) @result{} 3

(let ((x (kons 2 3)))
  (set-kar! x -1)
  (kar x)) @result{} -1
@end example

Conceptually, the above example is expanded into the following
sequence of forms.
@example
(define-class pare (<record>) (x y))
(define (kons x y)
  (let ((obj (make pare)))
    (slot-set! obj 'x x) 
    (slot-set! obj 'y y)
    obj))
(define (pare? obj) (is-a? obj pare))
(define-method kar ((obj pare))
  (slot-ref obj 'x))
(define-method set-kar! ((obj pare) value)
  (slot-set! obj 'x value))
(define-method kdr ((obj pare))
  (slot-ref obj 'y))
@end example

@end defmac

@c ----------------------------------------------------------------------
@node Let-values, String library, Record types, Library modules
@section @code{srfi-11} - Let-values

@deftp {Module} srfi-11
@mdindex srfi-11
Defines two macros, @code{let-values} and @code{let*-values}.
They are convenient to use with multiple values (@ref{srfi-11,,[SRFI-11]}).


@end deftp

@defmac let-values ((vars expr) @dots{}) body @dots{}
[SRFI-11]
@var{vars} are a list of variables. @var{expr} is evaluated, and
its first return value is bound to the first variable in @var{vars},
its second return value to the second variable, and so on, then
@var{body} is evaluated.
The scope of @var{expr}s are the outside of @code{let-values} form,
like @code{let}.

@example
(let-values (((a b) (values 1 2))
             ((c d) (values 3 4)))
  (list a b c d)) @result{} (1 2 3 4)

(let ((a 1) (b 2) (c 3) (d 4))
  (let-values (((a b) (values c d))
               ((c d) (values a b)))
    (list a b c d))) @result{} (3 4 1 2)
@end example

@var{vars} can be a dotted list or a single symbol, like the
lambda parameters.

@example
(let-values (((x . y) (values 1 2 3 4)))
  y) @result{} (2 3 4)

(let-values ((x (values 1 2 3 4)))
  x) @result{} (1 2 3 4)
@end example

If @var{expr} returns less values than specified in @var{vars},
an error is signalled.  If @var{expr} returns more values than
specified in @var{vars}, the unused values are discarded.
@end defmac

@defmac let*-values ((vars expr) @dots{}) body @dots{}
[SRFI-11]
Same as @code{let-values}, but each @var{expr}'s scope includes
the preceding @var{vars}.

@example
(let ((a 1) (b 2) (c 3) (d 4))
  (let*-values (((a b) (values c d))
                ((c d) (values a b)))
    (list a b c d))) @result{} (3 4 3 4)
@end example
@end defmac

@c ----------------------------------------------------------------------
@node String library, Character-set library, Let-values, Library modules
@section @code{srfi-13} - String library

@deftp {Module} srfi-13
@mdindex srfi-13
Defines a large set of string-related functions.
In Gauche, those functions are splitted to number of files
and the form @code{(use srfi-13)} merely sets up autoloading of
those files.  So it is not likely to slow down the script startup.

See SRFI-13 (@ref{srfi-13, [SRFI-13], SRFI-13})
for the detailed specification and discussion of design issues.
This manual serves as a reference of function API.
Some SRFI-13 functions are Gauche built-in and not listed here.

Note: SRFI-13 documents suggests the name of the module that
implements these functions to be ``string-lib'' and ``string-lib-internals''.
Gauche uses the name ``srfi-13'' for consistency.
@end deftp

@menu
* SRFI-13 General conventions::  
* SRFI-13 String predicates::   
* SRFI-13 String Constructors::  
* SRFI-13 String Selection::    
* SRFI-13 String Comparison::   
* SRFI-13 String Prefixes & Suffixes::  
* SRFI-13 String searching::    
* SRFI-13 String case mapping::  
* SRFI-13 String reverse & append::  
* SRFI-13 String mapping::      
* SRFI-13 String rotation::     
* SRFI-13 other string operations::  
* SRFI-13 String filtering::    
* SRFI-13 Low-level string procedures::  
@end menu

@node SRFI-13 General conventions, SRFI-13 String predicates, String library, String library
@subsection General conventions

There are a few common factors in string library API, which I don't
repeat in each function description

@table @emph
@item argument convention
The following argument names imply their types.
@table @var
@item s, s1, s2
Those arguments must be strings.
@item char/char-set/pred
This argument can be a character, a character-set object,
or a predicate that takes a single character and returns a boolean value.
``Applying @var{char/char-set/pred} to a character'' means,
if @var{char/char-set/pred} is a character, it is compared to the given
character; if @var{char/char-set/pred} is a character set, it is
checked if the character set contains the given character; if
@var{char/char-set/pred} is a procedure, it is applied
to the given character.  ``A character satisfies @var{char/char-set/pred}''
means such application to the character yields true value.

@item start, end
Lots of SRFI-13 functions takes these two optional arguments, which
limit the area of input string from @var{start}-th character
(inclusive) to @var{end}-th character (exclusive),
where the operation is performed.
When specified, the condition
0 <= @var{start} <= @var{end} <= @var{length of the string} must be
satisfied.  Default value of @var{start} and @var{end} is
0 and the length of the string, respectively.
@end table

@item `shared' variant
Some functions have variants with ``/shared'' attached to its name.
SRFI-13 defines those functions to allow to share the part of input
string, for better performance.  Gauche doesn't have a concept of
shared string, and these functions are mere synonyms of their
non-shared variants.  However, Gauche @emph{internally} shares
the storage of strings, so generally you don't need to worry
about the overhead of copying substrings.

@item `right' variant
Most functions works from left to right of the input string.
Some functions have variants with ``-right'' to its name, 
that works from right to left.

@end table

@node SRFI-13 String predicates, SRFI-13 String Constructors, SRFI-13 General conventions, String library
@subsection String predicates

@defun string-null? s
[SRFI-13] Returns @code{#t} if @var{s} is an empty string, @code{""}.
@end defun

@defun string-every char/char-set/pred s &optional start end
[SRFI-13] Sees if every character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-every} returns
the value that is returned at the last application of @var{char/char-set/pred}.
If any of the application returns @code{#f}, @code{string-every}
returns @code{#f} immediately.
@end defun

@defun string-any char/char-set/pred s &optional start end
[SRFI-13] Sees if any character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-any} returns
the value that is returned by the application.   If no character
satisfies @var{char/char-set/pred}, @code{#f} is returned.
@end defun

@node SRFI-13 String Constructors, SRFI-13 String Selection, SRFI-13 String predicates, String library
@subsection String Constructors

@defun string-tabulate proc len
[SRFI-13] @var{proc} must be a procedure that takes an integer
argument and returns a character.  @code{string-tabulate}
creates a string, whose @var{i}-th character is calculated by
@code{(proc i)}.
@example
(string-tabulate
  (lambda (i) (integer->char (+ i #x30))) 10)
 @result{} "0123456789"
@end example

@end defun

@defun reverse-list->string char-list
[SRFI-13] @equiv{} @code{(list->string (reverse char-list))}.
@end defun

@node SRFI-13 String Selection, SRFI-13 String Comparison, SRFI-13 String Constructors, String library
@subsection String selection

@defun substring/shared s start &optional end
[SRFI-13] In Gauche, this is the same as @code{substring}, except
that the @var{end} argument is optional.
@example
(substring/shared "abcde" 2) @result{} "cde"
@end example
@end defun

@defun string-copy! target tstart s &optional start end
[SRFI-13] Copies a string @var{s} into a string
@var{target} from the position @var{tstart}.
Optional @var{start} and @var{end} arguments limits the range of @var{s}.
If the copied string run over the end of @var{target}, an error is
signalled.
@example
(define s (string-copy "abcde"))
(string-copy! s 2 "ZZ")
s @result{} "abZZe"
@end example
@end defun

@defun string-take s nchars
@defunx string-drop s nchars
@defunx string-take-right s nchars
@defunx string-drop-right s nchars
[SRFI-13] Returns the first @var{nchars}-character string of @var{s}
(@code{string-take}) or the string without first @var{nchars}
(@code{string-drop}).  The @code{*-right} variation counts from
the end of string.  It is guaranteed that the returned string is
always a copy of @var{s}, even no character is dropped.
@example
(string-take "abcde" 2) @result{} "ab"
(string-drop "abcde" 2) @result{} "cde"

(string-take-right "abcde" 2) @result{} "cde"
(string-drop-right "abcde" 2) @result{} "ab"
@end example
@end defun

@defun string-pad s len &optional char start end
@defunx string-pad-right s len &optional char start end
[SRFI-13]
@end defun

@defun string-trim s &optional char/char-set/pred start end
@defunx string-trim-right s &optional char/char-set/pred start end
@defunx string-trim-both s &optional char/char-set/pred start end
[SRFI-13]
@end defun

@node SRFI-13 String Comparison, SRFI-13 String Prefixes & Suffixes, SRFI-13 String Selection, String library
@subsection String comparison

@defun string-compare s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
@defunx string-compare-ci s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string= s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-ci@code{=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-hash s &optional bound start end 
@defunx string-hash-ci s &optional bound start end 
[SRFI-13]
@end defun

@node SRFI-13 String Prefixes & Suffixes, SRFI-13 String searching, SRFI-13 String Comparison, String library
@subsection String Prefixes & Suffixes

@defun string-prefix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-length-ci s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-prefix? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix? s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-ci? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-ci? s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@node SRFI-13 String searching, SRFI-13 String case mapping, SRFI-13 String Prefixes & Suffixes, String library
@subsection String searching

@defun string-index s char/char-set/pred &optional start end
@defunx string-index-right s char/char-set/pred &optional start end
[SRFI-13] Looks for the first element in a string @var{s}
that matches @var{char/char-set/pred}, and returns its index.
If @var{char/char-set/pred} is not found in @var{s}, returns @code{#f}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.

@example
(string-index "Aloha oe" #\a) @result{} 4
(string-index "Aloha oe" #[Aa]) @result{} 0
(string-index "Aloha oe" #[\s]) @result{} 5
(string-index "Aloha oe" char-lower-case?) @result{} 1
(string-index "Aloha oe" #\o 3) @result{} 6
@end example


See also the Gauche built-in procedure @code{string-scan}
(@ref{String utilities}), if you need speed over portability.
@end defun

@defun string-skip s char/char-set/pred &optional start end
@defunx string-skip-right s char/char-set/pred &optional start end
[SRFI-13] Looks for the first element that does not match
@var{char/char-set/pred} and returns its index.
If such element is not found, returns @code{#f}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@end defun

@defun string-count s char/char-set/pred &optional start end
[SRFI-13] Counts the number of elements in @var{s}
that matches @var{char/char-set/pred}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@end defun

@defun string-contains s1 s2 &optional start1 end1 start2 end2
@defunx string-contains-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13] Looks for a string @var{s2} inside another string @var{s1}.
If found, returns an index in @var{s1} from where the maching string
begins.  Returns @code{#f} otherwise.
Optional @var{start1}, @var{end1}, @var{start2} and @var{end2}
limits the range of @var{s1} and @var{s2}.

See also the Gauche built-in procedure @code{string-scan}
(@ref{String utilities}), if you need speed over portability.
@end defun

@node SRFI-13 String case mapping, SRFI-13 String reverse & append, SRFI-13 String searching, String library
@subsection String case mapping

@defun string-titlecase s &optional start end
@defunx string-titlecase! s &optional start end
[SRFI-13]
@end defun

@defun string-upcase s &optional start end
@defunx string-upcase! s &optional start end
[SRFI-13]
@end defun

@defun string-downcase s &optional start end
@defunx string-downcase! s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String reverse & append, SRFI-13 String mapping, SRFI-13 String case mapping, String library
@subsection String reverse & append

@defun string-reverse s &optional start end
@defunx string-reverse! s &optional start end
[SRFI-13] Returns a string in which the character posisions are reversed
from @var{s}.  @code{string-reverse!} modifies @var{s}.
@example
(string-reverse "mahalo") @result{} "olaham"
(string-reverse "mahalo" 3) @result{} "ola"
(string-reverse "mahalo" 1 4) @result{} "aha"

(let ((s (string-copy "mahalo")))
  (string-reverse! s 1 5)
  s)
  @result{} "mlahao"
@end example
@end defun

@defun string-concatenate string-list
[SRFI-13] Concatenates list of strings.
@example
(string-concatenate '("humuhumu" "nukunuku" "apua" "`a"))
  @result{} "humuhumunukunukuapua`a"
@end example
@end defun

@defun string-concatenate/shared string-list
@defunx string-append/shared s @dots{}
[SRFI-13] ``Shared'' version of @code{string-concatenate} and
@code{string-append}.  In Gauche, these are just synonyms of them.
@end defun

@defun string-concatenate-reverse string-list
@defunx string-concatenate-reverse/shared string-list
[SRFI-13] Reverses @var{string-list} before concatenation.
``Shared'' version works the same in Gauche.
@end defun

@node SRFI-13 String mapping, SRFI-13 String rotation, SRFI-13 String reverse & append, String library
@subsection String mapping

@defun string-map proc s &optional start end
@defunx string-map! proc s &optional start end
[SRFI-13] @code{string-map} applies @var{proc} on every character of @var{s},
and collects the results into a string and returns it.
On the other hand, @code{string-map!} modifies @var{s}.
@example
(string-map char-upcase "wikiwiki") @result{} "WIKIWIKI"
(string-map char-upcase "wikiwiki" 4) @result{} "WIKI"

(let ((s (string-copy "wikiwiki")))
  (string-map! char-upcase s 4)
  s)
  @result{} "wikiWIKI"
@end example
@end defun

@defun string-fold kons knil s &optional start end
@defunx string-fold-right kons knil s &optional start end
[SRFI-13]
@end defun

@defun string-unfold p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-unfold-right p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-for-each proc s &optional start end
[SRFI-13]
@end defun

@defun string-for-each-index proc s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String rotation, SRFI-13 other string operations, SRFI-13 String mapping, String library
@subsection String rotation

@defun xsubstring s from &optional to start end
[SRFI-13]
@end defun

@defun string-xcopy! target tstart s sfrom &optional sto start end
[SRFI-13]
@end defun

@node SRFI-13 other string operations, SRFI-13 String filtering, SRFI-13 String rotation, String library
@subsection Other string operations

@defun string-replace s1 s2 start1 end2 &optional start2 end2
[SRFI-13]
@end defun

@defun string-tokenize s &optional token-set start end
[SRFI-13]
@end defun

@node SRFI-13 String filtering, SRFI-13 Low-level string procedures, SRFI-13 other string operations, String library
@subsection String filtering

@defun string-filter s char/char-set/pred &optional start end
@defunx string-delete s char/char-set/pred &optional start end
[SRFI-13]
@end defun

@node SRFI-13 Low-level string procedures,  , SRFI-13 String filtering, String library
@subsection Low-level string procedures

@defun string-parse-start+end proc s args
@defunx string-parse-final-start+end proc s args
[SRFI-13]
@end defun

@defmac let-string-start+end (start end [rest]) proc-exp s-exp args-exp body @dots{}
[SRFI-13]
@end defmac

@defun check-substring-spec proc s start end
@defunx substring-spec-ok? s start end
[SRFI-13]
@end defun

@defun make-kmp-restart-vector s &optional c= start end
[SRFI-13]
@end defun

@defun kmp-step pat rv c i c= p-start
[SRFI-13]
@end defun

@defun string-kmp-partial-search pat rv s i &optional c= p-start s-start s-end
[SRFI-13]
@end defun

@c ----------------------------------------------------------------------
@node Character-set library, CSV tables, String library, Library modules
@section @code{srfi-14} - Character-set library

@deftp {Module} srfi-14
@mdindex srfi-14
Implements the character set library defined in SRFI-14
(@ref{srfi-14,,SRFI-14}).  Note that several basic character-set
operations are Gauche's build-in functions.  @xref{Character set}.
@end deftp

@menu
* SRFI-14 Character-set constructors::  
* SRFI-14 Character-set Comparison::  
* SRFI-14 Character-set iteration::  
* SRFI-14 Character-set query::  
* SRFI-14 Character-set algebra::  
* SRFI-14 Predefined character-set::  
@end menu

@node SRFI-14 Character-set constructors, SRFI-14 Character-set Comparison, Character-set library, Character-set library
@subsection Character-set constructors

@defun list->char-set char-list &optional base-cs
@defunx list->char-set! char-list base-cs
[SRFI-14]
@end defun

@defun string->char-set char-list &optional base-cs
@defunx string->char-set! char-list base-cs
[SRFI-14]
@end defun

@defun char-set-filter pred char-set &optional base-cs
@defunx char-set-filter! pred char-set base-cs
[SRFI-14]
@end defun

@defun ucs-range->char-set lower upper &optional error? base-cs
@defunx ucs-range->char-set! lower upper error? base-cs
[SRFI-14]
@end defun

@defun integer-range->char-set lower upper &optional error? base-cs
@defunx integer-range->char-set! lower upper error? base-cs
@end defun

@defun ->char-set x
[SRFI-14]
@end defun

@node SRFI-14 Character-set Comparison, SRFI-14 Character-set iteration, SRFI-14 Character-set constructors, Character-set library
@subsection Character-set comparison

@defun char-set= char-set1 @dots{}
[SRFI-14]
@end defun

@defun char-set@code{<=} char-set1 @dots{}
[SRFI-14]
@end defun

@defun char-set-hash char-set &optional bound
[SRFI-14]
@end defun

@node SRFI-14 Character-set iteration, SRFI-14 Character-set query, SRFI-14 Character-set Comparison, Character-set library
@subsection Character-set iteration

@defun char-set-cursor char-set
[SRFI-14]
@end defun

@defun char-set-ref char-set cursor
[SRFI-14]
@end defun

@defun char-set-cursor-next char-set cursor
[SRFI-14]
@end defun

@defun end-of-char-set? ccursor
[SRFI-14]
@end defun

@defun char-set-fold kons knil char-set
[SRFI-14]
@end defun

@defun char-set-unfold pred fun gen seed &optional base-char-set
@defunx char-set-unfold! pred fun gen seed base-char-set
[SRFI-14]
@end defun

@defun char-set-for-each proc char-set
[SRFI-14]
@end defun

@defun char-set-map proc char-set
[SRFI-14]
@end defun

@node SRFI-14 Character-set query, SRFI-14 Character-set algebra, SRFI-14 Character-set iteration, Character-set library
@subsection Character-set query

@defun char-set-size char-set
[SRFI-14]
@end defun

@defun char-set-count pred char-set
[SRFI-14]
@end defun

@defun char-set->list char-set
[SRFI-14]
@end defun

@defun char-set->string char-set
[SRFI-14]
@end defun

@defun char-set-every pred char-set
[SRFI-14]
@end defun

@defun char-set-any pred char-set
[SRFI-14]
@end defun

@node SRFI-14 Character-set algebra, SRFI-14 Predefined character-set, SRFI-14 Character-set query, Character-set library
@subsection Character-set algebra

@defun char-set-adjoin char-set char1 @dots{}
@defunx char-set-adjoin! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-delete char-set char1 @dots{}
@defunx char-set-delete! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-complement char-set
@defunx char-set-complement! char-set
[SRFI-14]
@end defun

@defun char-set-union char-set @dots{}
@defunx char-set-union! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-intersection char-set @dots{}
@defunx char-set-intersection! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-difference char-set1 char-set2 @dots{}
@defunx char-set-difference! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-xor char-set @dots{}
@defunx char-set-xor! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-diff+intersection char-set1 char-set2 @dots{}
@defunx char-set-diff+intersection! char-set1 char-set2 char-set3 @dots{}
[SRFI-14]
@end defun



@node SRFI-14 Predefined character-set,  , SRFI-14 Character-set algebra, Character-set library
@subsection Predefined character-set

@defvar char-set:letter
[SRFI-14]
@end defvar

@defvar char-set:blank
[SRFI-14]
@end defvar

@defvar char-set:iso-control
[SRFI-14]
@end defvar

@defvar char-set:digit
@defvarx char-set:hex-digit
[SRFI-14]
@end defvar

@defvar char-set:graphic
[SRFI-14]
@end defvar

@defvar char-set:lower-case
@defvarx char-set:upper-case
@defvarx char-set:title-case
[SRFI-14]
@end defvar

@defvar char-set:printing
[SRFI-14]
@end defvar

@defvar char-set:punctuation
[SRFI-14]
@end defvar

@defvar char-set:whitespace
[SRFI-14]
@end defvar

@defvar char-set:symbol
[SRFI-14]
@end defvar

@defvar char-set:ascii
[SRFI-14]
@end defvar

@defvar char-set:empty
[SRFI-14]
@end defvar

@defvar char-set:full
[SRFI-14]
@end defvar

@c ----------------------------------------------------------------------
@node CSV tables, Simple HTML document construction, Character-set library, Library modules
@section @code{text.csv} - CSV tables

@deftp {Module} text.csv
@mdindex text.csv
Provides a function to parse/generate CSV (comma separated value) tables.
Actually, the separater is not limited to comma; you can customize it.

CSV format is widely used to exchange table-type data in plain text,
although there are apparently no ``formal'' specification.

CSV table is consisted by a series of @var{records}, separated by
a newline.  Each record contains number of @var{fields}, separated
by a separator character (by default, a comma).  A field can contain
comma or newline if quoted, i.e. surrounded by double-quote characters.
To include double-quote character in a quoted field, use two
consecutive double-quote character.   Usually, the whitespaces around
the field are ignored.

@c example here

@end deftp

Right now, the following two low-level procedures are exported.
A plan is to provide higher features, such as labelling fields
and automatic conversions.

@defun make-csv-reader separator
Returns a procedure with one argument, input port.
When the procedure is called, it reads one record from the port,
and returns a list of fields.
If input reaches EOF, it returns EOF.
@end defun

@defun make-csv-writer separator &optional newline
Returns a procedure with two arguments, output port and
a list of fields.  When the procedure is called, it
outputs a @var{separater}-separated fields with proper escapes,
to the output port.   You can also specify the record delimiter
string by @var{newline}; for example, you can pass @code{"\r\n"}
to prepare a file to be read by Windows programs.
@end defun

@c ----------------------------------------------------------------------
@node Simple HTML document construction, Parsing input stream, CSV tables, Library modules
@section @code{text.html-lite} - Simple HTML document construction

@deftp {Module} text.html-lite
@mdindex text.html-lite
Provides procedures to construct an HTML document easily.
For example, you can construct an HTML table by the following code:
@example
(html:table
  (html:tr (html:th "Item No") (html:th "Quantity"))
  (html:tr (html:td 1) (html:td 120))
  (html:tr (html:td 2) (html:td 30))
  (html:tr (html:td 3) (html:td 215)))
@end example
See the description of @code{html:@var{element}} below for details.

This module does little check for the constructed html documents,
such as whether the attributes are valid, and whether the content
of the element matches DTD.  It does not provide a feature to parse
the html document neither.  Hence the name `lite'.
@end deftp

@defun html-escape
@defunx html-escape-string string
Escapes the ``unsafe'' characters in HTML.  @code{html-escape}
reads input string from the current input port and writes the result
to the current output port.   @code{html-escape-string} takes the
input from @var{string} and returns the result in a string.
@end defun

@defun html-doctype &keyword type
Returns a doctype declaration for an HTML document.
@var{type} can be either one of @code{:strict}, @code{:transitional},
or @code{:frameset}, corresponding HTML4.01 strict, transitional or
frameset DTD, respectively.
@end defun

@deftp {Function} html:@var{element} @var{args} @dots{}
@findex html:a
@findex html:abbr
@findex html:acronym
@findex html:address
@findex html:area
@findex html:b
@findex html:base
@findex html:bdo
@findex html:big
@findex html:blockquote
@findex html:body
@findex html:br
@findex html:button
@findex html:caption
@findex html:cite
@findex html:code
@findex html:col
@findex html:colgroup
@findex html:dd
@findex html:del
@findex html:dfn
@findex html:div
@findex html:dl
@findex html:dt
@findex html:em
@findex html:fieldset
@findex html:form
@findex html:h1
@findex html:h2
@findex html:h3
@findex html:h4
@findex html:h5
@findex html:h6
@findex html:head
@findex html:hr
@findex html:html
@findex html:i
@findex html:img
@findex html:input
@findex html:ins
@findex html:kbd
@findex html:label
@findex html:legend
@findex html:li
@findex html:link
@findex html:map
@findex html:meta
@findex html:noscript
@findex html:object
@findex html:ol
@findex html:optgroup
@findex html:option
@findex html:p
@findex html:param
@findex html:pre
@findex html:q
@findex html:samp
@findex html:script
@findex html:select
@findex html:small
@findex html:span
@findex html:strong
@findex html:style
@findex html:sub
@findex html:sup
@findex html:table
@findex html:tbody
@findex html:td
@findex html:textarea
@findex html:tfoot
@findex html:th
@findex html:thead
@findex html:title
@findex html:tr
@findex html:tt
@findex html:ul
@findex html:var
Construct an HTML element @var{element}.  Right now,
the following elements are provided.
(The elements defined in HTML 4.01 DTD,
@uref{http://www.w3.org/TR/html4/sgml/dtd.html}).
@example
a        abbr       acronym    address     area      b
base     bdo        big        blockquote  body      br
button   caption    cite       code        col       colgroup
dd       del        dfn        div         dl        dt
em       fieldset   form       h1          h2        h3
h4       h5         h6         head        hr        html
i        img        input      ins         kbd       label
legend   li         link       map         meta      noscript
object   ol         optgroup   option      p         param
pre      q          samp       script      select    small
span     strong     style      sub         sup       table
tbody    td         textarea   tfoot       th        thead
title    tr         tt         ul          var
@end example

The result of these functions is a tree of text segments,
which can be written out to a port by @code{write-tree} or
can be converted to a string by @code{tree->string}
(@xref{Lazy text construction}).

You can specify attributes of the element by using a keyword-value
notation before the actual content.
@example
(tree->string (html:a :href "http://foo/bar" "foobar"))
  @result{}
  "<a href=\"http://foo/bar\">foobar</a>\n"

(tree->string
  (html:table :width "100%" :cellpading 0 "content here"))
  @result{}
  "<table width=\"100%\" cellpadding=\"0\">content here</table>\n"
@end example

The boolean value given to the attribute has a special meaning.
If @code{#t} is given, the attribute is renfered without a value.
If @code{#f} is given, the attribute is not rendered.
@example
(tree->string (html:table :border #t))
  @result{} "<table border></table>\n"

(tree->string (html:table :border #f))
  @result{} "<table></table>\n"
@end example

Special characters in attribute values are escaped by the function,
but the ones in the content are not.  It is caller's responsibility
to escape them.

The functions signal an error if a content is given to the
HTML element that doesn't take a content.   They do not
check if the given attribute is valid, neither
if the given content is valid for the element.
@end deftp

@c ----------------------------------------------------------------------
@node Parsing input stream, Transliterate characters, Simple HTML document construction, Library modules
@section @code{text.parse} - Parsing input stream

@deftp {Module} text.parse
@mdindex text.parse
A collection of utilities that does simple parsing from
the input port.   The API is inspired, and compatible with
Oleg Kiselyov's input parsing library (@ref{oleg1,,OLEG1}).
His library is used in lots of other libraries, notably,
a full-Scheme XML parser/generator SSAX (@ref{ssax,,SSAX}).

You can use this module in place of his
@code{input-parse.scm} and @code{look-for-str.scm}.

I reimplemented the functions to be efficient on Gauche.
Especially, usage of @code{string-set!} is totally avoided.
I extended the interface a bit so that they can deal with character sets
and predicates, as well as a list of characters.

These functions work sequentially on the given input port,
that is, they read from the port as much as they need, without
buffering extra characters.
@end deftp

@defun find-string-from-port? str in-port &optional max-no-chars
Looks for a string @var{str} from the input port @var{in-port}.
The optional argument @var{max-no-chars} limits the maximum number of
characters to be read from the port; if omitted, the search span is
until EOF.

If @var{str} is found, this function returns the number of characters
it has read.   The next read from @var{in-port} returns the next char
of @var{str}.  If @var{str} is not found, it returns @code{#f}.

Note: Although this procedure has `@code{?}' in its name,
it may return non-boolean value, contrary to the Scheme convention.
@end defun

@defun peek-next-char &optional port
Discards the current character and peeks the next character from @var{port}.
Useful to look ahead one character.
If @var{port} is omitted, the current input port is used.
@end defun

In the following functions, @var{char-list} refers to one of the
followings:
@itemize @bullet
@item
A character set.
@item
A list of characters, character sets and/or symbol @code{*eof*}.
@end itemize
That denotes a set of characters.  If a symbol @code{*eof*} is
included, the EOF condition is also included.  Without @code{*eof*},
the EOF condition is regarded as an error.

@defun assert-curr-char char-list string &optional port
Reads a character from @var{port}.  If it is included in @var{char-list},
returns the character.  Otherwise, signals an error with a message
containing @var{string}.
If @var{port} is omitted, the current input port is used.
@end defun

@defun skip-until char-list/number &optional port
@var{char-list/number} is either a char-list or a number.
If it is a number; it reas that many characters and returns @code{#f}.
If the input is not long enough, an error is signalled.
IF @var{char-list/number} is a char-list, it reads from @var{port}
until it sees a character that belongs to the char-list.
Then the character is returned.
If @var{port} is omitted, the current input port is used.
@end defun

@defun skip-while char-list &optional port
Reads from @var{port} until it sees a character that does not
belong to @var{char-list}.  The character remains in the stream.
If it reaches EOF, an EOF is returned.
If @var{port} is omitted, the current input port is used.

This example skips whitespaces from input.  Next read from
port returns the first non-whitespace character.
@example
(skip-while #[\s] port)
@end example
@end defun

@defun next-token prefix-char-list break-char-list &optional comment port
Skips any number of characters in @var{prefix-char-list},
then collects the characters until it sees @var{break-char-list}.
The collected characters are returned as a string.
The break character remains in the @var{port}.

If the function encounters EOF and @code{*eof*} is not included in
@var{break-char-list}, an error is signalled with @var{comment} is
included in the message.
@end defun

@defun next-token-of char-list/pred &optional port
Reads and collects the characters as far as
it belongs to @var{char-list/pred}, then returns them as a string.
The first character that doesn't belong to @var{char-list/pred} remains
on the port.

@var{char-list/pred} may be a char-list or a predicate that takes
a character.   If it is a predicate, each character is passed to it,
and the character is regarded to ``belong to'' @var{char-list/pred}
when it returns a true value.
@end defun

@defun read-string n &optional port
Reads up to @var{n} characters, collects them into a string, and returns it.
If the input stream contains less characters, the returns string contains
as many characters available.
@end defun

@c ----------------------------------------------------------------------
@node Transliterate characters, Lazy text construction, Parsing input stream, Library modules
@section @code{text.tr} - Transliterate characters
@c NODE 文字変換, @code{text.tr} - 文字変換

@deftp {Module} text.tr
@mdindex text.tr
@c EN
This module implements a transliterate function,
that substitutes characters of the input string.
This functionality is realized in Unix @code{tr(1)} command,
and incorporated in various programs such as @code{sed(1)}
and @code{perl}.

Gauche's @code{tr} is aware of multibyte characters.
@c JP
このモジュールは、入力ストリームから指定の文字を置き換えて出力する、
文字変換(transliterate)機能を提供します。
Unixの@code{tr(1)}コマンドで実装され、@code{sed}や@code{perl}にも
採り入れられている機能です。

Gaucheの@code{tr}はマルチバイト文字／文字列を正しく扱います。
@c COMMON
@end deftp

@defun tr from-list to-list &keyword :complement :delete :squeeze :table-size :input :output
@c EN
Reads from @var{input} and writes to @var{output},
with transliterating characters in @var{from-list} to the
corresponding ones in @var{to-list}.  Characters that doesn't
appear in @var{from-list} are passed through.
@c JP
@var{input}から文字を読み込み、その文字が@var{from-list}内にあれば
対応する@var{to-list}内の文字に置き換えて、@var{output}へと書き出します。
@var{from-list}に無い文字はそのまま@var{output}へと渡されます。
@c COMMON

@c EN
The default values of @var{input} and @var{output} are
current input port and current output port, respectively.
@c JP
@var{input}と@var{output}の既定値はそれぞれ現在の入力ポートと
出力ポートです。
@c COMMON

@c EN
Both @var{from-list} and @var{to-list} must be strings.
They may contain the following special syntax.
Other characters that doesn't fits in the syntax are taken as they are.
@c JP
@var{from-list}と@var{to-list}は文字列でなければなりません。
その中には次のような表記を使うことができます。それ以外の文字はそのまま使われます。
@c COMMON

@table @code
@item @b{x-y}
@c EN
Expanded to the increasing sequence of characters from @code{x} to @code{y},
inclusive.  The order is determined by the internal character
encoding system; generally it is safer to limit use of this within
the range of the same character class.   The character @code{x}
must be before @code{y}.
@c JP
文字@code{x}から文字@code{y}までの文字の昇順の並びと解釈されます。
@code{x}と@code{y}は含まれます。文字の並びはGaucheの内部文字エンコーディングに
よって決定されるので、一般には@code{x}と@code{y}は同じキャラクタクラスの中に
止めておいた方が安全でしょう。@code{x}は@code{y}より小さくなければなりません。
@c COMMON

@item @b{x*n}
@c EN
Repeat @code{x} for @code{n} times.  @code{n} is a decimal number notation.
Meaningful only in
@var{to-list}; it is an error to use this form in @var{from-list}.
If @code{n} is omitted or zero, @code{x} is repeated until @var{to-list}
matches the length of @var{from-list} (any character after it is ignored).
@c JP
文字@code{x}の@code{n}個の並び。@code{n}は10進数で表記された数値です。
これは@var{to-list}でのみ有効で、@var{from-list}で使うとエラーになります。
@code{n}が省略されるか0の場合、@code{x}は@var{to-list}の長さが@var{from-list}
の長さに達するまで繰り返されます(その場合、@var{to-list}の残りは無視されます)。
@c COMMON

@item @b{@code{\}x}
@c EN
Represents @code{x} itself.  Use this escape to avoid a special
character to be interpreted as itself.   Note that if you place
a backslash in a string, you must write @code{\\}, for the Scheme
reader also interprets backslash as a special character.

There's no special sequence to represent non-graphical characters,
for you can put such characters by the string syntax.
@c JP
文字@code{x}それ自身。特殊文字そのものを埋め込みたい場合に使います。
文字列のリーダも@code{\}を解釈するので、@code{\\}と書かねばならないことに注意
して下さい。

グラフィカルでない文字のための構文はありません。文字列リーダの構文を使って
そのような文字を文字列に含めることができます。
@c COMMON
@end table

@c EN
Here's some basic examples.
@example
;; @r{swaps case of input}
(tr "A-Za-z" "a-zA-Z")

;; @r{replaces 7-bit non-graphical characters to `?'}
(tr "\x00-\x19\x7f" "?*")
@end example
@c JP
いくつか例を挙げます。
@example
;; @r{大文字と小文字を交換します}
(tr "A-Za-z" "a-zA-Z")

;; @r{ひらがなとかたかなを交換します}
(tr "ぁ-んァ-ン" "ァ-ンぁ-ん")

;; @r{7ビットのノングラフィカルな文字を`?'に変換します}
(tr "\x00-\x19\x7f" "?*")
@end example
@c COMMON

@c EN
If @var{to-list} is shorter than @var{from-list}, the behavior
depends on the keyword argument @var{delete}.  If a true value is
given,  characters that appear in @var{from-list} but not
in @var{to-list} are deleted.   Otherwise, 
the extra characters in @var{from-list} are just passed through.
@c JP
@var{to-list}が@var{from-list}より短い場合、動作はキーワード引数@var{delete}に
依存します。もし真の値が@var{delete}に与えられれば、@var{from-list}に現われて
@var{to-list}に対応するものがない文字は入力から取り除かれます。そうでなければ
そのような文字はそのまま出力されます。
@c COMMON

@c EN
When a true value is specified to @var{complement},
the character set in @var{from-list} is complemented.
Note that it implies @emph{huge} set of characters,
so it is not very useful unless either output character
set is a single character (using `*') or used with
@code{delete} keyword.
@c JP
真の値が@var{complement}に与えられた場合、@var{from-list}の文字の
補集合が@var{from-list}として使われます。この文字集合は極めて大きくなる
可能性があることに注意してください。従って、一般にこのオプションは
@var{to-list}に`*'を使ってそれらの文字を一文字にマッピングするか、
@code{delete}オプションと併用するかしないとあまり意味がありません。
@c COMMON

@c EN
When a true value is specified to @var{squeeze},
the sequence of the same replaced characters is squeezed to one.
If @var{to-list} is empty, the sequence of the same characters
in @var{from-list} is squeezed.
@c JP
真の値が@var{squeeze}に与えられた場合、同じ文字への置換が2つ以上並ぶ場合に
2つめ以降の文字が削除されます。@var{to-list}が空の場合は、@var{from-list}
に含まれる文字で同一文字が並んだ場合に2つめ以降の文字が削除されます。
@c COMMON

@c EN
Internally, @code{tr} builds a table to map the characters for
efficiency.  Since Gauche can deal with potentially huge set
of characters, it limits the use of the table for only smaller
characters (<256 by default).  If you want to transliterate
multibyte characters on the large text, however, you might want 
to use larger table, trading off the memory usage.  You can specify
the internal table size by @var{table-size} keyword argument.
For example, if you transliterate lots of EUC-JP hiragana text
to katakana, you may want to set table size greater than 42483
(the character code of the last katakana).
@c JP
内部的に、@code{tr}はキャラクタのマッピングのためにテーブルを使用します。
但し、Gaucheでは極めて大きな文字セットを扱うため、テーブルはキャラクタコードの
小さい文字のみに対して使われます(デフォルトではコード255以下の文字)。
もし、より大きな文字を頻繁に変換することが分かっていて、メモリを余分に使っても
速度を上げたい場合は、このテーブルの大きさを@var{table-size}キーワード引数で
指定することができます。例えばEUC-JPコードで大量の平仮名と片仮名を変換する場合は、
@var{table-size}を42483以上にすると、全ての変換がテーブルルックアップで
行われます。
@c COMMON

@c EN
Note that the pre-calculation to build the transliterate table
needs some overhead.  If you want to call @code{tr} many times
inside loop, consider to use @code{build-transliterator} described below.
@c JP
@code{tr}が変換テーブルを計算するのにいくらかオーバーヘッドがあることに
注意して下さい。内側のループで@code{tr}を繰り返し呼ぶような場合は
下に示す@code{build-transliterator}を使った方が良いでしょう。
@c COMMON
@end defun

@defun string-tr string from-list to-list &keyword :complement :delete :squeeze :table-size
@c EN
Works like @code{tr}, except that input is taken from a string @var{string}.
@c JP
入力を@var{string}から取って変換結果を文字列で返す以外は@code{tr}と同じです。
@c COMMON
@end defun

@defun build-transliterator from-list to-list &keyword :complement :delete :squeeze :table-size :input :output
@c EN
Returns a procedure that does the actual transliteration.  This effectively
``pre-compiles'' the internal data structure.   If you want to run
@code{tr} with the same sets repeatedly, you may build the procedure
once and apply it repeatedly, saving the overhead of initialization.
@c JP
実際の変換動作をする手続きを作成して返します。内部データのセットアップを済ませるため、
同じ文字変換セットに対して@code{tr}を繰り返し呼ぶような場合は、この手続きを用いることで
初期化のオーバヘッドを軽減することができます。
@c COMMON

@example
(with-input-from-file "huge-file.txt"
  (lambda ()
    (let loop ((line (read-line)))
      (unless (eof-object? line) (tr "A-Za-z" "a-zA-Z")))))

@c EN
;; @r{runs more efficiently...}
@c JP
;; @r{以下の方が効率良く動作します...}
@c COMMON

(with-input-from-file "huge-file.txt"
  (lambda ()
    (let ((ptr (build-transliterator "A-Za-z" "a-zA-Z")))
      (let loop ((line (read-line)))
        (unless (eof-object? line) (ptr))))))
@end example

@end defun

@c ----------------------------------------------------------------------
@node Lazy text construction, Determine isomorphism, Transliterate characters, Library modules
@section @code{text.tree} - Lazy text construction

@deftp {Module} text.tree
@mdindex text.tree
@c EN
Defines simple but commonly used functions for a text construction.

When you generate a text by a program, 
It is a very common operation to concatenate text segments.
However, using string-append repeatedly causes unnecessary
copying of intermediate strings, and sometimes such intermediate
strings are discarded due to the error situation (for example,
think about constucting an HTML document in the CGI script).

The efficient technique is to delay concatenation of those
text segments until it is needed.  In Scheme it is done very
easily by just consing the text segments together, thus forming
a tree of text, and then traverse the tree to construct a text.
You can even directly writes out the text during traversal,
avoiding intermediate string buffer.
(Hans Boehm's ``cord'' library, which comes with his garbage
collector library, uses this technique and proves it is very
efficient for editor-type application).

Although the traversal of the tree can be written in a
few lines of Scheme, I provide this module in the spirits
of OnceAndOnlyOnce.   Also it's easier if we have a common interface.
@c JP
テキストを生成する場合によく使われるシンプルな手続きを定義します。

プログラムでテキストを生成する場合、テキストの断片をつなぎ合わせて行く操作が
非常に多く現われます。しかし単純に@code{string-append}を繰り返し
呼んでしまうと、中間結果の文字列を保持するためだけにメモリアロケーションが多発しますし、
途中でエラーが発生した場合にその中間結果は結局捨てられてしまうかもしれません
(例えば、CGIスクリプト中でHTMLドキュメントを構築してゆくような場合を考えてみて下さい)。

よく知られた効率の良い方法は、テキストの断片をつなぎ合わせるのを本当に必要に
なるまで遅らせることです。Schemeではそれは非常に簡単です。単に断片をコンス
していって木構造を作り、最後にそれをトラバースしてテキストを作成するのです。
場合によっては、トラバースしながらテキストを出力すれば事足りてしまうので、
中間結果のバッファを持つ必要さえありません。
(Hans Boehmのガベージコレクションライブラリに附属している ``cord'' ライブラリ
はこのテクニックを実装したもので、エディタ等のアプリケーションで非常に効率良く
動作することが知られています)。

木構造をトラバースする手続きなどほんの2〜3行で書けてしまいますが、
「一度、そして一度だけ」の精神の下に、このモジュールを提供します。
インタフェースが統一されてたほうが便利ですしね。
@c COMMON
@end deftp

@deffn {Generic Function} write-tree tree &optional out
@c EN
Writes out an @var{tree} as a tree of text, to the output port @var{out}.
If @var{out} is omitted, the current output port is used.

Two methods are defined for this generic function, as shown below.
If you have more complex behavior, you can define more methods
to customize the behavior.
@c JP
@var{tree}をテキストの木構造とみなして、出力ポート@var{out}に出力します。
@var{out}が省略された場合は現在の出力ポートが使われます。

下に示す2つのメソッドが定義されています。より複雑な動作をさせたい場合は、
単純なリストの替わりにノードとなるクラスを定義して、それにメソッドを定義するようにすれば
動作をカスタマイズできます。
@c COMMON
@end deffn

@deffn {Method} write-tree ((tree <list>) out)
@deffnx {Method} write-tree ((tree <top>) out)
@c EN
Default methods.  For a list, @code{write-tree} is recursively
called for each element.  Any objects other than list is written out
using @code{display}.
@c JP
@code{write-tree}の既定の動作です。@var{tree}がリストなら、その要素それぞれに
ついて@code{write-tree}を呼び出します。それ以外のオブジェクトに関しては
@code{display}を呼んで出力します。
@c COMMON
@end deffn

@defun tree->string tree
@c EN
Just calls the @code{write-tree} method for @var{tree} using
an output string port, and returns the result string.
@c JP
出力文字列ポートを作成して@code{write-tree}を呼び、生成された文字列を返します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Determine isomorphism, Queue, Lazy text construction, Library modules
@section @code{util.isomorph} - Determine isomorphism
@c NODE 同型判定, @code{util.isomorph} - 同型判定

@deftp {Module} util.isomorph
@mdindex util.isomorph
@c EN
Provides a procedure that determines whether two structures are
isomorphic.
@c JP
二つの構造が同型かどうかを判定する手続きを提供するモジュールです。
@c COMMON
@end deftp

@defun isomorphic? obj1 obj2 &optional context
@c EN
Returns @code{#t} if @var{obj1} and @var{obj2} are isomorphic.

@var{context} is used if you want to call @code{isomorphic?}
recursively inside @code{object-isomorphic?} described below.
@c JP
@var{obj1}と@var{obj2}が同型であれば@code{#t}を返します。

省略可能な引数@var{context}は、下で説明する@code{object-isomorphic?}
の中から@code{isomorphic?}を再帰的に呼び出す場合に使います。
@c COMMON

@example
(isomorphic? '(a b) '(a b)) @result{} #t

(define x (cons 0 0))
(define y (cons 0 0))
(isomorphic? (cons x x)
             (cons x y))
 @result{} #f
(isomorphic? (cons x x)
             (cons y y))
 @result{} #t
@end example
@end defun

@deffn {Generic Function} object-isomorphic? obj1 obj2 context
@c EN
With this method, you can customize how to determine isomorphism of
two objects.  Basically, you will call @code{isomorphic?} recursively
for each slots of object you want to traverse; the method should return
@code{#t} if all of the test succeeds, or return @code{#f} otherwise.
@var{context} is an opaque structure
that keeps the traversal context, and you should pass it to
@code{isomorphic?} as is.

The default method returns @code{#t} if @var{obj1} and @var{obj2} are
equal (in the sense of @code{equal?}).
@c JP
このメソッドで、二つのオブジェクトの同型判定処理をカスタマイズできます。
基本的には、オブジェクトのトラバースしたいスロットに対して@code{isomorphic?}を順に適用し、
全てが成功すれば@code{#t}を、一つでも失敗すれば@code{#f}を返すようにします。
@var{context}はトラバースのコンテクストを保持しているオブジェクトです。そのまま
@code{isomorphic?}に渡して下さい。

デフォルトメソッドは、@var{obj1}と@var{obj2}が@code{equal?}の意味で等しければ
@code{#t}を返します。
@c COMMON
@end deffn

@c ----------------------------------------------------------------------
@node Queue, Topological sort, Determine isomorphism, Library modules
@section @code{util.queue} - Queue
@c NODE キュー, @code{util.queue} - キュー

@deftp {Module} util.queue
@mdindex util.queue
@c EN
Provides a queue (FIFO).   This implementation is tuned for speed
than safety; a queue is simply a pair that keeps head and tail of
the queue, and minimal check is done in most of the operations.

SLIB (@xref{SLIB}) provides the queue library that is safer.
This API is upper compatible to the SLIB's.
The idea is that this queue is used inside other procedure or
structure that you know you don't need the strict checks.
Use either one depending on your requirement.
@c JP
キュー(FIFO)機能を提供します。この実装は安全さよりスピードに重点を置いています。
キューは単に先頭と末尾のpairで表現され、多くのオペレーションでキューが正しいかどうかは
チェックされません。

SLIB (@ref{SLIB}参照)にはより安全なキューの実装があります。
このAPIはSLIBの実装の上位互換です。特定の手続きや構造体の中だけで使うため、
厳しいチェックが必要でない場合にはこのモジュールを使うのが良く、そうでない場合は
SLIBのものが良いでしょう。要求仕様によって使い分けて下さい。
@c COMMON
@end deftp

@defun make-queue
@c EN
Creates and returns an empty queue.
@c JP
空のキューを作って返します。
@c COMMON
@end defun

@defun queue? obj
@c EN
Returns @code{#t} if @var{obj} is a queue.  This operation checks
@var{obj} is really in a shape of the queue.
@c JP
@var{obj}がキューであれば@code{#t}を返します。この操作に限り、@var{obj}が
本当にキューの構造をしているかどうかのチェックがなされます。
@c COMMON
@end defun

@defun queue-empty? queue
@c EN
Returns @code{#t} if @var{obj} is an empty queue.
@c JP
@var{obj}が空のキューであれば@code{#t}を返します。
@c COMMON
@end defun

@defun enqueue! queue obj &optional more-objs @dots{}
@c EN
Add @var{obj} to the end of @var{queue}.  You may give more than
one object, and each of them are enqueued in order.
(Note: SLIB version doesn't take the optional arguments).
@c JP
@var{obj}をキュー@var{queue}の末尾に追加します。
一つ以上の@var{obj}を与えることができ、その場合はそれらが順にenqueueされます。
(註：SLIBの@code{enqueue!}はオプショナルな引数を取りません)。
@c COMMON
@end defun

@defun queue-push! queue obj &optional more-objs @dots{}
@c EN
Add @var{obj} in front of @var{queue}.  You may give more than
one object, and each of them are pushed in order.
(Note: SLIB version doesn't take the optional arguments).
@c JP
@var{obj}をキュー@var{queue}の先頭に追加します。
一つ以上の@var{obj}を与えることができ、その場合はそれらが順にpushされます。
(註：SLIBの@code{queue-push!}はオプショナルな引数を取りません)。
@c COMMON
@end defun

@defun dequeue! queue
@defunx queue-pop! queue
@c EN
Take one object from the front of the queue @var{queue} and returns it.
Both function works the same, but @code{queue-pop!} may be used to
emphasize it works with @code{queue-push!}.  An error is signalled
if @var{queue} is empty.
@c JP
キュー@var{queue}の先頭からひとつ要素を取って返します。
二つの手続きは全く同じ動作をします。@code{queue-pop!}は@code{queue-push!}と
ペアで使われていることを強調したいときに使うと良いでしょう。キューが空の場合は
エラーが報告されます。
@c COMMON
@end defun

@defun dequeue-all! queue
@c EN
Returns the whole content of the queue by a list, with emptying
@var{queue}.   If @var{queue} is already empty, returns an empty list.
@c JP
キューの全ての内容をリストにして返します。キューそのものは空になります。
キューが既に空の場合は空リストが返されます。
@c COMMON
@end defun

@defun queue-front queue
@defunx queue-rear queue
@c EN
Peek the head or the tail of the queue and returns the object, respectively.
@var{Queue} is not modified.  An error is signalled
if @var{queue} is empty.
@c JP
キュー@var{queue}の先頭もしくは末尾の要素を返します。キューそのものは変更されません。
キューが空の場合はエラーが報告されます。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Topological sort, CGI Utility, Queue, Library modules
@section @code{util.toposort} - Topological sort
@c NODE トポロジカルソート, @code{util.toposort} - トポロジカルソート

@deftp {Module} util.toposort
@mdindex util.toposort
@c EN
Implements topological sort algorithm.
@c JP
トポロジカルソートのアルゴリズムを実装します。
@c COMMON
@end deftp

@defun topological-sort graph &optional eqproc
@c EN
@var{Graph} represents a directed acyclic graph (DAG) by a list
of connections, where each connection is the form
@example
(<node> <downstream> <downstream2> ...)
@end example
that means a node @code{<node>} is connected to other nodes
@code{<downstream>} etc.   @code{<node>} can be arbitrary
object, as far as it can be compared by the procedure @var{eqproc},
which is @var{eqv?} by default (@xref{Equivalence}).
Returns a list of @code{<node>}s sorted topologically.

If the graph contains circular reference, an error is signalled.
@c JP
@var{Graph}は有向非循環グラフ(DAG)を表現するリストです。
リストの各要素は次の形をしています。
@example
(<node> <downstream> <downstream2> ...)
@end example
これで、ノード@code{<node>}から別のノード@code{<downstream>}等への接続が
あることを表現します。@code{<node>}はどんなオブジェクトであっても構いませんが、
同一性の判定が@var{eqproc}で行えなければなりません。@var{eqproc}の既定値は
@code{eqv?}です (@ref{Equivalence}参照)。
トポロジカルにソートされたノードのリストを返します。

グラフに循環が検出された場合はエラーとなります。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node CGI Utility,  , Topological sort, Library modules
@section @code{www.cgi} - CGI utility
@c NODE CGIユーティリティ, @code{www.cgi} - CGIユーティリティ

@deftp {Module} www.cgi
@mdindex www.cgi
@c EN
Provides a few basic functions useful to write a CGI script.

In order to write CGI script easily, you may want to use
other modules, such as @code{rfc.uri} (@xref{URI parsing and construction}),
@code{text.html-lite} (@xref{Simple HTML document construction}) and
@code{text.tree} (@xref{Lazy text construction}).

Note: it seems that there is no active formal specification for CGI.
See @uref{http://w3c.org/CGI/} for more information.
@c JP
CGIスクリプトを書くのに便利ないくつかの基本的な手続きを提供します。

CGIスクリプトを手軽に書くにはこのモジュールの他に、
@code{rfc.uri} (@ref{URI parsing and construction})、
@code{text.html-lite} (@ref{Simple HTML document construction})、
@code{text.tree} (@ref{Lazy text construction}) 等のモジュールを併せて
使うとよいでしょう。

注：現在有効な、CGIに関する「正式な」仕様というのはどうも無いようです。
@uref{http://w3c.org/CGI/}あたりを参照して下さい。
@c COMMON
@end deftp

@defun cgi-parse-parameters &keyword :query-string :merge-cookies
@c EN
Parses query string and returns associative list of parameters.
When a keyword argument @var{query-string} is given, it is used
as a source query string.  Otherwise, the function checks the environment
variable @code{REQUEST_METHOD} and obtain the query string
depending on the value (either from stdin or from the environment
variable @code{QUERY_STRING}).
If such an environment variable is not defined and
the current input port is a terminal, the function prompts the user
to type parameters; useful for interactive debugging.
@c JP
CGIプログラムに渡されたquery stringをパーズして、パラメータの連想リストにして
返します。文字列がキーワード引数@var{query-string}に与えられればそれがパーズすべき
query stringとなります。その引数が渡されなければこの手続きは環境変数@code{REQUEST_METHOD}を
参照し、その値によって標準入力もしくは
環境変数@code{QUERY_STRING}からquery stringが取られます。
そのような環境変数が定義されておらず、かつ現在の入力ポートが端末である場合、
インタラクティブにデバッグをしているものと考えて、
この手続きはプロンプトを出してユーザにパラメータの入力を促します。
@c COMMON

@c EN
When a true value is given to @var{merge-cookies}, the cookie
values obtained from the environment variable @code{HTTP_COOKIE}
are appended to the result.
@c JP
キーワード引数@var{merge-cookies}に真の値が与えられた場合は、
環境変数@code{HTTP_COOKIE}からクッキーの値が読まれ、解析されて
結果に追加されます。
@c COMMON

@c EN
Note that the query parameter may have multiple values,
so @code{cdr} of each element in the result is a list, not an atom.
If no value is given to the parameter, @code{#t} is placed as its value.
See the following example:
@c JP
パラメータは複数の値を取り得るため、結果のパラメータに対応する値は常にリストになります。
パラメータに値が与えられていなければ、結果のパラメータに対する値には@code{#t}が置かれます。
次の例を参照して下さい。
@c COMMON
@example
(cgi-parse-parameters
  :query-string "foo=123&bar=%22%3f%3f%22&bar=zz&buzz")
 @result{} (("foo" "123") ("bar "\"??\"" "zz") ("buzz #t))
@end example
@end defun

@defun cgi-get-parameter name params &keyword :default :list :convert
@c EN
A convenient function to obtain a value of the parameter @var{name} from
parsed query string @var{params}, which is the value
@code{cgi-parse-parameters} returns.
@c JP
@code{cgi-parse-parameters}が返す、パーズされたQuery文字列@var{params}から、
名前@var{name}を持つパラメータの値を簡単に取り出すための手続きです。
@c COMMON

@c EN
Unless true value is given to @var{list}, the returned value is
a scalar value.  If more than one value is associated to @var{name},
only the first value is returned.  If @var{list} is true, the
returned value is always a list, even @var{name} has only one value.
@c JP
キーワード引数@var{list}に真の値が与えられていなければ、
返される値はスカラー値です。パラメータ@var{name}に複数の値が与えられた場合でも、
最初の値のみが返されます。@var{list}に真の値が与えられれば、返されるのは
常に値のリストとなります。
@c COMMON

@c EN
After the value is retrieved, you can apply a procedure to
convert the string value to the appropriate type by giving
a procedure to the @var{convert} argument.  The procedure must
take one string argument.  If @var{list} is true, the convert
procedure is applied to each values.
@c JP
キーワード引数@var{convert}に手続きを与えると、対応する値が取り出された後でその
手続きが値を引数として呼ばれます。これによって値を文字列から必要な型へと変換することが
できます。@var{list}に真の値が与えられている場合、変換手続きは各値に対して呼ばれ、
その結果のリストが@var{cgi-get-parameter}から返されます。
@c COMMON

@c EN
If no value is defined for @var{name}, a value given to the keyword
argument @var{default} is returned; the default value of @var{default}
is @code{#f} if @var{list} is false, or @code{()} otherwise.
@c JP
パラメータ@var{name}に対応する値が無ければ、@var{default}に与えられた値がそのまま
返されます。@var{default}が省略された場合、@var{list}が偽であれば@code{#f}が、
真であれば@code{()}が返されます。
@c COMMON
@end defun

@defun cgi-header &keyword content-type location cookies
@c EN
Creates a text tree (@xref{Lazy text construction}) for the
HTTP header of the reply message.  The most simple form is
like this:
@c JP
HTTPリプライメッセージのヘッダを、テキストツリー形式(@ref{Lazy text construction}参照)
で作成して返します。最も簡単な呼び出しでは次のようになります。
@c COMMON
@example
(tree->string (cgi-header))
  @result{} "Content-type: text/html\r\n\r\n"
@end example

@c EN
You can specify alternative content-type by the keyword argument
@var{content-type}.   If you want to set cookies to the client,
specify a list of cookie strings to the keyword argument @var{cookies}.
You can use @code{construct-cookie-string} (@xref{HTTP cookie handling})
to build such a list of cookie strings.
@c JP
キーワード引数@var{content-type}によってContent typeを指定できます。
また、@var{cookies}にクッキー文字列のリストを渡すことにより、
クライアントにクッキーを設定できます。クッキー文字列を構築するには手続き
@code{construct-cookie-string} (@ref{HTTP cookie handling}参照)
が使えます。
@c COMMON

@c EN
The keyword argument @var{location} may be used to generate
a @code{Location:} header to redirect the client to the specified URI.
@c JP
キーワード引数@var{location}は、@code{Location}ヘッダを作成して
クライアントを別のURIに誘導するのに使えます。
@c COMMON
@end defun

@defun cgi-main proc &keyword on-error merge-cookies
@c EN
A convenient wrapper function for CGI script.
This function calls @code{cgi-parse-parameters}, then calls
@var{proc} with the result of @code{cgi-parse-parameters}.
The keyword argument @var{merge-cookies} is passed to
@code{cgi-parse-parameters}.
@c JP
CGIスクリプトのための便利なラッパー手続きです。
この手続きは、まず@code{cgi-parse-parameters}を呼び出してCGIスクリプトに
渡されたパラメータを解析し、続いてその結果を引数として@var{proc}を呼び出します。
キーワード引数@var{merge-cookies}は、与えられればそのまま
@code{cgi-parse-parameters}に渡されます。
@c COMMON

@c EN
@var{proc} has to return a tree of strings
(@xref{Lazy text construction}), including the HTTP header.
@code{cgi-main} outputs the returned tree to the current output port
by @code{write-tree}, then returns zero.
@c JP
手続き@var{proc}はHTTPヘッダを含むドキュメントを
テキストツリー構造(@ref{Lazy text construction}参照)で
返さなければなりません。@code{cgi-main}はそれを@code{write-tree}を使って
現在の出力ポートに書き出し、0を返します。
@c COMMON

@c EN
If an error is signalled in @var{proc}, it is caught and an HTML
page reporting the error is generated.  You can customize the
error page by providing a procedure to the @var{on-error} keyword argument.
The procedure takes an @code{<exception>} object (@xref{Exception object}),
and has to return a tree of string for the error reporting HTML
page, including an HTTP header.
@c JP
もし@var{proc}内でエラーが起こった場合、そのエラーは捕捉されて、エラーを報告する
HTMLページが作成されて出力されます。このエラーページは、@var{on-error}キーワード引数に
手続きを渡すことでカスタマイズできます。@var{on-error}に渡された手続きは
エラー発生時に@code{<exception>}オブジェクト(@ref{Exception object}参照)
を引数として呼ばれ、HTTPヘッダを含むドキュメントをテキストツリー構造で返さねばなりません。
@c COMMON

@c EN
The following example shows the parameters given to the CGI program.
@c JP
以下の例はCGIに渡されたパラメータ全てをテーブルにして表示します。
@c COMMON

@example
#!/usr/local/bin/gosh

(use text.html-lite)
(use www.cgi)

(define (main args)
  (cgi-main
    (lambda (params)
      `(,(cgi-header)
        ,(html-doctype)
        ,(html:html
          (html:head (html:title "Example"))
          (html:body
           (html:table
            :border 1
            (html:tr (html:th "Name") (html:th "Value"))
            (map (lambda (p)
                   (html:tr
                    (html:td (html-escape-string (car p)))
                    (html:td (html-escape-string (x->string (cdr p))))))
                 params))))
       ))))
@end example
@end defun

@c ======================================================================
@node References, C to Scheme mapping, Library modules, Top
@appendix References
@c NODE 参考文献

@table @asis
@anchor{r5rs}
@item [R5RS]
R. Kelsey, W. Clinger, J. Rees (eds.),
Revised^5 Report on the Algorithmic Language Scheme,
Higher-Order and Symbolic Computation, 11(1), September, 1998
and ACM SIGPLAN Notices, 33(9), October, 1998. @*
@url{http://www.schemers.org/Documents/Standards/R5RS/}.

@anchor{onecont}
@item [1CC]
Carl Bruggeman, Oscar Waddell and R. Kent Dybvig,
Representing control in the presence of one-shot continuations,
in @i{Proceedings of SIGPLAN '96}, pp. 99--107, 1996.

@anchor{mop}
@item [MOP]
Gregor Kiczales, Jim Des Rivieres, Daniel Bobrow,
The Art of Metaobject Protocol, 
The MIT Press.

@anchor{rfc2045}
@item [RFC2045]
N. Freed, N. Borenstein: Multipurpose Internet Mail Extension
(MIME) Part One: Format of Internet Message Bodies,
November 1996. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2045.txt}.

@anchor{rfc2396}
@item [RFC2396]
T. Berners-Lee, R. Fielding, L. Masinter,
Uniform Resource Identifiers (URI): Generic Syntax,
August 1998. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2396.txt}.

@anchor{rfc2822}
@item [RFC2822]
P. Resnick (ed.), Internet Message Format, April 2001. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2822.txt}.

@anchor{rfc2965}
@item [RFC2965]
D. Kristol, L. Montulli, HTTP State Management Mechanism,
October 2000. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2965.txt}.

@anchor{srfi-0}
@item [SRFI-0]
Marc Feeley, Feature-based conditional expansion construct, May  1999.@*
@url{http://srfi.schemers.org/srfi-0/srfi-0.html}.

@anchor{srfi-1}
@item [SRFI-1]
Olin Shivers, List Library, October 1999. @*
@url{http://srfi.schemers.org/srfi-1/srfi-1.html}.

@anchor{srfi-2}
@item [SRFI-2]
Oleg Kiselyov, @code{AND-LET*}: an @code{AND} with local bindings, a guarded 
@code{LET*} special form, March 1998. @*
@url{http://srfi.schemers.org/srfi-2/srfi-2.html}.

@anchor{srfi-4}
@item [SRFI-4]
Marc Feeley, Homogeneous numeric vector types, May 1999.@*
@url{http://srfi.schemers.org/srfi-4/srfi-4.html}.

@anchor{srfi-6}
@item [SRFI-6]
William D Clinger, Basic String Ports, July 1999. @*
@url{http://srfi.schemers.org/srfi-6/srfi-6.html}.

@anchor{srfi-8}
@item [SRFI-8]
John David Stone, receive: Binding to multiple values, August 1999. @*
@url{http://srfi.schemers.org/srfi-8/srfi-8.html}.

@anchor{srfi-9}
@item [SRFI-9]
Richard Kelsey, Defining Record Types, September 1999.@*
@url{http://srfi.schemers.org/srfi-9/srfi-9.html}.

@anchor{srfi-10}
@item [SRFI-10]
Oleg Kiselyov, @code{#,} external form, January 2000.@*
@url{http://srfi.schemers.org/srfi-10/srfi-10.html}.

@anchor{srfi-11}
@item [SRFI-11]
Lars T Hansen, Syntax for receiving multiple values, March 2000. @*
@url{http://srfi.schemers.org/srfi-11/srfi-11.html}.

@anchor{srfi-13}
@item [SRFI-13]
Olin Shivers, String Libraries, December 2000. @*
@url{http://srfi.schemers.org/srfi-13/srfi-13.html}.

@anchor{srfi-14}
@item [SRFI-14]
Olin Shivers, Character-set Library, December 2000. @*
@url{http://srfi.schemers.org/srfi-14/srfi-14.html}.

@anchor{srfi-17}
@item [SRFI-17]
Per Bothner, Generalized @code{set!}, July 2000. @*
@url{http://srfi.schemers.org/srfi-17/srfi-17.html}.

@anchor{srfi-22}
@item [SRFI-22]
Martin Gasbichler and Michael Sperber, 
Running Scheme Scripts on Unix, January 2002. @*
@url{http://srfi.schemers.org/srfi-22/srfi-22.html}.

@anchor{srfi-23}
@item [SRFI-23]
Stephan Housen, Error reporting mechanism, April 2001.@*
@url{http://srfi.schemers.org/srfi-23/srfi-23.html}.

@anchor{ssax}
@item [SSAX]
Oleg Kiselyov, XML and Scheme, @*
@url{http://pobox.com/~oleg/ftp/Scheme/xml.html}.@*
The SSAX distribution is also available at sourceforge:@*
@url{http://ssax.sourceforge.net/}.

@anchor{oleg1}
@item [OLEG1]
Oleg Kiselyov, Making sense of an input stream,@*
@url{http://pobox.com/~oleg/ftp/Scheme/parsing.html}.

@anchor{oleg2}
@item [OLEG2]
Oleg Kiselyov, General ways to traverse collections,,@*
@url{http://pobox.com/~oleg/ftp/Scheme/enumerators-callcc.html}.
2000.
@end table

@c ======================================================================
@node C to Scheme mapping, Indices, References, Top
@appendix C to Scheme mapping
@c NODE CとSchemeの関数の対応

@c EN
For the convenience of the programmers familiar to C, 
I composed a simple table of C operators and library functions with
the corresponding Scheme functions.
@c JP
Cに馴染んだプログラマのために、Cのオペレータとライブラリ関数からSchemeの関数への
対応表を示しておきます。
@c COMMON

@table @code
@item +
R5RS arithmetic procedure @code{+}.   @xref{Arithmetics}.
@item +=
Gauche @code{inc!} macro.  @xref{Assignments}.
@item -
R5RS arithmetic procedure @code{-}.   @xref{Arithmetics}.
@item -=
Gauche @code{dec!} macro.  @xref{Assignments}.
@item ->
Gauche @code{slot-ref} is something close to this.  @xref{Accessing Instance}.
@item * (binary)
R5RS arithmetic procedure @code{*}.   @xref{Arithmetics}.
@item * (unary)
No equivalent procedure.  Scheme doesn't have explicit notation of
pointers.
@item *=
No equivalent procedure.
@item /
R5RS arithmetic procedure @code{/}.   @xref{Arithmetics}.
@item /=
No equivalent procedure.
@item & (binary)
Gauche @code{logand}.  @xref{Bitwise operations}.
@item & (unary)
No equivalent procedure.  Scheme doesn't have explicit notation of
pointers.
@item &&
R5RS syntax @code{and}.  @xref{Conditionals}.
@item &=
No equivalent procedure.
@item |
Gauche @code{logior}.  @xref{Bitwise operations}.
@item ||
R5RS syntax @code{or}.  @xref{Conditionals}.
@item |=
No equivalent procedure.
@item ^
Gauche @code{logxor}.  @xref{Bitwise operations}.
@item =
R5RS syntax @code{set!}.  @xref{Assignments}.
@item ==
R5RS equivalence procedure, @code{eq?}, @code{eqv?} and @code{equal?}.
@xref{Equivalence}.
@item <
@itemx <=
R5RS arithmetic procedure @code{<} and @code{<=}.
@xref{Numerical comparison}.  Unlike C operator, Scheme version
is transitive.
@item <<
Gauche @code{ash}.  @xref{Bitwise operations}.
@item <<=
No equivalent procedure.
@item >
@itemx >=
R5RS arithmetic procedure @code{>} and @code{>=}.
@xref{Numerical comparison}.  Unlike C operator, Scheme version
is transitive.
@item >>
Gauche @code{ash}.  @xref{Bitwise operations}.
@item >>=
No equivalent procedure.
@item %
R5RS operator @code{modulo} and @code{remainder}.  @xref{Arithmetics}.
@item %=
No equivalent procedure.
@item []
R5RS @code{vector-ref} (@xref{Vectors}) is something close.
Or you can use Gauche's generic function @code{ref} (@xref{Sequence framework})
for arbitrary sequences.
@item .
Gauche @code{slot-ref} is something close to this.  @xref{Accessing Instance}.
@item ~
Gauche @code{lognot}.  @xref{Bitwise operations}.
@item ~=
No equivalent procedure.
@item !
R5RS procedure @code{not}.  @xref{Booleans}.
@item !=
No equivalent procedure.
@item abort
Gauche @code{sys-abort}. 
@item abs
R5RS @code{abs}.  @xref{Arithmetics}.
@item access
Gauche @code{sys-access}.  @xref{File stats}.
@item acos
R5RS @code{acos}.  @xref{Arithmetics}.
@item alarm
Gauche @code{sys-alarm}.   @xref{Miscellaneous system calls}.
@item asctime
Gauche @code{sys-asctime}.  @xref{Time}.
@item asin
R5RS @code{asin}.  @xref{Arithmetics}.
@item assert
No equivalent function in Gauche.
@item atan
@itemx atan2
R5RS @code{atan}.  @xref{Arithmetics}.
@item atexit
No equivalent function in Gauche, but the "after" thunk of active
dynamic handlers are called when @code{exit} is called.
@xref{Program termination}, and @xref{Continuation}.
@item atof
@itemx atoi
@itemx atol
You can use @code{string->number}.  @xref{Numerical conversions}.
@item bsearch
No equivalent function in Gauche.
@item calloc
Allocation is handled automatically in Scheme.
@item ceil
R5RS @code{ceiling}.  @xref{Arithmetics}.
@item cfgetispeed
@itemx cfgetospeed
@itemx cfsetispeed
@itemx cfsetospeed
Gauche @code{sys-cfgetispeed}, @code{sys-cfgetospeed},
@code{sys-cfsetispeed}, @code{sys-cfsetospeed}.  @xref{Termios}.
@item chdir
Gauche @code{sys-chdir}.   @xref{Other file operations}.
@item chmod
Gauche @code{sys-chmod}.   @xref{File stats}.
@item chown
Not supported yet.
@item clearerr
Not supported yet.
@item clock
No equivalent function in Gauche.  You can use @code{sys-times}
to get information about CPU time.
@item close
You can't directly close the file descriptor, but when you use
@code{close-input-port} or @code{close-output-port}, underlying
file is closed.  Some port-related functions, such as
@code{call-with-output-file}, automatically closes the file
when operation is finished.  The file is also closed when
its governing port is garbage collected.
@xref{Common port operations}.
@item closedir
No equivalent function in Gauche.  You can use
@code{sys-readdir} to read the directory entries at once.
@xref{Directories}.
@item cos
@itemx cosh
@code{cos} and @code{cosh}.  @xref{Arithmetics}.
@item creat
A file is implictly created by default when you open it for writing.
See @ref{File ports} for more control over the creation of files.
@item ctermid
Gauche @code{sys-ctermid}.  @xref{System Inquiry}.
@item ctime
Gauche @code{sys-ctime}.  @xref{Time}.
@item cuserid
No equivalent function.  This is removed from the newer POSIX.
You can use alternative functions, such as @code{sys-getlogin} or
@code{sys-getpwuid} with @code{sys-getuid}.
@item difftime
Gauche @code{sys-difftime}.  @xref{Time}.
@item div
You can use R5RS @code{quotient} and @code{remainder}.
@xref{Arithmetics}.
@item dup
@itemx dup2
No equivalent function.  If you want to use this function to
set up I/Os for the child process, you can use `iomap' argument
of @code{sys-exec}.  @xref{Fork and exec}.
@item execl
@itemx execle
@itemx execlp
@itemx execv
@itemx execve
@itemx execvp
Gauche @code{sys-exec}.  @xref{Fork and exec}.
For higher level interface, @ref{High Level Process Interface}.
@item exit
@item _exit
Use @code{exit} or @code{sys-exit}, depends on what you need.
@xref{Program termination}.
@item exp
R5RS @code{exp}.  @xref{Arithmetics}.
@item fabs
R5RS @code{abs}.  @xref{Arithmetics}.
@item fclose
You can't directly close the file stream, but when you use
@code{close-input-port} or @code{close-output-port}, underlying
file is closed.  Some port-related functions, such as
@code{call-with-output-file}, automatically closes the file
when operation is finished.  The file is also closed when
its governing port is garbage collected.
@item fcntl
Implented as @code{sys-fcntl} in @code{gauche.fcntl} module.
@xref{Low-level file operations}.
@item fdopen
Not supported yet.
@item feof
Not supported yet.
@item ferror
Not supported yet.
@item fflush
Gauche's @code{flush}.
@item fgetc
Use @code{read-char} or @code{read-byte}.  @xref{Input}.
@item fgetpos
Not supported yet.
@item fgets
Use @code{read-line}.    @xref{Input}.
@item fileno
@code{port-file-numer}.   @xref{Common port operations}.
@item floor
R5RS @code{floor}.   @xref{Arithmetics}.
@item fmod
Gauche's @code{sys-fmod}.
@item fopen
R5RS @code{open-input-file} or @code{open-output-file}
corresponds to this operation.  @xref{File ports}.
@item fork
Gauche's @code{sys-fork}.   @xref{Fork and exec}.
@item fpathconf
Not supported.
@item fprintf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item fputc
Use @code{write-char} or @code{write-byte}.  @xref{Output}.
@item fputs
Use @code{display}.  @xref{Output}.
@item fread
Not directly supported.  If you want to read a chunk
of bytes, you may be able to use @code{read-block}.
@item free
You don't need this in Scheme.
@item freopen
Not supported.
@item frexp
Gauche's @code{sys-frexp}
@item fscanf
Not supported.  For general case, you have to write a parser.
If you can keep the data in S-exp, you can use @code{read}.
If the syntax is very simple, you may be able to utilize
@code{string-tokenize} in @code{srfi-14} (@ref{String library}),
and/or regular expression stuff (@ref{Regular expression},
also @ref{Regular expression utilities}.
@item fseek
Not implemented yet.
@item fsetpos
Not implemented yet.
@item fstat
Gauche's @code{sys-stat}.  @xref{File stats}.
@item ftell
Not implemented yet.
@item fwrite
Not directly supported.  If you want to write a chunk of bytes,
you can simply use @code{display}.  @xref{Output}.
@item getc
@itemx getchar
Use @code{read-char} or @code{read-byte}.  @xref{Input}.
@item getcwd
Gauche's @code{sys-getcwd}.   @xref{System Inquiry}.
@item getegid
Gauche's @code{sys-getegid}.   @xref{System Inquiry}.
@item getenv
Gauche's @code{sys-getenv}.   @xref{Environment Inquiry}.
@item geteuid
Gauche's @code{sys-geteuid}.   @xref{System Inquiry}.
@item getgid
Gauche's @code{sys-getgid}.   @xref{System Inquiry}.
@item getgrgid
@itemx getgrnam
Gauche's @code{sys-getgrgid} and @code{sys-getgrnam}.  @xref{Unix group}.
@item getgroups
Gauche's @code{sys-getgroups}.   @xref{System Inquiry}.
@item getlogin
Gauche's @code{sys-getlogin}.  @xref{System Inquiry}.
@item getpgrp
Gauche's @code{sys-getpgrp}.   @xref{System Inquiry}.
@item getpid
@itemx getppid
Gauche's @code{sys-getpid}.   @xref{System Inquiry}.
@item getpwnam
@itemx getpwuid
Gauche's @code{sys-getpwnam} and @code{sys-getpwuid}.  @xref{Unix password}.
@item gets
Use @code{read-line}.  @xref{Input}.
@item getuid
Gauche's @code{sys-getuid}.  @xref{System Inquiry}.
@item gmtime
Gauche's @code{sys-gmtime}.   @xref{Time}.
@item isalnum
Not directly supported, but you can use R5RS @code{char-alphabetic?} and
@code{char-numeric?}.  @xref{Characters}.   You can also use
character set.  @xref{Character set}, also @ref{Character-set library}.
@item isalpha
R5RS @code{char-alphabetic?}.  @xref{Characters}.  See also
@ref{Character set} and @ref{Character-set library}.
@item isatty
Gauche's @code{sys-isatty}.   @xref{Other file operations}.
@item iscntrl
Not directly supported, but you can use
@code{(char-set-contains? char-set:iso-control c)} with @code{srfi-14}.
@xref{Character-set library}.
@item isdigit
R5RS @code{char-numeric?}.  @xref{Characters}. 
You can also use @code{(char-set-contains? char-set:digit c)}
with @code{srfi-14}.   @xref{Character-set library}.
@item isgraph
Not directly supported, but you can use
@code{(char-set-contains? char-set:graphic c)} with @code{srfi-14}.
@xref{Character-set library}.
@item islower
R5RS @code{char-lower-case?}.  @xref{Characters}.
You can also use @code{(char-set-contains? char-set:lower-case c)}
with @code{srfi-14}.   @xref{Character-set library}.
@item isprint
Not directly supported, but you can use
@code{(char-set-contains? char-set:printing c)} with @code{srfi-14}.
@xref{Character-set library}.
@item ispunct
Not directly supported, but you can use
@code{(char-set-contains? char-set:punctuation c)} with @code{srfi-14}.
@xref{Character-set library}.
@item isspace
R5RS @code{char-whitespace?}.  @xref{Characters}.
You can also use @code{(char-set-contains? char-set:whitespace c)}
with @code{srfi-14}.   @xref{Character-set library}.
@item isuppoer
R5RS @code{char-upper-case?}.  @xref{Characters}.
You can also use @code{(char-set-contains? char-set:upper-case c)}
with @code{srfi-14}.   @xref{Character-set library}.
@item isxdigit
Not directly supported, but you can use
@code{(char-set-contains? char-set:hex-digit c)} with @code{srfi-14}.
@xref{Character-set library}.
@item kill
Gauche's @code{sys-kill}.  @xref{Signal}.
@item labs
R5RS @code{abs}.  @xref{Arithmetics}.
@item ldexp
Not directly supported.   @code{ldexp(x, n)} @equiv{} @code{(* x (expt 2 n))}.
@item ldiv
Use R5RS @code{quotient} and @code{remainder}.
@xref{Arithmetics}.
@item link
Gauche's @code{sys-link}.  @xref{Directory manipulation}.
@item localeconv
Gauche's @code{sys-localeconv}. 
@item localtime
Gauche's @code{sys-localtime}.  @xref{Time}.
@item log
R5RS @code{log}.  @xref{Arithmetics}.
@item log10
Not directly supported.  @code{log10(z)} @equiv{} @code{(/ (log z) (log 10))}.
@item longjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item lseek
Not supported yet.
@item malloc
Not necessary in Scheme.
@item mblen
@itemx mbstowcs
@itemx mbtowc
Gauche handles multibyte strings internally, so generally you don't 
need to care about multibyte-ness of the string.   @code{string-length}
always returns a number of characters for a string in supported
encoding.   If you want to convert the character encoding,
see @ref{Character code conversion}.
@item memcmp
@itemx memcpy
@itemx memmove
@itemx memset
No equivalent functions.
@item mkdir
Gauche's @code{sys-mkdir}.  @xref{Directory manipulation}.
@item mkfifo
Gauche's @code{sys-mkfifo}.
@item mkstemp
Gauche's @code{sys-mkstemp}.   @xref{Directory manipulation}.
Use this instead of tmpnam.
@item mktime
Gauche's @code{sys-mktime}.  @xref{Time}.
@item modf
Gauche's @code{sys-modf}
@item open
Not directly supported.
R5RS @code{open-input-file} or @code{open-output-file}
corresponds to this operation.  @xref{File ports}.
@item opendir
Not directly supported.
You can use @code{sys-readdir} to read the directory entries at once.
@xref{Directories}.
@item pathconf
Not supported.
@item pause
Gauche's @code{sys-pause}.  @xref{Miscellaneous system calls}.
@item perror
No equivalent function in Gauche.  System calls generally throws an
error (@code{<system-error>}), including the description of the reason
of failure.
@item pipe
Gauche's @code{sys-pipe}.  @xref{Other file operations}.
@item pow
R5RS @code{expt}.  @xref{Arithmetics}.
@item printf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item putc
@itemx putchar
Use @code{write-char} or @code{write-byte}.  @xref{Output}.
@item puts
Use @code{display}.   @xref{Output}.
@item qsort
Gauche's @code{sort} and @code{sort!} provides a convenient way to sort
list of items.  @xref{Comparison and sorting}.
@item raise
No equivalent function in Gauche.  Scheme function @code{raise} (SRFI-18)
is to raise an exception.   You can use @code{(sys-kill (sys-getpid) SIG)}
to send a signal @code{SIG} to the current process.
@item rand
Not supported directly, but on most platforms a better RNG is available
as @code{sys-random}.  @xref{Miscellaneous system calls}.
@item read
Not supported directly, but you may be able to use
@code{read-block}.  @xref{Input}.
@item readdir
Not supported directly.   Gauche's @code{sys-readdir} reads
the directly at once.  @xref{Directories}.
@item readlink
Gauche's @code{sys-readlink}.  @xref{Directory manipulation}.
This function is available on systems that support symbolink links.
@item realloc
Not necessary in Scheme.
@item remove
Gauche's @code{sys-remove}.  @xref{Directory manipulation}.
@item rename
Gauche's @code{sys-rename}.  @xref{Directory manipulation}.
@item rewind
Not supported yet.
@item rewinddir
Not supported directly.
You can use @code{sys-readdir} to read the directory entries at once.
@xref{Directories}.
@item rmdir
Gauche's @code{sys-rmdir}.  @xref{Directory manipulation}.
@item scanf
Not supported.  For general case, you have to write a parser.
If you can keep the data in S-exp, you can use @code{read}.
If the syntax is very simple, you may be able to utilize
@code{string-tokenize} in @code{srfi-14} (@ref{String library}),
and/or regular expression stuff (@ref{Regular expression},
also @ref{Regular expression utilities}.
@item select
Gauche @code{sys-select}.  @xref{I/O multiplexing}.
@item setbuf
Not necessary.
@item setgid
Gauche's @code{sys-setgid}.
@item setjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item setlocale
Gauche's @code{sys-setlocale}.
@item setpgid
Gauche's @code{sys-setpgid}.
@item setsid
Gauche's @code{sys-setsid}.
@item setuid
Gauche's @code{sys-setuid}.
@item setvbuf
Not necessary.
@item sigaction
You can use @code{with-signal-handlers} to install signal handlers.
@xref{Handling signals}.
@item sigaddset
@itemx sigdelset
@itemx sigemptyset
@itemx sigfillset
Gauche's @code{sys-sigset-add!} and @code{sys-sigset-delete!}.
@xref{Signals and signal sets}.
@itemx sigismember
Not supported yet.
@item siglongjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item signal
You can use @code{with-signal-handlers} to install signal handlers.
@xref{Handling signals}.
@item sigpending
Not supported yet.
@item sigprocmask
Signal mask is handled internally.  See @xref{Handling signals}.
@item sigsetjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item sigsuspend
Not supported yet.
@item sin
@itemx sinh
Use @code{sin} and @code{sinh}.   @xref{Arithmetics}.
@item sleep
Gauche's @code{sys-sleep}.  @xref{Miscellaneous system calls}.
@item sprintf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item sqrt
R5RS @code{sqrt}.  @xref{Arithmetics}.
@item srand
Not supported directly, but on most platforms a better RNG is available
as @code{sys-srandom}.  @xref{Miscellaneous system calls}.
@item sscanf
Not supported.  For general case, you have to write a parser.
If you can keep the data in S-exp, you can use @code{read}.
If the syntax is very simple, you may be able to utilize
@code{string-tokenize} in @code{srfi-14} (@ref{String library}),
and/or regular expression stuff (@ref{Regular expression},
also @ref{Regular expression utilities}.
@item stat
Gauche's @code{sys-stat}.  @xref{File stats}.
@item strcasecmp
R5RS @code{string-ci=?} and other comparison functions.
@xref{String Comparison}.
@item strcat
R5RS @code{string-append}.  @xref{String utilities}.
@item strchr
SRFI-13 @code{string-index}.  @xref{SRFI-13 String searching}.
@item strcmp
R5RS @code{string=?} and other comparison functions.
@xref{String Comparison}.
@item strcoll
Not supported yet.
@item strcpy
R5RS @code{string-copy}.    @xref{String utilities}.
@item strcspn
Not directly supported, but you can use SRFI-13 @code{string-skip}
with a character set.  @xref{SRFI-13 String searching}.
@item strerror
Not supported.
@item strftime
Gauche's @code{sys-strftime}.  @xref{Time}.
@item strlen
R5RS @code{string-length}.   @xref{String Accessors & Modifiers}.
@item strncat
Not directly supported, but you can use @code{string-append} and
@code{substring}.
@item strncasecmp
SRFI-13 @code{string-compare-ci} provides the most flexible
(but a bit difficult to use) functionality.
@xref{SRFI-13 String Comparison}.
If what you want is just to check the fixed-length prefixes of two
string matches, you can use SRFI-13 @code{string-prefix-ci?}.
@item strncmp
SRFI-13 @code{string-compare} provides the most flexible
(but a bit difficult to use) functionality.
@xref{SRFI-13 String Comparison}.
If what you want is just to check the fixed-length prefixes of two
string matches, you can use SRFI-13 @code{string-prefix?}.
@xref{SRFI-13 String Prefixes & Suffixes}.
@item strncpy
SRFI-13 @code{substring}.  @xref{String utilities}.
@item strpbrk
Not directly supported, but you can use SRFI-13 @code{string-skip}
with a character set.  @xref{SRFI-13 String searching}.
@item strrchr
SRFI-13 @code{string-index-right}.  @xref{SRFI-13 String searching}.
@item strspn
Not directly supported, but you can use SRFI-13 @code{string-index}
with a character set.  @xref{SRFI-13 String searching}.
@item strstr
SRFI-13 @code{string-contains}.  @xref{SRFI-13 String searching}.
@item strtod
You can use R5RS @code{string->number}.   @xref{Numerical conversions}.
@item strtok
SRFI-13 @code{string-tokenize}.  @xref{SRFI-13 other string operations}.
@item strtol
@itemx strtoul
You can use R5RS @code{string->number}.   @xref{Numerical conversions}.
@item strxfrm
Not supported yet.
@item symlink
Gauche's @code{sys-symlink}.  @xref{Directory manipulation}.
This function is available on systems that support symbolink links.
@item sysconf
Not supported yet.
@item system
Gauche @code{sys-system}.   @xref{Fork and exec}.
It is generally recommended to use the process library
(@ref{High Level Process Interface}).
@item tan
@itemx tanh
R5RS @code{tan} and Gauche @code{tanh}.  @xref{Arithmetics}.
@item tcdrain
@item tcflow
@item tcflush
@item tcgetattr
@item tcgetpgrp
@item tcsendbreak
@item tcsetattr
@item tcsetpgrp
Corresponding functions are: @code{sys-tcdrain}, @code{sys-tcflow},
@code{sys-tcflush}, @code{sys-tcgetattr}, @code{sys-tcgetpgrp},
@code{sys-tcsendbreak}, @code{sys-tcsetattr}, @code{sys-tcsetpgrp.}
@xref{Termios}
@item time
Gauche's @code{sys-time}.  @xref{Time}.
@item times
Gauche's @code{sys-times}.  @xref{System Inquiry}.
@item tmpfile
Not exactly supported.
@item tmpnam
Gauche's @code{sys-tmpnam}.
This function is provided since it is in POSIX, but its use is
discouraged for the potential security risk.  Use @code{sys-mkstemp}
instead.   @xref{Directory manipulation}.
@item tolower
@itemx toupper
R5RS @code{char-upcase} and @code{char-downcase}.   @xref{Characters}.
@item ttyname
Gauche's @code{sys-ttyname}.  @xref{Other file operations}.
@item tzset
Not supported yet.
@item umask
Gauche's @code{sys-umask}.  @xref{Directory manipulation}.
@item uname
Gauche's @code{sys-uname}.  @xref{System Inquiry}.
@item ungetc
Not directly supported.  You can use @code{peek-char} to look
one character ahead, instead of pushing back.
@item unlink
Gauche's @code{sys-unlink}.  @xref{Directory manipulation}.
@item utime
Not supported yet.
@item va_arg
@itemx va_end
@itemx va_start
Not necessary, for Scheme handles variable number of arguments naturally.
@item vfprintf
@itemx vprintf
@itemx vsprintf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item wait
Gauche's @code{sys-wait}.  @xref{Wait}.
@item waitpid
Gauche's @code{sys-waitpid}.  @xref{Wait}.
@item wcstombs
@itemx wctomb
Gauche handles multibyte strings internally, so generally you don't 
need to care about multibyte-ness of the string.   @code{string-length}
always returns a number of characters for a string in supported
encoding.   If you want to convert the character encoding,
see @ref{Character code conversion}.
@item write
R5RS @code{display}.   @xref{Output}.
@end table

@c Appendix : Common Lisp to Scheme mapping
@c Appendix : Perl to Scheme mapping
@c Appendix : Python to Scheme mapping?

@c ======================================================================
@node Indices,  , C to Scheme mapping, Top
@appendix Indices
@c NODE 索引

@menu
* Function and Syntax Index::   
* Module Index::                
* Class Index::                 
* Variable Index::              
@end menu

@node Function and Syntax Index, Module Index, Indices, Indices
@appendixsec Function and Syntax Index
@c NODE 手続きと構文索引
@printindex fn

@node Module Index, Class Index, Function and Syntax Index, Indices
@appendixsec Module Index
@c NODE モジュール索引
@printindex md


@node Class Index, Variable Index, Module Index, Indices
@appendixsec Class Index
@c NODE クラス索引

For readability, the surrounding @code{<} and @code{>} are stripped off.

@printindex cl

@node Variable Index,  , Class Index, Indices
@appendixsec Variable Index
@c NODE 変数索引
@printindex vr


@contents
@bye

@c Local variables:
@c outline-regexp: "@chap\\|@unnu\\|@\\(sub\\)*section"
@c end:

