@node Library modules - SRFIs, Library modules - Utilities, Library modules - R7RS standard libraries, Top
@chapter Library modules - SRFIs
@c NODE ライブラリモジュール - SRFI

@c EN
This chapter lists modules that provides SRFI functionalities.
Note that some of SRFI features are built in Gauche core and
not listed here.  @xref{Standard conformance}, for entire list
of supported SRFIs.

(Even if a srfi is not listed here, you can still say
@code{(use srfi-N)} or @code{(import (srfi N))}, as far as
srfi N is supporeted by Gauche.)
@c JP
この章ではSRFIの機能を提供するモジュールをリストします。
一部のSRFIはGaucheのコアに組み込まれており、
この章には挙げられていないことに注意して下さい。
サポートされている全てのSRFIのリストは@ref{Standard conformance}にあります。

(ここに挙げられていないSRFIでも、サポートされているものについては
@code{(use srfi-N)}や@code{(import (srfi N))}と書くことができます。)
@c COMMON

@c ----------------------------------------------------------------------
@menu
* List library::                srfi-1
* Homogeneous vectors::         srfi-4
* A compatible let form with signatures and rest arguments::  srfi-5
* Feature-based program configuration language::  srfi-7
* String library::              srfi-13
* Character-set library::       srfi-14
* Time data types and procedures::  srfi-19
* Sources of random bits::      srfi-27
* Localization::                srfi-29
* A program argument processor::  srfi-37
* Eager comprehensions::        srfi-42
* Vector library (Legacy)::     srfi-43
* Requiring extensions::        srfi-55
* Integers as bits::            srfi-60
* Octet vectors::               srfi-66
* Basic hash tables::           srfi-69
* Octet-addressed binary blocks::  srfi-74
* Accessing environment variables::  srfi-98
* Basic socket interface::      srfi-106
* Boxes::                       srfi-111
* Portable runtime environment inquiry::  srfi-112
* Sets and bags::               srfi-113
* Comparators::                 srfi-114
* Queues based on lists::       srfi-117
* Simple adjustable-size strings::  srfi-118
* Lazy sequence (srfi)::        srfi-127
* Sort library::                srfi-132
* Vector library::              srfi-133
* Integer division::            srfi-141
* Fixnums::                     srfi-143
* Mappings and hashmaps::       srfi-146
* Bitwise operations::          srfi-151
* String library (reduced)::    srfi-152
* Generators and accumulators::  srfi-158
@end menu


@c ----------------------------------------------------------------------
@node List library, Homogeneous vectors, Library modules - SRFIs, Library modules - SRFIs
@section @code{srfi-1} - List library
@c NODE リストライブラリ, @code{srfi-1} - リストライブラリ

@deftp {Module} srfi-1
@mdindex srfi-1
@c EN
SRFI-1 has become a part of R7RS large.
@xref{R7RS lists}.
@c JP
SRFI-1はR7RS largeに採り入れられました。
@ref{R7RS lists}を参照してください。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node Homogeneous vectors, A compatible let form with signatures and rest arguments, List library, Library modules - SRFIs
@section @code{srfi-4} - Homogeneous vectors
@c NODE 単一型のベクタ, @code{srfi-4} - 単一型のベクタ

@deftp {Module} srfi-4
@mdindex srfi-4
@c EN
SRFI-4 is now implemented in @code{gauche.uvector} module
@xref{Uniform vectors}.
This module simply inherits @code{gauche.uvector} for backward-compatibility.
@c JP
SRFI-4は、@code{gauche.uvector}モジュールとして実装されています。
@ref{Uniform vectors}参照。
このモジュールは後方互換性のために単に@code{gauche.uvector}を継承しています。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node A compatible let form with signatures and rest arguments, Feature-based program configuration language, Homogeneous vectors, Library modules - SRFIs
@section @code{srfi-5} - A compatible let form with signatures and rest arguments
@c NODE シグネチャとrest引数に互換性のあるlet形式, @code{srfi-5} - シグネチャとrest引数に互換性のあるlet形式

@deftp {Module} srfi-5
@mdindex srfi-5
@c EN
This module provides srfi-5's extended @code{let} syntax.
@c JP
このモジュールは SRFI-5 の拡張 @code{let} 構文を提供します。
@c COMMON
@end deftp

@defmac let ((var val) @dots{} [. (rest val @dots{})]) body @dots{}
@defmacx let name ((var val) @dots{} [. (rest val @dots{})]) body @dots{}
@defmacx let (name (var val) @dots{} [. (rest val @dots{})]) body @dots{}
[SRFI-5]
@c MOD srfi-5
@c EN
The @code{let} syntax is extended in two ways.
@c JP
@code{let} 構文は 2通りの拡張がされています。
@c COMMON

@c EN
@itemize @bullet
@item
The extended @code{let} syntax accepts the @var{name} identifier (for
named let syntax) within the list of bindings (as in the third
syntax above).
@item
The extended @code{let} syntax accepts the rest parameter binding
which works like the rest paremter in the @code{lambda} syntax.
@end itemize

See SRFI-5 document for rationale of this extension.
@c JP
@itemize @bullet
@item
拡張 @code{let} 構文は、@var{name} 束縛リスト中で(名前付き let 構文用の)
識別子を許します(上の3つめの構文)。
@item
拡張 @code{let} 構文は、@code{lambda} 構文の rest パラメータと同様の
働きをする rest パラメータ束縛を許します。
@end itemize

この拡張に関する理論的根拠については SRFI-5 のドキュメントを参照してください。
@c COMMON
@end defmac

@c ----------------------------------------------------------------------
@node Feature-based program configuration language, String library, A compatible let form with signatures and rest arguments, Library modules - SRFIs
@section @code{srfi-7} - Feature-based program configuration language
@c NODE 機能ベースプログラム設定言語, @code{srfi-7} - 機能ベースプログラム設定言語

@deftp {Module} srfi-7
@mdindex srfi-7
@c EN
This module provides a program configuration metalanguage
(@code{program} form) defined in srfi-7.
@c JP
このモジュールは、SRFI-7 で定義されている
プログラム設定メタ言語(@code{program} フォーム)を提供します。

@c EN
Gauche autoloads srfi-7 module, so you don't need
to say @code{(use srfi-7)} explicitly.
@c JP
Gauche は srfi-7 モジュールを autoload しますので、@code{(use srfi-7)} と
明示的に書く必要はありません。

@c EN
Note that the @code{program} form isn't necessary to be a
Scheme expression.  Srfi-7 allows an implementation to preprocess
the @code{program} form to produce a Scheme program, then
executes it with different means.
@c JP
@code{program} フォームは Scheme の式である必要がないことに注意してください。
SRFI-7 では、この @code{program}フォームを処理して Scheme プログラムを
生成してから、それを別の方法で実行するような実装を許しています。

@c EN
Gauche implements @code{program} form as a macro, so it can
evaluates the form directly.  Nonetheless, it doesn't make sense
to mix @code{program} form and other forms in one file,
or expecting a return value of @code{program} form.
@c JP
Gauche @code{program} フォームをマクロとして実装しています。それゆえ、
そのフォームを直接、評価することができます。とはいえ、@code{program}
フォームと他のフォームを一つのファイル中で混在させたり、@code{program}
フォームの返り値を期待するのは、よいことではありません。

@c EN
A typical usage of @code{program} form is to prepare a single
file which just contains @code{program} form.  (It can load
other files using @code{files} clause (see below) within the
@code{program} form.)   To execute such a program file in Gauche,
you can just load it.
@c JP
@code{program}フォームの典型的な使い方は、@code{program} フォームのみを
含む単一のファイルを用意することです。(@code{program}フォーム中で
@code{files} 節(後述)を用いて他のファイルをロードするとが可能です。)
このようなプログラムファイルを Gauche で実行するには、単にそれを
ロードするだけです。
@c COMMON
@end deftp

@deffn {Configuration Language} program program-clause program-clause2 @dots{}
[SRFI-7]
@c MOD srfi-7
@c EN
This is a configuration language to structure a Scheme program,
based on availability of the features.

A Scheme program is constructed from the @code{program} form.
Gauche evaluates the constructed Scheme program on-the-fly.

Each @var{program-clause} needs to be one of the "Program Clauses" below.
@c JP
これは Scheme プログラムを構成する設定言語で、機能の利用可能性に基づいて
います。

Scheme のプログラムは、この @code{program}フォームから構築されます。
Gauche は構築された Scheme のプログラムをそのまま実行します。

各 @var{program-clause} は以下の "Program Clause" のどれか一つである
必要があります。
@c COMMON
@end deffn

@deffn {Program Clause} requires feature-id feature-id2 @dots{}
[SRFI-7]
@c EN
The @var{feature-id}'s are the same as @code{srfi-0}'s
(@pxref{Feature conditional}).
It tells that the following code requires these @var{feature-id}'s.

If a feature-id which is not supported in Gauche is given,
an error is signaled.
@c JP
@var{feature-id} は @code{srfi-0} のものと同じです
(@pxref{Feature conditional})。
あとに続くコードが @var{feature-id} を必要とすることを教えます。

Gauche ではサポートされていない feature-id が与えられた場合には、
エラーシグナルが発生します。
@c COMMON
@end deffn

@deffn {Program Clause} files filename @dots{}
[SRFI-7]
@c EN
Inserts the content of the @var{filename}s into a program.
In Gauche, this clause just causes @var{filename}s to be loaded
into the current module.
@c JP
プログラムに @var{filename}の内容を挿入します。Gauche では
単に、現在のモジュール中への @var{filename} のロードをひきおこします。
@c COMMON
@end deffn

@deffn {Program Clause} code scheme-expression @dots{}
[SRFI-7]
@c EN
The @var{scheme-expression}s are inserted into a program.
@c JP
@var{scheme-expression} がプログラムに挿入されます。
@c COMMON
@end deffn

@deffn {Program Clause} feature-cond clause clause2 @dots{}
[SRFI-7]
@c EN
@var{Clause} is a following form:
@c JP
@var{clause} は以下のようなフォームです。
@c COMMON
@example
(@var{requirement} @var{program-clause} @var{program-clause2} @dots{})
@end example

@c EN
Where @var{requirement} should be one of the following:
@c JP
ここでは、@var{requirement} は以下のもののどれかひとつでなければなりません。
@c COMMON
@itemize @bullet
@item
@var{feature-id}
@item
@code{(and @var{requirement} @dots{})}
@item
@code{(or @var{requirement} @dots{})}
@item
@code{(not @var{requirement})}
@end itemize

@c EN
The @var{requirement} of the last @var{clause} may be @code{else}.

Gauche checks each @var{requirement} one by one, and if it finds
a fulfilled @var{requirement}, inserts the @var{program-clause}s
in that @var{clause} into the program.
@c JP
最後の @var{clause} の @var{requirement} は @code{else} になるでしょう。

Gauche はそれぞれの @var{requirement} をひとつずつチェックし、
満された @var{requirement} が見つかると、その@var{clause}中の
@var{program-clause} をプログラムに挿入します。
@c COMMON
@end deffn

@c ----------------------------------------------------------------------
@node String library, Character-set library, Feature-based program configuration language, Library modules - SRFIs
@section @code{srfi-13} - String library
@c NODE 文字列ライブラリ, @code{srfi-13} - 文字列ライブラリ

@deftp {Module} srfi-13
@mdindex srfi-13
@c EN
Defines a large set of string-related functions.
In Gauche, those functions are splitted to number of files
and the form @code{(use srfi-13)} merely sets up autoloading of
those files.  So it is not likely to slow down the script startup.
@c JP
文字列に関連する関数の大きなセットを定義しています。
Gaucheでは、それらの関数はいくつかのファイルに分割されており、
@code{(use srfi-13)}というフォームは単にそれらのファイルの
オートロードのセットアップをするだけです。
したがって、スクリプトのスタートアップを遅くするようなことは
ありません。
@c COMMON
@c EN
See SRFI-13 (@ref{srfi-13, [SRFI-13], SRFI-13})
for the detailed specification and discussion of design issues.
This manual serves as a reference of function API.
Some SRFI-13 functions are Gauche built-in and not listed here.
@c JP
詳細な仕様とデザインに関する議論については、SRFI-13 (@ref{srfi-13, [SRFI-13], SRFI-13})
を参照して下さい。
このマニュアルは、関数のAPIのリファレンスとして提供されます。
いくつかのSRFI-13の関数は、Gaucheのビルトインになっており、
ここにはリストされていないものもあります。
@c COMMON
@c EN
Note: SRFI-13 documents suggests the name of the module that
implements these functions to be ``string-lib'' and ``string-lib-internals''.
Gauche uses the name ``srfi-13'' for consistency.
@c JP
注意: SRFI-13のドキュメントは、これらの関数を実装するモジュールの
名前を``string-lib''と``string-lib-internals''とすることを推奨しています。
Gaucheでは、一貫性のために``srfi-13''と名付けています。
@c COMMON
@end deftp

@menu
* SRFI-13 General conventions::
* SRFI-13 String predicates::
* SRFI-13 String Constructors::
* SRFI-13 String Selection::
* SRFI-13 String Comparison::
* SRFI-13 String Prefixes & Suffixes::
* SRFI-13 String searching::
* SRFI-13 String case mapping::
* SRFI-13 String reverse & append::
* SRFI-13 String mapping::
* SRFI-13 String rotation::
* SRFI-13 other string operations::
* SRFI-13 String filtering::
* SRFI-13 Low-level string procedures::
@end menu

@node SRFI-13 General conventions, SRFI-13 String predicates, String library, String library
@subsection General conventions
@c NODE 一般規約

@c EN
There are a few common factors in string library API, which I don't
repeat in each function description
@c JP
文字列ライブラリのAPIにはいくつか共通するものがありますが、
それぞれの関数の説明において繰り返しません。
@c COMMON

@table @emph
@c EN
@item argument convention
@c JP
@item 引数の仕様
@c EN
The following argument names imply their types.
@c JP
以下の引数名はその型を暗に表しています。
@c COMMON
@table @asis
@item @var{s}, @var{s1}, @var{s2}
@c EN
Those arguments must be strings.
@c JP
これらの引数は文字列でなければなりません。
@c COMMON
@item @var{char/char-set/pred}
@c EN
This argument can be a character, a character-set object,
or a predicate that takes a single character and returns a boolean value.
``Applying @var{char/char-set/pred} to a character'' means,
if @var{char/char-set/pred} is a character, it is compared to the given
character; if @var{char/char-set/pred} is a character set, it is
checked if the character set contains the given character; if
@var{char/char-set/pred} is a procedure, it is applied
to the given character.  ``A character satisfies @var{char/char-set/pred}''
means such application to the character yields true value.
@c JP
この引数は、文字、文字セットオブジェクト、あるいは1つの文字を引数に取り
真偽値を返す述語のいずれかです。``文字に@var{char/char-set/pred}を適用する''
の意味はそれぞれ、@var{char/char-set/pred}が文字ならば与えられた文字と比較される、
@var{char/char-set/pred}が文字セットならばその文字セットに与えられた文字が
含まれるかを検査する、@var{char/char-set/pred}が述語ならばそれを与えられた
文字に適用する、となります。``ある文字が@var{char/char-set/pred}を満足する''
とは、その文字への前述のような適用が真値を返すという意味になります。
@c COMMON

@item @var{start}, @var{end}
@c EN
Lots of SRFI-13 functions takes these two optional arguments, which
limit the area of input string from @var{start}-th character
(inclusive) to @var{end}-th character (exclusive),
where the operation is performed.
When specified, the condition
0 <= @var{start} <= @var{end} <= @var{length of the string} must be
satisfied.  Default value of @var{start} and @var{end} is
0 and the length of the string, respectively.
@c JP
SRFI-13の関数の多くは、その操作が実行される対象入力文字列の
範囲を限定する開始インデックスと終了インデックスをオプショナルな
引数として取ります。開始(@var{start}番目)の文字は含まれ、
終了(@var{end}番目)の文字は含まれません。
これらが指定されるとき、0 <= @var{start} <= @var{end} <= @var{length of the string}が
満たされなければなりません。@var{start}と@var{end}のデフォルト値は、
それぞれ0と文字列の長さです。
@c COMMON
@end table

@c EN
@item @code{shared} variant
@c JP
@item @code{shared}バージョン
@c EN
Some functions have variants with ``/shared'' attached to its name.
SRFI-13 defines those functions to allow to share the part of input
string, for better performance.  Gauche doesn't have a concept of
shared string, and these functions are mere synonyms of their
non-shared variants.  However, Gauche @emph{internally} shares
the storage of strings, so generally you don't need to worry
about the overhead of copying substrings.
@c JP
いくつかの関数は、その名前に``/shared''が付きます。
SRFI-13では、それらの関数はより良いパフォーマンスのために
入力文字列の一部を共有しても良いと定義しています。
Gaucheは、共有文字列という概念を持っていませんし、
それらの関数は単に共有でないバージョンの変名に過ぎません。
しかし、Gaucheは@emph{内部的には}文字列の保存場所を共有しているので、
一般的には部分文字列をコピーするオーバヘッドについて心配する
必要はありません。
@c COMMON

@c EN
@item @code{right} variant
@c JP
@item @code{right}バージョン
@c EN
Most functions works from left to right of the input string.
Some functions have variants with ``-right'' to its name,
that works from right to left.
@c JP
ほとんどの関数は、入力文字列を左から右へと扱います。
いくつかの関数は、その名前に``-right''が付き、右から左へと
扱うものがあります。
@c COMMON

@end table

@node SRFI-13 String predicates, SRFI-13 String Constructors, SRFI-13 General conventions, String library
@subsection String predicates
@c NODE 文字列についての述語

@defun string-null? s
[SRFI-13]
@c MOD srfi-13
@c EN
Returns @code{#t} if @var{s} is an empty string, @code{""}.
@c JP
@var{s}が空文字列、@code{""}なら、@code{#t}を返します。
@c COMMON
@end defun

@defun string-every char/char-set/pred s :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
Sees if every character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-every} returns
the value that is returned at the last application of @var{char/char-set/pred}.
If any of the application returns @code{#f}, @code{string-every}
returns @code{#f} immediately.
@c JP
@var{s}に含まれる全ての文字が@var{char/char-set/pred}を
満足するかを検査します。満足するならば、@code{string-every}は
最後に適用された@var{char/char-set/pred}が返した値を戻り値とします。
どの適用も@code{#f}を返した場合は、@code{string-every}はすぐに
@code{#f}を返します。
@c COMMON
@end defun

@defun string-any char/char-set/pred s :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
Sees if any character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-any} returns
the value that is returned by the application.   If no character
satisfies @var{char/char-set/pred}, @code{#f} is returned.
@c JP
@var{s}に含まれるいずれかの文字が@var{char/char-set/pred}
を満足するかを検査します。いずれかの文字が満足するならば、
@code{string-any}はその適用が返した値を戻り値とします。
どの文字も@var{char/char-set/pred}を満たさなければ、@code{#f}が返ります。
@c COMMON
@end defun

@node SRFI-13 String Constructors, SRFI-13 String Selection, SRFI-13 String predicates, String library
@subsection String Constructors
@c NODE 文字列の構築子

@defun string-tabulate proc len
[SRFI-13]
@c MOD srfi-13
@c EN
@var{proc} must be a procedure that takes an integer
argument and returns a character.  @code{string-tabulate}
creates a string, whose @var{i}-th character is calculated by
@code{(proc i)}.
@c JP
@var{proc}は整数を1つ引数として取り文字を返す手続きで
なければなりません。@code{string-tabulate}は、その@var{i}番目の
文字が@code{(proc i)}で計算されるような文字列を返します。
@c COMMON
@example
(string-tabulate
  (lambda (i) (integer->char (+ i #x30))) 10)
 @result{} "0123456789"
@end example

@end defun

@defun reverse-list->string char-list
[SRFI-13]
@c MOD srfi-13
@equiv{} @code{(list->string (reverse char-list))}.
@end defun

@node SRFI-13 String Selection, SRFI-13 String Comparison, SRFI-13 String Constructors, String library
@subsection String selection
@c NODE 文字列の選択

@defun substring/shared s start :optional end
[SRFI-13]
@c MOD srfi-13
@c EN
In Gauche, this is the same as @code{substring}, except
that the @var{end} argument is optional.
@c JP
Gaucheでは、引数@var{end}がオプショナルであることを除いて、
@code{substring}と同じです。
@c COMMON
@example
(substring/shared "abcde" 2) @result{} "cde"
@end example
@end defun

@defun string-copy! target tstart s :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
Copies a string @var{s} into a string
@var{target} from the position @var{tstart}.
The @var{target} string must be mutable.
Optional @var{start} and @var{end} arguments limits the range of @var{s}.
If the copied string run over the end of @var{target}, an error is
signaled.
@c JP
文字列@var{s}を、文字列@var{target}の@var{tstart}番目以降へコピーします。
@var{target}文字列は変更可能でなければなりません。
オプションの引数@var{start}と@var{end}は、@var{s}の範囲を制限します。
コピーされた文字列が@var{target}の終端を越えたらエラーが通知されます。
@c COMMON
@example
(define s (string-copy "abcde"))
(string-copy! s 2 "ZZ")
s @result{} "abZZe"
@end example

@c EN
It is ok to pass the same string to @var{target} and @var{s}; this
always work even if the regions of source and destination are overlapping.
@c JP
@var{target}と@var{s}に同じ文字列を渡しても構いません。コピー元とコピー先の
領域が重なっていても、コピーは常に正しく行われます。
@c COMMON

@c EN
Note that Gauche encourages you to treat strings as immutable objects.
Internally, a string is an indirect pointer to a immutable entity, and 
mutating a string means copying the original entity and creating a new one.
It doesn't ``save allocations''.
Always use the functional version @code{string-copy} unless you
absolutely need to replace a string in-place.
@xref{String utilities}.
@c JP
Gaucheでは、文字列を変更不可なオブジェクトとして扱うことを強く推奨しています。
内部的に、文字列オブジェクトは変更不可な文字列の実体へのポインタとなっています。
文字列を変更すると、新たな文字列実体がアロケートされそれが変更されるので、
破壊的手続きを使えばメモリアロケーションが節約できるということはありません。
どうしても文字列そのものを破壊的変更したい場合でない限りは、
非破壊版の@code{string-copy}を使いましょう。@ref{String utilities}参照。
@c COMMON
@end defun

@defun string-take s nchars
@defunx string-drop s nchars
@defunx string-take-right s nchars
@defunx string-drop-right s nchars
[SRFI-13]
@c MOD srfi-13
@c EN
Returns the first @var{nchars}-character string of @var{s}
(@code{string-take}) or the string without first @var{nchars}
(@code{string-drop}).  The @code{*-right} variation counts from
the end of string.  It is guaranteed that the returned string is
always a copy of @var{s}, even no character is dropped.
@c JP
@code{string-take}は、@var{s}の最初の@var{nchars}文字からなる文字列を返します。
@code{string-drop}は、@var{s}から最初の@var{nchars}文字からなる文字列を
除いた残りを返します。@code{*-right}バージョンは、文字列の最後から数えます。
返される文字列はいつも@var{s}のコピーであり、どの文字も削除されないことが
保証されています。
@c COMMON
@example
(string-take "abcde" 2) @result{} "ab"
(string-drop "abcde" 2) @result{} "cde"

(string-take-right "abcde" 2) @result{} "de"
(string-drop-right "abcde" 2) @result{} "abc"
@end example
@end defun

@defun string-pad s len :optional char start end
@defunx string-pad-right s len :optional char start end
[SRFI-13]
@c MOD srfi-13
@c EN
If a string @var{s} is shorter than @var{len},
returns a string of @var{len} where @var{char} is
padded to the left or right, respectively.
If @var{s} is longer than @var{len}, the rightmost
or leftmost @var{len} chars are taken.
@var{Char} defaults to @code{#\space}.
If @var{start} and @var{end} are provided,
the substring of @var{s} is used as the source.
@c JP
文字列@var{s}が@var{len}より短い場合は、@var{char}がそれぞれ左か
右にパディングされた長さ@var{len}の文字列を返します。
@var{s}が@var{len}よりも長い場合は、@var{len}文字が右端か左端から
取り除かれます。@var{Char}のデフォルト値は@code{#\space}です。
@var{start}と@var{end}が与えられると、@var{s}の部分文字列がソース
文字列として使われます。
@c COMMON

@example
(string-pad "abc" 10)    @result{} "       abc"
(string-pad "abcdefg" 3) @result{} "efg"

(string-pad-right "abc" 10) @result{} "abc       "

(string-pad "abcdefg" 10 #\+ 2 5)
  @result{} "+++++++cde"
@end example
@end defun

@defun string-trim s :optional char/char-set/pred start end
@defunx string-trim-right s :optional char/char-set/pred start end
@defunx string-trim-both s :optional char/char-set/pred start end
[SRFI-13]
@c MOD srfi-13
@c EN
Removes characters that match @var{char/char-set/pred}
from @var{s}.  @code{String-trim} removes the characters from
left of @var{s}, @code{string-trim-right} does from right,
and @code{string-trim-both} does from both sides.
@c JP
@var{s}から@var{char/char-set/pred}にマッチする文字を削除します。
@code{String-trim}は@var{s}の左から文字を削除し、
@code{string-trim-right}は右から、@code{string-trim-both}は
両端から削除します。
@c COMMON
@c EN
@var{Char/char-set/pred} defaults to @code{#[\s]}, i.e. a char-set
of whitespaces.
If @var{start} and @var{end} are provided,
the substring of @var{s} is used as the source.
@c JP
@var{Char/char-set/pred}のデフォルト値は@code{#[\s]}、つまり空白文字の
文字セットです。@var{start}と@var{end}が与えられると、@var{s}の部分文字列が
ソース文字列として使われます。
@c COMMON

@example
(string-trim "   abc  ")       @result{} "abc  "
(string-trim-right "   abc  ") @result{} "   abc"
(string-trim-both "   abc  ")  @result{} "abc"
@end example
@end defun

@node SRFI-13 String Comparison, SRFI-13 String Prefixes & Suffixes, SRFI-13 String Selection, String library
@subsection String comparison
@c NODE 文字列の色々な比較

@defun string-compare s1 s2 proc< proc= proc> :optional start1 end1 start2 end2
@defunx string-compare-ci s1 s2 proc< proc= proc> :optional start1 end1 start2 end2
[SRFI-13]
@c MOD srfi-13
@c EN
Compares two strings @var{s1} and @var{s2} codepoint-wise from left.
When mismatch is found at the index @var{k} of @var{s1},
calls @var{proc<} with @var{k} if @var{s1}'s codepoint is smaller than
the corresponding @var{s2}'s, or calls @var{proc>} if @var{s1}'s one is
greater than @var{s2}'s.  If two strings are the same, calls @var{proc=}
with the index of the last compared position in @var{s1}.
@c JP
文字列@var{s1}と@var{s2}をコードポイント毎に左から比較します。
不一致が@var{s1}のインデックス@var{k}で見つかった場合、対応する@var{s2}の
コードポイントより@var{s1}のコードポイントの方が小さければ
@var{proc<}を@var{k}を引数にして呼び出し、逆に大きければ
@var{proc>}を@var{k}を引数にして呼び出します。
二つの文字列が等しければ、@var{proc=}が、@var{s1}の比較された最後のインデックスを
引数にして呼び出されます。
@c COMMON

@example
(string-compare "abcd" "abzd"
                (^i `(< ,i)) (^i `(= ,i)) (^i `(> ,i)))
  @result{} (< 2)

(string-compare "abcd" "abcd"
                (^i `(< ,i)) (^i `(= ,i)) (^i `(> ,i)))
  @result{} (= 3)
@end example

@c EN
The optional arguments restricts
the range of the input strings; however, the index passed to one 
of the procedures is always an index from the beginning of @var{s1}.
@c JP
省略可能引数は入力の文字列の比較すべき範囲を制限します。
但し、@var{proc<}、@var{proc=}、@var{proc>}に渡されるインデックスは
常に@var{s1}の最初から数えたものになります。
@c COMMON

@example
(string-compare "zzabcdyy" "abcz"
   (^i `(< ,i)) (^i `(= ,i)) (^i `(> ,i)) 2 6 0 4)
 @result{} (< 5)

(string-compare "zzabcdyy" "abcz"
   (^i `(< ,i)) (^i `(= ,i)) (^i `(> ,i)) 2 5 0 3)

 @result{} (= 4)
@end example

@c EN
The case-insensitive variant, @code{string-compare-ci}, compares
each codepoint with character-wise case-folding.  It won't consider
special case folding such as German eszett.
@c JP
@code{string-compare-ci}は大文字小文字を区別しない比較です。
文字毎の大文字小文字変換を行って比較するので、文字列の長さが変わる
大文字小文字変換のケース (ドイツ語のエスツェット等) は考慮されません。
@c COMMON
@end defun

@defun string= s1 s2 :optional start1 end1 start2 end2
@defunx string<> s1 s2 :optional start1 end1 start2 end2
@defunx string< s1 s2 :optional start1 end1 start2 end2
@defunx string<= s1 s2 :optional start1 end1 start2 end2
@defunx string> s1 s2 :optional start1 end1 start2 end2
@defunx string>= s1 s2 :optional start1 end1 start2 end2
[SRFI-13]
@c MOD srfi-13
@c EN
Compare two strings @var{s1} and @var{s2}.  Optional arguments
can limit the portion of strings to be compared.
Comparison is done by character-wise.

Note: The builtin procedures @code{string=?} etc. can also be
used for character-wise string comparison, but they take
arguments differently.  @xref{String Comparison}.
@c JP
二つの文字列@var{s1}と@var{s2}を比較します。省略可能引数で
それぞれの文字列の一部のみを比較するように指定できます。
比較は文字ごとに行われます。

註: 組み込み手続きの@code{string=?}等も文字毎の比較に使えますが、
引数の取り方が違います。@ref{String Comparison}参照。
@c COMMON
@end defun

@defun string-ci= s1 s2 :optional start1 end1 start2 end2
@defunx string-ci<> s1 s2 :optional start1 end1 start2 end2
@defunx string-ci< s1 s2 :optional start1 end1 start2 end2
@defunx string-ci<= s1 s2 :optional start1 end1 start2 end2
@defunx string-ci> s1 s2 :optional start1 end1 start2 end2
@defunx string-ci>= s1 s2 :optional start1 end1 start2 end2
[SRFI-13]
@c MOD srfi-13
@c EN
Compare two strings @var{s1} and @var{s2} in case-insensitive way.
Optional arguments can limit the portion of strings to be compared.
Case folding and comparison is done by character-wise, so they don't
consider case folding that affects multiple characters.

Note: We have two other sets of string comparison operations,
both are named as @code{string-ci=?} etc.
The builtin version (@pxref{String Comparison}) does character-wise
comparison.  The one in @code{gauche.unicode} uses full-string
case conversion (@pxref{Full string case conversion}).
R7RS version is the latter.
@c JP
二つの文字列@var{s1}と@var{s2}を、大文字小文字を区別せずに比較します。
省略可能引数でそれぞれの文字列の一部のみを比較するように指定できます。
大文字小文字の畳み込みと比較は文字ごとに行われます。複数の文字に
影響を与えるような大文字小文字の畳み込みは考慮しません。

註: Gaucheには他に2種類の大文字小文字を区別しない文字列比較手続き群があります。
どちらも@code{string-ci=?}等のようにクエスチョンマーク付きの名前を持っています。
Gauche組み込みのものは文字毎に大文字小文字を畳み込みます
(@ref{String Comparison}参照)。一方、@code{gauche.unicode}にあるものは
文字列としての畳み込みを行います(@ref{Full string case conversion}参照)。
R7RS版は後者です。
@c COMMON
@end defun

@defun string-hash s :optional bound start end
@defunx string-hash-ci s :optional bound start end
[SRFI-13]
@c MOD srfi-13
@c EN
(Note: Gauche has builtin @code{string-hash} and @code{string-ci-hash}
according to SRFI-128. @xref{Hashing}, for the details.
SRFI-13's API is upper-compatible to SRFI-128's.  The underlying
hash algorighm is the same as the builtin ones, so @code{string-hash}
returns the same value as the builtin ones for the same string
if optional arguments are omitted.
On the other hand, the builtin @code{string-ci-hash} uses string case
folding (e.g. German eszett and @code{SS} are the same), while
SRFI-13's @code{string-hash-ci} uses character-wise case folding.
Unless there's a strong reason, we recommend new code should use
builtin SRFI-128 version instead of SRFI-13.)

Calculates hash value of a string @var{s}.  For @code{string-hash-ci},
character-wise case folding is done before calculating the hash value.

If the optional @var{bound} argument is given, it must be a positive
exact integer, and the return value is limited below it.
The optional @var{start} and @var{end} arguments allows
using that portion for calculation.
@c JP
(註: Gaucheは、SRFI-128に準拠した@code{string-hash}と@code{string-ci-hash}を
組み込みで持っています。詳しくは@ref{Hashing}参照。
SRFI-13のAPIはSRFI-128の上位互換になっています。内部で使っているハッシュ
アルゴリズムは一緒なので、省略可能引数を全て省略したSRFI-13の@code{string-hash}は、
組み込みの@code{string-hash}と同じ値を返します。
一方、組み込みの@code{string-ci-hash}は文字列として大文字小文字の畳み込みを
行います(ドイツ語のエスツェットと@code{SS}は等しく扱われます)が、SRFI-13の
@code{string-hash-ci}は文字毎に大文字小文字を畳み込むように定められているので、
結果が異なる可能性があります。特に強い理由がなければ、新しいコードは
組み込みのSRFI-128版を使うことをおすすめします。)

文字列@var{s}のハッシュ値を計算して返します。@code{string-hash-ci}では
ハッシュ値を計算する前に各文字について大文字小文字を畳み込みを行います。

省略可能引数@var{bound}は、与えられたなら正の正確な整数でなければならず、
返される値は0から@code{(- bound 1)}までの値に制限されます。
@var{start}と@var{end}は、与えられれば@var{s}中の対象となる部分文字列を
指定します。
@c COMMON
@end defun

@node SRFI-13 String Prefixes & Suffixes, SRFI-13 String searching, SRFI-13 String Comparison, String library
@subsection String Prefixes & Suffixes
@c NODE 文字列のプリフィックスとサフィックス

@defun string-prefix-length s1 s2 :optional start1 end1 start2 end2
@defunx string-suffix-length s1 s2 :optional start1 end1 start2 end2
@defunx string-prefix-length-ci s1 s2 :optional start1 end1 start2 end2
@defunx string-suffix-length-ci s1 s2 :optional start1 end1 start2 end2
[SRFI-13]
@c MOD srfi-13
@c EN
Returns the length of the longest common prefix/suffix of two strings,
@var{s1} and @var{s2}.  The optional arguments restrict the range of
search.  The @code{*-ci} variations use case foling character comparison.
@c JP
二つの文字列@var{s1}と@var{s2}の、共通するプレフィクスもしくはサフィックスの
長さを返します。省略可能引数はそれぞれの文字列の探索範囲を限定します。
@code{*-ci}版は文字ごとに、大文字小文字を区別しない比較を行います。
@c COMMON

@example
(string-prefix-length "abacus" "abalone")   @result{} 3
(string-prefix-length "machine" "umbrella") @result{} 0
(string-suffix-length "peeking" "poking")   @result{} 4

(string-prefix-length "obvious" "oblivious" 2 7 4 9)
  @result{} 5
@end example
@end defun

@defun string-prefix? s1 s2 :optional start1 end1 start2 end2
@defunx string-suffix? s1 s2 :optional start1 end1 start2 end2
@defunx string-prefix-ci? s1 s2 :optional start1 end1 start2 end2
@defunx string-suffix-ci? s1 s2 :optional start1 end1 start2 end2
[SRFI-13]
@c MOD srfi-13
@c EN
Returns true iff @var{s1} is a prefix or suffix of @var{s2}, respectively.
The optional arguments limit the range of @var{s1} and @var{s2} to look at.
The @code{*-ci} variations use case foling character comparison.
@c JP
それぞれ、@var{s1}が@var{s2}のプレフィクスまたはサフィックスになっていた場合に
@code{#t}を、それ以外の場合に@code{#f}を返します。
省略可能引数はそれぞれの文字列の探索範囲を限定します。
@code{*-ci}版は文字ごとに、大文字小文字を区別しない比較を行います。
@c COMMON

@example
(string-prefix? "sch" "scheme")   @result{} #t
(string-prefix? "lisp" "scheme")  @result{} #f

(string-suffix? "eme" "scheme")   @result{} #t
(string-suffix? "eme" "lisp")     @result{} #f

(string-prefix? "mit-scheme" "scheme-family" 4) @result{} #t
@end example
@end defun

@node SRFI-13 String searching, SRFI-13 String case mapping, SRFI-13 String Prefixes & Suffixes, String library
@subsection String searching
@c NODE 文字列の探索

@defun string-index s char/char-set/pred :optional start end
@defunx string-index-right s char/char-set/pred :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
Looks for the first element in a string @var{s}
that matches @var{char/char-set/pred}, and returns its index.
If @var{char/char-set/pred} is not found in @var{s}, returns @code{#f}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@c JP
文字列@var{s}の中で、@var{char/char-set/pred}にマッチする
最初の要素を探し、そのインデックスを返します。
@var{s}の中に@var{char/char-set/pred}が見つからない場合は、@code{#f}を
返します。オプションの@var{start}と@var{end}は、@var{s}の中で検索対象と
なる範囲を制限します。
@c COMMON
@example
(string-index "Aloha oe" #\a) @result{} 4
(string-index "Aloha oe" #[Aa]) @result{} 0
(string-index "Aloha oe" #[\s]) @result{} 5
(string-index "Aloha oe" char-lower-case?) @result{} 1
(string-index "Aloha oe" #\o 3) @result{} 6
@end example

@c EN
See also the Gauche built-in procedure @code{string-scan}
(@ref{String utilities}), if you need speed over portability.
@c JP
ポータビリティよりも速度を重視する場合は、Gaucheのビルトイン手続き
@code{string-scan}(@ref{String utilities})を参照して下さい。
@c COMMON
@end defun

@defun string-skip s char/char-set/pred :optional start end
@defunx string-skip-right s char/char-set/pred :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
Looks for the first element that does not match
@var{char/char-set/pred} and returns its index.
If such element is not found, returns @code{#f}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@c JP
@var{char/char-set/pred}にマッチしない最初の要素を探し、
そのインデックスを返します。そのような要素が見つからない場合、@code{#f}を
返します。オプションの@var{start}と@var{end}は、@var{s}の中で検索対象と
なる範囲を制限します。
@c COMMON
@end defun

@defun string-count s char/char-set/pred :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
Counts the number of elements in @var{s}
that matches @var{char/char-set/pred}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@c JP
@var{s}の中で、@var{char/char-set/pred}にマッチする要素の数を
カウントします。オプションの@var{start}と@var{end}は、@var{s}の中で検索対象と
なる範囲を制限します。
@c COMMON
@end defun

@defun string-contains s1 s2 :optional start1 end1 start2 end2
@defunx string-contains-ci s1 s2 :optional start1 end1 start2 end2
[SRFI-13]
@c MOD srfi-13
@c EN
Looks for a string @var{s2} inside another string @var{s1}.
If found, returns an index in @var{s1} from where the matching string
begins.  Returns @code{#f} otherwise.
Optional @var{start1}, @var{end1}, @var{start2} and @var{end2}
limits the range of @var{s1} and @var{s2}.

See also the Gauche built-in procedure @code{string-scan}
(@ref{String utilities}), if you need speed over portability.
@c JP
@var{s1}の中で、文字列@var{s2}を探します。見つかった場合は、
@var{s1}でマッチした文字列が始まるインデックスを返します。そうでなければ、
@code{#f}を返します。
オプションの@var{start1}、@var{end1}、@var{start2}、@var{end2}は、
@var{s1}と@var{s2}の範囲を制限します。

ポータビリティよりも速度を重視する場合は、Gaucheのビルトイン手続き
@code{string-scan}(@ref{String utilities})を参照して下さい。
@c COMMON
@end defun

@node SRFI-13 String case mapping, SRFI-13 String reverse & append, SRFI-13 String searching, String library
@subsection String case mapping
@c NODE 文字列のケース(大文字小文字)マッピング

@defun string-titlecase s :optional start end
@defunx string-titlecase! s :optional start end
@defunx string-upcase s :optional start end
@defunx string-upcase! s :optional start end
@defunx string-downcase s :optional start end
@defunx string-downcase! s :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
Converts a string @var{s} to titlecase, upcase or downcase,
respectively.  These operations uses character-by-character
mapping provided by @code{char-upcase} etc.  That is, @code{string-upcase}
and @code{string-downcase} can be understood as follow:
@c JP
文字列@var{s}をタイトルケース、大文字、小文字にそれぞれ変換します。
これらの手続きは、文字ごとに@code{char-upcase}等を使った変換を行います。
すなわち、@code{string-upcase}と@code{string-downcase}は以下の操作と
考えることができます。
@c COMMON

@example
(string-upcase s)
  @equiv{} (string-map char-upcase s)
(string-downcase s)
  @equiv{} (string-map char-downcase s)
@end example

@c EN
If you need full case mapping that handles the case when
a character is mapped to more than one characters, use
the procedures with the same name in @code{gauche.unicode} module
(@pxref{Full string case conversion}).
@c JP
一文字がケース変換によって複数文字になるような場合も考慮したい場合は、
@code{gauche.unicode}モジュールに定義されている同名の手続きを使ってください
(@ref{Full string case conversion}参照)。
@c COMMON

@c EN
The linear-update version @code{string-titlecase!}, @code{string-upcase!}
and @code{string-downcase!} destroys @var{s} to store the result.
Note that in Gauche, using those procedures doesn't save anything,
since string mutation is expensive by design.  They are provided merely
for completeness.
@c JP
@code{string-titlecase!}、@code{string-upcase!}、
@code{string-downcase!}はその場で更新するバージョンで、@var{s}を破壊的に
変更します。ただし、Gaucheでは文字列の変更は新たな文字列を作るのと効率的に
何ら変わりがありません。これらの手続きは互換性のためだけに用意されています。
@c COMMON
@end defun


@node SRFI-13 String reverse & append, SRFI-13 String mapping, SRFI-13 String case mapping, String library
@subsection String reverse & append
@c NODE 文字列の反転と追加

@defun string-reverse s :optional start end
@defunx string-reverse! s :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
Returns a string in which the character positions are reversed
from @var{s}.  @code{string-reverse!} modifies @var{s}.
@c JP
@var{s}の文字の位置を逆順にした文字列を返します。
@code{string-reverse!}は@var{s}そのものを変更します。
@c COMMON
@example
(string-reverse "mahalo") @result{} "olaham"
(string-reverse "mahalo" 3) @result{} "ola"
(string-reverse "mahalo" 1 4) @result{} "aha"

(let ((s (string-copy "mahalo")))
  (string-reverse! s 1 5)
  s)
  @result{} "mlahao"
@end example
@end defun

@defun string-concatenate string-list
[SRFI-13]
@c MOD srfi-13
@c EN
Concatenates list of strings.
@c JP
文字列のリストを連結します。
@c COMMON
@example
(string-concatenate '("humuhumu" "nukunuku" "apua" "`a"))
  @result{} "humuhumunukunukuapua`a"
@end example
@end defun

@defun string-concatenate/shared string-list
@defunx string-append/shared s @dots{}
[SRFI-13]
@c MOD srfi-13
@c EN
``Shared'' version of @code{string-concatenate} and
@code{string-append}.  In Gauche, these are just synonyms of them.
@c JP
@code{string-concatenate}と@code{string-append}の``共有''
バージョンです。Gaucheでは、これらは単に別名です。
@c COMMON
@end defun

@defun string-concatenate-reverse string-list
@defunx string-concatenate-reverse/shared string-list
[SRFI-13]
@c MOD srfi-13
@c EN
Reverses @var{string-list} before concatenation.
``Shared'' version works the same in Gauche.
@c JP
@var{string-list}を連結する前に逆順にします。
Gaucheでは、``共有''バージョンは全く同じ動作をします。
@c COMMON
@end defun

@node SRFI-13 String mapping, SRFI-13 String rotation, SRFI-13 String reverse & append, String library
@subsection String mapping
@c NODE 文字列のマッピング

@defun string-map proc s :optional start end
@defunx string-map! proc s :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
@code{string-map} applies @var{proc} on every character of @var{s},
and collects the results into a string and returns it.
On the other hand, @code{string-map!} modifies @var{s}.
@c JP
@code{string-map}は、@var{s}の全ての文字に対して@var{proc}を
適用し、その結果を文字列に集めそれを返します。
一方、@code{string-map!}は@var{s}そのものを変更します。
@c COMMON
@example
(string-map char-upcase "wikiwiki") @result{} "WIKIWIKI"
(string-map char-upcase "wikiwiki" 4) @result{} "WIKI"

(let ((s (string-copy "wikiwiki")))
  (string-map! char-upcase s 4)
  s)
  @result{} "wikiWIKI"
@end example
@end defun

@defun string-fold kons knil s :optional start end
@defunx string-fold-right kons knil s :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
Like @var{fold} and @var{fold-right} (@pxref{Walking over lists}),
but works on a string instead of a list.
@c JP
文字列に対して動作する@var{fold}や@var{fold-right} (@ref{Walking over lists}参照)
です。
@c COMMON

@example
(string-fold cons '() "abcde")
  @result{} (#\e #\d #\c #\b #\a)
(string-fold-right cons '() "abcde")
  @result{} (#\a #\b #\c #\d #\e)
@end example
@end defun

@defun string-unfold p f g seed :optional base make-final
[SRFI-13]
@c MOD srfi-13
A fundamental string builder.  The @var{p}, @var{f} and @var{g} are
procedures, taking the current seed value.  The stop predicate @var{p}
determines when to stop: If it returns a true value, string building
stops.  The mapping function @var{f} returns a character
from the current seed value.  The next seed function @var{g} returns
a next seed value from the current seed value.  The @var{seed} argument
gives the initial seed value.

@example
(string-unfold (^n (= n 10))
               (^n (integer->char (+ n 48)))
               (^n (+ n 1))
               0)
  @result{} "0123456789"
@end example

The optional argument @var{base} is, when given, prepended to the
result string.  Another optional argument @var{make-final}
is a procedure that takes the last return value of @var{g} and
returns a string that becomes the suffix of the result string.

@example
(string-unfold (^n (= n 10))
               (^n (integer->char (+ n 48)))
               (^n (+ n 1))
               0 "foo" x->string)
  @result{} "foo012345678910"
@end example
@end defun

@defun string-unfold-right p f g seed :optional base make-final
[SRFI-13]
@c MOD srfi-13
Another fundamental string builder.  The meanings of arguments
are the same as @samp{string-unfold}.  The only difference is
that the string is build right-to-left.  The optional @var{base},
if given, becomes the suffix of result, and the result of
@var{make-final} becomes the prefix.

@example
(string-unfold-right (^n (= n 10))
                     (^n (integer->char (+ n 48)))
                     (^n (+ n 1))
                     0 "foo" x->string)
  @result{} "109876543210foo"
@end example
@end defun

@defun string-for-each proc s :optional start end
[SRFI-13]
@c MOD srfi-13
Apply @var{proc} on each character of string @var{s},
from left to right.  Optional @var{start} and @var{end} arguments
limit the range of the input string.
@end defun

@defun string-for-each-index proc s :optional start end
[SRFI-13]
@c MOD srfi-13
Call @var{proc} on each index of the string @var{s}.
@end defun

@node SRFI-13 String rotation, SRFI-13 other string operations, SRFI-13 String mapping, String library
@subsection String rotation
@c NODE 文字列のローテーション

@defun xsubstring s from :optional to start end
[SRFI-13]
@c MOD srfi-13
Takes a substring of inifinite repetition of string @var{s}
between index @var{from} (inclusive) and index @var{to} (exclusive).

For example, if @var{s} is @code{"abcde"}, we repeat it
infinitely to both sides.  So @var{5n}-th character for integer @var{n}
is always @code{#\a}, which extends negative @var{n} as well.

@example
(xsubstring "abcde" 2 10)
  @result{} "cdeabcde"
(xsubstring "abcde" -9 -2)
  @result{} "bcdeabc"
@end example
@end defun

@defun string-xcopy! target tstart s sfrom :optional sto start end
[SRFI-13]
@c MOD srfi-13
@end defun

@node SRFI-13 other string operations, SRFI-13 String filtering, SRFI-13 String rotation, String library
@subsection Other string operations
@c NODE 他の文字列操作

@defun string-replace s1 s2 start1 end1 :optional start2 end2
[SRFI-13]
@c MOD srfi-13
@c EN
Returns a new string whose content is a copy of a string @var{s1}, except
the part beginning from the index
@var{start1} (inclusive) and ending at the index @var{end1} (exclusive)
are replaced by a string @var{s2}.   When optional @var{start2} and @var{end2}
arguments are given, @var{s2} is trimmed first according to them.
The size of the @emph{gap}, @code{(- @var{end1} @var{start1})}, doesn't
need to be the same as the size of the inserted string.
Effectively, this is the same as the following code.
@c JP
文字列@var{s1}の@var{start1}文字目(inclusive)から@var{end1}文字目(exclusive)
までを文字列@var{s2}に置き換えた文字列を新たに作って返します。@var{s1}, @var{s2}は
変更されません。
オプショナルな引数@var{start2}、@var{end2}が与えられた場合は、
@var{s2}がまずそれらによって切り取られて置換文字列として使われます。
置き換える隙間の大きさ、つまり@code{(- @var{end1} @var{start1})}は
@var{s2}と同じ長さである必要はありません。
実質的に、この手続きは次のコードと等価です。
@c COMMON

@example
(string-append (substring s1 0 start1)
               (substring s2 start2 end2)
               (substring s1 end1 (string-length s1)))
@end example
@end defun

@defun string-tokenize s :optional token-set start end
[SRFI-13]
@c MOD srfi-13
@c EN
Splits the string @var{s} into a list of substrings,
where each substring is a maximal non-empty contiguous
sequence of characters from the character set @var{token-set}.
The default of @var{token-set} is @code{char-set:graphic}
(@pxref{Predefined character-set}).

See also Gauche's built-in @code{string-split} (@pxref{String utilities}),
which provides similar features but different criteria.
@c JP
文字列 @var{s} を、@var{token-set} で指定される文字セットで
構成される、空でない最大限連続した文字のシーケンスのそれぞれを
要素とするリストを返します。
@var{token-set} のデフォルト値は @code{char-set:graphic}
(@ref{Predefined character-set}参照)。

同様の機能を提供する、しかし異なる基準を持つ、Gauche の組み込み手続き
@code{string-split} (@ref{String utilities} 参照) も見て下さい。
@c COMMON
@end defun

@node SRFI-13 String filtering, SRFI-13 Low-level string procedures, SRFI-13 other string operations, String library
@subsection String filtering
@c NODE 文字列のフィルタリング

@defun string-filter char/char-set/pred s :optional start end
@defunx string-delete char/char-set/pred s :optional start end
[SRFI-13]
@c MOD srfi-13
@c EN
Returns a string consists of characters in a string @var{s} 
that passes (or don't pass) the test indicated by @var{char/char-set/pred},
respectively.  
@c JP
それぞれ、文字列@var{s}中の文字のうち@var{char/char-set/pred}で示される
テストを通る、または通らない文字からなる文字列を返します。
@c COMMON

@example
(string-filter char-upper-case? "Hello, World!")
  @result{} "HW"

(string-delete char-upper-case? "Hello, World!")
  @result{} "ello, orld!"

(string-delete #\l "Hello, World!")
  @result{} "Heo, Word!"

(string-filter #[\w] "Hello, World!")
  @result{} "HelloWorld"
@end example

@c EN
Note: Srfi-13 was revised after finalization to switch
the order of arguments @var{char/char-set/pred} and @var{s} was.
At the time of finalization, the order was
@code{(string-filter s pred)} and Gauche implemented it accordingly.
However, most existing implementations follows the revised order,
since that was what the srfi-13 reference implementation had.

So, from 0.9.4, we revised the API to comply the current
srfi-13 spec, but we also accept the old order as well
not to break the old code.
We recommend the new code to use the new order.
@c JP
註: srfi-13は制定後に改訂され、引数@var{char/char-set/pred}と@var{s}の
順序が逆になりました。制定時点では引数順は
@code{(string-filter s pred)}で、Gaucheもそれに従って実装していました。
しかし既存の実装のほとんどは@code{(string-filter pred s)}という順序に
なっています。srfi-13の参照実装がそうだったからです。

0.9.4からGaucheも現在のsrfi-13の実装に合わせましたが、
以前の仕様で書かれたコードとの互換性を保つため、
引数順を逆にしても動作するようになっています。
新しく書かれるコードは、現在のsrfi-13の引数順を使うのが良いでしょう。
@c COMMON
@end defun

@node SRFI-13 Low-level string procedures,  , SRFI-13 String filtering, String library
@subsection Low-level string procedures
@c NODE 低レベルな文字列に関する手続き

@defun string-parse-start+end proc s args
@defunx string-parse-final-start+end proc s args
[SRFI-13]
@c MOD srfi-13
@end defun

@defmac let-string-start+end (start end [rest]) proc-exp s-exp args-exp body @dots{}
[SRFI-13]
@c MOD srfi-13
@end defmac

@defun check-substring-spec proc s start end
@defunx substring-spec-ok? s start end
[SRFI-13]
@c MOD srfi-13
@end defun

@defun make-kmp-restart-vector s :optional c= start end
[SRFI-13]
@c MOD srfi-13
@end defun

@defun kmp-step pat rv c i c= p-start
[SRFI-13]
@c MOD srfi-13
@end defun

@defun string-kmp-partial-search pat rv s i :optional c= p-start s-start s-end
[SRFI-13]
@c MOD srfi-13
@end defun

@c ----------------------------------------------------------------------
@node Character-set library, Time data types and procedures, String library, Library modules - SRFIs
@section @code{srfi-14} - Character-set library
@c NODE 文字集合ライブラリ, @code{srfi-14} - 文字集合ライブラリ

@deftp {Module} srfi-14
@mdindex srfi-14
@c EN
SRFI-14 has become a part of R7RS large.
@xref{R7RS character sets}.
@c JP
SRFI-14はR7RS largeに採り入れられました。
@ref{R7RS character sets}を参照してください。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node Time data types and procedures, Sources of random bits, Character-set library, Library modules - SRFIs
@section @code{srfi-19} - Time data types and procedures
@c NODE 時間のデータ型と手続き, @code{srfi-19} - 時間のデータ型と手続き

@deftp {Module} srfi-19
@mdindex srfi-19
@c EN
This SRFI defines various representations of time and date, and
conversion methods among them.
@c JP
このSRFIは、時間と日付に関する様々な表現と、それらの間の変換メソッドを提供します。
@c COMMON

@c EN
On Gauche, time object is supported natively by @code{<time>} class
(@pxref{Time}).  Date object is supported by @code{<date>} class
described below.
@c JP
Gaucheでは、timeオブジェクトは@code{<time>}クラスとして組み込みで
サポートされています(@ref{Time}参照)。dateオブジェクトは以下で説明する
@code{<date>}クラスとしてサポートされます。
@c COMMON
@end deftp

@menu
* SRFI-19 Time types::
* SRFI-19 Time queries::
* SRFI-19 Time procedures::
* SRFI-19 Date::
* SRFI-19 Date reader and writer::
@end menu

@node SRFI-19 Time types, SRFI-19 Time queries, Time data types and procedures, Time data types and procedures
@subsection Time types
@c NODE 時間のタイプ

@c EN
Time type is represented by a symbol.  This module defines
the following constant variables that is bound to its name, for
convenience.
@c JP
時間のタイプはシンボルで表現されます。
このモジュールでは以下の定数が自分の名前に束縛された形で提供されています。
@c COMMON

@defvr {Constant} time-utc
[SRFI-19]
@c MOD srfi-19
@c EN
UTC time.  Gauche's built-in @code{current-time} always returns
this type (@pxref{Time}).
@c JP
UTC timeです。Gaucheの組み込みの@code{current-time}は常にこのタイプの時間を
返します (@ref{Time}参照)。
@c COMMON
@end defvr

@defvr {Constant} time-tai
[SRFI-19]
@c MOD srfi-19
@c EN
International Atomic Time.  This time is a bit larger than UTC, due to
the leap seconds.
@c JP
International Atomic Time。この時間は閏秒による調整を受けないため、
UTCより若干大きな値を取ります。
@c COMMON
@end defvr

@defvr {Constant} time-monotonic
[SRFI-19]
@c MOD srfi-19
@c EN
Implementation-dependent monotonically increasing time.
In Gauche, this is the same as @code{time-tai}.
@c JP
実装依存の、単調増加する時間。Gaucheの実装ではこれは@code{time-tai}と同じです。
@c COMMON
@end defvr

@defvr {Constant} time-duration
[SRFI-19]
@c MOD srfi-19
@c EN
Duration between two absolute time points.
@c JP
二つの絶対的な時点の間の期間。
@c COMMON
@end defvr

@defvr {Constant} time-process
[SRFI-19]
@c MOD srfi-19
@c EN
CPU time in current process.
Gauche calculates this from user time and system time returned by
POSIX times(3).
@c JP
現在のプロセスのCPU時間。
Gaucheは、POSIX time(3)コールが返すユーザ時間とシステム時間の合計からこの値を
計算します。
@c COMMON
@end defvr

@defvr {Constant} time-thread
[SRFI-19]
@c MOD srfi-19
@c EN
CPU time in current thread.
In the current implementation, this is the same as @code{time-process}.
@c JP
現在のスレッドのCPU時間。
現在の実装ではこれは@code{time-process}と同じです。
@c COMMON
@end defvr

@node SRFI-19 Time queries, SRFI-19 Time procedures, SRFI-19 Time types, Time data types and procedures
@subsection Time queries
@c NODE 時間に関する問い合わせ

@defun current-time :optional time-type
[SRFI-19]
@c MOD srfi-19
@c EN
Extends Gauche built-in @code{current-time} (@pxref{Time}) to take
optional @var{time-type} argument to specify the desired time type.
@var{time-type} must be one of the types described in @ref{SRFI-19 Time types}.
@c JP
Gauche組み込みの@code{current-time} (@ref{Time}参照)を拡張して、
必要な時間のタイプを省略可能な引数@var{time-type}で指定できるようにしています。
可能な@var{time-type}の値は@ref{SRFI-19 Time types}で説明されているものです。
@c COMMON
@end defun

@defun current-date :optional tz-offset
[SRFI-19]
@c MOD srfi-19
@c EN
Returns the current date as an instance of @code{<date>} class
(@pxref{SRFI-19 Date}).  If @var{tz-offset} is given, it must be
an offset from UTC in number of seconds.  If @var{tz-offset} is
not given, returns the date in local time zone.
@c JP
現在の日付を@code{<date>}クラスのインスタンスとして返します(@ref{SRFI-19 Date}参照)。
@var{tz-offset}が与えられた場合、それがUTCからのオフセットを表す秒数として
使われます。@var{tz-offset}が与えられなかった場合はローカルタイムゾーンで
表現された日付が返されます。
@c COMMON
@end defun

@defun current-julian-day
[SRFI-19]
@c MOD srfi-19
@c EN
Returns the current julian day, a point in time as a real number of
days since -4714-11-24T12:00:00Z (November 24, -4714 at noon, UTC).
@c JP
現在のユリウス日(Julian day)を返します。Julian dayは
-4714-11-24T12:00:00Z (November 24, -4714 at noon, UTC) からの日数を
実数で表現したものです。
@c COMMON
@end defun

@defun current-modified-julian-day
[SRFI-19]
@c MOD srfi-19
@c EN
Returns the current modified julian day, a point in time as a real
number of days since 1858-11-17T00:00:00Z
(November 17, 1858 at midnight, UTC).
@c JP
現在の修正ユリウス日(Modified julian day)を返します。Modified julian dayは
1858-11-17T00:00:00Z (November 17, 1858 at midnight, UTC)
からの日数を実数で表現したものです。
@c COMMON
@end defun

@defun time-resolution
[SRFI-19]
@c MOD srfi-19
@end defun


@node SRFI-19 Time procedures, SRFI-19 Date, SRFI-19 Time queries, Time data types and procedures
@subsection Time procedures
@c NODE 時間に関する手続き

@defun make-time type nanoseconds seconds
[SRFI-19]
@c MOD srfi-19
@c EN
Returns an instance of @code{<time>} class with specified initial values.
Equivalent to @code{(make <time> :type type :second seconds :nanosecond nanoseconds)}.

(This function had been defined incorrectly before release 0.6.8;
the arguments @var{seconds} and @var{nanoseconds} were switched.
Please check your code if it uses @code{make-time}).
@c JP
与えられた初期値を持つ@code{<time>}クラスのインスタンスを返します。
@code{(make <time> :type type :second seconds :nanosecond nanoseconds)}
と等価です。

(この関数は0.6.8より前のリリースでは間違って定義されていました。
@var{seconds}と@var{nanoseconds}の引数が逆になっていたのです。
@code{make-time}を使っているコードは注意して下さい)。
@c COMMON
@end defun

@defun time-type time
@defunx time-second time
@defunx time-nanosecond time
@defunx set-time-type! time type
@defunx set-time-second! time second
@defunx set-time-nanosecond! time nanosecond
[SRFI-19]
@c MOD srfi-19
@c EN
Getter and setter of @code{<time>} object slots.
@c JP
@code{<time>}オブジェクトのスロットのアクセサです。
@c COMMON
@end defun

@defun copy-time time
[SRFI-19]
@c MOD srfi-19
@c EN
Returns a new instance of @code{<time>} whose content is the same as
given @var{time}
@c JP
与えられた@var{time}と同じ内容の新しい@code{<time>}オブジェクトを返します。
@c COMMON
@end defun

@defun time=? time0 time1
@defunx time<? time0 time1
@defunx time<=? time0 time1
@defunx time>? time0 time1
@defunx time>=? time0 time1
[SRFI-19]
@c MOD srfi-19
@c EN
Compares two times.  Types of both times must match.
@c JP
二つの時間を比較します。時間のタイプは一致していなければなりません。
@c COMMON
@end defun

@defun time-difference time0 time1
@defunx time-difference! time0 time1
[SRFI-19]
@c MOD srfi-19
@c EN
Returns the difference of two times, in @code{time-duration} time.
Types of both times must match.
@code{Time-difference!} modifies @var{time0} to store the result.
@c JP
二つの時間の差を@code{time-duration}タイプの時間として返します。
二つの時間のタイプは一致していなければなりません。
@code{Time-difference!}は結果を格納するために@var{time0}を変更します。
@c COMMON
@end defun

@defun add-duration time0 time-duration
@defunx add-duration! time0 time-duration
@defunx subtract-duration time0 time-duration
@defunx subtract-duration! time0 time-duration
[SRFI-19]
@c MOD srfi-19
@c EN
Adds or subtracts @var{time-duration} to or from @var{time0}.
Type of returned time is the same as @var{time0}.  Type of
@var{time-duration} must be @code{time-duration}.
@code{add-duration!} and @code{subtract-duration!} reuse
@var{time0} to store the result.
@c JP
@var{time-duration}を@var{time0}に加算、または@var{time0}から減算します。
返される時間のタイプは@var{time0}と同じです。@var{time-duration}のタイプは
@code{time-duration}でなければなりません。
@code{add-duration!}と@code{subtract-duration!}は結果を格納するのに
@var{time0}を再利用します。
@c COMMON
@end defun

@node SRFI-19 Date, SRFI-19 Date reader and writer, SRFI-19 Time procedures, Time data types and procedures
@subsection Date
@c NODE 日付

@deftp {Class} <date>
@clindex date
@c MOD srfi-19
@c EN
Represents a date.
@c JP
日付を表現します。
@c COMMON

@defivar <date> nanosecond
@c EN
Nanosecond portion of the date by an integer between 0 and 999,999,999,
inclusive.
@c JP
日付のナノ秒部分、0 から 999,999,999 までの整数です。
@c COMMON
@end defivar

@defivar <date> second
@c EN
Second portion of the date by an integer between 0 and 60, inclusive.
(60 for leap second).
@c JP
日付の秒部分、0 から 60 までの整数です。(60 は閏秒)
@c COMMON
@end defivar

@defivar <date> minute
@c EN
Minute portion of the date by an integer between 0 and 59, inclusive.
@c JP
日付の分部分、0 から 59 までの整数です。
@c COMMON
@end defivar

@defivar <date> hour
@c EN
Hour portion of the date by an integer between 0 and 23, inclusive.
@c JP
日付の時部分、0 から 23 までの整数です。
@c COMMON
@end defivar

@defivar <date> day
@c EN
Day portion of the date by an integer between 0 and 31, inclusive.
The actual upper bound of the day is determined by the year and the month.
(Note: 1 is for the first day; 0 is allowed by the specification,
but I don't see why).
@c JP
日付の日部分、0 から 31 日までの整数です。実際の上限は年と月によって決定
されます。(註: 1 は朔日(ついたち)、0 は仕様では認められていますが、
なぜなのかはわかりません。)
@c COMMON
@end defivar

@defivar <date> month
@c EN
Month portion of the date by an integer between 1 and 12, inclusive.
1 for January, 2 for February, and so on.
(Note: this is different from POSIX's @code{<sys-tm>} convention).
@c JP
日付の月部分、1 から 12 までの整数です。1 は一月、2 は二月、以下同様です。
(註: これは POSIX の @code{<sys-tm>} の命名法とは異ります。)
@c COMMON
@end defivar

@defivar <date> year
@c EN
Year portion of the date.
@c JP
日付の年部分です。
@c COMMON
@end defivar

@defivar <date> zone-offset
@c EN
The number of seconds east of GMT for this timezone, by an integer.
@c JP
このタイムゾーンが GMT より何秒東にあるかを示す整数です。
@c COMMON
@end defivar
@end deftp

@defun make-date nanosecond second minute hour day month year zone-offset
[SRFI-19]
@c MOD srfi-19
@c EN
Makes a @code{<date>} object from the given values.
Note: this procedure does not check if the values are in the valid range.
@c JP
与えられた値から @code{<date>} オブジェクトを作成します。
註: この手続きは与えられた値が正しい範囲であるかどうかをチェックしません。
@c COMMON
@end defun

@defun date? obj
[SRFI-19]
@c MOD srfi-19
@c EN
Returns true iff @var{obj} is a @code{<date>} object.
@c JP
@var{obj} が @code{<date>} オブジェクトである場合にかぎり真を返します。
@c COMMON
@end defun

@defun date-nanosecond date
@defunx date-second date
@defunx date-minute date
@defunx date-hour date
@defunx date-day date
@defunx date-month date
@defunx date-year date
@defunx date-zone-offset date
[SRFI-19]
@c MOD srfi-19
@c EN
Accessors.
@c JP
アクセサです。
@c COMMON
@end defun

@defun date-year-day date
@defunx date-week-day date
@defunx date-week-number date day-of-week-starting-week
[SRFI-19]
@c MOD srfi-19
@c EN
Calculates the day number in the year (1 for January 1st),
the day number in the week (0 for Sunday, 1 for Monday, ...),
and the ordinal week of the year which holds this date,
ignoring a first partial week, respectively.

@var{Day-of-week-starting-week} is the integer corresponding to
the day of the week which is to be considered the first day of
the week (Sunday=0, Monday=1, etc.).
@c JP
それぞれ、一年の何日目(一月一日が 1)か、何曜日(日曜日が 0、月曜日が 1
など)か、一年のうち何週目(一年の最初の週が一週間に満たない場合はその
週は無視)かを計算します。
@c COMMON
@end defun

@defun date->julian-day date
@defunx date->modified-julian-day date
@defunx date->time-monotonic date
@defunx date->time-tai date
@defunx date->time-utc date
[SRFI-19]
@c MOD srfi-19
@c EN
Conversions from date to various date/time types.
@c JP
日付から様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@defun julian-day->date jd :optional tz-offset
@defunx julian-day->time-monotonic jd
@defunx julian-day->time-tai jd
@defunx julian-day->time-utc jd
[SRFI-19]
@c MOD srfi-19
@c EN
Conversions from julian-day to various date/time types.
@c JP
ユリウス日からから様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@defun modified-julian-day->date jd :optional tz-offset
@defunx modified-julian-day->time-monotonic jd
@defunx modified-julian-day->time-tai jd
@defunx modified-julian-day->time-utc jd
[SRFI-19]
@c MOD srfi-19
@c EN
Conversions from modified julian-day to various date/time types.
@c JP
修正ユリウス日から様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@defun time-monotonic->date time :optional tz-offset
@defunx time-monotonic->julian-day time
@defunx time-monotonic->modified-julian-day time
@defunx time-monotonic->time-tai time
@defunx time-monotonic->time-tai! time
@defunx time-monotonic->time-utc time
@defunx time-monotonic->time-utc! time
[SRFI-19]
@c MOD srfi-19
@c EN
Conversions from time-monotonic to various date/time types.
@c JP
time-monotonic形式から様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@defun time-tai->date time :optional tz-offset
@defunx time-tai->julian-day time
@defunx time-tai->modified-julian-day time
@defunx time-tai->time-monotonic time
@defunx time-tai->time-monotonic! time
@defunx time-tai->time-utc time
@defunx time-tai->time-utc! time
[SRFI-19]
@c MOD srfi-19
@c EN
Conversions from time-tai to various date/time types.
@c JP
time-tai形式から様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@defun time-utc->date time :optional tz-offset
@defunx time-utc->julian-day time
@defunx time-utc->modified-julian-day time
@defunx time-utc->time-monotonic time
@defunx time-utc->time-monotonic! time
@defunx time-utc->time-tai time
@defunx time-utc->time-tai! time
[SRFI-19]
@c MOD srfi-19
@c EN
Conversions from time-utc to various date/time types.
@c JP
UTC 形式から様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@node SRFI-19 Date reader and writer,  , SRFI-19 Date, Time data types and procedures
@subsection Date reader and writer
@c NODE 日付の読み書き

@defun date->string date :optional format-string
[SRFI-19+]
@c MOD srfi-19
@c EN
Converts a @code{<date>} object to a string, according
to the format specified by @var{format-string}.
If @var{format-string} is omitted, @code{"~c"} is assumed.
@c JP
@code{<date>}オブジェクトを文字列に変換します。書式は
@var{format-string}で指定します。@var{format-string}が省略された場合に
は@code{"~c"}が指定されたものとします。
@c COMMON

@c EN
A format string is copied to output, except a sequence begins with
@code{~} which is replaced with the following rules:
@c JP
書式文字列は出力にコピーされます。ただし、@code{~}で始まる並びの部分は
以下の規則にしたがって書き換えられます。
@c COMMON

@c EN
@table @code
@item ~~
A literal @code{~}.
@item ~a
Locale's abbreviated weekday name (Sun...Sat).
@item ~A
Locale's full weekday name (Sunday...Saturday).
@item ~b
Locale's abbreviate month name (Jan...Dec).
@item ~B
Locale's full month name (January...December).
@item ~c
Locale's date and time (e.g., "Fri Jul 14 20:28:42-0400 2000").
@item ~d
Day of month, zero padded (01...31).
@item ~D
Date (mm/dd/yy).
@item ~e
Day of month, blank padded ( 1...31).
@item ~f
Seconds+fractional seconds, using locale's decimal separator (e.g. 5.2).
@item ~h
Same as ~b.
@item ~H
Hour, zero padded, 24-hour clock (00...23).
@item ~I
Hour, zero padded, 12-hour clock (01...12).
@item ~j
Day of year, zero padded.
@item ~k
Hour, blank padded, 24-hour clock ( 0...23).
@item ~l
Hour, blank padded, 12-hour clock ( 1...12).
@item ~m
Month, zero padded (01...12).
@item ~M
Minute, zero padded (00...59).
@item ~n
New line.
@item ~N
Nanosecond, zero padded.
@item ~p
Locale's AM or PM.
@item ~r
Time, 12 hour clock, same as "~I:~M:~S ~p".
@item ~s
Number of full seconds since "the epoch" (in UTC).
@item ~S
Second, zero padded (00...60).
@item ~t
Horizontal tab.
@item ~T
Time, 24 hour clock, same as "~H:~M:~S".
@item ~U
Week number of year with Sunday as first day of week (01...53).
@item ~V
Week number of year with Monday as first day of week (00...52).
@item ~w
Day of week (0...6).
@item ~W
Week number of year with Monday as first day of week (00...52).
@item ~x
Locale's date representation, for example: "07/31/00".
@item ~X
Locale's time representation, for example: "06:51:44".
@item ~y
Last two digits of year (00...99).
@item ~Y
Year.
@item ~z
Time zone in RFC-822 style.
@c @item ~Z
@c Symbol time zone (not-implemented).
@item ~1
ISO-8601 year-month-day format.
@item ~2
ISO-8601 hour-minute-second-timezone format.
@item ~3
ISO-8601 hour-minute-second format.
@item ~4
ISO-8601 year-month-day-hour-minute-second-timezone format.
@item ~5
ISO-8601 year-month-day-hour-minute-second format.
@end table
@c JP
@table @code
@item ~~
文字@code{~}そのもの。
@item ~a
ロケールによる曜日省略形(Sun...Sat)
@item ~A
ロケールによる曜日完全形(Sunday...Saturday)
@item ~b
ロケールによる月省略形(Jan...Dec)
@item ~B
ロケールによる月完全形(January...December)
@item ~c
ロケールによる日付時刻(たとえば、"Fri Jul 14 20:28:42-0400 2000")
@item ~d
月日にち、0を補填(01...31)
@item ~D
日付(mm/dd/yy)
@item ~e
月日にち、空白補填( 1...31)
@item ~f
秒 + 小数秒、小数点はロケールによるセパレータ(たとえば、5.2)
@item ~h
~b に同じ
@item ~H
時、0を補填、24時制(00...23)
@item ~I
時、0を補填、12時制(01...12)
@item ~j
年日にち、0補填(001...366)
@item ~k
時、空白補填、24時制( 0...23)
@item ~l
時、空白補填、12時制( 1...12)
@item ~m
月、0補填、(01...12)
@item ~M
分、0補填、(00...59)
@item ~n
改行
@item ~N
ナノ秒、0補填
@item ~p
ロケールによるAM、PM
@item ~r
時刻、12時制、"~I:~M:~S ~p"と同じ
@item ~s
エポックからの経過秒(UTC)
@item ~S
秒、0補填(00...60)
@item ~t
水平タブ
@item ~T
時刻、24時制、"~H:~M:~S"と同じ
@item ~U
年経過週、週は日曜はじまり(01...53)
@item ~V
年経過週、週は月曜はじまり(00...52)
@item ~w
曜日を表す数字、日曜が0 (0...6)
@item ~W
年経過週、週は月曜日はじまり(00...52)
@item ~x
ロケールによる日付、例えば、"07/31/00"
@item ~X
ロケールによる時刻、24時制、例えば、"06:51:44"
@item ~y
西暦の下2桁(00...99)
@item ~Y
西暦
@item ~z
RFC-2822スタイルのタイムゾーン
@c @item ~Z
@c Symbol time zone (not-implemented).
@item ~1
ISO-8601 の「年-月-日」形式
@item ~2
ISO-8601 の「時-分-秒タイムゾーン」形式
@item ~3
ISO-8601 の「時:分:秒」形式
@item ~4
ISO-8601 の「西暦-月-日T時:分:秒タイムゾーン」形式
@item ~5
ISO-8601 の「西暦-月-日T時:分:秒」形式
@end table
@c COMMON

@c EN
Note: currently Gauche doesn't honor process's locale setting,
and it always formats the date as if the locale is "C".  It may
be changed in future, so you shouldn't rely on, for example,
@code{~a} always formatted as "Sun".."Sat".
@c JP
注意：現時点でGaucheはロケールの設定には従っておらず、常にロケールが
"C" に設定されているものとしてフォーマットします。これについては将来変
更する可能性がありますので、現在の振舞いを前提として、たとえば、
@code{~a}が常に"Sun".."Sat"のようにフォーマットされることを前提にプロ
グラムしてはいけません。
@c COMMON

@c EN
There's no portable way to ensure you'll get "C" locale formats
since there's no standard way to set process's locale yet.
However, Gauche provides a way to ensure the locale to be "C",
as an extension to srfi-19.
Insert @code{@@} between @code{~} and the directive
character, such as @code{~@@a}.
@c JP
いまのところプロセスのロケールを設定する標準的な方法がないので、
"C"ロケール形式を取得できるかどうかを確かめるポータブルな方法がありま
せん。とはいえ、Gaucheでは SRFI-19の拡張として"C"ロケールであることを
確認する方法を提供しています。@code{@@} を @code{~} とディレクティブ文
字の間に挿入し、@code{~@@a} のようにします。
@c COMMON
@end defun

@defun string->date string template-string
[SRFI-19]
@c MOD srfi-19
@c   [NB] srfi-19's string->date is broken, in both spec and reference
@c   implementation.  I'm wondering whether I should change string->date
@c   to make usable, or introduce another procedure, like string->date*,
@c   which fixes the problem.
@c
@c Both procedures parse a string representation of date in @var{string},
@c according to the format given in @var{template-string}.

@c The input string must match the @var{template-string},
@c except tilde-directives described below, which matches
@c one or more component(s) of the date.  If the input string
@c is parsed successfully, a @code{<date>} object is returned
@c with the matched components are filled.

@c If the input string does not match @var{template-string},
@c an error is signaled.  (The SRFI-19 spec doesn't explicitly
@c state what happens if @code{string->date} doesn't accept the
@c input, which actually reduces usability of @code{string->date}

@c but the reference implentation signals an error, and
@c it would be safe to assume


@c @table @code
@c @item ~~
@c Matches literal @code{~}.
@c @item ~a
@c Skip to an alphanumeric character, then matches abbreviated
@c weekday in locale.  Match result is ignored.
@c @item ~A
@c Skip to an alphanumeric character, then matches full
@c weekday in locale.  Match result is ignored.
@c @item ~b
@c Skip to an alphanumeric character, then matches abbreviated
@c month name in locale.  Sets the month component of the date.
@c @item ~B
@c Skip to an alphanumeric character, then matches full
@c month name in locale.  Sets the month component of the date.
@c @item ~d
@c Skip to a numeric character, then maches the day of month.
@c Sets the month component of the date.
@c @item ~e

@c ~e	any	day of month, blank padded	date-day
@c ~h	char-alphabetic?	same as ~b	nothing
@c ~H	char-numeric?	hour	date-hour
@c ~k	any	hour, blank padded	date-hour
@c ~m	char-numeric?	month	date-month
@c ~M	char-numeric?	minute	date-minute
@c ~S	char-numeric?	second	date-second
@c ~y	any	2-digit year	date-year within 50 years
@c ~Y	char-numeric?	year	date-year
@c ~z	any	time zone	date-zone-offset@end table

@end defun

@c ----------------------------------------------------------------------
@node Sources of random bits, Localization, Time data types and procedures, Library modules - SRFIs
@section @code{srfi-27} - Sources of Random Bits
@c NODE ランダムビットのソース, @code{srfi-27} - ランダムビットのソース

@deftp {Module} srfi-27
@mdindex srfi-27
@c EN
This module provides SRFI-27 pseudo random generator interface,
using Mersenne Twister algorithm
(@pxref{Mersenne-Twister random number generator}) as the backbone.
@c JP
このモジュールはメルセンヌツイスタアルゴリズム
(@ref{Mersenne-Twister random number generator} 参照)
を基礎に用いたSRFI-27疑似乱数発生器インタフェースを提供します。
@c COMMON
@end deftp

@defun random-integer n
[SRFI-27]
@c MOD srfi-27
@c EN
Returns a random exact integer between [0, @var{n}-1], inclusive,
using the default random source.
To set a random seed for this procedure, use @code{random-source-randomize!}
or @code{random-source-pseudo-randomize!} on @code{default-random-source}.
@c JP
デフォルトの乱数発生源を用いて、0 から @var{n}-1 までの正確な整数の乱数を
返します。この手続きの乱数のシードを設定するには
@code{default-random-source} に対して
@code{random-source-randomize!} あるいは、
@code{random-source-pseudo-randomize!} を用います。
@c COMMON
@end defun

@defun random-real
[SRFI-27]
@c MOD srfi-27
@c EN
Returns a random real number between (0, 1), exclusive,
using the default random source.
To set a random seed for this procedure, use @code{random-source-randomize!}
or @code{random-source-pseudo-randomize!} on @code{default-random-source}.
@c JP
デフォルトの乱数発生源を用いて、0 より大きく、1 未満の実数乱数を返します。
この手続きの乱数のシードを設定するには @code{default-random-source} に対して
@code{random-source-randomize!} あるいは、
@code{random-source-pseudo-randomize!} を用います。
@c COMMON
@end defun

@defvar default-random-source
[SRFI-27]
@c MOD srfi-27
@c EN
Keeps the default random source that is used by @code{random-integer}
and @code{random-real}.
@c JP
@code{random-integer} および @code{random-real} が利用するデフォルトの
乱数発生源を保持しています。
@c COMMON
@end defvar

@defun make-random-source
[SRFI-27]
@c MOD srfi-27
@c EN
Creates and returns a new random source.
In the current Gauche implementation, it is just a @code{<mersenne-twister>}
object.  It may be changed in the future implementation.
@c JP
乱数の発生源を生成し返します。
現在の Gauche の実装では、これは @code{<mersenne-twister>} のオブジェクトです。
将来の実装では変更される可能性があります。
@c COMMON
@end defun

@defun random-source? obj
[SRFI-27]
@c MOD srfi-27
@c EN
Returns @code{#t} if @var{obj} is a random source object.
@c JP
@var{obj} が乱数発生源オブジェクトであれば、@code{#t} を返します。
@c COMMON
@end defun

@defun random-source-state-ref s
@defunx random-source-state-set! s state
[SRFI-27]
@c MOD srfi-27
@c EN
Gets and sets the "snapshot" of the state of the random source @var{s}.
@var{State} is an opaque object whose content depends on the backbone
generator.
@c JP
乱数発生源 @var{s} の状態の「スナップショット」を獲得あるいは設定します。
@var{state} は背後にある発生器に依存する内容をもつ不透明なオブジェクトです。
@c COMMON
@end defun

@defun random-source-randomize! s
[SRFI-27]
@c MOD srfi-27
@c EN
Makes an effort to set the state of the random source @var{s} to
a truly random state.  The current implementation uses the current
time and the process ID to set the random seed.
@c JP
乱数発生源 @var{s} の状態を完全にランダムな状態にしようとします。
現在の実装では乱数のシードを設定するのに、現在の時刻とプロセス ID を
使います。
@c COMMON
@end defun

@defun random-source-pseudo-randomize! s i j
[SRFI-27]
@c MOD srfi-27
@c EN
Changes the state of the random source @var{s} into the initial state
of the (@var{i}, @var{j})-th independent random source,
where @var{i} and @var{j} are non-negative integers.
This procedure can be used to reuse a random source @var{s} as large
number of independent random source, indexed by two non-negative integers.
Note that this procedure is entirely deterministic.
@c JP
乱数発生源 @var{s} の状態を発生源とは独立した (@var{i}, @var{j}) 番の
初期状態に設定します。@var{i} および @var{j} は非負の整数です。
この手続きは乱数発生源 @var{s} を二つの非負整数でインデックス付した、
大規模の独立の乱数発生源として再利用するときに利用できます。
この手続きは、完全な決定性があることに注意してください。
@c COMMON
@end defun

@defun random-source-make-integers s
[SRFI-27]
@c MOD srfi-27
@c EN
Returns a procedure, that takes one integer argument @var{n} and
returns a random integer between 0 and @var{n}-1 inclusive for every
invocation, from the random source @var{s}.
@c JP
呼出しのたびに乱数発生源 @var{s} より、 0 から @var{n}-1 までの整数の
乱数を返す、一つの整数 @var{n} を引数としてとる手続きを、返します。
@c COMMON
@end defun

@defun random-source-make-reals s :optional unit
[SRFI-27]
@c MOD srfi-27
@c EN
Returns a procedure, that takes no argument and
returns a random real between 0 and 1 exclusive for
every invocation, from the random source @var{s}.
If @var{unit} is given, the random real the returned procedure
generates will be quantized by the given @var{unit}, where
0 < @var{unit} < 1.
@c JP
呼出しのたびに乱数発生源 @var{s} から 0 より大きく 1 未満の実数乱数を
返す、無引数の手続きを返します。
@var{unit} が与えられた場合、返された手続きが生成する実数乱数は
@var{unit} 単位に量子化されます。@var{unit} は、 0 より大きく 1 未満で
なければなりません。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Localization, A program argument processor, Sources of random bits, Library modules - SRFIs
@section @code{srfi-29} - Localization
@c NODE 地域化, @code{srfi-29} - 地域化

@deftp {Module} srfi-29
@mdindex srfi-29
@mdindex srfi-29.bundle
@mdindex srfi-29.format
@c EN
This module implements the message localization mechanism
defined in SRFI-29.

In fact, this module consists of two submodules,
@code{srfi-29.bundle} and @code{srfi-29.format}.
The module @code{srfi-29} extends both submodules.
It is because srfi-29's definition of the @code{format}
procedure is incompatible to Gauche's native @code{format}
(thus Common Lisp's @code{format}) in the handling of
@code{~@@*} directive.

So I splitted the module into two, @code{srfi-29.format}
which contains srfi-29's @code{format}, and @code{srfi-29.bundle}
which contains the rest ("bundle" API).
If a program wishes a complete compatibility of
srfi-29, use @code{srfi-29} module, which overrides
Gauche's native @code{format}.   If a program just wants
srfi-29's "bundle" API, but wants to keep Gauche's @code{format},
use @code{srfi-29.bundle}.

A localization feature is also provided by @code{text.gettext} module
(@pxref{Localized messages}),
which is a preferable way of message localization in Gauche.
This module is provided mainly for porting code that uses
srfi-29 features.
@c JP
このモジュールは SRFI-29 で定義されたメッセージの地域化機構を実装したものです。

実際には、このモジュールは2つのサブモジュール、@code{srfi-29.bundle}
および @code{srfi-29.format} で構成されています。@code{srfi-29}モジュールは
このふたつのモジュールをextendしています。このようにしているのは、
SRFI-29 での @code{format} 手続きの定義が Gauche ネイティヴの(すなわち
Common Lisp の) @code{format} とでは @code{~@@*} 指令の扱い
において互換性がないからです。

そんなわけで、SRFI-29 の @code{format} を含む @code{srfi-29.format} と
それ以外(「バンドル」API)を含む @code{srfi-29.bundle} に分離しました。
プログラムを SRFI-29 と完全に互換性のあるものにしたければ、@code{srfi-29}
モジュールを使って下さい。こうすると Gauche ネイティヴの
@code{format} が上書きされます。SRFI-29 の「バンドル」API を使いたいだけで、
Gauche の @code{format} をそのままにしておきたいなら、@code{srfi-29.bundle}
を使って下さい。

地域化機能は @code{text.gettext} モジュールによっても提供され
(@pxref{Localized messages})、Gauche でメッセージの地域化をするのなら
@code{text.gettext} を使うのが好ましい方法です。@code{srfi-29} モジュールは
主として SRFI-29 の機能を使っているコードをポーティングするためにあります。
@c COMMON
@end deftp

@c EN
@subheading Bundle specifier
@c JP
@subheading バンドル指定子
@c COMMON

@c EN
A @emph{bundle specifier} is an arbitrary list of symbols,
but typically it takes the form like:
@c JP
@emph{バンドル指定子}はシンボルを要素とする任意のリストです。しかし
典型的には以下のようなフォームになります。
@c COMMON
@example
@code{(@var{package} @var{language} @var{country} @var{details} @dots{})}
@end example
@c EN
Where @var{package} specifies the software package,
@var{language} and @var{country} specifies language and country code,
and @var{details} gives other informations like encoding.

The values for the default bundle specifier can be obtained
by the following parameters.
@c JP
ここで、@var{package} はソフトウェアパッケージを指定し、
@var{language} および @var{country} は言語と国コードを指定、そして、
@var{details} はエンコーディングのようなそのほかの情報を指定します。

デフォルトのバンドル指定子の値は以下のようなパラメータで取得可能です。
@c COMMON

@deffn {Parameter} current-language
@deffnx {Parameter} current-country
@deffnx {Parameter} current-locale-details
[SRFI-29]
@c MOD srfi-29
@c EN
The @code{current-language} and @code{current-country} parameters
keep the ISO 639-1 language code and ISO 3166-1 country code
respectively, both as symbols.
The @code{current-locale-details} keeps a list of auxiliary
local informations, such as encodings.

These parameters are initialized if @code{LANG} environment
variable is set in the form of @code{lang_country.encoding} format.
For example, if the @code{LANG} setting is @code{ja_JP.eucJP},
those parameters are @code{ja}, @code{jp}, and @code{(eucjp)},
respectively.   If @code{LANG} is @code{C} or undefined,
the default values are @code{en}, @code{us}, and @code{()}, respectively.
@c JP
@code{current-language} および @code{current-country} パラメータは
ISO 639-1 の言語コードと ISO 3166-1 の国コードをそれぞれシンボルで
保持しています。@code{current-locale-details} はエンコーディングのような
補助的な地域情報のリストを保持しています。

これらのパラメータは、環境変数 @code{LANG} が @code{lang_country.encoding}
フォーマットの形式で設定されていれば、初期化されます。たとえば、
@code{LANG} が @code{ja_JP.eucJP} に設定されていれば、それらの
パラメータはそれぞれ @code{ja}、@code{jp}、@code{(eucjp)} に設定されます。
@code{LANG} が @code{C} であるかあるいは定義されていなければ、
デフォルト値は、それぞれ @code{en}、@code{us}、@code{()} です。
@c COMMON
@end deffn

@c EN
@subheading Bundle preparation
@c JP
@subheading バンドル準備
@c COMMON

@defun declare-bundle! bundle-specifier association-list
[SRFI-29]
@c MOD srfi-29
@c EN
Put the association list of template key (symbol) and the locale-specific
message (string) into the bundle database, with @var{bundle-specifier}
as the key.
@c JP
テンプレートキー(シンボル)と特定ロケールのメッセージ(文字列)の連想リストを
@var{bundle-specifier} をキーとして、バンドルデータベースに入れます。
@c COMMON
@end defun

@c EN
Gauche currently supports only in-memory bundle database.
That is, you have to call @code{declare-bundle!} within the application
in order to lookup the localized messages.
@c JP
Gauche は現在のところメモリ上のバンドルデータベースのみサポートしています。
つまり、地域化されてメッセージを探しあてるには、そのアプリケーション内で
@code{declare-bundle!} を呼ぶ必要があるということです。
@c COMMON

@defun save-bundle! bundle-specifier
@defunx load-bundle! bundle-specifier
[SRFI-29]
@c MOD srfi-29
@c EN
Since Gauche doesn't support persistent bundle database yet,
these procedures does nothing and returns @code{#f}.
(It is still conforming behavior of srfi-29).
@c JP
Gauche は今のところ永続バンドルデータベースをサポートしていないので、
これらの手続きはなにもせず @code{#f} を返します
(これはいまのところ srfi-29 の振舞いと適合しています)。
@c COMMON
@end defun

@c EN
@subheading Retrieving localized message
@c JP
@subheading 地域化されたメッセージの検索
@c COMMON

@defun localized-template package-name message-template-name
[SRFI-29]
@c MOD srfi-29
@c EN
Retrieves localized message, associated with a symbol
@var{message-template-name} in the package @var{package-name}.
@c JP
地域化されたメッセージを検索します。当該メッセージは
@var{package-name} パッケージの中で、@var{message-template-name}
シンボルと関連つけられています。
@c COMMON
@end defun

@c EN
@subheading Extended format procedure
@c JP
@subheading 拡張された format 手続き
@c COMMON

@defun format format-string args
[SRFI-29]
@c MOD srfi-29
@c EN
SRFI-29 extends SRFI-28's @code{format} procedure spec
(which supports @code{~a}, @code{~s}, @code{~%} and @code{~~} directives),
in order to support argument repositioning.

A directive @code{~N@@*}, where N is an integer or can be omitted,
causes the next directive to retrieve a value from @var{N}-th
optional argument.  The referenced value isn't consumed,
and won't affect the processing of subsequent directives.

Although SRFI-28 spec is compatible to
Gauche's native @code{format} (@pxref{Output}),
this SRFI-29 extention isn't.
Specifically, the @code{~N@@*} directive of Gauche's @code{format}
changes the argument pointer to points @var{N}-th optional argument,
thus it affects all the subsequent arguments.

Because of this incompatibility, this function is defined in
a separate module, @code{srfi-29.format}.  If you use @code{srfi-29},
which extends @code{srfi-29.bundle} and @code{srfi-29.format},
the @code{format} procedure will be overridden by srfi-29's @code{format}
in your module.  If you want to keep Gauche's native @code{format},
use @code{srfi-29.bundle} only.
@c JP
SRFI-29 は SRFI-28 の @code{format} 手続きの仕様(これは @code{~a}、
@code{~s}、@code{~%} および @code{~~} 指令をサポートしている)を
引数再配置をサポートするために拡張しています。

@code{~N@@*} 指令は @var{N}-番目のオプション引数から値を引き出す次の
指令の契機となります。参照された値が消費されることはありません。また、
参照された値がその後につづく指令の処理に影響を与えることはありません。

SRFI-28 の仕様は Gauche ネイティヴの @code{format} (@pxref{Output}) と
互換性がありますが、この SRFI-29 の拡張には互換性がありません。
具体的には、Gauche ネイティヴの @code{format} の @code{~N@@*} 指定は
引数ポインタを @var{N}-番目のオプション引数を指すように変更します。
それゆえ、そのあとに続くすべての引数に影響をあたえます。

この非互換性があるために、この関数は、分離したモジュール
@code{srfi-29.format} で定義されています。@code{srfi-29.bundle} と
@code{srfi-29.format} を拡張する @code{srfi-29} を使うと、@code{format}
手続きは SRFI-29 の @code{format} でそのモジュール内で上書きされます。
Gauche ネイティヴの @code{format} を使いたければ、@code{srfi-29.bundle}
だけを使うようにしてください。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node A program argument processor, Eager comprehensions, Localization, Library modules - SRFIs
@section @code{srfi-37} - args-fold: a program argument processor
@c NODE args-fold プログラム引数処理, @code{srfi-37} - args-fold プログラム引数処理

@deftp {Module} srfi-37
@mdindex srfi-37
@c EN
This module implements @code{args-fold},
yet another procedure to process command-line
arguments, defined in SRFI-37 (@ref{srfi-37,[SRFI-37],SRFI-37}).

Unlike @code{gauche.parseopt}
(@pxref{Parsing command-line options}),
@code{args-fold} provides functional interface, i.e.
the user's states are explicitly passed via parser's argument and
return values, and also follows POSIX and GNU getopt guidelines,
including long options.
@c JP
このモジュールは、@code{args-fold} を実装しています。
これは、SRFI-37 (@ref{srfi-37,[SRFI-37],SRFI-37}) で定義されている
コマンドライン引数の処理をするもうひとつの手続きです。

@code{gauche.parseopt} (@ref{Parsing command-line options}
参照) とは違って、@code{args-fold} は関数的なインタフェースです。すなわち、
利用者側の状態は、パーザの引数を通じて明示的に渡され、値が返ります。
また、ロングオプションを含む、POSIX および GNU の getopt のガイドラインに
準拠しています。
@c COMMON
@end deftp

@defun args-fold args options unrecognized-proc operand-proc :rest seeds
@c MOD srfi-37
@c EN
Processes program options @var{args} from left to right,
according to given option specification @var{options},
and two procedures @var{unrecognized-proc} and @var{operand-proc}.

@var{Options} is a list of option objects, explained below.
Each option object keeps the name(s) of the option,
a flag to specify whether the option takes
an argument or not, and a procedure to process that option
(we'll call it @emph{option procedure}).

@code{Args-fold} recognizes both single-character options (short options)
and long options.  A short option must begin with single hyphen
(e.g. @code{-a}), while long option must begin with double hyphens
(e.g. @code{--help}).   Short options can be
concatenated, e.g. @code{-abc} or @code{-a -b -c}.
Both a short option and a long option can take
required or optional arguments.   Required short-option argument
can appear with or without space after the option, e.g.
@code{-afoo} or @code{-a foo}.
Long-option argument can appear after character '@code{=}' or
space, e.g. @code{--long=foo} or @code{--long foo}.

When @code{args-fold} encounters a command-line argument that cannot
be an option argument, and doesn't begin with hyphen, the argument is
treated as an @emph{operand}.   @code{Args-fold} allows operands and
options to be interleaved.  However, if @code{args-fold} encounters
'@code{--}', the rest of arguments are treated as operands,
regardless of beginning with hyphen or not.

When the given option matches one of option object in @var{options},
the option procedure is called as follows:
@c JP
与えられたオプション仕様 @var{options} および、ふたつの手続き
@var{unrecognized-proc} と @var{operand-proc} とにしたがって、プログラム
引数 @var{args} を左から右へ処理します。

@var{options} はオプションオブジェクトのリストで以下のようなものです。
各オプションオブジェクトはオプションの名前、そのオプションが引数を
とるかどうかを指定するフラグ、そのオプションを処理する手続き
(今後これを @emph{オプション手続き}とよびます)を保持しています。

@code{args-fold} は単一文字のオプション(ショートオプション)と
ロングオプションの両方を認識します。ショートオプションは単一の
ハイフンで始まって(たとえば、@code{-a})いなければなりません。一方、
ロングオプションは二つのハイフンで始まって(たとえば、@code{--help})
いなければなりません。ショートオプションは連結することが可能で、
たとえば、@code{-abc} あるいは @code{-a -b -c} と書くことができます。
ショートオプション、ロングオプションはともに、必須引数あるいはオプショナル
引数を取ることができます。ショートオプションの必須引数は当該オプション
あとに空白なしあるいは空白をいれて指定することができます。たとえば、
@code{-afoo} あるいは @code{-a foo} が可能です。ロングオプションの
引数は'@code{=}'文字あるいは空白をはさみます。たとえば、
@code{--long=foo} または @code{--long foo} です。

@code{args-fold} はオプションの引数ではなく、ハイフンで始まっていない
コマンドライン引数を@emph{オペランド}としてとりあつかいます。
@code{args-fold} はオペランドとオプションが交互に出現するのを許します。
しかし、'@code{--}' に出逢うと、のこりは、ハイフンで始まっていようと
なかろうと、オペランドとして扱われます。

与えられたオプションが @var{options} 内のオプションオブジェクトのひとつ
にマッチすれば、オプション手続きが以下のように呼出されます。
@c COMMON

@example
(@var{option-proc} @var{option} @var{name} @var{arg} @var{seed} @dots{})
@end example

@c EN
where @var{option} is the matched option object, @var{name} is
the string actually used to specify the option, @var{arg} is
the option argument (or @code{#f} if there's none), and
@var{seed} @dots{} is the user's state information.
@var{Option-proc} must return as many arguments as @var{seed}s.

When @code{args-fold} encounters an option that doesn't match
any of the option objects, it creates a new option object
for the option and calls @var{unrecognized-proc}
with the same arguments as @var{option-proc}.

When @code{args-fold} finds an operand, @var{operand-proc}
is called as follows:
@c JP
ここで、@var{option} はマッチしたオプションオブジェクトで、@var{name}
は実際にオプションを指定するのに使われた文字列、@var{arg} はそのオプション
の引数(あるいは存在しなければ、@code{#f})、そして @var{seed} @dots{} は
利用者側の状態情報です。@var{option-proc} は @var{seed} と同じ数だけ
値を返さなければなりません。

@code{args-fold} がオペランドを見つけたら、@var{operand-proc} が
以下のように呼出されます。
@c COMMON

@example
(@var{operand-proc} @var{operand} @var{seed} @dots{})
@end example

@c EN
@var{Operand-proc} must return as many arguments as @var{seed}s.

The caller's state should be explicitly passed around seed arguments
and return values.  The initial seed values are @var{seed}s given
to @code{args-fold}.  The values returned from option procedure,
@var{unrecognized-proc} and @var{operand-proc} are used as the seed
arguments of next invocation of those procedures.  The values
returned from the last call to the procedures are returned
from @code{args-fold}.
@c JP
@var{operand-proc} は @var{seed} と同じ数だけ
値を返さなければなりません。

呼出し側の状態は明示的にシード引数で渡され、戻されます。初期のシード値は
@code{args-fold} に与えた @var{seed} です。この値は、オプション手続き
@var{unrecognized-proc} と @var{operand-proc} によって戻され、
次にこれらのオプション手続きの呼出し時にシード引数として使われます。
これらの手続きの最後の呼出しから返されたこの値は @code{args-fold} によって
返されます。
@c COMMON
@end defun

@defun option names require-arg? optional-arg? processor
@c MOD srfi-37
@c EN
Creates an option object with the passed properties.

@var{Names} is a list of characters and/or strings.
A character is used for a short option, and a string is used
for a long option.

Two flags, @var{require-arg?} and @var{optional-arg?}
indicates whether the option should take an option argument,
or may take an option argument.

@var{Processor} is the option processor procedure.

Note that, if an option argument is passed using '@code{=}'
character, it is passed to the option procedure even if
the option has @code{#f} in both @var{require-arg?}
and @var{optional-arg?}.  It is up to the option procedure
to deal with the argument.

It should also be noted that the optional option argument
for a short option is only recognized if it is given
without whitespace after the short option.  That is, if
a short option '@code{d}' is marked to take optional option argument,
then '@code{-dfoo}' is interpreted as '@code{-d}' with argument '@code{foo}',
but '@code{-d foo}' is interpreted as '@code{-d}' without argument
and an operand @code{foo}.  If '@code{d}' is marked to
take required option argument, however, both are interpreted
as '@code{-d}' with argument '@code{foo}'.
@c JP
渡されたプロパティでオプションオブジェクトを作成します。

@var{names} は文字と(あるいは)文字列のリストです。文字はショートオプションに
使い、文字列はロングオプションに使います。

ふたつのフラグ @var{require-arg?} と @var{optional-arg?} はオプションが
必須引数をとるか、あるいは、オプショナル引数をとるかを示します。

@var{processor} はそのオプションの処理をする手続きです。

オプションの引数が '@code{=}' つきで渡された場合には、
たとえ @var{require-arg?}、@var{optional-arg?} がともに @code{#f}
であっても、そのオプションの引数はオプション処理手続きに渡されることに
注意してください。オプション手続きにその引数を処理させようとします。

ショートオプションに対するオプショナルなオプションの引数は、オプションに
つづいてスペースなしで指定されたときにだけ認識されることにも
注意してください。たとえば、ショートオプション @code{d} がオプショナル
引数をもつことになっているとき、'@code{-dfoo}' は '@code{-d}' が引数
'@code{foo}' をもつと解釈されますが、'@code{-d foo}' は引数なしの
'@code{-d}' とオペランド '@code{foo}' と解釈されてしまいます。もし、
'@code{-d}' が必須引数をもつと設定されているなら、両方ともに
'@code{-dfoo}' は '@code{-d}' が引数 '@code{foo}' をもつと解釈されます。
@c COMMON
@end defun

@defun option? obj
@c MOD srfi-37
@c EN
Returns @code{#t} if @var{obj} is an option object,
@code{#f} otherwise.
@c JP
@var{obj} がオプションオブジェクトなら @code{#t} を返し、
そうでなければ、@code{#f} を返します。
@c COMMON
@end defun

@defun option-names option
@defunx option-required-arg? option
@defunx option-optional-arg? option
@defunx option-processor
@c MOD srfi-37
@c EN
Returns the properties of an option object @var{option}.
@c JP
オプションオブジェクト @var{option} のプロパティを返します。
@c COMMON
@end defun

@c EN
A simple example:
@c JP
簡単な例:
@c COMMON

@example
(use srfi-37)

(define options
 (list (option '(#\d "debug") #f #t
               (lambda (option name arg debug batch paths files)
                 (values (or arg "2") batch paths files)))
       (option '(#\b "batch") #f #f
               (lambda (option name arg debug batch paths files)
                 (values debug #t paths files)))
       (option '(#\I "include") #t #f
               (lambda (option name arg debug batch paths files)
                 (values debug batch (cons arg paths) files)))))

(define (main args)
  (receive (debug-level batch-mode include-paths files)
    (args-fold (cdr args)
               options
               (lambda (option name arg . seeds)         ; unrecognized
                 (error "Unrecognized option:" name))
               (lambda (operand debug batch paths files) ; operand
                 (values debug batch paths (cons operand files)))
               0      ; default value of debug level
               #f     ; default value of batch mode
               '()    ; initial value of include paths
               '()    ; initial value of files
               )
     (print "debug level = " debug-level)
     (print "batch mode = " batch-mode)
     (print "include paths = " (reverse include-paths))
     (print "files = " (reverse files))
     0))
@end example

@c ----------------------------------------------------------------------
@node Eager comprehensions, Vector library (Legacy), A program argument processor, Library modules - SRFIs
@section @code{srfi-42} - Eager comprehensions
@c NODE Eager comprehensions, @code{srfi-42} - 先行評価的内包表記

@deftp {Module} srfi-42
@mdindex srfi-42
@c EN
This module provides a generic comprehension mechanism, which some other
languages (e.g. Haskell and Python) offer as a built-in mechanism.
It provides a rich set of operators so it can be used not only as a list
generator but as a generic loop construct (actually, some may say
it is as powerful/evil as Common Lisp's @emph{loop} macro).
@c JP
このモジュールはジェネリックな内包表記(comprehension)機構を提供します。
この機構は他の言語(Haskell、Pythonなど)では組み込みの機構になっていま
す。この機構は豊富な操作手続を提供しているので、リストジェネレータとい
うだけではなく、ジェネリックなループ構文(Common Lisp の @emph{loop} マ
クロ並みに強力/邪悪だという人もいます)を提供しています。
@c COMMON

@c EN
It runs eagerly as the name suggests, that is, if it generates a list, it
creates the entire list when evaluated, instead of generate the
elements @emph{on demand}.  Thus it can't represent an infinite
sequence, which Haskell's comprehension naturally does.  Gauche offers
a few alternatives to deal with lazy, possibly infinite, sequences:
See @ref{Lazy sequences}, @ref{Generators} and @ref{Stream library}.
@c JP
この機構は名前の通り、先行評価的に走ります。すなわち、リストを生成する場合、評価時
にすべてのリストを生成します。要素を@emph{要求駆動的}に生成するわけで
はありません。それゆえ、無限列を表現することはできません。それが自然に
できる Haskell とは違います。Gaucheは、遅延生成される有限/無限列を
扱う方法を他にいくつか提供しています。
@ref{Lazy sequences}、@ref{Generators}、@ref{Stream library}を
参照してください。
@c COMMON
@end deftp

@c EN
@subheading Eager comprehension examples
@c JP
@subheading 先行評価的内包表記の例
@c COMMON

@c EN
Let's begin with some examples.
@c JP
いくつかの例からはじめましょう。
@c COMMON

@c EN
Generate a list of squares for the first five integers:
@c JP
5番目までの整数の自乗のリストを生成しましょう。
@c COMMON
@example
(list-ec (: i 5) (* i i)) @result{} (0 1 4 9 16)
@end example

@c EN
@code{list-ec} is a comprehension macro that generates a list.
The first form @code{(: i 5)} is called a @var{qualifier}, which
specifies a set of values to repeat over (here it is each integer
from 0 below 5).
The last form
@code{(* i i)} is called a @var{body}, which is ordinary Scheme expression
evaluated for each values specified by the @var{qualifier}.
@c JP
@code{list-ec}はリストを生成する内包表記マクロです。
最初のフォーム@code{(: i 5)}は@var{qualifier}と呼ばれ、
繰り返しを行う値の集合を指定します (この例では0以上5未満の整数)。
最後のフォーム@code{(* i i)}は@var{body}と呼ばれ、
@var{qualifier}が指定する値それぞれにつき評価される通常のScheme式です。
@c COMMON

@c EN
A comprehension can have more than one qualifiers.
Next example generate set of pair of numbers @code{(x y)}, where @code{x}
is between 2 (inclusive) and 5 (exclusive),
and @code{y} is between 1 (inclusive) and x (exclusive).
@c JP
内包表記は複数のqualifierを持つことができます。
次の例は数の対@code{(x y)}の集合を生成します。ここで@code{x}は
2以上 5未満、@code{y}は1以上 x 未満です。
@c COMMON

@example
(list-ec (: x 2 5) (: y 1 x) (list x y))
  @result{} ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3))
@end example

@c EN
The qualifiers works as @emph{nested}; that is, @code{(: x 2 5)}
specifies to repeat the rest of the clauses---@code{(: y 1 x)} and
@code{(list x y)}.
@c JP
複数のqualifierはネストするように動作します。つまり、@code{(: x 2 5)}は
残りの節---@code{(: y 1 x)} および @code{(list x y)} を繰り返すように
指定しているということです。
@c COMMON

@c EN
The above two examples can be written in Haskell as the followings:
@c JP
上の2つの例はHaskellで書くと以下のようになります。
@c COMMON

@example
[ i*i   | i <- [0..4] ]
[ (x,y) | x <- [2..4], y <- [1..x-1] ]
@end example

@c EN
Note the differences: (1) In Haskell, the body expression to yield the
elements comes first, followed by qualifiers (selectors).  In srfi-42, the body
expression comes last.  (2) In srfi-42, range operator's lower bound
is inclusive but its upper bound is exclusive.
@c JP
違いに注意：(1) Haskellでは要素になる本体部が先にきて、そのあとに修飾
部(セレクタ)がきます。SRFI-42では本体部は最後になります。(2) SRFI-42で
は範囲指定の下限はそれを含み、上限はそれを含みません。
@c COMMON

@c EN
List a set of numbers @code{(a b c d)}, where @code{a^3+b^3 = c^3+d^3}:
@c JP
@code{a^3+b^3 = c^3+d^3}を満すような数字の集合@code{(a b c d)}を列挙し
ましょう。
@c COMMON
@example
(define (taxi-number n)
  (list-ec (: a 1 n)
           (: b (+ a 1) n)
           (: c (+ a 1) b)
           (: d (+ c 1) b)
           (if (= (+ (expt a 3) (expt b 3))
                  (+ (expt c 3) (expt d 3))))
           (list a b c d)))
@end example

@c EN
If you want to change values of more than one variable
simultaneously, instead of nesting, you can bundle the qualifiers
like this:
@c JP
複数の変数を(ネストするのではなく)同時に変化させたい場合は、
複数のqualifierを次のようにまとめることができます。
@c COMMON

@example
(list-ec (:parallel (: x '(a b c d)) (: y '(1 2 3 4)))
         (list x y))
  @result{} ((a 1) (b 2) (c 3) (d 4))
@end example

@c EN
You can generate not only a list, but other sequences:
@c JP
リストだけではなく、他のシーケンスも生成できます。
@c COMMON
@example
(vector-ec (: i 5) i) @result{} #(0 1 2 3 4)
(string-ec (: i 5) (integer->char (+ i 65))) @result{} "ABCDE"
@end example

@c EN
Or apply folding operations:
@example
(sum-ec (: i 1 100) i)
  @result{} 4950    ;; sum of integers from 1 below 100.
(product-ec (: i 1 10) i)
  @result{} 362880 ;; ... and product of them.
@end example
@c JP
畳み込み演算も適用できます。
@example
(sum-ec (: i 1 100) i)
  @result{} 4950    ;; 1以上100未満の整数の和
(product-ec (: i 1 10) i)
  @result{} 362880 ;;  1以上10未満の整数の積
@end example
@c COMMON

@c EN
@subheading Comprehension macros
@c JP
@subheading 内包表記マクロ
@c COMMON

@c EN
Each comprehension takes the following form.
@c JP
それぞれの内包表記は以下のような形式になります。
@c COMMON
@example
(@var{comprehension-macro} @var{qualifier} @dots{} @var{body})
@end example

@c EN
It evaluates @var{body} repeatedly as specified by @var{qualifier} @dots{}.
Depending on the type of comprehension,
the results of @var{body} may be either collected to create an
aggregate (list, vector, string, ...), folded by some operator
(sum, product, min, max, ...), or simply discarded.
@c JP
@var{qualifier} @dots{}の指定に従って@var{body}をくりかえし評価します。内包表記の種類
によって、@var{body}の結果は(リスト、ベクタ、文字列などに)集約されるか、
(sum、product、min、maxなどによって)畳み込まれるか、あるいは、単に捨て
られます。
@c COMMON

@c EN
Each @var{qualifier} specifies how to repeat the following
@var{qualifiers} and @var{body}.  A @var{qualifier} can be a
generational qualifier that yields a set of values to loop
over, or a control qualifier that specify a condition
to exclude some values.  See the Qualifiers heading below.
@c JP
それぞれの@var{qualifier}は、それ以降の@var{qualifier}と@var{body}
をどのように繰り返すかを指定します。@var{qualifier}には、繰り返しに
使う値を生成する生成的@var{qualifier}と、条件によって値を繰り返しから
省く制御的@var{qualifier}があります。以下のQualifiersの節を参照してください。
@c COMMON

@c EN
A few comprehensions takes extra values before @var{qualifiers} or
after @var{body}.
@c JP
いくつかの内包表記では、追加の値が@var{qualifiers}の前か、@var{body}
の後に置かれます。
@c COMMON

@defmac do-ec qualifier @dots{} body
[SRFI-42]
@c MOD srfi-42
@c EN
Repeats @var{body}.  The results of @var{body} is discarded.
This is for side-effecting operations.
@c JP
@var{body}を繰り返します。@var{body}の返り値は捨てられます。
この形式は副作用目的で使います。
@c COMMON
@end defmac

@defmac list-ec qualifier @dots{} body
[SRFI-42]
@c MOD srfi-42
@c EN
Repeats @var{body} and collects the results into a list.
@c JP
@var{body}を繰り返し、結果をリストに集めて返します。
@c COMMON
@end defmac

@defmac append-ec qualifier @dots{} body
[SRFI-42]
@c MOD srfi-42
@c EN
Repeats @var{body}, which must yield a list.
Returns a list which is the concatenation of all lists returned by @var{body}.
@c JP
@var{body}を繰り返し、その結果のリストを結合して返します。
@var{body}は必ずリストを返さなければなりません。
@c COMMON
@end defmac

@defmac string-ec qualifier @dots{} body
@defmacx string-append-ec qualifier @dots{} body
[SRFI-42]
@c MOD srfi-42
@c EN
Repeats @var{body}, which must yield a character (in @code{string-ec})
or a string (in @code{string-append-ec}).  Returns a string that
consists of the results of @var{body}.
@c JP
@var{body}を繰り返します。@var{body}は@code{string-ec}では文字へ、
@code{string-append-ec}では文字列へと評価されなければなりません。
結果を集め、または結合した文字列が買えされます。
@c COMMON
@end defmac

@defmac vector-ec qualifier @dots{} body
[SRFI-42]
@c MOD srfi-42
Repeats @var{body} and collects the results into a vector.
@end defmac

@defmac vector-of-length-ec k qualifier @dots{} body
[SRFI-42]
@c MOD srfi-42
This is like @code{vector-ec}, except that the length of the
result vector is known to be @var{k}.  It can be more efficient
than @code{vector-ec}.  Unless the comprehension repeats exactly
@code{k} times, an error is signaled.
@end defmac

@defmac sum-ec qualifier @dots{} body
@defmacx product-ec qualifier @dots{} body
[SRFI-42]
@c MOD srfi-42
@var{body} must yield a numeric value.  Returns sum of and product of
the results, respectively.
@end defmac

@defmac min-ec qualifier @dots{} body
@defmacx max-ec qualifier @dots{} body
[SRFI-42]
@c MOD srfi-42
@var{body} must yield a numeric value.  Returns maximum and minimum value
of the results, respectively.  @var{body} must be evaluated at least once,
or an error is signaled.
@end defmac

@defmac any?-ec qualifier @dots{} test
@defmacx every?-ec qualifier @dots{} test
[SRFI-42]
@c MOD srfi-42
Evaluates @var{test} for each iteration, and returns
@code{#t} as soon as it yields non-@code{#f} (for @code{any-ec?}),
or returns @code{#f} as soon as it yields @code{#f} (for @code{every?-ec}).
Unlink the comprehensions introduced above, these stop evaluating
@var{test} as soon as the condition meets.
If the qualifiers makes no iteration, @code{#f} and @code{#t} are
returned, respectively.
@end defmac

@defmac first-ec default qualifier @dots{} body
@defmacx last-ec default qualifier @dots{} body
[SRFI-42]
@c MOD srfi-42
First initializes the result by the value of the expression @var{default},
then start iteration, and returns the value of the first and last
evaluation of @var{body}, respectively.  In fact, @code{first-ec}
only evaluates @var{body} at most once.

These procedures are most useful when used with control qualifiers.
For example, the following @code{first-ec} returns the @emph{first}
set of distinct integers (@var{x}, @var{y}, @var{z}),
where @var{x}*@var{x}+@var{y}*@var{y}+@var{z}*@var{z} becomes a square
of another integer @var{w}.

@example
(first-ec #f (:integers w) (: z 1 w) (: y 1 z) (: x 1 y)
          (if (= (* w w) (+ (* x x) (* y y) (* z z))))
          (list x y z w))
@end example

Note that the first qualifier, @code{(:integers w)}, generates
infinite number of integers; if you use @code{list-ec} instead of
@code{first-ec} it won't stop.
@end defmac

@defmac fold-ec seed qualifier @dots{} expr proc
@defmacx fold3-ec seed qualifier @dots{} expr init proc
[SRFI-42]
@c MOD srfi-42
Reduces the values produced by @var{expr}.

Suppose @var{expr} produces a sequence of values
@var{x0}, @var{x1}, @dots{}, @var{xN}.  @code{Fold-ec}
calculates the following value:

@example
(@var{proc} @var{xN} (@dots{}(@var{proc} @var{x1} (@var{proc} @var{x0} @var{seed}))@dots{}))
@end example

It's similar to @code{fold}, except that @var{proc} is evaluated
within the scope of @var{qualifier} @dots{} so you can refer to the
variables introduced by them.  On the other hand,
@var{seed} is outside of the scope of @var{qualifier}s.

@code{Fold-ec3} is almost the same but the initial value calculation.
In @code{fold-ec3}, @var{seed} is only used when @var{qualifier}s
makes no iteration.  Otherwise it calculates the following value:

@example
(@var{proc} @var{xN} (@dots{}(@var{proc} @var{x1} (@var{init} @var{x0}))@dots{}))
@end example

@end defmac

@subheading Qualifiers

@c EN
@subsubheading Generational qualifiers
@c JP
@subsubheading 生成的qualifier
@c COMMON

@c EN
This type of qualifiers generates (possibly infinite) values
over which the rest of clauses iterate.
@c JP
このタイプのqualifierは、いくつかの値(無限個のこともあります)を次々に
生成し、各値について残りの節を繰り返します。
@c COMMON

@c EN
In the following descriptions, @var{vars} refers to either
a single identifier, or a series of identifier and a form
@code{(index @var{identifier2})}.  The single identifier
in the former case and the first identifier in the latter case
name the variable to which each generated value is bound.
The @var{identifier2} in the latter case names a variable
to which a series of integers, increasing with each generated
element, is bound.   See the following example:
@c JP
以下の説明において、@var{vars}というのはひとつの識別子か、
識別子とフォーム@code{(index @var{identifier2})}の並びです。
最初の形式での識別子、あるいは二番目の形式での最初の識別子は、
生成された値が束縛される変数です。二番目の形式の@var{identifier2}は、
0から始まり値が生成されるたびにインクリメントされる整数値が束縛されます。
次の例を見てください。
@c COMMON

@example
(list-ec (: x '(a b c)) x)
  @result{} (a b c)
(list-ec (: x (index y) '(a b c)) (cons x y))
  @result{} ((a . 0) (b . 1) (c . 2))
@end example

@deffn {EC Qualifier} : vars arg1 args @dots{}
@c EN
A generic dispatcher of generational qualifiers.
An appropriate generational qualifier is selected based on the
types of @var{arg1} @var{args} @dots{}.
@c JP
@var{arg1} @var{args} @dots{} の型に基づいて、以下の生成的qualifierの
いずれかにディスパッチされる、汎用的なqualifierです。
@c COMMON
@end deffn

@deffn {EC Qualifier} :list vars arg1 args @dots{}
@deffnx {EC Qualifier} :vector vars arg1 args @dots{}
@deffnx {EC Qualifier} :string vars arg1 args @dots{}
@c EN
@var{Arg1} @var{args} @dots{} should be all lists, vectors, or strings,
respectively.  Repeats the subsequent clauses while binding
each element from those args bound to @var{vars}.
@c JP
それぞれのフォームにおいて、
@var{arg1} @var{args} @dots{}は全てリスト、ベクタ、文字列でなければなりません。
各要素を@var{vars}に束縛して続く節を繰り返します。
@c COMMON

@example
(list-ec (:string c "ab" "cd") c) @result{} (#\a #\b #\c #\d)
@end example

@c EN
If the arguments given to the generic qualifier @code{:} are
all lists, vectors or strings, then these qualifiers are used.
@c JP
汎用qualifier@code{:}に渡された引数が全てリスト、ベクタ、あるいは文字列
であった場合は、これらのqualifierが使われます。
@c COMMON
@end deffn

@deffn {EC Qualifier} :integers vars
@c EN
Generates infinite series of increasing integers, starting from 0.
@c JP
0から始まり1づつ増加しつづける無限正確整数列を生成します。
@c COMMON
@end deffn

@deffn {EC Qualifier} :range vars stop
@deffnx {EC Qualifier} :range vars start stop
@deffnx {EC Qualifier} :range vars start stop step
@c EN
Generates a series of exact integers, starting from
@var{start} (defaults to 0) and stops below @var{stop},
stepping by @var{step} (defaults to 1).  Giving a negative
integer to @var{step} makes a decreasing series.
@c JP
@var{start}から始まり、@var{step}づつ増加し、@var{stop}を越えないような
正確な整数列を生成します。@var{start}が省略された場合は0、
@var{step}が省略された場合は1が使われます。
@var{step}に負数を与えれば減少列も作れます。
@c COMMON

@example
(list-ec (:range v 5) v)      @result{} (0 1 2 3 4)
(list-ec (:range v 3 8) v)    @result{} (3 4 5 6 7)
(list-ec (:range v 1 8 2) v)  @result{} (1 3 5 7)
(list-ec (:range v 8 1 -2) v) @result{} (8 6 4 2)
@end example

@c EN
If one, two or three exact integer(s) is/are given to the generic
qualifier @code{:}, this qualifier is used.
@c JP
汎用qualifier@code{:}に1個から3個の正確な整数が与えられた場合は、
このqualifierが使われます。
@c COMMON
@end deffn

@deffn {EC Qualifier} :real-range vars stop
@deffnx {EC Qualifier} :real-range vars start stop
@deffnx {EC Qualifier} :real-range vars start stop step
@c EN
Generates a series of real numbers, starting from
@var{start} (defaults to 0) and stops below @var{stop},
stepping by @var{step} (defaults to 1).  If all the arguments
are exact numbers, the result consists of exact numbers; if any
of the arguments are inexact, the result consists of inexact numbers.
@c JP
@var{start}から始まり、@var{step}づつ増加し、@var{stop}を越えないような
実数列を生成します。@var{start}が省略された場合は0、
@var{step}が省略された場合は1が使われます。
全ての引数が正確数であれば正確な数列が、ひとつでも非正確数が混じって入れば
非正確な数列が生成されます。
@c COMMON

@example
(list-ec (:real-range v 5.0) v)
  @result{} (0.0 1.0 2.0 3.0 4.0)
(list-ec (:real-range v 1 4 1/3) v)
  @result{} (1 4/3 5/3 2 7/3 8/3 3 10/3 11/3)
(list-ec (:real-range v 1 5.0 1/2) v)
  @result{} (1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5)
@end example

@c EN
If one, two or three real numbers is/are given to the generic
qualifier @code{:}, and any one of them isn't an exact integer,
then this qualifier is used.
@c JP
汎用qualifier@code{:}に1個から3個の実数が与えられ、そのうちどれかひとつでも
正確な整数でないものがあれば、このqualifierが使われます。
@c COMMON
@end deffn

@deffn {EC Qualifier} :char-range vars min max
@c EN
Generates a series of characters, starting from @var{min} and
ending at @var{max} (inclusive).  The characters are enumerated
in the order defined by @code{char<=?} (@pxref{Characters}).
@c JP
文字@var{min}から@var{max}まで(両端含む)の文字を順に生成します。
文字順は@code{char<=?}で比べられるのと同じ順になります (@ref{Characters}参照)。
@c COMMON

@example
(list-ec (:char-range v #\a #\e) v)
  @result{} (#\a #\b #\c #\d #\e)
@end example

@c EN
If two characters are given to the generic
qualifier @code{:}, this qualifier is used.
@c JP
汎用qualifier@code{:}に2つの文字が与えられた場合は、
このqualifierが使われます。
@c COMMON
@end deffn

@deffn {EC Qualifier} :port vars port
@deffnx {EC Qualifier} :port vars port read-proc
@c EN
Generates a series of values read from an input port @var{port},
by the procedure @var{read-proc} (defaults to @code{read}).  The
series terminates when EOF is read.
@c JP
入力ポート@var{port}から、@var{read-proc}を使って読まれる値を、
EOFに出会うまで次々に生成します。@var{read-proc}が省略された場合は@code{read}
が使われます。
@c COMMON

@example
(call-with-input-string "a \"b\" :c"
  (^p (list-ec (:port v p) v)))
  @result{} (a "b" :c)
@end example

@c EN
If one or two arguments are given to the generic
qualifier @code{:} and the first one is an input port,
then this qualifier is used.
@c JP
汎用qualifier@code{:}に2つの引数が与えられ、最初の引数が入力ポートであれば、
このqualifierが使われます。
@c COMMON
@end deffn

@deffn {EC Qualifier} :generator vars gen
@c EN
This is Gauche's extension and not defined in SRFI-42.
@var{gen} must be a procedure with zero arguments.
This qualifier repeats until @var{gen} returns EOF.

Gauche has a set of utilities to create and operate on
such procedures; see @ref{Generators}.
@c JP
これはSRFI-42には定義さていない、Gauche独自の拡張です。
@var{gen}は引数と取らない手続きです。このqualifierは
@var{gen}がEOFを返すまで繰り返します。

Gaucheは、そのような手続きを作ったり操作したりする便利な関数群を
提供しています。@ref{Generators}を参照してください。
@c COMMON

@example
(use gauche.generator)
(list-ec (:generator v (grange 1 8)) v)
  @result{} (1 2 3 4 5 6 7)
@end example

@c EN
If one argument is given to the generic
qualifier @code{:} and it is applicable without arguments,
then this qualifier is used.
@c JP
汎用qualifier@code{:}に1つの引数が与えられ、それが引数無しで呼び出し可能なものであれば、
このqualifierが使われます。
@c COMMON
@end deffn

@deffn {EC Qualifier} :parallel generator @dots{}
@c EN
This is used to run through mutiple generators in parallel.
It terminates when any one of @var{generator} is exhausted.
@c JP
複数のジェネレータ節を並列に走査するのに使います。
@var{generator}のどれかが値を使い切った時点で止まります。
@c COMMON

@example
(list-ec (:parallel (: x '(a b c))
                    (: y "defg"))
  (cons x y))
 @result{} ((a . #\d) (b . #\e) (c . #\f))

;; Compare with this:
(list-ec (: x '(a b c))
         (: y "defg")
  (cons x y))
 @result{} ((a . #\d) (a . #\e) (a . #\f) (a . #\g)
     (b . #\d) (b . #\e) (b . #\f) (b . #\g)
     (c . #\d) (c . #\e) (c . #\f) (c . #\g))
@end example
@end deffn

@deffn {EC Qualifier} :let vars expr
@end deffn

@deffn {EC Qualifier} :while generator expr
@end deffn

@deffn {EC Qualifier} :until generator expr
@end deffn

@deffn {EC Qualifier} :dispatched vars dispatch arg1 args @dots{}
@end deffn

@deffn {EC Qualifier} :do (lb @dots{}) ne1? (ls @dots{})
@deffnx {EC Qualifier} :do (let (ob @dots{}) oc @dots{}) (lb @dots{}) ne1? (let (ib @dots{}) ic @dots{}) ne2? (ls @dots{})
@end deffn

@subsubheading Control qualifiers

@deffn {EC Qualifier} if test
@end deffn

@deffn {EC Qualifier} not test
@deffnx {EC Qualifier} and test @dots{}
@deffnx {EC Qualifier} or test @dots{}
@end deffn

@deffn {EC Qualifier} begin command @dots{} expr
@end deffn

@deffn {EC Qualifier} nested qualifier @dots{}
@end deffn


@c ----------------------------------------------------------------------
@node Vector library (Legacy), Requiring extensions, Eager comprehensions, Library modules - SRFIs
@section @code{srfi-43} - Vector library (legacy)
@c NODE ベクタライブラリ(旧式), @code{srfi-43} - ベクタライブラリ(旧式)

@deftp {Module} srfi-43
@mdindex srfi-43
@c EN
This module is effectively superseded by R7RS and @code{srfi-133}.  
There are a few procedures that are not compatbile with R7RS and 
@code{srfi-133}, and this module remains to support
legacy code that depends on them.  

@xref{Vectors}, and @pxref{Vector library}, for the ``modern'' versions
of vector library.  New code should use them.

The following procedures in srfi-43 are built-in.
@xref{Vectors}, for the description.
@c JP
このモジュールは実効的に、R7RSと@code{srfi-133}に取って代わられています。
いくつかの手続きはR7RSや@code{srfi-133}の同名の手続きとは非互換で、
このモジュールは@code{srfi-43}に依存している既存のコードのためだけに
残されています。

「現代的な」ベクタライブラリは、@ref{Vectors}と@ref{Vector library}
で説明されています。新たなコードはそちらを使うべきです。

以下の@code{srfi-43}の手続きは組み込みになっています。
説明は@ref{Vectors}を参照してください。
@c COMMON

@example
make-vector     vector          vector?         vector-ref
vector-set!     vector-length   vector-fill!    vector-copy
vector-copy!    vector-append   vector->list    list->vector
reverse-list->vector
@end example

@c EN
The following procedures in srfi-43 are supported by srfi-133.
@xref{Vector library}, for the description.
@c JP
以下の@code{srfi-43}の手続きは@code{srfi-133}でも同様にサポートされています。
説明は@ref{Vector library}を参照してください。
@c COMMON

@example
vector-unfold         vector-unfold-right   vector-reverse-copy
vector-reverse-copy!  vector-concatenate    vector-empty?
vector=               vector-index          vector-index-right
vector-skip           vector-skip-right     vector-binary-search
vector-any            vector-every          vector-swap!    
reverse-vector->list
@end example

@c EN
We explain the procedures that are not listed above.
@c JP
ここでは上に挙げられていない手続きを説明します。
@c COMMON
@end deftp

@defun vector-fold kons knil vec1 vec2 @dots{}
@defunx vector-fold-right kons knil vec1 vec2 @dots{}
[SRFI-43]
@c MOD srfi-43
@c EN
Like @code{vector-fold} and @code{vector-fold-right}
in @code{srfi-133}, but @var{kons}
takes an extra argument, the current index, as its first argument.
So @var{kons} must accept @var{n}+2 arguments, where
@var{n} is the number of given vectors.
It is called as @code{(kons <index> <cumulated-value> <elt1> <elt2> ...)}.
@c JP
@code{srfi-133}の@code{vector-fold}と@code{vector-fold-right}と似ていますが、
@var{kons}手続きは追加で、現在のインデックスを第一引数として取ります。
従って、@var{n}を引数で与えられたベクタの数とすると、
@var{kons}は@var{n+2}個の引数を取らなければなりません。
@var{kons}は@code{(kons <index> <cumulated-value> <elt1> <elt2> ...)}
のように呼ばれます。
@c COMMON

@c EN
Gauche has @code{fold-with-index} (@pxref{Mapping over sequences})
that can be used to fold vectors with index, but the argument order
of @var{kons} is slightly different: It passes the index, each
element from argument vectors, then cumulated values.  
@c JP
Gaucheには@code{fold-with-index}があって、ベクタをインデックスつきで
foldするのに使えます(@ref{Mapping over sequences})が、
@var{kons}が受け取る引数の順序が違います: インデックスの次に
各ベクタの要素、そして最後に累積された値が来ます。
@c COMMON

@example
(use srfi-43)
(vector-fold list '() '#(a b c) '#(d e f))
  @result{} (2 (1 (0 () a d) b e) c f)

(use gauche.sequence)
(fold-with-index list '() '#(a b c) '#(d e f))
  @result{} (2 c f (1 b e (0 a d ())))
@end example
@end defun

@defun vector-map f vec1 vec2 @dots{}
@defunx vector-map! f vec1 vec2 @dots{}
@defunx vector-for-each f vec1 vec2 @dots{}
@defunx vector-count f vec1 vec2 @dots{}
[SRFI-43]
@c MOD srfi-43
@c EN
Like @code{vector-map} and @code{vector-for-each} of R7RS,
and @code{vector-map!} and @code{vector-count} in @code{srfi-133},
except @var{f} takes
an extra argument, the current index, as its first argument.
@c JP
R7RSの@code{vector-map}および@code{vector-for-each}、
そして@code{srfi-133}の@code{vector-map!}および@code{vector-cout}と
ほぼ同じですが、@var{f}が現在のインデックスを最初の引数として(他の引数より前に)
取ります。
@c COMMON

@c EN
Gauche provides @code{vector-map-with-index},
@code{vector-map-with-index!} and @code{vector-for-each-with-index}
which are the same as @code{srfi-43}'s @code{vector-map}, @code{vector-map!}
and @code{vector-for-each}, respectively.  @xref{Vectors}.
@c JP
Gaucheは@code{srfi-43}の@code{vector-map}、@code{vector-map!}、
@code{vector-for-each}互換な手続きをそれぞれ
@code{vector-map-with-index}、
@code{vector-map-with-index!}、@code{vector-for-each-with-index}という
名前で提供しています。@ref{Vectors}参照。
@c COMMON

@example
(vector-map list '#(a b c))
 @result{} #((0 a) (1 b) (2 c))
(vector-map list '#(a b c) '#(d e f g))
 @result{} #((0 a d) (1 b e) (2 c f))
(vector-count = '#(0 2 2 4 4))
 @result{} 3
@end example

@c EN
(Note: The @code{vector-count} example calls @code{=} with
two arguments, the current index and the element, for each element
of the input vector.  So it counts the number of
occasions when the element is equal to the index.)
@c JP
(註: @code{vector-count}は@code{=}を二つの引数、現在のインデックスと
ベクタの要素で呼び出します。従ってこの例は、ベクタの要素がインデックスと一致する
場合を数えています。)
@c COMMON

@c EN
The generic @code{map} and @code{for-each}
in @code{gauche.collection} can be used
on vectors, but the mapped procedure is called without index, and the result
is returned as a list.
@code{(vector-map f vec1 vec2 @dots{})} is operationally equivalent to
@code{(map-to-with-index <vector> f vec1 vec2 @dots{})}.
See @ref{Collection framework} and @ref{Sequence framework}.
@c JP
@code{gauche.collection}のジェネリックな@code{map}や@code{for-each}は
ベクタに対しても使えますが、マップされる手続きはインデックスを取らず、
また結果はリストになります。
@code{(vector-map f vec1 vec2 @dots{})}は機能的には
@code{(map-to-with-index <vector> f vec1 vec2 @dots{})}と同じになります。
詳しくは@ref{Collection framework}と@ref{Sequence framework}を参照してください。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Requiring extensions, Integers as bits, Vector library (Legacy), Library modules - SRFIs
@section @code{srfi-55} - Requiring extensions
@c NODE Requiring extensions, @code{srfi-55} - require の拡張

@deftp {Module} srfi-55
@mdindex srfi-55
@c EN
This module defines @code{require-extension} macro, a yet another way
to write portable scripts.  See @ref{Feature conditional} and
@ref{Feature-based program configuration language} for other means of
ensuring specific features.
@c JP
このモジュールでは @code{require-extension} マクロが定義されています。
これは、ポータブルなスクリプトを書くためのもうひとつ別の方法です。
指定した特性を確認する他の方法については、@ref{Feature conditional}
および@ref{Feature-based program configuration language}を見てください。
@c COMMON

@c EN
This module is autoloaded when you use @code{require-extension}, so
you don't need explicitly say @code{(use srfi-55)}; for portable scripts,
you shouldn't.
@c JP
このモジュールは、@code{require-extension}を使った際に自動的にロードさ
れます。それゆえ明示的に@code{(use srfi-55)}する必要はありませんし、ポー
タビリティのためにはするべきではありません。
@c COMMON
@end deftp

@defmac require-extension clause @dots{}
@c MOD srfi-55
@c EN
Make extension(s) specified by @var{clause}s available in the rest
of the program.
@c JP
@var{clause}で指定した拡張を以降のプログラムで利用可能にします。
@c COMMON

@c EN
A @var{clause} takes the following form:
@c JP
@var{clause}は以下の形式になります。
@c COMMON
@example
(@var{extension-id} @var{extension-arg} @dots{})
@end example

@c EN
Currently, only @code{srfi} is supported as @var{extension-id}, and
its arguments are SRFI numbers.
@c JP
現時点では、@code{srfi}のみ@var{extension-id}として使えます。その引数
はSRFIの番号です。
@c COMMON

@c EN
For example, the following form:
@c JP
たとえば、以下の
@c COMMON
@example
(require-extension (srfi 1 13 14))
@end example

@c EN
Roughly corresponds to Gauche's @code{use} forms:
@c JP
は以下の Gauche の @code{use} 形式にほぼ対応します。
@c COMMON
@example
(use srfi-1)
(use srfi-13)
(use srfi-14)
@end example
@end defmac

@c ----------------------------------------------------------------------
@node Integers as bits, Octet vectors, Requiring extensions, Library modules - SRFIs
@section @code{srfi-60} - Integers as bits
@c NODE 整数に対するビット操作, @code{srfi-60} - 整数に対するビット操作

@deftp {Module} srfi-60
@mdindex srfi-60
This srfi provides bit operations on integers, regarding them
as 2's complement representation.  It is compatible to SLIB's @code{logical}
module.

The newer srfi-151 (@pxref{Bitwise operations}) provides the same
functionality and more, with more consistent naming.  We recommend
new code to use srfi-151, while we keep srfi-60 for the backward
compatibility.

The following procedures are Gauche built-in.
@xref{Basic bitwise operations}, for the description.

@example
lognot           logand           logior           logxor
logtest          logcount         integer-length   logbit?
copy-bit         bit-field        copy-bit-field   ash
@end example

The following procedures are defined in srfi-151.
@xref{Bitwise operations}, for the description.

@example
bitwise-not      bitwise-and      bitwise-ior      bitwise-xor
arithmetic-shift bit-count        bitwise-if       bit-set?
copy-bit         first-set-bit    
@end example
@end deftp

We describe procedures that are unique in srfi-60 below.

@defun bitwise-merge mask n0 n1
[SRFI-60]
@c MOD srfi-60
Same as @code{bitwise-if} (@pxref{Bitwise operations}).
@end defun

@defun any-bits-set? mask n
[SRFI-60]
@c MOD srfi-60
Same as builtin @code{logtest} (@pxref{Basic bitwise operations}).
It is also called @code{any-bit-set?} in srfi-151 (@pxref{Bitwise operations}).
@end defun

@defun log2-binary-factors n
[SRFI-60]
@c MOD srfi-60
It is also called as @code{first-set-bit} in this srfi, which is also
in srfi-151 (@pxref{Bitwise operations}).
This is equivalent to Gauche's built-in  @code{twos-exponent-factor}
(@pxref{Basic bitwise operations}).
@end defun

@defun rotate-bit-field n count start end
[SRFI-60]
@c MOD srfi-60
This is equivalent to @code{bit-field-rotate} in srfi-151
(@pxref{Bitwise operations}).
@end defun

@defun reverse-bit-field n start end
[SRFI-60]
@c MOD srfi-60
This is equivalent to @code{bit-field-reverse} in srfi-151
(@pxref{Bitwise operations}).
@end defun

@defun integer->list n :optional len
[SRFI-60]
@c MOD srfi-60
Breaks @var{n} to each bits, representing @code{1} as @code{#t} and
@code{0} as @code{#f}, LSB last, and returns a list of them.
If a nonnegative integer @var{len} is given, it specifies the length
of the result.   If it is omitted, @code{(integer-length n)} is used.

@example
(integer->list 10)   @result{} (#t #f #t #f)
(integer->list 10 6) @result{} (#f #f #t #f #t #f)
@end example

Srfi-151 has similar procedure @code{bits->list}, with a reversed bit
order (LSB first) (@pxref{Bitwise operations}).
@end defun

@defun list->integer lis
[SRFI-60]
@c MOD srfi-60
Takes a list of boolean values, replaces the true value for @code{1}
and the false value for @code{0}, and compose an integer regarding
each value as a binary digit.  If @var{n} is nonnegative integer,
@code{(eqv? (list->integer (integer->list n)) n)} is true.

@example
(list->integer '(#f #t #f #t #f)) @result{} 10
@end example

Srfi-151 has similar procedure @code{list->bits}, with a reversed bit
order (LSB first) (@pxref{Bitwise operations}).
@end defun

@defun booleans->integer bool @dots{}
[SRFI-60]
@c MOD srfi-60
@equiv{} @code{(list->integer (list @var{bool} @dots{}))}

Srfi-151 has similar procedure @code{bits}, with a reversed bit
order (LSB first) (@pxref{Bitwise operations}).
@end defun

@c ----------------------------------------------------------------------
@node Octet vectors, Basic hash tables, Integers as bits, Library modules - SRFIs
@section @code{srfi-66} - Octet vectors
@c NODE オクテットベクタ, @code{srfi-66} - オクテットベクタ

@deftp {Module} srfi-66
@mdindex srfi-66
This module defines procedures to deal with @code{u8vector}s; they are
almost a subset of @code{srfi-4} and @code{gauche.uvector}
(@pxref{Uniform vectors}, except one procedure, @code{u8vector-copy!},
which has different argument orders (unfortunate historical artifacts).

The following procedures are the same as @code{gauche.uvector}:

@example
u8vector?       make-u8vector      u8vector
u8vector->list  list->u8vector
u8vector-length u8vector-ref       u8vector-set!
u8vector=?      u8vector-compare   u8vector-copy
@end example
@end deftp

@defun u8vector-copy! src sstart target tstart n
[SRFI-66]
@c MOD srfi-66
Copy the content of an u8vector @var{src}, starting from @var{sstart}
for @var{n} octets, into an u8vector @var{target} beginning from
@var{tstart}.  The @var{target} u8vector must be mutable.

Note that @code{gauche.uvector} has also @code{u8vector-copy!},
but its argument order is as follows, where @var{send} 
is @code{(+ @var{sstart} @var{n})}:

@example
(u8vector-copy! target tstart src sstart send)
@end example

Gauche's argument order is consistent with @code{vector-copy!} of
R7RS, srfi-43 and srfi-133.

We recommend to use @code{srfi-66} only for porting third-party
libraries to avoid confusion.
@end defun

@c ----------------------------------------------------------------------
@node Basic hash tables, Octet-addressed binary blocks, Octet vectors, Library modules - SRFIs
@section @code{srfi-69} - Basic hash tables
@c NODE 基本的なハッシュテーブル, @code{srfi-69} - 基本的なハッシュテーブル

@deftp {Module} srfi-69
@mdindex srfi-69
This module has been superseded by R7RS @code{scheme.hash-table}
(@pxref{R7RS hash tables}).  New code should use it instead.

This is a thin adaptor on Gauche's built-in hashtables
(@pxref{Hashtables}).  This is provided for the compatibility
to the portable libraries; the hashtable object created by
this module's @code{make-hash-table} is the same as the one
created by Gauche's built-in, and you can pass the table to
both APIs.
@end deftp

Here's a summary of difference between srfi-69 and Gauche's built-in
hash table API:

@itemize
@item
The constructor @code{make-hash-table}, as well as @code{alist->hash-table},
takes equality predicate and hash function, instead of a single
comparator argument.
@item
The hash function passed to @code{srfi-69}'s @code{make-hash-table}
takes two arguments, an object to calculate a hash value,
and a positive integer that limits the range of the hash value.
@item
@code{Srfi-69}'s primary hash table accessor is @code{hash-table-ref},
which takes a thunk to be called when the table doesn't have an
entry for the given key, while Gauche's @code{hash-table-get} takes
a fallback value for that.
@code{Srfi-69} also has @code{hash-table-ref/default},
which takes a fallback value like Gauche's @code{hash-table-get},
but the default value can't be omitted.
@item
The basic iterator of @code{srfi-69} is called @code{hash-table-walk},
which is Gauche's @code{hash-table-for-each}.  The srfi name is chosen
to avoid conflict with existing Scheme implementations.
@end itemize

The following procedures are the same as Gauche's built-in ones.
@xref{Hashtables}, for the details.

@example
hash-table?       hash-table-delete!   hash-table-exists?
hash-table-keys   hash-table-values    hash-table-fold
hash-table->alist hash-table-copy 
@end example


@defun make-hash-table :optional eq-pred hash-proc :rest args
[SRFI-69]
@c MOD srfi-69
Creates a new hashtable and returns it.  This is the same name
as Gauche's built-in procedure, but the arguments are different.

The @var{eq-pred} argument is an equality predicate; it takes
two arguments and returns @code{#t} if two are the same,
and @code{#f} if not.  When omitted, @code{equal?} is used.

The @var{hash-proc} argument is a hash function.
It takes two arguments: an object to hash, and a positive
integer to limit the range of the hash value.  (Note that
Gauche's native hash functions takes only one argument.)
When omitted, Gauche tries to choose appropriate hash function
if @code{eq-pred} is known one (@code{eq?}, @code{eqv?},
@code{equal?}, @code{string=?} or @code{string-ci=?}).
Otherwise we use Gauche's @code{hash} procedure, but there's
no guarantee that it works appropriately; you should give
suitable @var{hash-proc} if you pass custom @var{eq-pred}.

The returned hash table is an instance of Gauche's native
hash table.  You can pass it to Gauche's builtin procedures.

@code{Srfi-69} allows implementation-specific arguments @var{args} to be
passed to @code{make-hash-table}.  At this moment, Gauche
ignores them.
@end defun

@defun alist->hash-table alist :optional eq-pred hash-fn :rest args
[SRFI-69]
@c MOD srfi-69
Like Gauche's builtin @code{alist->hash-table}, but takes
@var{eq-pred} and @var{hash-fn} separately,
instead of a single comparator.

The @var{alist} argument is a list of pairs.  The car of each
pair is used for a key, and the cdr for its value.

See @code{make-hash-table} above for the description of
@var{eq-pred}, @var{hash-fn} and @var{args}.
@end defun

@defun hash-table-equivalence-function ht
@defunx hash-table-hash-function ht
[SRFI-69]
@c MOD srfi-69
Returns equivalence function and hash function of the
hashtable @var{ht}.

The hash function returned from @code{hash-table-hash-function}
takes two arguments, an object to hash and bound, a positive exact integer.
Note that the function returned by @code{hash-table-hash-function} may not
be @code{eq?} to the one you gave to @code{make-hash-table}.
@end defun

@defun hash-table-ref ht key :optional thunk
[SRFI-69]
@c MOD srfi-69
Looks up the value corresponding to @var{key} in a hash table @var{ht}.
If there's no entry for @var{key}, @var{thunk} is called
without arguments.  The default of @var{thunk} is to signal an error.
@end defun

@defun hash-table-ref/default ht key default
[SRFI-69]
@c MOD srfi-69
Looks up the value corresponding to @var{key} in a hash table @var{ht}.
This is like Gauche's @code{hash-table-get}, but @var{default} can't be
omitted.
@end defun

@defun hash-table-set! ht key val
[SRFI-69]
@c MOD srfi-69
This is the same as Gauche's @code{hash-table-put!}.
@end defun

@defun hash-table-update! ht key proc :optional thunk
@defunx hash-table-update!/default ht key proc default
[SRFI-69]
@c MOD srfi-69
@end defun

@defun hash-table-size ht
[SRFI-69]
@c MOD srfi-69
Returns the number of entries in a hash table @var{ht}.  The same as Gauche's
@code{hash-table-num-entries}.
@end defun
          
@defun hash-table-walk ht proc
[SRFI-69]
@c MOD srfi-69
For each entry in a hash table @var{ht}, 
calls @var{proc} with two arguments, a key and its value.
It's the same as Gauche's @code{hash-table-for-each}.
@end defun

@defun hash-table-merge! ht1 ht2
[SRFI-69]
@c MOD srfi-69
Add all entries in a hash table @var{ht2} into a hash table @var{ht1},
and returns @var{ht1}.
@end defun

@defun hash obj :optional bound
[SRFI-69]
@c MOD srfi-69
Like Gauche's @code{hash}, except this one can take bound argument;
if provided, it must be a positive integer, and the return value
is limited between 0 and @code{(- bound 1)}, inclusive.
@end defun

@defun string-hash obj :optional bound
@defunx string-ci-hash obj :optional bound
[SRFI-69]
@c MOD srfi-69
These are like @code{srfi-13}'s (@pxref{String library}), except
these don't take @var{start} and @var{end} argument.
@end defun

@defun hash-by-identity obj :optional bound
[SRFI-69]
@c MOD srfi-69
This is Gauche's @code{eq-hash}, except this one can take bound argument.
@end defun

@c ----------------------------------------------------------------------
@node Octet-addressed binary blocks, Accessing environment variables, Basic hash tables, Library modules - SRFIs
@section @code{srfi-74} - Octet-addressed binary blocks

@deftp {Module} srfi-74
@mdindex srfi-74
This module provides procedures to deal with @emph{blob},
or a sequence of octets.  In Gauche, a blob is simply an u8vector.

Most functionalities of this module is available
in @code{binary.io} module (@pxref{Binary I/O}), and in fact
this module is a thin wrapper to it.
We provide this module for the compatibility.
If you're writing Gauche-specific code, we recommend to use
@code{binary.io} directly.
@end deftp

@defmac endianness e
[SRFI-74]
@c MOD srfi-74
The argument @var{e} must be either @code{big}, @code{little},
or @code{native}.  It expands to the implementation-specific
endianness designator.  In Gauche, the result is one of the
symbols; @pxref{Endianness}, for the details.
@end defmac

@defun make-blob size
[SRFI-74]
@c MOD srfi-74
Returns a freshly created blob that can hold @var{size} octets.
In Gauche, this is the same as @code{(make-u8vector size)}.
@end defun

@defun blob? obj
[SRFI-74]
@c MOD srfi-74
Returns @code{#t} if @var{obj} is a blob, @code{#f} otherwise.
In Gauche, this is the same as @code{(u8vector? obj)}.
@end defun

@defun blob-length blob
[SRFI-74]
@c MOD srfi-74
Returns the size of the blob, in octets.  In Gauche,
this is the same as @code{(u8vector-length blob)}.
@end defun

@defun blob-uint-ref size endian blob pos
@defunx blob-sint-ref size endian blob pos
[SRFI-74]
@c MOD srfi-74
Read an unsigned or signed integer of @var{size} octets beginning
at the position of @var{pos} from @var{blob}, respectively.

These are wrappers of @code{(get-uint size blob pos endian)}
and @code{(get-sint size blob pos endian)} in @code{binary.io}
module (@pxref{Binary I/O}), except that
@code{blob-uint-ref}/@code{blob-sint-ref} only accept u8vector
as @var{blob}.
@end defun

@defun blob-uint-set! size endian blob pos val
@defunx blob-sint-set! size endian blob pos val
[SRFI-74]
@c MOD srfi-74
Store an unsigned or signed integer @var{val} of @var{size} octets
into @var{blob} starting at the position of @var{pos}, respectively.

These are wrappers of @code{(put-uint! size blob pos val endian)}
and @code{(put-sint! size blob pos val endian)} in @code{binary.io}
module (@pxref{Binary I/O}), except that
@code{blob-uint-set!}/@code{blob-sint-set!} only accept u8vector
as @var{blob}.
@end defun

@defun blob-u8-ref blob pos
@defunx blob-u8-set! blob pos val
@defunx blob-s8-ref blob pos
@defunx blob-s8-set! blob pos val
[SRFI-74]
@c MOD srfi-74
Get/set an unsigned or signed integer as a octet at @var{pos}
from/to @var{blob}.

These are wrappers of @code{get-u8}, @code{put-u8!},
@code{get-s8} and @code{put-s8!} in @code{binary.io}, respectively.
@end defun

@defun blob-u16-ref endian blob pos
@defunx blob-u16-set! endian blob pos val
@defunx blob-s16-ref endian blob pos
@defunx blob-s16-set! endian blob pos val
@defunx blob-u32-ref endian blob pos
@defunx blob-u32-set! endian blob pos val
@defunx blob-s32-ref endian blob pos
@defunx blob-s32-set! endian blob pos val
@defunx blob-u64-ref endian blob pos
@defunx blob-u64-set! endian blob pos val
@defunx blob-s64-ref endian blob pos
@defunx blob-s64-set! endian blob pos val
[SRFI-74]
@c MOD srfi-74
Get/set an unsigned or signed integer of the indicated length
at @var{pos} from/to @var{blob}, using the specified @var{endian}.

These are wrappers of corresponding @code{get-XX} and @code{put-XX!}
in @code{binary.io}; note that the argument orders differ, though.
@end defun

@defun blob-u16-native-ref blob pos
@defunx blob-u16-native-set! blob pos val
@defunx blob-s16-native-ref blob pos
@defunx blob-s16-native-set! blob pos val
@defunx blob-u32-native-ref blob pos
@defunx blob-u32-native-set! blob pos val
@defunx blob-s32-native-ref blob pos
@defunx blob-s32-native-set! blob pos val
@defunx blob-u64-native-ref blob pos
@defunx blob-u64-native-set! blob pos val
@defunx blob-s64-native-ref blob pos
@defunx blob-s64-native-set! blob pos val
[SRFI-74]
@c MOD srfi-74
Get/set an unsigned or signed integer of the indicated length
at @var{pos} from/to @var{blob}, using the native endianness.

These are wrappers of corresponding @code{get-XX} and @code{put-XX!}
in @code{binary.io}; note that the argument orders differ, though.
@end defun

@defun blob=? blob1 blob2
[SRFI-74]
@c MOD srfi-74
This is the same as @code{u8vector=?} in @code{gauche.uvector}.
@end defun

@defun blob-copy! src sstart target tstart n
[SRFI-74]
@c MOD srfi-74
Copy @var{n} octets from the source blob @var{src} starting from @var{sstart}
into the target blob @var{target} starting from @var{tstart}.

Note that the order of arguments differs from other @code{*-copy!}
procedures (e.g. R7RS's @code{string-copy!} and @code{vector-copy!},
and @code{gauhce.uvector}'s @code{u8vector-copy!})), which have the
following signature: @code{(*-copy! target tstart src sstart send)}
@end defun

@defun blob-copy blob
[SRFI-74]
@c MOD srfi-74
Returns a fresh copy of @var{blob}.  The same as @code{u8vector-copy}
in @code{gauche.uvector}.
@end defun

@defun blob->u8-list blob
@defunx u8-list->blob list
[SRFI-74]
@c MOD srfi-74
Wrappers of @code{u8vector->list} and @code{list->u8vector}, except
those don't take optional start/end arguments.
@end defun

@defun blob->uint-list size endian blob
@defunx blob->sint-list size endian blob
[SRFI-74]
@c MOD srfi-74
Read a sequence of unsigned or signed integers of @var{size} octets from
@var{blob} with @var{endian}, and returns them as a list.

@example
(blob->uint-list 3 (endianness big) '#u8(0 0 1 0 0 2 0 0 3))
  @result{} (1 2 3)
@end example
@end defun

@defun uint-list->blob size endian list
@defunx sint-list->blob size endian list
[SRFI-74]
@c MOD srfi-74
Convert a @var{list} of unsigned or signed integers to a blob.
The resulting blob has @code{(* size (length list))} octets.
Each integer occupies @var{size} octets.

@example
(uint-list->blob 3 (endianness little) '(1 2 3))
  @result{} #u8(1 0 0 2 0 0 3 0 0)
@end example
@end defun

@c ----------------------------------------------------------------------
@c @node Lightweight testing
@c @section @code{srfi-78} - Lightweight testing
@c @c NODE 軽量なテスト, @code{srfi-78} - 軽量なテスト

@c NOTE: Keep this unoffical, until we integrate this into gauche.test.

@c @deftp {Module} srfi-78
@c @mdindex srfi-78
@c This srfi defines @code{check} and @code{check-ec} macro, along
@c with a few helper procedures, to write tests.  Especially,
@c @code{check-ec} uses the same comprehension style as @code{srfi-42}
@c to run test expressions with various combinations of input easily.

@c Currently we provide the module independently from @code{gauche.test},
@c but the plan is to integrate this into @code{gauche.test} so that
@c the test results are folded into @code{gauche.test} and can be reported
@c together.
@c @end deftp

@c @defmac check expr => expected
@c @defmacx check expr (=> equal) expected
@c [SRFI-78]
@c @end defmac

@c @defmac check-ec qualifier @dots{} => expected (argument @dots{})
@c @defmacx check-ec qualifier @dots{} (=> equal) expected (argument @dots{})
@c @defmacx check-ec qualifier @dots{} => expected
@c @defmacx check-ec qualifier @dots{} (=> equal) expected
@c [SRFI-78]
@c @end defmac

@c @defun check-report
@c [SRFI-78]
@c @end defun

@c @defun check-set-mode! mode
@c [SRFI-78]
@c @end defun

@c @defun check-reset!
@c [SRFI-78]
@c @end defun

@c @defun check-passed? expected-total-count
@c [SRFI-78]
@c @end defun

@c ----------------------------------------------------------------------
@node Accessing environment variables, Basic socket interface, Octet-addressed binary blocks, Library modules - SRFIs
@section @code{srfi-98} - Accessing environment variables
@c NODE 環境変数へのアクセス, @code{srfi-98} - 環境変数へのアクセス

@deftp {Module} srfi-98
@mdindex srfi-98
@c EN
This srfi defines a portable way to access the underlying system's
environment variables.  Gauche supports such procedures built-in
(@pxref{Environment Inquiry}),
but portable programs may want to use srfi API instead.
@c JP
このsrfiはシステムの環境変数にアクセスするポータブルな方法を定義しています。
Gaucheは組み込みで環境変数にアクセスする手続きを持っていますが
(@ref{Environment Inquiry}参照)、
ポータブルなコードを書くにはこちらのAPIを使うのが良いでしょう。
@c COMMON
@end deftp

@defun get-environment-variable name
[SRFI-98]
@c MOD srfi-98
@c EN
Returns a string value of an environment variable named by a string @var{name}.
If the named environment variable doesn't exist, @code{#f} is returned.

This is equivalent to @code{sys-getenv}.
@c JP
文字列@var{name}で指定される名前を持つ環境変数の値を文字列で返します。
そのような環境変数が存在しなければ、@code{#f}が返されます。

この手続きは@code{sys-getenv}と等価です。
@c COMMON
@example
(get-environment-variable "PATH")
  @result{} "/bin:/usr/sbin:/usr/bin"
@end example
@end defun

@defun get-environment-variables
[SRFI-98]
@c MOD srfi-98
@c EN
Returns an assoc list of the name and the value of each environment
variable.

This is equivalent to @code{sys-environ->alist} without
the optional argument.
@c JP
全ての環境変数の名前と値の連想リストを返します。

この手続きは、省略引数を取らない時の@code{sys-environ->alist}と等価です。
@c COMMON
@example
(get-environment-variables)
  @result{} (("PATH" . "/bin:/usr/sbin:/usr/bin")
        @dots{})
@end example
@end defun

@c ----------------------------------------------------------------------
@node Basic socket interface, Boxes, Accessing environment variables, Library modules - SRFIs
@section @code{srfi-106} - Basic socket interface
@c NODE 基本的なソケットインタフェース, @code{srfi-106} - 基本的なソケットインタフェース

@deftp {Module} srfi-106
@mdindex srfi-106
@c EN
A portable basic socket interface.

Although comprehensive network API is provided by @code{gauche.net}
(@pxref{Networking}), it is Gauche-specific.  This srfi provides
a small subset of socket operations, but it offers a portable way
to create applications that needs simple networking.

Note that some procedures have the same name as the ones in @code{gauche.net},
but the interface may differ.

A socket object created by this srfi's API is an instance
of Gauche's @code{<socket>}, so it can be passed to the API
in @code{gauche.net} and vice versa.

The following procedures are exactly the same as defined in @code{gauche.net}.
@xref{Networking}, for the details.
@c JP
ポータブルなソケットインタフェースです。

Gaucheは@code{gauche.net}モジュールで包括的なネットワークAPIを提供しています
(@ref{Networking}参照)。しかしそれはGauche特有のものです。
このsrfiはソケット操作の小さなサブセットを提供し、
簡単なネットワーキングを必要とするアプリケーションをポータブルに書けるようにします。

@code{gauche.net}と同じ名前を持ち、インタフェースが異なる手続きがあることに注意してください。

このsrfiのAPIで作られるソケットオブジェクトはGaucheの@code{<socket>}オブジェクト
そのものなので、@code{gauche.net}のAPIに渡したり、またその逆も可能です。

以下にあげる手続きは@code{gauche.net}のものと全く同一です。
説明は@ref{Networking}を参照してください。
@c COMMON

@example
socket-accept        socket-shutdown       socket-close
socket-input-port    socket-output-port
@end example
@end deftp

@c EN
@subheading Socket object
@c JP
@subheading ソケットオブジェクト
@c COMMON

@defun make-client-socket node service :optional ai-family ai-socktype ai-flags ai-protocol
[SRFI-106]
@c MOD srfi-106
@c EN
Creates and returns a socket to
communicate with the node @var{node} and @var{service}.
If the socket type is connection-oriented (that is, @var{ai-socktype} is
@code{*sock-stream*}, which is the default),
the returned socket is already connected.
@c JP
ノード@var{node}のサービス@var{service}と通信するためのソケットを作って返します。
ソケットの型がコネクション指向なら(つまり、@var{ai-socktype}が
@code{*sock-stream*}なら、これはデフォルトですが)、
返されるソケットは既にコネクトされた状態になっています。
@c COMMON

@c EN
Both @var{node} and @var{service} must be strings.
The @var{node} argument is passed to @code{getaddrinfo(3)} to resolve
to the server IP address(es).
A service name solely consists of decimal digits is interpreted as
a port number.
@c JP
@var{node}と@var{service}は文字列でなければなりません。
@var{node}は@code{getaddrinfo(3)}に渡されてサーバのIPアドレスに解決されます。
@var{service}が数字のみで構成されていた場合はポート番号とみなされます。
@c COMMON

@c EN
The default value of optional arguments are as follows:
@code{*af-inet*} for @var{ai-family},
@code{*sock-stream*} for @var{ai-socktype},
@code{(socket-merge-flags *ai-v4mapped* *ai-addrconfig*)} for
@var{ai-flags}, and @code{*ipproto-ip*} for @var{ai-protocol}.
See below for valid flag values.
@c JP
省略可能引数のデフォルト値は次の通りです:
@var{ai-family}は@code{*af-inet*}、
@var{ai-socktype}は@code{*sock-stream*}、
@var{ai-flags}は@code{(socket-merge-flags *ai-v4mapped* *ai-addrconfig*)}、
そして@var{ai-protocol}は@code{*ipproto-ip*}。
有効なフラグの種類については下を参照してください。
@c COMMON

@c EN
This API differs from @code{make-client-socket} in @code{gauche.net}.
@c JP
@code{gauche.net}の@code{make-client-socket}とはAPIが異なることに注意してください。
@c COMMON

@example
(make-client-socket "127.0.0.1" "80")
 @result{} a <socket> connected to port 80 of localhost
@end example
@end defun

@defun make-server-socket service :optional ai-family ai-socktype ai-protocol
[SRFI-106]
@c MOD srfi-106
@c EN
Creates and returns a server socket that binds and listens at
the port specified by
@var{service}, which must be a string.  A service name solely consists
of decimal digits is interpreted as a port number.
@c JP
@var{serivce}で指定されるポートで待ち受けるサーバソケットを作って返します。
@var{service}は文字列でなければなりません。@var{service}が全て数字で構成されていた
場合はポート番号と解釈されます。
@c COMMON

@c EN
The default value of optional arguments are as follows:
@code{*af-inet*} for @var{ai-family},
@code{*sock-stream*} for @var{ai-socktype},
and @code{*ipproto-ip*} for @var{ai-protocol}.
See below for valid flag values.
@c JP
省略可能引数のデフォルト値は次の通りです:
@var{ai-family}は@code{*af-inet*}、
@var{ai-socktype}は@code{*sock-stream*}、
@var{ai-protocol}は@code{*ipproto-ip*}。
有効なフラグの種類については下を参照してください。
@c COMMON

@c EN
This API differs from @code{make-server-socket} in @code{gauche.net}.
@c JP
@code{gauche.net}の@code{make-server-socket}とはAPIが異なることに注意してください。
@c COMMON
@end defun

@defun socket? obj
[SRFI-106]
@c MOD srfi-106
@c EN
Equivalent to @code{(is-a? obj <socket>)}.
@c JP
@code{(is-a? obj <socket>)}と同じです。
@c COMMON
@end defun

@c EN
@subheading Communication
@c JP
@subheading 通信
@c COMMON

@defun socket-send socket u8vector :optional flags
[SRFI-106]
@c MOD srfi-106
@c EN
Almost same as @code{socket-send} in @code{gauche.net}, except that
this procedure only accepts a u8vector as the message.
(The one in @code{gauche.net} can take a string as well.)

Returns the number of octets that are actually sent.
@c JP
@code{gauche.net}の@code{socket-send}とほぼ同じですが、
@code{gauche.net}のものが文字列も引数に取ることができるのに対し、
こちらはu8vectorのみを受け付けます。

実際に送られたオクテット数を返します。
@c COMMON
@end defun

@defun socket-recv socket size :optional flags
[SRFI-106]
@c MOD srfi-106
@c EN
This is like @code{socket-recv} in @code{gauche.net}, except that
this procedure returns the received data in u8vector,
instead of a string.  If the peer has shut down the connection,
this procedure returns an empty u8vector, @code{#u8()}.

The @var{size} argument specifies the maximum size of the receiving
data.  The returned vector may be shorter if that much data is received.
@c JP
@code{gauche.net}の@code{socket-recv}に似ていますが、こちらは
文字列ではなくu8vectorを返します。もし通信の相手がコネクションを閉じていた場合は、
空のu8vector @code{#u8()}が返されます。

@var{size}引数は受信データの最大のサイズを指定します。
受信データがそれより小さい場合は返されるベクタもそれに合わせて短くなります。
@c COMMON
@end defun

@c EN
@subheading Flags
@c JP
@subheading フラグ
@c COMMON

@c EN
The srfi provides common names for constants of typical socket flags,
as well as macros that map symbolic name(s) to the flags.
@c JP
このsrfiでは、典型的なソケットフラグを表す定数と、
名前からフラグ値を求めるマクロも提供しています。
@c COMMON

@defun socket-merge-flags flag @dots{}
[SRFI-106]
@c MOD srfi-106
@c EN
Merge bitwise flags.  This is simply @code{logior} in Gauche.
@c JP
与えられた@var{flag} @dots{}をビット演算でマージします。
Gauche組み込みの@code{logior}と実質的に同じです。
@c COMMON
@end defun

@defun socket-purge-flags base-flag flag @dots{}
[SRFI-106]
@c MOD srfi-106
@c EN
Drop the bitwise flags in @var{base-flag} that are set
in @var{flag} @dots{}.
@c JP
@var{base-flag}のビットのうち、@var{flag} @dots{}で示されるビットを0にします。
@c COMMON
@end defun

@subsubheading Address family

@multitable {aaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaa}
@vindex *af-inet*
@vindex *af-inet6*
@vindex *af-unspec*
@item @code{*af-inet*} @tab @code{AF_INET}
@item @code{*af-inet6*} @tab @code{AF_INET6}
@item @code{*af-unspec*} @tab @code{AF_UNSPEC}
@end multitable

@defmac address-family name
@c MOD srfi-106
@c EN
@var{Name} can be either one of symbols
@code{inet}, @code{inet6}, or @code{unspec}, and
the macro expands into the value of @code{*af-inet*},
@code{*af-inet6*} or @code{*af-unspec*}, respectively.

If @var{name} is other object, an error is signaled.
@c JP
@var{name}がシンボル@code{inet}、@code{inet6}、@code{unspec}のいずれかであれば、
それぞれ@code{*af-inet*}、@code{*af-inet6*}、@code{*af-unspec*}の値へと展開されます。

@var{name}がそれ以外のオブジェクトならエラーが報告されます。
@c COMMON
@end defmac


@subsubheading Socket domain

@multitable {aaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaa}
@vindex *sock-stream*
@vindex *sock-dgram*
@item @code{*sock-stream*} @tab @code{SOCK_STREAM}
@item @code{*sock-dgram*} @tab @code{SOCK_DGRAM}
@end multitable

@defmac socket-domain name
@c MOD srfi-106
@c EN
@var{Name} can be either one of symbols
@code{stream} or @code{datagram}, and the macro
expands into the value of @code{*sock-stream*} and
@code{*sock-dgram*}, respectively.

If @var{name} is other object, an error is signaled.
@c JP
@var{name}がシンボル@code{stream}、@code{datagram}のいずれかであれば、
それぞれ@code{*sock-stream*}、@code{*sock-dgram*}の値へと展開されます。

@var{name}がそれ以外のオブジェクトならエラーが報告されます。
@c COMMON
@end defmac


@subsubheading Address info

@multitable {aaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaa}
@vindex *ai-canonname*
@vindex *ai-numerichost*
@vindex *ai-v4mapped*
@vindex *ai-all*
@vindex *ai-addrconfig*
@item @code{*ai-canonname*} @tab @code{AI_CANONNAME}
@item @code{*ai-numerichost*} @tab @code{AI_NUMERICHOST}
@item @code{*ai-v4mapped*} @tab @code{AI_V4MAPPED}
@item @code{*ai-all*} @tab @code{AI_ALL}
@item @code{*ai-addrconfig*} @tab @code{AI_ADDRCONFIG}
@end multitable

@defmac address-info name @dots{}
@c MOD srfi-106
@c EN
Maps combination of names @code{canoname}, @code{numerichost},
@code{v4mapped}, @code{all} and @code{addrconfig}
to the combination of corresponding flags.

An error is signaled if other symbols are passed.
(Note: @code{canoname} for @code{*ai-canonname*}).
@c JP
シンボル@code{canoname}、@code{numerichost}、
@code{v4mapped}、@code{all}、@code{addrconfig}の組み合わせを、
対応するビットフラグの組み合わせへと展開します。

他のシンボルが渡された場合はエラーが報告されます。
(註: @code{*ai-canonname*}に対応するのは@code{canoname}です)。
@c COMMON
@end defmac

@c EN
@subsubheading Protocol
@c JP
@subsubheading プロトコル
@c COMMON

@multitable {aaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaa}
@vindex *ipproto-ip*
@vindex *ipproto-tcp*
@vindex *ipproto-udp*
@item @code{*ipproto-ip*} @tab @code{IPPROTO_IP}
@item @code{*ipproto-tcp*} @tab @code{IPPROTO_TCP}
@item @code{*ipproto-udp*} @tab @code{IPPROTO_UDP}
@end multitable

@defmac ip-protocol name
@c MOD srfi-106
@c EN
Maps one of names @code{ip}, @code{tcp}, and @code{udp}
to the corresponding flag value.  An error is signaled
if other symbol is passed.
@c JP
シンボル@code{ip}、@code{tcp}、and @code{udp}を
それぞれ対応するフラグの値へと展開します。
他のシンボルが渡されたらエラーを報告します。
@c COMMON
@end defmac

@c EN
@subsubheading Message type
@c JP
@subsubheading メッセージタイプ
@c COMMON

@multitable {aaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaa}
@vindex *msg-none*
@vindex *msg-peek*
@vindex *msg-oob*
@vindex *msg-waitall*
@item @code{*msg-none*} @tab 0
@item @code{*msg-peek*} @tab  @code{MSG_PEEK}
@item @code{*msg-oob*} @tab   @code{MSG_OOB}
@item @code{*msg-waitall*} @tab @code{MSG_WAITALL}
@end multitable

@defmac message-type name @dots{}
@c MOD srfi-106
@c EN
Maps combination of names @code{none}, @code{peek},
@code{oob} and @code{wait-all}
to the combination of corresponding flags.

An error is signaled if other symbols are passed.
(Note: @code{wait-all} for @code{*msg-waitall*}).
@c JP
シンボル@code{none}、@code{peek}、
@code{oob}、@code{wait-all}の組み合わせを、
対応するビットフラグの組み合わせへと展開します。

他のシンボルが渡された場合はエラーが報告されます。
(註: @code{*msg-waitall*}に対応するのは@code{wait-all}です)。
@c COMMON
@end defmac

@c EN
@subsubheading Shutdown method
@c JP
@subsubheading シャットダウン
@c COMMON

@multitable {aaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaa}
@vindex *shut-rd*
@vindex *shut-wr*
@vindex *shut-rdwr*
@item @code{*shut-rd*} @tab @code{SHUT_RD}
@item @code{*shut-wr*} @tab @code{SHUT_WR}
@item @code{*shut-rdwr*} @tab @code{SHUT_RDWR}
@end multitable

@defmac shutdown-method name @dots{}
@c MOD srfi-106
@c EN
Maps combination of names @code{read} and @code{write}
to the combination of corresponding flags.

An error is signaled if other symbols are passed.
@c JP
シンボル@code{code}と@code{write}の組み合わせを対応するビットマスクの値へと展開します。

他のシンボルが渡された場合はエラーが報告されます。
@c COMMON
@end defmac


@c ----------------------------------------------------------------------
@node Boxes, Portable runtime environment inquiry, Basic socket interface, Library modules - SRFIs
@section @code{srfi-111} - Boxes
@c NODE ボックス, @code{srfi-111} - ボックス

@deftp {Module} srfi-111
@mdindex srfi-111
@c EN
SRFI-111 has become a part of R7RS large.
@xref{R7RS boxes}.
@c JP
SRFI-111はR7RS largeに採り入れられました。
@ref{R7RS boxes}を参照してください。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node Portable runtime environment inquiry, Sets and bags, Boxes, Library modules - SRFIs
@section @code{srfi-112} - Environment inquiry
@c NODE ポータブルな実行環境の問い合わせ, @code{srfi-112} - 実行環境の問い合わせ

@deftp {Module} srfi-112
@mdindex srfi-112
This srfi provides a portable way to obtain runtime information.
@end deftp

@defun implementation-name
[SRFI-112]
@c MOD srfi-112
Returns a string @code{"Gauche"}.
@end defun

@defun implementation-version
[SRFI-112]
@c MOD srfi-112
Returns a string of Gauche's version.  The same as @code{gauche-version}
(@pxref{Environment Inquiry}).
@end defun

@defun cpu-architecture
[SRFI-112]
@c MOD srfi-112
Returns a string of CPU architecture info, such as @code{"x86_64"}.
Same as the @code{machine} field of the return value of @code{sys-uname}
(@pxref{System inquiry}).
@end defun

@defun machine-name
[SRFI-112]
@c MOD srfi-112
Returns the host name.  Same as the @code{nodename} field of
the return value of @code{sys-uname}.
(@pxref{System inquiry}).
@end defun

@defun os-name
[SRFI-112]
@c MOD srfi-112
Returns the OS name.  Same as the @code{sysname} field
of the return value of @code{sys-uname}.
@end defun

@defun os-version
[SRFI-112]
@c MOD srfi-112
Returns the OS version.  Same as the @code{release} field
of the return value of @code{sys-uname}.
@end defun

Here's an example of output:

@example
gosh> (implementation-name)
"Gauche"
gosh> (implementation-version)
"0.9.5"
gosh> (cpu-architecture)
"x86_64"
gosh> (machine-name)
"scherzo"
gosh> (os-name)
"Linux"
gosh> (os-version)
"3.2.0-89-generic"
@end example


@c ----------------------------------------------------------------------
@node Sets and bags, Comparators, Portable runtime environment inquiry, Library modules - SRFIs
@section @code{srfi-113} - Sets and bags
@c NODE setとbag, @code{srfi-113} - setとbag

@deftp {Module} srfi-113
@mdindex srfi-113
@c EN
SRFI-113 has become a part of R7RS large.
@xref{R7RS sets}.
@c JP
SRFI-113はR7RS largeに採り入れられました。
@ref{R7RS sets}を参照してください。
@c COMMON
@end deftp


@c ----------------------------------------------------------------------
@node Comparators, Queues based on lists, Sets and bags, Library modules - SRFIs
@section @code{srfi-114} - Comparators
@c NODE 比較器, @code{srfi-114} - 比較器

@deftp {Module} srfi-114
@mdindex srfi-114
This module is provided for the compatibility of code using srfi-114.
The new code should use srfi-128, which is fully built-in.
@end deftp

The following procedures are built-in.  @xref{Basic comparators}, for
the detailed documentation.   Those are also exported from @code{srfi-114}
for the compatibility.

@table @asis
@item Predicates
@code{comparator?},

@item Standard comparators
@code{boolean-comparator},
@code{char-comparator},
@code{char-ci-comparator},
@code{string-comparator},
@code{string-ci-comparator},
@code{symbol-comparator},
@code{exact-integer-comparator},
@code{integer-comparator},
@code{rational-comparator},
@code{real-comparator},
@code{complex-comparator},
@code{number-comparator},
@code{pair-comparator},
@code{list-comparator},
@code{vector-comparator},
@code{bytevector-comparator},
@code{uvector-comparator}

@item The default comparator
@code{default-comparator}

@item Wrapped equality predicates
@code{eq-comparator},
@code{eqv-comparator},
@code{equal-comparator}

@item Accessors
@code{comparator-equality-predicate},
@code{comparator-comparison-procedure},
@code{comparator-hash-function}

@item Primitive applicators
@code{comparator-test-type},
@code{comparator-check-type},
@code{comparator-compare},
@code{comparator-hash}

@item Comparison predicates
@code{=?},
@code{<?},
@code{<=?},
@code{>?},
@code{>=?}
@end table

@subsubheading Basic comparator interface

@defun make-comparator type-test equal compare hash :optional name
[SRFI-114+]
@c MOD srfi-114
This is SRFI-114 style comparator constructor.  The optional @var{name}
argument is Gauche's extension.

This is the same as built-in @code{make-comparator/compare}.
@xref{Basic comparators}, for the details.

Do not confuse this with built-in (SRFI-128) @code{make-comparator};
if you @code{(use srfi-114)}, this one shadows the built-in one.

Note that a comparator works for both SRFI-114 and SRFI-128 procedures,
regardless of how it is constructed.
@end defun

@defun comparator-comparison-procedure? c
@defunx comparator-hash-function? c
[SRFI-114]
@c MOD srfi-114
Returns true iff a comparator @var{c} can be used to order objects
or to hash them, respectively.  These are aliases of
built-in @code{comparator-ordered?} and @code{comparator-hashable?}.
@end defun

@defun comparator-type-test-procedure c
[SRFI-114]
@c MOD srfi-114
Returns type test predicate of a comparator @var{c}.
This is an alias of bulit-in @code{comparator-type-test-predicate}.
@end defun

@defun comparator-equal? c a b
[SRFI-114]
@c MOD srfi-114
Checks equality of @var{a} and @var{b} using the equality predicate
of a comparator @var{c}.  This can be also written in @code{=?}, which
is bulit-in (@pxref{Comparator predicates and accessors}).
@example
(=? c a b)
@end example
@end defun


@subsubheading Auxiliary comparator constructors

@defun make-inexact-real-comparator epsilon rounding nan-handling
[SRFI-114]
@c MOD srfi-114
Returns a comparator for inexact real numbers, taking into
account of errors and NaNs.

The basic idea is that we compare two finite real numbers
after rounding them to @var{epsilon} interval, which must be
a nonnegative real number.
(Note that it's not to compare two numbers ``close enough'', as often
being done to compare inexact numbers.  ``Close enough'' scheme
won't be transitive.)

The rounding mode is specified by the @var{rounding} argument.
It can be either one of the symbols @code{round}, @code{ceiling},
@code{floor} or @code{truncate}, or a procedure that takes
two arguments, a real number and an epsilon, and returns
the rounded result of the first argument according to the
given epsilon.

The @var{nan-handling} argument determines how to handle the
case to compare NaN and non-NaN numbers.  (If both are NaNs,
this comparator regards them as equal).  It can be either
one of the followings:
@table @asis
@item @code{min}
If it's a symbol @code{min}, NaN is compared as smaller than
all other real numbers, even than @code{-inf.0}.
@item @code{max}
If it's a symbol @code{min}, NaN is compared as greater than
all other real numbers, even than @code{+inf.0}.
@item @code{error}
If it's a symbol @code{error}, an error is signaled.
@item a procedure taking one argument
The procedure is invoked with the real number which is not NaN.
If it ever returns, it must return eithr 1, 0 or -1, for
it's used as the result of the comparison procedure of
the comparator.  However, since the procedure doesn't know
@emph{which} argument is non-NaN, it's hard to have consistent
semantics; the best bet is to throw a custom error.
@end table

@example
(define c (make-inexact-real-comparator 0.1 'round 'error))

(comparator-compare c 0.112 0.098) @result{} 0
(comparator-compare c 0.131 0.172) @result{} -1
@end example

Note: Rounding to the nearest epsilon interval would involve
scaling inexact numbers, and that may reveal small difference
between the actual number and its notation.  For example,
an inexact real number denoted as @code{0.15} is actually
slightly smaller than @code{15/100}, and rounding with epsilon
@code{0.1} would result @code{0.1}, not @code{0.2}.
@end defun

@defun make-car-comparator cmpr
@defunx make-cdr-comparator cmpr
[SRFI-114]
@c MOD srfi-114
@c EN
Returns comparators that accept pairs, and compare them with
their car or cdr by @var{cmpr}, respectively.

Using @code{make-key-comparator}, these cam be written as follows
(@pxref{Combining comparators}, for @code{make-key-comparator}).
@c JP
ペアを受け取り、その@code{car}のみまたは@code{cdr}のみを@var{cmpr}で
比較するような比較器を返します。

@code{make-key-comparator}を使えばこれらは以下の通りに書けます。
(@code{make-key-comparator}については@ref{Combining comparators}を参照)。
@c COMMON
@example
(define (make-car-comparator cmpr)
  (make-key-comparator cmpr pair? car))

(define (make-cdr-comparator cmpr)
  (make-key-comparator cmpr pair? cdr))
@end example
@end defun

@defun make-list-comparator element-comparator
@defunx make-vector-comparator element-comparator
@defunx make-bytevector-comparator element-comparator
@c MOD srfi-114
[SRFI-114]
Returns a new comparator that compares lists, vectors and
bytevectors element-wise using @var{element-comparator},
respectively.  These are more general versions of
@code{list-comparator}, @code{vector-comparator} and
@code{bytevector-comparator}, which use @code{default-comparator}
as @var{element-comparator}.

For a list comparator, it is an error to pass improper lists.

Note that comparing sequences of different lenghts is slightly
different between lists and vector/bytevectors.  List comparator
uses ``dictionary'' order, so @code{(1 3)} comes after @code{(1 2 3)},
assuming elements are compared numerically.
For vectors and bytevectors, shorter one always precedes the other,
so @code{#(1 3)} comes before @code{#(1 2 3)}.
@end defun

@defun make-listwise-comparator type-test element-comparator empty? head tail
[SRFI-114]
@c MOD srfi-114
More general version of @code{make-list-comparator}.
Returns a comparator that compares structures which can be
traversed using three procedures, @var{empty?}, @var{head} and @var{tail}.
Each of those procedure receives a structure to be compared, and @var{empty?}
must return @code{#t} iff the structure is empty, @var{head}
must return the first element in the structure, and @var{tail}
must return the same type of structure containing all the elements
but the head.  The @var{type-test} predicate checks if the arguments
passed to the comparator to be a suitable structure.

That is, @code{make-list-comparator} can be written in
@code{make-listwise-comparator} as follows.
@example
(make-list-compartator element-comparator)
  @equiv{}
  (make-listwise-comparator list? element-compartor null? car cdr)
@end example

This can be used to compare list-like structures.  For example,
the following call returns a comparator that compares elements
of two lazy streams (@pxref{Stream library}).

@example
(make-listwise-comparator stream?
                          element-comparator
                          stream-null?
                          stream-car
                          stream-cdr)
@end example
@end defun

@defun make-vectorwise-comparator type-test element-comparator length ref
[SRFI-114]
@c MOD srfi-114
More general version of @code{make-vector-comparator}.
Returns a comparator that compares structures which can be
traversed using two procedures, @var{length} and @var{ref}.
The @var{length} procedure must return the number of elements in the
structure.  The @var{ref} procedure receives a structure and a nonnegative
exact integer index @var{k}, and must return @var{k}-th element
of the structure.

That is, the following equivalence holds:
@example
(make-vector-comparator element-comparator)
  @equiv{}
  (make-vectorwise-comparator vector? element-comparator
                              vector-length vector-ref)

(make-bytevector-comparator element-comparator)
  @equiv{}
  (make-vectorwise-comparator u8vector? element-comparator
                              u8vector-length u8vector-ref)
@end example
@end defun

@defun make-pair-comparator car-comparator cdr-comparator
[SRFI-114]
@c MOD srfi-114
Creates a comparator that compares pairs, with their cars
by @var{car-comparator} and their cdrs by @var{cdr-comparator}.
@end defun

@defun make-improper-list-comparator element-comparator
[SRFI-114]
@c MOD srfi-114
This may be understood as recursive pair comparator; if objects
to be compared are pairs, we recurse their cars then their cdrs.
If objects to be compared are not pairs, we use @var{element-comparator}
to compare them.
@end defun

@defun make-selecting-comparator comparator1 comparator2 @dots{}
[SRFI-114]
@c MOD srfi-114
This creates a comparator that works any one of the given comparators;
the objects to be compared are type-tested with each of the comparators
in order, and the first comparator that accepts all objects will be used.
@end defun

@defun make-refining-comparator comparator1 comparator2 @dots{}
[SRFI-114]
@c MOD srfi-114
This is similar to @code{make-selecting-comparator}, except that
if the first comparator that accepts given objects to compare finds
they are equal (or 0 by the comparison procedure), it tries other
comparators down the list, if any.
@end defun

@defun make-reverse-comparator comparator
[SRFI-114]
@c MOD srfi-114
Returns a comparator that just reverses the comparison order of
@var{comparator}.
@end defun

@defun make-debug-comparator comparator
[SRFI-114]
@c MOD srfi-114
@end defun

@subsubheading Comparison procedure constructors

@defun make-comparison< lt-pred
@defunx make-comparison> gt-pred
@defunx make-comparison<= le-pred
@defunx make-comparison>= ge-pred
@defunx make-comparison=/< eq-pred lt-pred
@defunx make-comparison=/> eq-pred gt-pred
[SRFI-114]
@c MOD srfi-114
Utility procedures to create a comparison procedure (the one returns
-1, 0, or 1) from the given predicate.  For example, 
@code{make-comparison<} can be defined as follows:

@example
(define (make-comparison< pred)
  (^[a b] (cond [(pred a b) -1]
                [(pred b a) 1]
                [else 0])))
@end example
@end defun

@subsubheading Comparison syntax

@defmac if3 expr less equal greater
[SRFI-114]
@c MOD srfi-114
Three-way @code{if}: Evaluates @var{expr}, and then evaluates
either one of @var{less}, @var{equal}, or @var{greater},
depending on the value of @var{expr} is either less than zero,
equal to zero, or greater than zero, respectively.
@end defmac

@defmac if=? expr consequent :optional alternate
@defmacx if<? expr consequent :optional alternate
@defmacx if>? expr consequent :optional alternate
@defmacx if<=? expr consequent :optional alternate
@defmacx if>=? expr consequent :optional alternate
@defmacx if-not=? expr consequent :optional alternate
[SRFI-114]
@c MOD srfi-114
Conditional evaluation according to comparison expression @var{expr};
that is, @code{if@var{OP}?} evaluates @var{consequent} if
@code{(@var{OP} expr 0)} is true, otherwise it evaluates @var{alternate}
when provided.

@example
(if<? (compare 10 20) 'yes)      @result{} yes
(if>=? (compare 10 20) 'yes 'no) @result{} no
@end example
@end defmac

@subsubheading Comparison predicate constructors

@defun make=? comparator
@defunx make<? comparator
@defunx make>? comparator
@defunx make<=? comparator
@defunx make>=? comparator
[SRFI-114]
@c MOD srfi-114
@example
((make=? comparator) obj1 obj2 obj3 @dots{})
  @equiv{} (=? comparator obj1 obj2 obj3 @dots{})
@end example
@end defun

@subsubheading Interval comparison predicates


@defun in-open-interval? [comparator] obj1 obj2 obj3
@defunx in-closed-interval? [comparator] obj1 obj2 obj3
@defunx in-open-closed-interval? [comparator] obj1 obj2 obj3
@defunx in-closed-open-interval? [comparator] obj1 obj2 obj3
[SRFI-114]
@c MOD srfi-114
Check if @var{obj1}, @var{obj2} and @var{obj3} has the following
relationships:

@example
(and (op1 obj1 obj2) (op2 obj2 obj3))
@end example

Where each of @var{op1} and @var{op2} can be
@code{(make<? comparator)} (if that end is @emph{open}),
or @code{(make<=? comparator)} (if that end is @emph{closed}).

When @var{comparator} is omitted, the default comparator is used.

@example
(use srfi-42)
(list-ec (: x 0 5) (list x (in-closed-open-interval? 1 x 3)))
  @result{} ((0 #f) (1 #t) (2 #t) (3 #f) (4 #f))
@end example
@end defun

@subsubheading Min/max comparison procedures

@defun comparator-min comparator obj1 obj2 @dots{}
@defunx comparator-max comparator obj1 obj2 @dots{}
[SRFI-114]
@c MOD srfi-114
Find the object in @var{obj1} @var{obj2} @dots{} that is
minimum or maximum compared by @var{comparator}.

@example
(comparator-min list-comparator '(a c b) '(a d) '(a c))
  @result{} (a c)
@end example
@end defun

@c ----------------------------------------------------------------------
@node Queues based on lists, Simple adjustable-size strings, Comparators, Library modules - SRFIs
@section @code{srfi-117} - Queues based on lists
@c NODE リストを元にしたキュー, @code{srfi-117} - リストを元にしたキュー

@deftp {Module} srfi-117
@mdindex srfi-117
@c EN
SRFI-117 has become a part of R7RS large.
@xref{R7RS list queues}.
@c JP
SRFI-117はR7RS largeに採り入れられました。
@ref{R7RS list queues}を参照してください。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node Simple adjustable-size strings, Lazy sequence (srfi), Queues based on lists, Library modules - SRFIs
@section @code{srfi-118} - Simple adjustable-size strings
@c NODE 簡単な可変長文字列, @code{srfi-118} - 簡単な可変長文字列

@deftp {Module} srfi-118
@mdindex srfi-118
@c EN
This SRFI defines two string mutating operations that can change
the length of the string: @code{string-append!} and @code{string-replace!}.

Note that, in Gauche, the body of strings is immutable; when you mutate
a string, Gauche creates a fresh new string body and just switch a pointer
in the original string to point the new string body.  So it is not a
problem to implement this SRFI in Gauche, but it also means you won't
get any performance benefit by using these operations.  Using immutable
counterparts (@code{string-append} and @code{string-replace}) gives
you the same performance.  (Be aware that the interface is slightly
different from the immutable versions.)

We provide this module only for the compatibility.  Gauche-specific
programs should stay away from this module.  Particulary, avoid
code like the example in SRFI-118 document (build a string by
@code{append!}-ing small chunks at a time)---they're quadratic on Gauche.
@c JP
このSRFIは、文字列の長さを変えるような破壊的変更を行う文字列操作ルーチンを
提供します。

Gaucheでは、文字列の本体は変更不可になっています。
文字列の破壊的変更は、
実際には新たな文字列本体を作成して、元の文字列が指している本体とポインタを
置き換えることで実現されます。
ですのでこのsrfiをGaucheに実装すること自体は全く問題ないのですが、
これらのAPIを使ったからといって性能上の恩恵にあずかれるわけではありません。
変更不可な文字列を@code{string-append} and @code{string-replace}で
切り貼りするのと、性能的には何ら変わりません。
(このモジュールのAPIは、変更不可文字列を扱うAPIと若干異なることに注意してください。)

このモジュールは、互換性のためだけ提供されます。
Gaucheに依存したプログラムはこのモジュールを使う必要はないでしょう。
特に、srfi-118のドキュメントにある例は避けるのが懸命です
(文字列を、小さな塊ごとに破壊的にappendしてゆくという実装ですが、
Gaucheではそれは文字列の長さの2乗に比例した時間がかかってしまいます)。
@c COMMON
@end deftp

@defun string-append! string values @dots{}
[SRFI-118]
@c MOD srfi-118
@c EN
The @var{string} argument must be a mutable string.
Modify @var{string} by appending @var{values}, each of which is
either a character or a string.
@c JP
@var{string}引数は変更可能な文字列でなければなりません。
残りの引数@var{values}はそれぞれ文字または文字列です。それらを@var{string}に
破壊的に追加します。
@c COMMON

@example
(rlet1 a (string-copy "abc")
  (string-append! a #\X "YZ"))
 @result{} "abcXYZ"
@end example
@end defun

@defun string-replace! dst dst-start dst-end src :optional src-start src-end
[SRFI-118]
@c MOD srfi-118
@c EN
The @var{dst} argument must be a mutable string.
Replace @var{dst} between @var{dst-start} (inclusive) and
@var{dst-end} (exclusive) with a string @var{src}.  The optional
arguments @var{src-start} and @var{src-end} limits the region of
@var{src} to be used.
@c JP
@var{dst}引数は変更可能な文字列でなければなりません。
@var{dst}中の、@var{dst-start}(inclusive)から@var{dst-end}(exclusive)までの
内容が文字列@var{src}で置き換えられます。省略可能引数
@var{src-start}と@var{src-end}で、@var{src}の使う部分を制限することができます。
@c COMMON

@c EN
Be aware that the order of arguments differ from
SRFI-13's @code{string-replace} (@pxref{SRFI-13 other string operations});
@code{string-replace!} resembles to @code{string-copy!} (also in SRFI-13),
rather than @code{string-replace}.
@c JP
引数の順序がSRFI-13の@code{string-replace}とは異なることに
注意して下さい (@ref{SRFI-13 other string operations}参照)。
@code{string-replace!}の引数順は同じくSRFI-13にある@code{string-copy!}に
似せてあります。
@c COMMON

@example
(rlet1 a (string-copy "abc")
  (string-replace! a 1 2 "XYZ"))
 @result{} "aXYZc"
@end example
@end defun

@c ----------------------------------------------------------------------
@node Lazy sequence (srfi), Sort library, Simple adjustable-size strings, Library modules - SRFIs
@section @code{srfi-127} - Lazy sequence (srfi)

@deftp {Module} srfi-127
@mdindex srfi-127
@c EN
SRFI-127 has become a part of R7RS large.
@xref{R7RS lazy sequences}.
@c JP
SRFI-127はR7RS largeに採り入れられました。
@ref{R7RS lazy sequences}を参照してください。
@c COMMON
@end deftp


@c ----------------------------------------------------------------------
@node Sort library, Vector library, Lazy sequence (srfi), Library modules - SRFIs
@section @code{srfi-132} - Sort library
@c NODE ソートライブラリ, @code{srfi-133} - ソートライブラリ

@deftp {Module} srfi-132
@mdindex srfi-132
@c EN
SRFI-132 has become a part of R7RS large.
@xref{R7RS sort}.
@c JP
SRFI-132はR7RS largeに採り入れられました。
@ref{R7RS sort}を参照してください。
@c COMMON
@end deftp


@c ----------------------------------------------------------------------
@node Vector library, Integer division, Sort library, Library modules - SRFIs
@section @code{srfi-133} - Vector library
@c NODE ベクタライブラリ, @code{srfi-133} - ベクタライブラリ

@deftp {Module} srfi-133
@mdindex srfi-133
@c EN
SRFI-133 has become a part of R7RS large.
@xref{R7RS vectors}.
@c JP
SRFI-133はR7RS largeに採り入れられました。
@ref{R7RS vectors}を参照してください。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node Integer division, Fixnums, Vector library, Library modules - SRFIs
@section @code{srfi-141} - Integer division
@c NODE 整数除算, @code{srfi-141} - 整数除算

@deftp {Module} srfi-141
@mdindex srfi-141
@c EN
This module provides a comprehensive set of integer division operators.

Quotient and remainder in integer divisions can be defined in multiple
ways, when you consider the choice of sign of the result with regard to
the operands.  Gauche has builtin procedures in several flavors:
R5RS @code{quotient}, @code{remadiner} and @code{modulo},
R6RS @code{div}, @code{mod}, @code{div0} and @code{mod0},
and R7RS @code{floor-quotient}, @code{floor-remainder}, @code{floor/},
@code{truncate-quotinet}, @code{truncate-remainder}, @code{truncate/}.

This module complements R7RS procedures, by adding @code{ceiling},
@code{round}, @code{euclidean} and @code{balanced} variants.

The following procedures are in srfi-141 but built-in in Gauche
(@pxref{Arithmetics}).
@c JP
このモジュールは、様々な整数除算操作を包括的に提供します。

整数除算の商と剰余には、除数と被除数の符号の考慮によって、
いくつかの定義が考えられます。
Gaucheはそのうちいくつかの定義を組み込みで提供しています：
R5RSの@code{quotient}、@code{remainder}、@code{modulo}、
R6RSの@code{div}、@code{mod}、@code{div0}、@code{mod0}、
そしてR7RSの
@code{floor-quotient}、@code{floor-remainder}、@code{floor/}、
@code{truncate-quotinet}、@code{truncate-remainder}、@code{truncate/}、です。

このモジュールは、R7RSの手続きにさらに
@code{ceiling}、
@code{round}、@code{euclidean}、@code{balanced}のバリエーションを加えます。

srfi-141の以下の手続きについては組み込みになっているので、
@ref{Arithmetics}を参照してください。
@c COMMON
@example
floor-quotient     floor-remainder    floor/
truncate-quotient  truncate-remainder truncate/
@end example
@end deftp

@defun ceiling-quotient n d
@defunx ceiling-remainder n d
@defunx ceiling/ n d
[SRFI-141]
@c MOD srfi-141
@example
ceiling-quotient = ceiling(n / d)
ceiling-remainder = n - d * ceiling-quotient
ceiling/ = values(ceiling-quotient, ceiling-remainder)
@end example
@end defun

@defun round-quotient n d
@defunx round-remainder n d
@defunx round/ n d
[SRFI-141]
@c MOD srfi-141
@example
round-quotient = round(n/d)
round-remainder = n - d * round-quotient
round/ = values(round-quotient, round-remainder)
@end example
@end defun

@defun euclidean-quotient n d
@defunx euclidean-remainder n d
@defunx euclidean/ n d
[SRFI-141]
@c MOD srfi-141
@example
euclidean-quotient = floor(n / d)   if d > 0
                     ceiling(n / d) if d < 0
euclidean-remainder = n - d * euclidean-quotient
euclidean/ = values(euclidean-quotient, euclidean-remainder)
@end example
@c EN
The Eclidean variant satisfies a property @code{0 <= remainder < abs(d)}.
These are the same as R6RS's @code{div}, @code{mod}, and @code{div-and-mod},
except that they accept non-integers (@pxref{Arithmetics})
@c JP
Eclideanバリエーションは、@code{0 <= remainder < abs(d)}という関係を常に満たします。
この定義はR6RSの@code{div}、@code{mod}および@code{div-and-mod}と同じです。
但し、R6RS版は非整数を引数に取ることもできます(@ref{Arithmetics}参照)。
@c COMMON
@end defun

@defun balanced-quotient n d
@defunx balanced-remainder n d
@defunx balanced/ n d
[SRFI-141]
@c MOD srfi-141
@example
balanced-quotient = roundup(n / d)
balanced-remainder = n - d * balanced-quotient
balanced/ = values(balanced-quotient, balanced-remainder)
  where roundup(x) is  ceiling(x) if x - floor(x) <= 0.5
                   and floor(x)   if x - floor(x) > 0.5
@end example
@c EN
The balanced variant satisfies a property
@code{-abs(d/2) <= remainder < abs(d/2)}.
These are the same as R6RS's @code{div0}, @code{mod0}, and
@code{div0-and-mod0}, except that they accept non-integers
(@pxref{Arithmetics}).
@c JP
Balancedバージョンは@code{-abs(d/2) <= remainder < abs(d/2)}という
関係を常に満たします。これはR6RSの
@code{div0}、@code{mod0}および@code{div0-and-mod0}と同じです。
但し、R6RS版は非整数を引数に取ることもできます(@ref{Arithmetics}参照)。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Fixnums, Mappings and hashmaps, Integer division, Library modules - SRFIs
@section @code{srfi-143} - Fixnums
@c NODE Fixnums, @code{srfi-143} - Fixnums

@deftp {Module} srfi-143
@mdindex srfi-143
@c EN
This module provides a set of fixnum-specific operations.

A fixnum is a small exact integer that can be handled very efficiently.
In Gauche, fixnum is 62bit wide on 64bit platforms, and
30bit wide on 32bit platforms.
@c JP
このモジュールはfixnumに特化した操作を提供します。

fixnumは絶対値が小さめの正確な整数で、極めて効率的に処理できます。
Gaucheのfixnumは、64ビット環境では62ビット、32ビット環境では30ビットの幅を持ちます。
@c COMMON

@c EN
Note that these procedures are defined only to work on fixnums,
but it is not enforced.  If you pass non-fixnum arguments, or
the result falls out of range of fixnums, what happens is up to
the implementation.  Consider these procedures as the way to
tell your intentions to the compiler for potential optimizations.
@c JP
このモジュールの手続きはfixnumの範囲でしか動作を定義されていませんが、
それを強制するのではないことに注意してください。fixnumでない引数を
渡したり、結果がfixnumの範囲外になった場合に何が起きるかは
処理系依存とされています。これらの手続きは、プログラマがその意図を
コンパイラに伝えて最適化を期待するためのものと考えると良いでしょう。
@c COMMON

@c EN
In the current Gauche architecture,
generic numeric operators are just as efficient, 
so most procedures provided in this module are aliases to corresponding
operators.   However, we might employ some optimizations in future
versions.
@c JP
現在のGaucheのアーキテクチャでは一般的な数値計算が効率よく実行できるようになっているので、
これらの手続きは対応する手続きの単なる別名になっています。
将来は、fixnum特有の最適化を導入するかもしれません。
@c COMMON

@c EN
The procedure @code{fixnum?} is built-in, and
not explaned here.  @xref{Numerical predicates}.
@c JP
手続き@code{fixnum?}は組み込みなのでここでは説明しません。
@ref{Numerical predicates}を参照してください。
@c COMMON
@end deftp

@defvar fx-width
[SRFI-143]
@c MOD srfi-143
@c EN
A variable bound to an exact positive integer @var{w}, where @var{w}
is the greatest number such that exact integers between
@code{2^(w-1) - 1} and @code{-2^(w-1)} are all fixnums.
This value is the same as the built-in procedure @code{fixnum-width}
returns (@pxref{Arithmetics}).

In Gauche, it is usually @code{30} for 32bit platforms, and @code{62} for
64bit platforms.
@c JP
@code{2^(w-1) - 1}から@code{-2^(w-1)}までの正確な整数が全てfixnumであるような
最大の正整数@code{w}に束縛された変数です。
組み込み手続き@code{fixnum-width}が返す値と同じです。
(@ref{Arithmetics}参照)。

Gaucheでは、これは通常32ビット環境で@code{30}、64ビット環境で@code{62}です。
@c COMMON
@end defvar

@defvar fx-greatest
@defvarx fx-least
[SRFI-143]
@c MOD srfi-143
@c EN
Variables bound to the greatest fixnum and the least fixnum.
They are the same as the built-in procedures
@code{greatest-fixnum} and @code{least-fixnum} return, respectively
(@pxref{Arithmetics}).

The following table shows the typical values on Gauche:
@c JP
最大および最小のfixnumに束縛された変数です。これらの値は
組み込み手続き@code{greatest-fixnum}および@code{least-fixnum}が
返すものと同じです(@ref{Arithmetics}参照)。

次の表はGaucheでの典型的な値を示します。
@c COMMON

@multitable {Platform} {2,305,843,009,213,693,951} {-2,305,843,009,213,693,951}
@headitem Platform @tab @code{fx-greatest} @tab @code{fx-least}
@item 32bit @tab 536,870,911 @tab -536,870,912
@item 64bit @tab 2,305,843,009,213,693,951 @tab -2,305,843,009,213,693,952
@end multitable
@end defvar

@defun fx=? i @dots{}
@defunx fx<? i @dots{}
@defunx fx<=? i @dots{}
@defunx fx>? i @dots{}
@defunx fx>=? i @dots{}
[SRFI-143]
@c MOD srfi-143
@c EN
These are equivalent to built-in @code{=}, @code{<}, @code{<=},
@code{>} and @code{>=}, except that you should use these only for fixnums.
@c JP
これらは、fixnumのみに適用しなければならないことを除き、組み込みの
@code{=}、@code{<}、@code{<=}、@code{>}、@code{>=}と同じです。
@c COMMON
@end defun

@defun fxzero? i
@defunx fxpositive? i
@defunx fxnegative? i
@defunx fxodd? i
@defunx fxeven? i
[SRFI-143]
@c MOD srfi-143
@c EN
These are equivalent to built-in @code{zero?}, @code{positive?},
@code{negative?}, @code{odd?} and @code{even?},
except that you should use these only for fixnums.
@c JP
これらは、fixnumのみに適用しなければならないことを除き、組み込みの
@code{zero?}、@code{positive?}、@code{negative?}、@code{odd?}、@code{even?}と同じです。
@c COMMON
@end defun

@defun fxmax i j @dots{}
@defunx fxmin i j @dots{}
[SRFI-143]
@c MOD srfi-143
@c EN
These are equivalent to built-in @code{max} and  @code{min},
except that you should use these only for fixnums.
@c JP
これらは、fixnumのみに適用しなければならないことを除き、組み込みの
@code{max}および@code{min}と同じです。
@c COMMON
@end defun

@defun fx+ i j
@defunx fx- i j
@defunx fx* i j
[SRFI-143]
@c MOD srfi-143
@c EN
These are equivalent to built-in @code{+}, @code{-}
and  @code{*},
except that these take exactly two arguments, and
you should use these only for fixnums and
when the result fits within fixnum range.
@c JP
これらは、常に2つの引数を取ること、
fixnumのみに適用しなければならないこと、
そして結果がfixnumの範囲に収まる場合だけに使わなければならないことを除き、
組み込みの@code{+}、@code{-}、@code{*}と同じです。
@c COMMON
@end defun

@defun fxneg i
[SRFI-143]
@c MOD srfi-143
@c EN
This is equivalent to single-argument @code{-},
except that you should use this only for fixnums and
when the result fits within fixnum range.
@c JP
これは、fixnumのみに適用しなければならないこと、
そして結果がfixnumの範囲に収まる場合だけに使わなければならないことを除き、
組み込みの単項@code{-}と同じです。
@c COMMON
@end defun

@defun fxquotient i j
@defunx fxremainder i j
@defunx fxabs i
@defunx fxsquare i
[SRFI-143]
@c MOD srfi-143
@c EN
These are equivalent to built-in @code{quotient}, @code{remainder},
@code{abs} and @code{square},
except that you should use these only for fixnums and
when the result fits within fixnum range.
@c JP
これらは、fixnumのみに適用しなければならないこと、
そして結果がfixnumの範囲に収まる場合だけに使わなければならないことを除き、
組み込みの@code{quotient}、@code{remainder}、@code{abs}、@code{square}と
同じです。
@c COMMON
@end defun

@defun fxsqrt i
[SRFI-143]
@c MOD srfi-143
@c EN
This is equivalent to @code{exact-integer-sqrt} (not @code{sqrt}),
except that you should use it only for fixnums.
@xref{Arithmetics}.
@c JP
これらは、fixnumのみに適用しなければならないことを除き、
@code{exact-integer-sqrt}と同じです。@code{sqrt}ではありません。
@ref{Arithmetics}参照。
@c COMMON
@end defun

@defun fx+/carry i j k
@defunx fx-/carry i j k
@defunx fx*/carry i j k
[SRFI-143]
@c MOD srfi-143
@c EN
These calculates @code{(+ i j k)}, @code{(- i j k)} and @code{(+ (* i j) k)},
respectively, then split the result to the remainder value @code{R}
in the fixnum range, and spilled value @code{Q}, and return those values.
That is,
@code{(+ (* Q (expt 2 fx-width)) R)} is the result of above calculations.
Both @code{Q} and @code{R} fits in the fixnum range, and
@code{- 2^(w-1) <= R < 2^(w-1)}, where @code{w} is @code{fx-width}.
@c JP
これらはそれぞれ、まず
@code{(+ i j k)}、@code{(- i j k)}、@code{(+ (* i j) k)}を計算し、
その結果をfixnumの範囲内に収まる剰余@code{R}と、溢れ@code{Q}に分割して
2つの値として返します。
すなわち、@code{(+ (* Q (expt 2 fx-width)) R)}が上記計算と一致します。
@code{Q}と@code{R}は常にfixnumの範囲内であり、また@code{R}は
@code{- 2^(w-1) <= R < 2^(w-1)}を満たします。ただし@code{w}は
@code{fx-width}です。
@c COMMON

@example
(fx*/carry 1845917459 19475917581 4735374)
 @result{} -942551854601421179 @r{and} 8

(+ (* 8 (expt 2 fx-width)) -942551854601421179)
 @result{} 35950936292817682053

(+ (* 1845917459 19475917581) 4735374)
 @result{} 35950936292817682053
@end example

@c EN
These are primitives to implement extended-precision
integer arithmetic on top of fixnum operations.  In Gauche, however,
you can just use built-in bignums.  We provide these for the compatibility.
@c JP
これらは拡張精度整数演算をfixnum手続き上に効率よく実装するためのプリミティブです。
ただ、Gaucheでは必要ならbignumを使えば良いので、これらは単に互換性のために提供しています。
@c COMMON
@end defun

@defun fxnot i
@defunx fxand i @dots{}
@defunx fxior i @dots{}
@defunx fxxor i @dots{}
@defunx fxarithmetic-shift i count
@defunx fxlength i
@defunx fxbit-count i
@defunx fxcopy-bit index i boolean
@defunx fxbit-set? index i
@defunx fxbit-field i start end
@defunx fxfirst-set-bit i
[SRFI-143]
@c MOD srfi-143
@c EN
These are equivalent to @code{lognot}, @code{logand},
@code{logior}, @code{logxor}, @code{ash}, @code{integer-length},
@code{logcount},
@code{copy-bit}, @code{logbit?}, @code{bit-field},
and @code{twos-exponent-factor} respectively,
except that you should use these only for fixnums.
@xref{Basic bitwise operations}.
@c JP
これらはfixnumのみに適用しなければならないことを除き、
組み込みの@code{lognot}、 @code{logand}、
@code{logior}、 @code{logxor}、 @code{ash}、 @code{integer-length}、
@code{logcount}、
@code{copy-bit}、 @code{logbit?}、 @code{bit-field}、
@code{twos-exponent-factor}とそれぞれ同じです。
詳しくは@ref{Basic bitwise operations}参照。
@c COMMON
@end defun

@defun fxif mask i j
@defunx fxbit-field-rotate i start end
@defunx fxbit-field-rotate i start end
[SRFI-143]
@c MOD srfi-143
@c EN
These are equivalent to srfi-60's 
@code{bitwise-if}, @code{rotate-bit-field} and
@code{reverse-bit-field},
except that you should use these only for fixnums.
@xref{Integers as bits}.
@c JP
これらはfixnumのみに適用しなければならないことを除き、
srfi-60の@code{bitwise-if}、@code{rotate-bit-field}、
@code{reverse-bit-field}と同じです。
@ref{Integers as bits}参照。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Mappings and hashmaps, Bitwise operations, Fixnums, Library modules - SRFIs
@section @code{srfi-146} - Mappings and hashmaps
@c NODE mappingとhashmap, @code{srfi-146} - mappingとhashmap

SRFI-146 defines a @emph{mapping} data structure, which is
a conceptually immutable collection of associations of key and value.
Mappings are assumed to be built on top of treemaps (and indeed,
Gauche uses built-in @code{<tree-map>} as mappings) but the API
abstracts the implementation.

SRFI-146 also defines a submodlue @code{(srfi-146 hash)} which
provides hashmaps,
whose API is functionally almost identical to mappings but
it assumes to be built on top of hashtables.

``Conceptually immutable'' means that the mappings should be used
as if they are immutable, but under a certain circumstance the
APIs are allowed to mutate the mapping.  Such circumstance
is marked as 


@menu
* Mappings::
* Hashmaps::
@end menu

@node Mappings, Hashmaps, Mappings and hashmaps, Mappings and hashmaps
@subsection Mappings
@c NODE Mappings

@deftp {Module} srfi-146
@mdindex srfi-146
This module provides treemap-based mappings API.
On Gauche, an instance of @code{mapping} is just an instance
of built-in @code{<tree-map>} (@pxref{Treemaps}).
However, the API assumes a
mapping to be treated as immutable data structure, except
the ``linear update'' APIs, which is @emph{allowed} to
mutate the mappings passed to the arguments, under assumption
that the argument won't be used afterwards.

@xref{Hashmaps}, which is a sibling of mappings but based
on hashtables.
@end deftp

@deftp {Class} <mapping>
@clindex mapping
@c MOD srfi-146
On Gauche, this is just an alias of @code{<tree-map>}.
@end deftp

@subsubheading Constructors

@defun mapping comparator key value @dots{}
[SRFI-146]
@c MOD srfi-146
Creates a new mapping with the given @var{comparator},
whose initial content is
provided by @var{key} @var{value} @dots{}.

The @var{comparator} argument must be a comparator
(@pxref{Basic comparators}).

The @var{key} @var{value} @dots{} arguments must be
even length, alternating keys and values.

@example
(define m (mapping default-comparator 'a 1 'b 2))

(mapping-ref m 'a) @result{} 1
(mapping-ref m 'b) @result{} 2
@end example
@end defun

@defun mapping-unfold p f g seed comparator
[SRFI-146]
@c MOD srfi-146
Creates a new mapping, whose content is populated by
three procedures, @var{p}, @var{f} and @var{g}, and
a seed value @var{seed}, as follows.

In each iteration, we have a current seed value, whose initial
value is @var{seed}.

First, @var{p}, a stop predicate, is applied to the current
seed value. If it returns true, we stop iteration and returns
the new mapping.

Next, @var{f} is applied to the current seed value.  It must
return two values.  The first one is for a key and the second
one for the value.  We add this pair to the mapping.

Then, @var{g} is applied to the current seed value.  The result
becomes the seed value of the next iteration.  And we iterate.

The following example creates a mapping that maps ASCII characters
to their character codes:

@example
(mapping-unfold (cut >= <> 128)
                (^c (values (integer->char c) c))
                (cut + <> 1)
                0
                default-comparator)
@end example
@end defun

@defun mapping/ordered comparator key value @dots{}
[SRFI-146]
@c MOD srfi-146
Similar to @code{mapping}, but keys are given in the ascending order
w.r.t. the comparator.  An implementation may use more efficient algorithm
than @code{mapping}.  In Gauche, this is the same as @code{mapping}
at this moment.
@end defun

@defun mapping-unfold/ordered p f g seed comparator
[SRFI-146]
@c MOD srfi-146
Similar to @code{mapping-unfold}, but keys are generated in the
ascendnig order
w.r.t. the comparator.  An implementation may use more efficient algorithm
than @code{mapping-unfold}. 
In Gauche, this is the same as @code{mapping-unfold} at this moment.
@end defun

@subsubheading Predicates

@defun mapping? obj
[SRFI-146]
@c MOD srfi-146
Returns @code{#t} iff @var{obj} is a mapping object.
@end defun

@defun mapping-empty? m
[SRFI-146]
@c MOD srfi-146
@var{M} must be a mapping.
Returns @code{#t} if @var{m} is empty, @code{#f} otherwise.
In Gauche, this is same as @code{tree-map-empty?}
(@pxref{Treemaps}).
@end defun

@defun mapping-contains? m key
[SRFI-146]
@c MOD srfi-146
@var{M} must be a mapping.
Returns @code{#t} if @var{m} has an entry with @var{key},
@code{#f} otherwise.
In Gauche, this is same as @code{tree-map-exists?}
(@pxref{Treemaps}).
@end defun

@defun mapping-disjoint? m1 m2
[SRFI-146]
@c MOD srfi-146
Returns @code{#t} iff two mappings @var{m1} and @var{m2} have no keys
in common.  In other words, there's no such key K that
satisfy both @code{(mapping-contains? m1 K)} and
@code{(mapping-contains? m2 K)}.
@end defun

@subsubheading Accessors

@defun mapping-ref m key :optional failure success
[SRFI-146]
@c MOD srfi-146
Get the value from a mapping @var{m} associated with @var{key},
and calls @var{success} on the value, and returns its result.
If @var{m} doesn't have @var{key}, @var{failure} is invoked with no
arguments and its result is returned.
Both @var{success} and @var{failure} is called in tail context.

When @var{failure} is omitted and @var{key} is not found, an error
is signaled.  When @var{success} is omitted, @code{identity} is
assumed.
@end defun

@defun mapping-ref/default m key default
[SRFI-146]
@c MOD srfi-146
Returns the value associated to @var{key} from a mapping @var{m}.
If @var{m} doesn't have @var{key}, @var{default} is returned.
@end defun

@defun mapping-key-comparator m
[SRFI-146]
@c MOD srfi-146
Returns a comparator used to compare keys in a mapping @var{m}.
@xref{Basic comparators}, for the details of comparators.
@end defun

@subsubheading Updaters

Note that the basic premise of mappings srfi is to treat mappings 
as immutable.  Each updating operation comes with a purely functional
version (without bang) and a linear update version (with bang), but
the linear update version may not require to destructively modiy
the passed mapping; it's merely a hint that it may reuse the
argument for the efficiency.  You always need to use the returned
mapping as the result of update.  If you use linear update versions,
you shouldn't use the passed mapping afterwards, for there's no guarantee
how the state of the passed mapping is.

@defun mapping-adjoin m arg @dots{}
@defunx mapping-adjoin! m arg @dots{}
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-set m arg @dots{}
@defunx mapping-set! m arg @dots{}
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-replace m key value
@defunx mapping-replace! m key value
[SRFI-146]
@c MOD srfi-146
@end defun


@defun mapping-delete m key @dots{}
@defunx mapping-delete! m key @dots{}
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-delete-all m key-list
@defunx mapping-delete-all! m key-list
[SRFI-146]
@c MOD srfi-146
@end defun


@defun mapping-intern m key failure
@defunx mapping-intern! m key failure
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-update m key updater :optional failure success
@defunx mapping-update! m key updater :optional failure success
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-update/default m key updater default
@defunx mapping-update!/default m key updater default
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-pop m :optional failure
@defunx mapping-pop! m :optional failure
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-search m k failure success
@defunx mapping-search! m k failure success
[SRFI-146]
@c MOD srfi-146
@end defun

@subsubheading The whole mapping

@defun mapping-size m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-find pred m failure
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-count pred m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-any? pred m
@defunx mapping-every? pred m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-keys m
@defunx mapping-values m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-entries m
[SRFI-146]
@c MOD srfi-146
@end defun

@subsubsection Mapping and folding

@defun mapping-map proc comparator m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-map/monotone proc comparator m
@defunx mapping-map/monotone! proc comparator m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-for-each proc m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-fold kons knil m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-fold/reverse kons knil m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-map->list proc m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-filter pred m
@defunx mapping-filter! pred m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-remove pred m
@defunx mapping-remove! pred m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-partition pred m
@defunx mapping-partition! pred m
[SRFI-146]
@c MOD srfi-146
@end defun

@subsubheading Copying and conversion

@defun mapping-copy m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping->alist m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun alist->mapping comparator alist
[SRFI-146]
@c MOD srfi-146
@end defun

@defun alist->mapping! m alist
[SRFI-146]
@c MOD srfi-146
@end defun

@defun alist->mapping/ordered comparator alist
@defunx alist->mapping/ordered! m alist
[SRFI-146]
@c MOD srfi-146
@end defun

@subsubheading Submappings

@defun mapping=? comparator m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping<? comparator m1 m2 @dots{}
@defunx mapping<=? comparator m1 m2 @dots{}
@defunx mapping>? comparator m1 m2 @dots{}
@defunx mapping>=? comparator m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146
@end defun

@subsubheading Set operations

@defun mapping-union m1 m2 @dots{}
@defunx mapping-union! m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-intersection m1 m2 @dots{}
@defunx mapping-intersection! m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-difference m1 m2 @dots{}
@defunx mapping-difference! m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-xor m1 m2 @dots{}
@defunx mapping-xor! m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146
@end defun

@subsubheading Mappings with ordered keys

@defun mapping-min-key m
@defunx mapping-max-key m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-min-value m
@defunx mapping-max-value m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-min-entry m
@defunx mapping-max-entry m
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-key-predecessor m obj failure
@defunx mapping-key-successor m obj failure
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-range= m obj
@defunx mapping-range< m obj
@defunx mapping-range<= m obj
@defunx mapping-range> m obj
@defunx mapping-range>= m obj
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-range=! m obj
@defunx mapping-range<! m obj
@defunx mapping-range<=! m obj
@defunx mapping-range>! m obj
@defunx mapping-range>=! m obj
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-split m obj
@defunx mapping-split! m obj
[SRFI-146]
@c MOD srfi-146
@end defun

@defun mapping-catenate comparator m1 key value m2 
@defunx mapping-catenate! m1 key value m2 
[SRFI-146]
@c MOD srfi-146
@end defun

@subsubheading Comparators

@defun make-mapping-comparator comparator
[SRFI-146]
@c MOD srfi-146
@end defun

@defvar mapping-comparator
[SRFI-146]
@c MOD srfi-146
@end defvar


@node Hashmaps,  , Mappings, Mappings and hashmaps
@subsection Hashmaps
@c NODE Hashmaps

@deftp {Module} srfi-146.hash
@mdindex srfi-146.hash
This module provides hashtable-based hashmap API.
On Gauche, an instance of @code{hashmap} is just an instance
of built-in @code{<hash-table>}.  However, the API assumes a
hashmap to be treated as immutable data structure, except
the ``linear update'' APIs, which is @emph{allowed} to
mutate the hashmaps passed to the arguments, under assumption
that the argument won't be used afterwards.

@xref{Mappings}, which is a sibling of hashmaps but based
on treemaps.
@end deftp

@subsubheading Constructors

@defun hashmap comparator key value @dots{}
[SRFI-146]
@c MOD srfi-146.hash
Creates a new hashmap with the given @var{comparator},
whose initial content is
provided by @var{key} @var{value} @dots{}.

The @var{comparator} argument must be a comparator
(@pxref{Basic comparators}).

The @var{key} @var{value} @dots{} arguments must be
even length, alternating keys and values.

@example
(define m (hashmap default-comparator 'a 1 'b 2))

(hashmap-ref m 'a) @result{} 1
(hashmap-ref m 'b) @result{} 2
@end example
@end defun

@defun hashmap-unfold p f g seed comparator
[SRFI-146]
@c MOD srfi-146.hash
Creates a new hashmap, whose content is populated by
three procedures, @var{p}, @var{f} and @var{g}, and
a seed value @var{seed}, as follows.

In each iteration, we have a current seed value, whose initial
value is @var{seed}.

First, @var{p}, a stop predicate, is applied to the current
seed value. If it returns true, we stop iteration and returns
the new hashmap.

Next, @var{f} is applied to the current seed value.  It must
return two values.  The first one is for a key and the second
one for the value.  We add this pair to the hashmap.

Then, @var{g} is applied to the current seed value.  The result
becomes the seed value of the next iteration.  And we iterate.

The following example creates a hashmap that maps ASCII characters
to their character codes:

@example
(hashmap-unfold (cut >= <> 128)
                (^c (values (integer->char c) c))
                (cut + <> 1)
                0
                default-comparator)
@end example
@end defun

@subsubheading Predicates

@defun hashmap? obj
[SRFI-146]
@c MOD srfi-146.hash
Returns @code{#t} iff @var{obj} is a hashmap object.
@end defun

@defun hashmap-empty? m
[SRFI-146]
@c MOD srfi-146.hash
@var{M} must be a hashmap.
Returns @code{#t} if @var{m} is empty, @code{#f} otherwise.
In Gauche, this is same as @code{tree-map-empty?}
(@pxref{Treemaps}).
@end defun

@defun hashmap-contains? m key
[SRFI-146]
@c MOD srfi-146.hash
@var{M} must be a hashmap.
Returns @code{#t} if @var{m} has an entry with @var{key},
@code{#f} otherwise.
In Gauche, this is same as @code{tree-map-exists?}
(@pxref{Treemaps}).
@end defun

@defun hashmap-disjoint? m1 m2
[SRFI-146]
@c MOD srfi-146.hash
Returns @code{#t} iff two hashmaps @var{m1} and @var{m2} have no keys
in common.  In other words, there's no such key K that
satisfy both @code{(hashmap-contains? m1 K)} and
@code{(hashmap-contains? m2 K)}.
@end defun

@subsubheading Accessors

@defun hashmap-ref m key :optional failure success
[SRFI-146]
@c MOD srfi-146.hash
Get the value from a hashmap @var{m} associated with @var{key},
and calls @var{success} on the value, and returns its result.
If @var{m} doesn't have @var{key}, @var{failure} is invoked with no
arguments and its result is returned.
Both @var{success} and @var{failure} is called in tail context.

When @var{failure} is omitted and @var{key} is not found, an error
is signaled.  When @var{success} is omitted, @code{identity} is
assumed.
@end defun

@defun hashmap-ref/default m key default
[SRFI-146]
@c MOD srfi-146.hash
Returns the value associated to @var{key} from a hashmap @var{m}.
If @var{m} doesn't have @var{key}, @var{default} is returned.
@end defun

@defun hashmap-key-comparator m
[SRFI-146]
@c MOD srfi-146.hash
Returns a comparator used to compare keys in a hashmap @var{m}.
@xref{Basic comparators}, for the details of comparators.
@end defun

@subsubheading Updaters

Note that the basic premise of hashmaps srfi is to treat hashmaps 
as immutable.  Each updating operation comes with a purely functional
version (without bang) and a linear update version (with bang), but
the linear update version may not require to destructively modiy
the passed hashmap; it's merely a hint that it may reuse the
argument for the efficiency.  You always need to use the returned
hashmap as the result of update.  If you use linear update versions,
you shouldn't use the passed hashmap afterwards, for there's no guarantee
how the state of the passed hashmap is.

@defun hashmap-adjoin m arg @dots{}
@defunx hashmap-adjoin! m arg @dots{}
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-set m arg @dots{}
@defunx hashmap-set! m arg @dots{}
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-replace m key value
@defunx hashmap-replace! m key value
[SRFI-146]
@c MOD srfi-146.hash
@end defun


@defun hashmap-delete m key @dots{}
@defunx hashmap-delete! m key @dots{}
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-delete-all m key-list
@defunx hashmap-delete-all! m key-list
[SRFI-146]
@c MOD srfi-146.hash
@end defun


@defun hashmap-intern m key failure
@defunx hashmap-intern! m key failure
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-update m key updater :optional failure success
@defunx hashmap-update! m key updater :optional failure success
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-update/default m key updater default
@defunx hashmap-update!/default m key updater default
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-pop m :optional failure
@defunx hashmap-pop! m :optional failure
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-search m k failure success
@defunx hashmap-search! m k failure success
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@subsubheading The whole hashmap

@defun hashmap-size m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-find pred m failure
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-count pred m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-any? pred m
@defunx hashmap-every? pred m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-keys m
@defunx hashmap-values m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-entries m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@subsubsection Mapping and folding

@defun hashmap-map proc comparator m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-for-each proc m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-fold kons knil m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-map->list proc m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-filter pred m
@defunx hashmap-filter! pred m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-remove pred m
@defunx hashmap-remove! pred m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-partition pred m
@defunx hashmap-partition! pred m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@subsubheading Copying and conversion

@defun hashmap-copy m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap->alist m
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun alist->hashmap comparator alist
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun alist->hashmap! m alist
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@subsubheading Subhashmaps

@defun hashmap=? comparator m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap<? comparator m1 m2 @dots{}
@defunx hashmap<=? comparator m1 m2 @dots{}
@defunx hashmap>? comparator m1 m2 @dots{}
@defunx hashmap>=? comparator m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@subsubheading Set operations

@defun hashmap-union m1 m2 @dots{}
@defunx hashmap-union! m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-intersection m1 m2 @dots{}
@defunx hashmap-intersection! m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-difference m1 m2 @dots{}
@defunx hashmap-difference! m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defun hashmap-xor m1 m2 @dots{}
@defunx hashmap-xor! m1 m2 @dots{}
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@subsubheading Comparators

@defun make-hashmap-comparator comparator
[SRFI-146]
@c MOD srfi-146.hash
@end defun

@defvar hashmap-comparator
[SRFI-146]
@c MOD srfi-146.hash
@end defvar



@c ----------------------------------------------------------------------
@node Bitwise operations, String library (reduced), Mappings and hashmaps, Library modules - SRFIs
@section @code{srfi-151} - Bitwise operations
@c NODE ビット演算, @code{srfi-151} - ビット演算

@deftp {Module} srfi-151
@mdindex srfi-151
@c EN
This module provides comprehensive bitwise operations.  It is mostly
a superset of srfi-60, with some change of names for the consistency
and the compatibility (@pxref{Integers as bits}).  We keep srfi-60 for
legacy code, while recommend this module to be used in the new code.

The following procedures are Gauche built-in.
@xref{Basic bitwise operations}, for the description.
@c JP
このモジュールは包括的なビット演算手続きを提供します。
ほぼsrfi-60のスーパーセットですが、いくつかの手続きは一貫性と互換性のために
名前が変わりました(srfi-60については@ref{Integers as bits}参照)。
srfi-60も以前のコードとの互換性のため残されますが、新たに書くコードは
このモジュールを使うことを推奨します。

以下の手続きはGauche組み込みになっています。
説明は@ref{Basic bitwise operations}を参照してください。
@c COMMON

@example
integer-length    copy-bit          bit-field
@end example
@end deftp

@c EN
@subheading Basic operations
@c JP
@subheading 基本演算
@c COMMON

@defun bitwise-not n
[SRFI-151]
@c MOD srfi-151
@c EN
Returns the bitwise complement of @var{n}.
Same as builtin @code{lognot} (@pxref{Basic bitwise operations}).
@c JP
@var{n}の各ビットを反転したものを返します。
組み込みの@code{lognot}と同じです。(@ref{Basic bitwise operations}参照)。
@c COMMON
@end defun

@defun bitwise-and n @dots{}
@defunx bitwise-ior n @dots{}
@defunx bitwise-xor n @dots{}
@defunx bitwise-eqv  n @dots{}
[SRFI-151]
@c MOD srfi-151
@c EN
When no arguments are given, these procedures returns @code{-1}, @code{0},
@code{0} and @code{-1}, respectively.  With one arguments, they return the
argument as is.  With two arguments, they return bitwise and, ior, xor,
and eqv (complement of xor).  With three or more arguments, they apply
binary operations associaively, that is,
@c JP
引数が与えられない場合、これらはそれぞれ@code{-1}、@code{0}、@code{0}、@code{-1}を
返します。引数がひとつの場合はそれをそのまま返します。
引数が二つの場合は、それらのビット毎のand、ior、xor、及びeqv (xorの論理反転) を
取ったものを返します。3引数以上は、2引数の計算から導かれます。
@c COMMON

@example
(bitwise-xor a b c)
 @equiv{} (bitwise-xor a (bitwise-xor b c))
 @equiv{} (bitwise-xor (bitwise-xor a b) c)
@end example

@c EN
Be careful that multi-argument @code{bitwise-eqv} does not produce
bit 1 everywhere that all the argument's bit agree.
@c JP
この定義では、3引数以上の@code{bitwise-eqv}は
「すべての引数の該当ビットが同じである時に1」とはならないことに注意してください。
@c COMMON

@c EN
The first three procedures are the same as built-in 
@code{logand}, @code{logior} and @code{logxor}, respectively
(@pxref{Basic bitwise operations}).
@c JP
最初の3つの手続きはそれぞれ組み込みの
@code{logand}、@code{logior}、@code{logxor}と同じです
(@ref{Basic bitwise operations}参照)。
@c COMMON
@end defun

@defun bitwise-nand n0 n1
@defunx bitwise-nor n0 n1
@defunx bitwise-andc1 n0 n1
@defunx bitwise-andc2 n0 n1
@defunx bitwise-orc1 n0 n1
@defunx bitwise-orc2 n0 n1
[SRFI-151]
@c MOD srfi-151
@c EN
These operations are not associative.
@c JP
これらの手続きは2引数固定です。
@c COMMON

@example
nand n0 n1   @equiv{}  (NOT (AND n0 n1))
nor n0 n1    @equiv{}  (NOT (OR n0 n1))
andc1 n0 n1  @equiv{}  (AND (NOT n0) n1)
andc2 n0 n1  @equiv{}  (AND n0 (NOT n1))
orc1 n0 n1   @equiv{}  (OR (NOT n0) n1)
orc2 n0 n1   @equiv{}  (OR n0 (NOT n1))
@end example
@end defun

@c EN
@subheading Integer operations
@c JP
@subheading 整数演算
@c COMMON

@defun arithmetic-shift n count
[SRFI-151]
@c MOD srfi-151
@c EN
Shift @var{n} for @var{count} bits to left; if @var{count} is negative,
it shifts @var{n} to right for @var{-count} bits.

Same as builtin @code{ash} (@pxref{Basic bitwise operations}).
@c JP
整数@var{n}を@var{count}ビット左シフトします。@var{count}が負ならば、
@code{n}は@var{-count}ビット右にシフトされることになります。

これは組み込みの@code{ash}と同じです(@ref{Basic bitwise operations}参照)。
@c COMMON
@end defun

@defun bit-count n
[SRFI-151]
@c MOD srfi-151
@c EN
If @var{n} is positive, returns the number of @code{1}'s in @var{n}.
If @var{n} is negative, returns the number of @code{0}'s in @var{n}.

Same as builtin @code{logcount} (@pxref{Basic bitwise operations}).
@c JP
@var{n}が正の場合は@var{n}中の@code{1}であるビットの数を、
@var{n}が負の場合は@var{n}中の@code{0}であるビットの数を返します。

組み込みの@code{logcount}と同じです(@ref{Basic bitwise operations}参照)。
@c COMMON
@end defun

@defun bitwise-if mask n0 n1
[SRFI-151]
@c MOD srfi-151
@c EN
Returns integer, whose @var{n}-th bit is taken as follows:
If the @var{n}-th bit of @var{mask} is 1, the @var{n}-th bit of @var{n0};
otherwise, the @var{n}-th bit of @var{n1}.
@c JP
整数を返します。戻り値の@var{n}番目のビットは、@var{mask}の@var{n}番目のビットが
1であれば@var{n0}の@code{n}番目のビット、0であれば@var{n1}の@code{n}番目のビット
になります。
@c COMMON

@example
(bitwise-if #b10101100 #b00110101 #b11001010)
 @result{} #b01100110
@end example
@end defun

@c EN
@subheading Single-bit operations
@c JP
@subheading 単一ビットの操作
@c COMMON

@defun bit-set? index n
[SRFI-151]
@c MOD srfi-151
@c EN
Returns @code{#t} or @code{#f} if @var{index}-th bit (counted from LSB)
of @var{n} is @code{1} or @code{0}, respectively.

Same as built-in @code{logbit?} (@pxref{Basic bitwise operations}).
@c JP
@var{n}のLSBから数えて@var{index}番目(0ベース)のビットが@code{1}であれば
@code{#t}を、@code{0}であれば@code{#f}を返します。

組み込みの@code{logbit?}と同じです(@ref{Basic bitwise operations}参照)。
@c COMMON
@end defun

@defun bit-swap index1 index2 n
[SRFI-151]
@c MOD srfi-151
@c EN
Returns an integer with @var{index1}-th bit and @var{index2}-th bit are
swapped.  Index is counted from LSB.
@c JP
@var{n}の@var{index1}番目のビットと@var{index2}番目のビットを入れ替えた整数を
返します。インデックスは0ベースでLSBから数えます。
@c COMMON
@end defun

@defun any-bit-set? mask n
@defunx every-bit-set? mask n
[SRFI-151]
@c MOD srfi-151
@c EN
Returns @code{#t} iff any/all bits set in @var{mask} are also set in @var{n}.

@code{any-bit-set?} is the same as built-in @code{logtest},
except @code{logtest} accepts one or more arguments
(@pxref{Basic bitwise operations}).
@c JP
@var{n}中で、@var{mask}でビットの立っている箇所のビットのいずれか(@code{any-bit-set?})
あるいはすべて(@code{every-bit-set?})が@code{1}であれば@code{#t}を返し、
それ以外では@code{#f}を返します。

@code{any-bit-set?}は組み込みの@code{logtest}とほぼ同じですが、
@code{logtest}は可変長引数です
(@ref{Basic bitwise operations}参照)。
@c COMMON
@end defun

@defun first-set-bit n
[SRFI-151]
@c MOD srfi-151
@c EN
Returns the number of factors of two of integer @var{n}; that is,
returns a maximum @code{k} such that @code{(expt 2 k)} divides
@var{n} without a remainder.
It is the same as the index of the least significant @code{1} in @var{n},
hence the alias @code{first-set-bit}.
@c JP
@var{n}を割り切る@code{(expt 2 k)}のうち最大のkを返します。別の言い方をすれば、
@var{n}のビット列のうち一番右にある@code{1}のインデックスを返します。
@code{first-set-bit}の名前はそこからきています。
@c COMMON

@example
(first-set-bit 0) @result{} -1   ; @r{edge case}
(first-set-bit 1) @result{} 0
(first-set-bit 2) @result{} 1
(first-set-bit 15) @result{} 0
(first-set-bit 16) @result{} 4
@end example

@c EN
This is equivalent to Gauche's built-in @code{twos-exponent-factor}
(@pxref{Basic bitwise operations}).
@c JP
これはGauche組み込みの@code{twos-exponent-factor}と同じです
(@ref{Basic bitwise operations}参照)。
@c COMMON
@end defun

@c EN
@subheading Bit field operations
@c JP
@subheading ビットフィールド操作
@c COMMON

@defun bit-field-any? n start end
@defunx bit-field-every? n start end
[SRFI-151]
@c MOD srfi-151
@c EN
Returns @code{#t} iff any/all bits of @var{n} from @var{start} (inclusive)
to @var{end} (exclusive) are set.
@c JP
@var{n}中の@var{start}ビット目(含む)から@var{end}ビット目(含まない)までの
ビットフィールドのうち、一つでもビットが立っていた場合(@code{bit-field-any?})、
あるいは全てのビットが立っていた場合(@code{bit-field-every?})に@code{#t}を、
それ以外に@code{#f}を返します。
@c COMMON
@end defun

@defun bit-field-clear n start end
@defunx bit-field-set n start end
[SRFI-151]
@c MOD srfi-151
@c EN
Returns @var{n} with the bits from @var{start} (inclusive)
to @var{end} (exclusive) are set to all @code{0}'s/@code{1}'s.
@c JP
@var{n}中の@var{start}ビット目(含む)から@var{end}ビット目(含まない)までの
ビットを全て@code{0}あるいは@code{1}にした整数値を返します。
@c COMMON
@end defun

@defun bit-field-replace dst src start end
[SRFI-151]
@c MOD srfi-151
@c EN
Returns @var{dst} with the bitfield from @var{start} to @var{end}
are replaced with the least-significant (@var{end}-@var{start}) bits
of @var{src.}
@c JP
@var{dst}中の@var{start}ビット目(含む)から@var{end}ビット目(含まない)までの
ビットフィールドを、@var{src}中の下位(@var{end}-@var{start})ビットで置き換えた
値を返します。
@c COMMON

@example
(bit-field-replace #b101010 #b010 1 4) @result{} #b100100
@end example

@c EN
Same as built-in @code{copy-bit-field} (@pxref{Basic bitwise operations}).
@c JP
組み込みの@code{copy-bit-field}と同じです(@ref{Basic bitwise operations}参照)。
@c COMMON
@end defun

@defun bit-field-replace-same dst src start end
[SRFI-151]
@c MOD srfi-151
@c EN
Returns @var{dst} with the bitfield from @var{start} to @var{end}
are replaced with the @code{src}'s bitfield from @var{start} to @var{end}.
@c JP
@var{dst}中の@var{start}ビット目(含む)から@var{end}ビット目(含まない)までの
ビットフィールドを、
@var{src}中の同じ位置にあるビットフィールドに置き換えた値を返します。
@c COMMON

@example
(bit-field-replace-same #b111111 #b100100 1 4) @result{} #b110101
@end example
@end defun

@defun bit-field-rotate n count start end
[SRFI-151]
@c MOD srfi-151
@c EN
Rotate the region of @var{n} between @var{start}-th bit (inclusive) and
@var{end}-th bit (exclusive) by @var{count} bits to the left.
If @var{count} is negative, it rotates to the right by @var{-count}
bits.
@c JP
@var{n}中の@var{start}ビット目(含む)から@var{end}ビット目(含まない)までの
ビットフィールドを、@var{count}ビットだけ左にローテートした値を返します。
@var{count}が負の場合は@var{-count}ビットだけ右にローテートします。
@c COMMON

@example
(bit-field-rotate #b110100100010000 -1 5 9)
 @result{} 26768 ;#b110100010010000

(bit-field-rotate #b110100100010000 1 5 9)
 @result{} 26672 ;#b110100000110000
@end example
@end defun

@defun bit-field-reverse n start end
[SRFI-151]
@c MOD srfi-151
@c EN
Reverse the order of bits of @var{n} between @var{start}-th bit
(inclusive) and @var{end}-th bit (exclusive).
@c JP
@var{n}中の@var{start}ビット目(含む)から@var{end}ビット目(含まない)までの
ビットフィールドを逆順にしたものを返します。
@c COMMON

@example
(bit-field-reverse #b10100111 0 8)
 @result{} 229 ; #b11100101
@end example
@end defun

@c EN
@subheading Bits conversion
@c JP
@subheading ビット変換
@c COMMON

@defun bits->list n :optional len
@defunx bits->vector n :optional len
[SRFI-151]
@c MOD srfi-151
@c EN
Returns a list/vector of booleans of length @var{len},
corresponding to each bit in non-negative integer @var{n}, LSB-first.
When @var{len} is omitted, @code{(integer-length n)} is used.
@c JP
非負整数@var{n}を、長さ@var{len}の真偽値からなるリストまたはベクタにして返します。
ビットはLSBから順に取り出されます。@var{len}が省略された場合は
@code{(integer-length n)}が使われます。
@c COMMON

@example
(bits->vector #b101101110)
  @result{} #(#f #t #t #t #f #t #t #f #t)
@end example

@c EN
Note: Srfi-60 has a similar @code{integer->list}, but the order of
bits is reversed.
@c JP
註: srfi-60には@code{integer->list}という似た手続きがありますが、
ビットの順番が逆です。
@c COMMON
@end defun

@defun list->bits bool-list
@defunx vector->bits bool-vector
[SRFI-151]
@c MOD srfi-151
@c EN
Returns an exact integer formed from boolean values in given list/vector,
LSB first.  The result will never be negative.
@c JP
真偽値のリストまたはベクタを受け取り、
LSBから対応するビットを詰めた正確な整数を返します。
返り値は負になることはありません。
@c COMMON

@example
(list->bits '(#f #t #t #t #f #t #t #f #t))
 @result{} #b101101110
@end example

@c EN
Note: Srfi-60 has a similar @code{list->integer}, but the order of
bits is reversed.
@c JP
註: srfi-60には@code{list->integer}という似た手続きがありますが、
ビットの順番が逆です。
@c COMMON
@end defun

@defun bits bool @dots{}
[SRFI-151]
@c MOD srfi-151
@c EN
Returns the integer coded by @var{bool}s, LSB first.
The result will never be negative.
@c JP
真偽値@var{bool}の列をLSBから順にビットとして詰めた整数を返します。
返り値は負になることはありません。
@c COMMON

@example
(bits #f #t #t #t #f #t #t #f #t)
 @result{} #b101101110
@end example

@c EN
Note: Srfi-60 has a similar @code{booleans->integer}, but the order of
bits is reversed.
@c JP
註: srfi-60には@code{booleans->integer}という似た手続きがありますが、
ビットの順番が逆です。
@c COMMON
@end defun

@c EN
@subheading Fold, unfold and generate
@c JP
@subheading Foldとunfoldとgenerate
@c COMMON

@defun bitwise-fold kons knil n
[SRFI-151]
@c MOD srfi-151
@c EN
Traverse bits in integer @var{n} from LSB to the @code{(integer-length n)} bit,
applying @code{kons} on the bit as boolean
and the seed value, whose initial value
is given by @var{knil}.  Returns the last result of @var{kons}.
@c JP
整数@var{n}のビットを、LSBから@code{(integer-length n)}ビット分、順に調べ、
各ビットを真偽値とみなした値とシード値に@var{kons}を適用してゆきます。
@var{kons}の戻り値が次のシード値となり、最後の@var{kons}の結果が返されます。
@c COMMON

@example
(bitwise-fold cons '() #b10110111)
 @result{} (#t #f #t #t #f #t #t #t)
@end example
@end defun

@defun bitwise-for-each proc n
[SRFI-151]
@c MOD srfi-151
@c EN
Applies @var{proc} to the bit as boolean in @var{n}, from LSB to
the @code{(integer-length n)} bit.  The result is discarded.
@c JP
整数@var{n}の各ビットを真偽値とみなした値に対して、
LSBから順に@code{(integer-length n)}ビット分、@var{proc}を適用してゆきます。
@var{proc}の結果は捨てられます。
@c COMMON
@end defun

@defun bitwise-unfold p f g seed
[SRFI-151]
@c MOD srfi-151
@c EN
Generates a non-negative integer bit by bit, from LSB to MSB.
The @var{seed} gives the initial state value.
For each iteration, @var{p} is applied to the current state value,
and if it returns a true value, the iteration ends and @code{bitwise-unfold}
returns the accumulated bits as an integer.
Otherwise, @var{f} is applied to the current state value, and
its result, coerced to a boolean value, determines the bit value.
Then @var{g} is applied to the current state value to produce
the next state value of the next iteration.
@c JP
非負整数をLSBから順に1ビットづつ生成します。
@var{seed}は状態の値の初期値を与えます。
各繰り返しにおいて、@var{p}が現在の状態の値に適用され、
その結果が真ならば繰り返しは終了し@code{bitwise-unfold}は蓄積されたビットを整数として
返します。
そうでなければ、@var{f}が現在の状態の値に適用され、
その結果が真の値なら対応するビットが1に、偽なら0になります。
次いで@var{g}が現在の状態の値に適用され、その結果が次の繰り返しにおける状態の値となります。
@c COMMON

@c EN
The following expression produces a bitfield of width 100, where n-th bit
indicates whether n is prime or not:
@c JP
次の式は、nビット目が、nが素数なら1になっているような100ビット長の整数を返します。
@c COMMON

@example
(use math.prime)
(bitwise-unfold (cut = 100 <>)
                small-prime?
                (cut + 1 <>)
                0)
@end example
@end defun

@defun make-bitwise-generator n
[SRFI-151]
@c MOD srfi-151
@c EN
Returns a generator that generates boolean values
corresponding to the bits in @var{n}, LSB-first.  The returned generator
is infinite.

This is similar to @code{bits->generator} in @code{gauche.generator},
except that the generator created by it stops at the integer
length of @var{n} (@pxref{Generators}).
@c JP
整数nの各ビットをLSBから順に真偽値として生成するようなジェネレータを作って返します。
返されるジェネレータは無限です。

これは@code{gauche.integer}の@code{bits->generator}と似ていますが、
@code{bits->generator}が作るジェネレータの方は@var{n}の@code{integer-length}で止まります。
詳しくは@ref{Generators}を参照してください。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node String library (reduced), Generators and accumulators, Bitwise operations, Library modules - SRFIs
@section @code{srfi-152} - String library (reduced)
@c NODE 文字列ライブラリ(簡略版), @code{srfi-152} - 文字列ライブラリ(簡略版)

@deftp {Module} srfi-152
@mdindex srfi-152
@c EN
This is an improved version of @code{srfi-13}.  The spec is actually smaller
than srfi-13 (hence 'reduced' in the title) by removing bells and whistles.
The consistency with R7RS and recent srfis are also considered.

The following are built-in.  @xref{Strings}, for the details.
@c JP
これは@code{srfi-13}の改良版です。
@code{srfi-13}から余分なものを取り除き、R7RSや最近のsrfiとの一貫性を
改善したもので、実際は@code{srfi-13}より小さくなっています。

以下に示す手続きは組み込みです。詳しくは@ref{Strings}を参照してください。
@c COMMON

@example
string?            make-string        string             string-length
string->vector     string->list       vector->string     list->string
string-ref         string-set!        substring          string-copy
string=?           string<?           string<=?          string>?
string>=?          string-append      string-join        string-split
read-string        write-string       string-fill!
@end example

@c EN
The following procedures are defined to use Unicode string case folding,
and @code{gauche.unicode} module provides them.
@xref{Full string case conversion}, for the details.
Note that Gauche's
built-in versions uses character-wise case folding, which differs
from string case folding on some characters (German eszett, for example).
@c JP
以下に示す手続きはUnicodeの文字列の大文字小文字変換を使うように定義されていて、
元は@code{gauche.unicode}で提供されています。
説明は@ref{Full string case conversion}を参照してください。
Gaucheの組み込みにも同名の手続きがありますが、それらは文字ごとに
大文字小文字変換を行うので、文字列としての大文字小文字変換とは異なります
(ドイツ語のエスツェット等)。
@c COMMON

@example
string-ci=?   string-ci<?   string-ci<=?  string-ci>?   string-ci>=?
@end example

@c EN
The following procedures are defined in srfi-13.  @xref{String library},
for the details.  Note: Some of those procedures in srfi-13 that require
predicate allows a char-set or a character to be passed instead
(e.g. @code{string-filter}).  In srfi-152, only predicate is allowed.
Our srfi-152 implementation shares the same procedure with srfi-13, so
they accept the same arguments as srfi-13's, but such code won't be
portable as srfi-152.
@c JP
以下に示す手続きはsrfi-13で定義されています。
説明は@ref{String library}を参照してください。
srfi-13ではこれらの手続きのいくつかは、述語引数として手続きだけでなく文字セットや
文字を取ることができます(例: @code{string-filter})。
srfi-152では手続きしか許していません。Gaucheの実装ではこれらの手続きは
srfi-13のものと同じなのでsrfi-13のような使い方ができますが、
srfi-152として移植性のあるコードを書く際には手続きだけを渡すように気をつけてください。
@c COMMON

@example
string-null?       string-any         string-every       string-tabulate
string-unfold      string-unfold-right      reverse-list->string
string-take        string-drop        string-take-right  string-drop-right
string-pad         string-pad-right   string-trim        string-trim-right
string-trim-both   string-replace     string-prefix-length string-suffix-length
string-prefix?     string-suffix?     string-innex       string-index-right
string-skip        string-skip-right  string-contains    string-concatenate
string-concatenate-reverse            string-fold        string-fold-right
string-count       string-filter      string-copy!
@end example

@c EN
The following procedures are the same with the ones in
R7RS @code{scheme.base} module (@pxref{R7RS base library}).
Note that srfi-13 defines different procedures with the same name.
@c JP
次の手続きはR7RS @code{scheme.base}モジュールにあるものと同じです。
srfi-13に同名の手続きがありますが異なるので注意してください。
@c COMMON

@example
string-map         string-for-each
@end example
@end deftp

@c EN
We describe procedures unique to this module below.
@c JP
以降では、srfi-152特有の手続きについて説明します。
@c COMMON

@defun string-remove pred string :optional start end
[SRFI-152]
@c MOD srfi-152
@c EN
Returns a substring of @var{string} between @var{start} and @var{end},
except characters that satisfy @var{pred}.   In other words,
it is @code{(string-filter (complement pred) string start end)}.

This is called @var{string-delete} in @code{srfi-13}.  Being changed
to take only a predicate (but not a character), it is renamed for
the consistency of other srfi (e.g. @code{filter}, @code{remove} and
@code{delete} in srfi-1.)
@c JP
@var{string}の@var{start}と@var{end}インデックス間から、
述語@var{pred}を満たす文字を除いた部分文字列を返します。
@code{(string-filter (complement pred) string start end)}と同じです。

これは@code{srfi-13}で@var{string-delete}と呼ばれていた手続きに相当します。
第一引数に述語手続きだけを取るようにし、また他のsrfiとの一貫性を重視して
名前が変えられました(例えばsrfi-1の@code{filter}、@code{remove}、@code{delete}の
関係を考えてください)。
@c COMMON

@example
(string-remove char-whitespace?
               "Quick fox jumps over the lazy dog"
               3 22)
 @result{} "ckfoxjumpsovert"
@end example
@end defun

@defun string-replicate string from to :optional start end
[SRFI-152]
@c MOD srfi-152
@c EN
Extended substring.  It is called @code{xsubstring} in srfi-13, but
renamed for the consistency.

Extract a substring of @var{string} between @var{start} and @var{end},
and conceptually create a bidirectional infinite string by repeating
the substring to both direction.  For example, suppose @var{string}
is @code{"abcde"}, @var{start} is 1, and @var{end} is 4.  So we repeat
the substring @code{"bcd"}, with one @code{b} falling on the index zero:
@c JP
拡張版substringです。srfi-13では@code{xsubstring}と呼ばれていましたが、
一貫性のため名前が変えられました。

@var{string}のインデックス@var{start}から@var{end}までの部分文字列をとり、
それを両側に無限に繰り返した文字悦を考えます。
例えば@var{string}が@code{"abcde"}であり、@var{start}が1、@var{end}が4なら、
@code{"bcd"}が無限に繰り替えされた文字列を考えます。この文字列がソース文字列となります。
@code{b}がインデックスの起点です。
@c COMMON

@example
... b  c  d  b  c  d  b  c  d  b  c  d  b ... 
   -6 -5 -4 -3 -2 -1  0  1  2  3  4  5  6
@end example

@c EN
Then we extract a substring between @var{from} and @var{to}
out of this infinite string.
@c JP
このソース文字列から、インデックス@var{from}と@var{to}の間の部分文字列を取り出し返します。
@c COMMON

@example
(string-replicate "abcde" 2 10 1 4)
  @result{} "dbcdbcdb"
(string-replicate "abcde" -5 -3 1 4)
  @result{} "cdbcdbcd"
@end example
@end defun

@defun string-segment string k
[SRFI-152]
@c MOD srfi-152
@c EN
Splits @var{string} by every @var{k} characters and returns
a list of those strings.  The last string may be shorter than @var{k}.
@c JP
@var{string}を@var{k}文字ごとに分割して、そのリストを返します。
最後の文字列は@var{k}文字より短いかもしれません。
@c COMMON

@example
(string-segment "abcdefghijklmn" 3)
 @result{} ("abc" "def" "ghi" "jkl" "mn")
@end example

@c EN
We have a similar procedure on lists, @code{slices}
(@pxref{List accessors and modifiers}).
@c JP
類似の手続きとして、@code{slices}があります。
(@ref{List accessors and modifiers}参照)。
@c COMMON
@end defun

@defun string-contains-right string1 string2 :optional start1 end1 start2 end2
[SRFI-152]
@c MOD srfi-152
@c EN
Like @code{string-contains}, looks for a needle @var{string2} from
a haystack @var{string1}, but if it is found, returns the start index
of the @emph{last} match, instead of the first match.  The returned index
is in @var{string1}.  The optional arguments limit the range of a needle
and a haystack.  If a needle isn't found, @var{#f} is returned.

An edge case: If a needle is empty (e.g. @var{string2} is empty,
or @var{start2} = @var{end2}), it always matches right after the haystack,
so @var{end1} is returned.
@c JP
@code{string-contains}と同様、
ソース文字列@var{string1}から探索文字列@var{string2}を探しますが、
見つかった場合は最初ではなく最後のマッチの開始インデックスを返します。
開始インデックスは@var{string1}に対するものです。
省略可能引数は@var{string1}、@var{string2}それぞれの対象とする文字列を制限します。
探索文字列@var{string2}が見つからなかった場合は@var{#f}が返されます。

エッジケースとして、探索文字列が空文字列の場合 (@var{string2}が空であるとか、
@var{start2} = @var{end2}である場合)は、
それは常にソース文字列の一番右端とマッチします。つまり@var{end1}が戻り値になります。
@c COMMON

@example
(string-contains-right "Little Lisper" "Li")
  @result{} 7
@end example
@end defun

@defun string-take-while string pred :optional start end
@defunx string-take-while-right string pred :optional start end
[SRFI-152]
@c MOD srfi-152
@c EN
Returns the longest prefix or suffix of @var{string} in which all characters
satisfy @var{pred}.

Note: The order of @var{pred} and the source object is different from
other @code{take-while}-style procedures, such as @code{take-while}
(@ref{R7RS lists}), @code{ideque-take-while} (@ref{R7RS immutable deques}),
and @code{lseq-take-while} (@ref{R7RS lazy sequences}).
@c JP
@var{string}から、全ての文字が述語@var{pred}を満たすような最長のプレフィクスまたは
サフィックスを返します。

註: @var{pred}引数と対象とするオブジェクトの順序が、
他の@code{take-while}系手続き、
@code{take-while}(@ref{R7RS lists})、
@code{ideque-take-while} (@ref{R7RS immutable deques})、
@code{lseq-take-while} (@ref{R7RS lazy sequences})等とは逆であることに
注意してください。
@c COMMON
@end defun

@defun string-drop-while string pred :optional start end
@defunx string-drop-while-right string pred :optional start end
[SRFI-152]
@c MOD srfi-152
@c EN
Returns the longest prefix or suffix of @var{string} in which all characters
does not satisfy @var{pred}.

Note: The order of @var{pred} and the source object is different from
other @code{drop-while}-style procedures, such as @code{drop-while}
(@ref{R7RS lists}), @code{ideque-drop-while} (@ref{R7RS immutable deques}),
and @code{lseq-drop-while} (@ref{R7RS lazy sequences}).
@c JP
@var{string}から、全ての文字が述語@var{pred}を満たさないような最長のプレフィクスまたは
サフィックスを返します。

註: @var{pred}引数と対象とするオブジェクトの順序が、
他の@code{drop-while}系手続き、
@code{drop-while}(@ref{R7RS lists})、
@code{ideque-drop-while} (@ref{R7RS immutable deques})、
@code{lseq-drop-while} (@ref{R7RS lazy sequences})等とは逆であることに
注意してください。
@c COMMON
@end defun

@defun string-span string pred :optional start end
@defunx string-break string pred :optional start end
[SRFI-152]
@c MOD srfi-152
@c EN
Find the longest prefix of @var{string} between @var{start} and @var{end}
in which all characters satisy / do not satisfy @var{pred}, and returns
the prefix and the rest of substring as two values.
@c JP
@var{string}の@var{start}から@var{end}までの範囲のうち、
全ての文字が述語@var{pred}を満たす、あるいは満たさないような最長のプレフィクスをみつけ、
そのプレフィクスと、残りの部分文字列を二つの値として返します。
@c COMMON

@example
(string-break "foo@@example.com" (cut eqv? <> #\@@))
 @result{} "foo" @r{and} "@@example.com"

(string-break "foo@@example.com" (cut eqv? <> #\@@) 1 10)
 @result{} "oo" "@@exampl"

@c EN
;; This is Gauche specific - a char-set can work as a predicate:
@c JP
;; Gaucheでは文字セットを述語手続きとしても使える
@c COMMON
(string-span "VAR_1 = $VAR_2" #[\w])
 @result{} "VAR_1" @r{and} " = $VAR_2"
@end example

@c EN
Note: The order of @var{pred} and the source object is different from
@code{span} and @code{break} in @code{scheme.list}
(@pxref{R7RS lists}).
@c JP
@var{pred}引数とソースオブジェクトの順が、
@code{scheme.list}の@code{span}、@code{break}と逆であることに注意
(@ref{R7RS lists}参照)。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Generators and accumulators,  , String library (reduced), Library modules - SRFIs
@section @code{srfi-158} - Generators and accumulators
@c NODE ジェネレータとアキュムレータ, @code{srfi-158} - ジェネレータとアキュムレータ

@deftp {Module} srfi-158
@mdindex srfi-158
@c EN
This is an enhanced (and upward compatible)
version of @code{srfi-121} Generators.
In Gauche, all generator procedures are the same as
provided in @code{gauche.generator}
(@pxref{Generators}).
@c JP
これは@code{srfi-121}ジェネレータの上位互換な拡張版です。
Gaucheでは、以下に示す全てのジェネレータ手続きは
@code{gauche.generator}で提供されるものと同じです
(@ref{Generators}参照)。
@c COMMON

@example
generator                circular-generator       make-iota-generator
make-range-generator     make-coroutine-generator
list->generator          vector->generator        reverse-vector->generator
string->generator        bytevector->generator
make-for-each-generator  make-unfold-generator
gcons*                   gappend                  gflatten
ggroup                   gmerge                   gmap
gcombine                 gfilter                  gremove
gstate-filter            ggroup                   generator-map->list
gtake                    gdrop                    gtake-while
gdrop-while              gdelete                  gdelete-neighbor-dups
gindex                   gselect                  generator->list
generator->reverse-list  generator-map->list      generator->vector
generator->vector!       generator->string        generator-fold
generator-for-each       generator-find           generator-count
generator-any            generator-every          generator-unfold
@end example

@c EN
Accumulators are opposite of generators.  They are procedures
that work as consumers.  An accumulator takes one argument.
When non-eof value is given, the value is stored, and when EOF
is given, the accumulated value is returned.
How the values are accumulated depends on the accumulator.
@c JP
アキュムレータはジェネレータの反対で、値を消費する手続きと考えられます。
アキュムレータは一つの引数を取ります。EOF以外の値が与えられた場合は、
それが内部に何らかの形で蓄えられ、EOFが与えられた場合、
蓄えられた値が返されます。
どのように値が蓄えられるかは各アキュムレータに依存します。
@c COMMON

@c EN
Once EOF is given, the accumulator is ``finalized''.  Subsequent
EOF makes it return the same accumulated value.  It is undefined
if other values are passed after EOF is passed.
@c JP
一度EOFが与えられると、アキュムレータは終了状態になります。
その後何度EOFが与えられても同じ蓄積結果を返します。
終了状態になったアキュムレータにEOF以外の値を与えた場合の動作は未定義です。
@c COMMON

@c EN
The accumulator can be used to parameterize procedures that yield
aggregate objects.  Consider the following procedure, which
takes items from two generators and accumulate them alternatively.
(Note that @code{glet*} is Gauche's procedure but not in srfi-158).
@c JP
アキュムレータは、複合的なオブジェクトを生成する手続きで、
実際に生成される値の型をパラメタライズするのに使えます。
次の手続きを見てみましょう。これは二つのジェネレータから交互に値を取り、
それを蓄積して返す手続きです。
(@code{glet*}はGaucheの手続きですがsrfi-158には含まれていません。)
@c COMMON

@example
(define (intertwine acc gen1 gen2)
  (let loop ()
    (glet* ([a (gen1)]
            [b (gen2)])
      (acc a)
      (acc b)
      (loop)))
  (acc (eof-object)))
@end example

@c EN
The procedure can return various type of collections, without
knowing the actual type---the passed accumulator determines it.
@c JP
この手続きは具体的に返される値が何かは関知しません。
それは引数に与えられたアキュムレータにより決定されます。
@c COMMON

@example
(intertwine (list-accumulator) (giota 5) (giota 5 100))
  @result{} (0 100 1 101 2 102 3 103 4 104)
(intertwine (vector-accumulator) (giota 5) (giota 5 100))
  @result{} #(0 100 1 101 2 102 3 103 4 104)
(intertwine (bytevector-accumulator) (giota 5) (giota 5 100))
  @result{} #u8(0 100 1 101 2 102 3 103 4 104)
@end example

@c EN
Note: In Gauche, you can also use classes to parameterize returned
container types (e.g. @code{map-to}),
for many collection classes support @emph{builder protocol}.
@xref{Collection framework}, for the details.
Accumulator has the flexibility that you can provide more than one
ways to construct return value on the same type (e.g. forward and reverse
list).
@c JP
註: Gaucheでは、クラスを使うことで戻り値となるコンテナの型をパラメタライズできます
(例: @code{map-to})。これは多くのコレクションクラスが@emph{builderプロトコル}を
サポートしているからです。詳しくは@ref{Collection framework}を見てください。
アキュムレータの利点は、同じ型の戻り値についても、異なる値の蓄積方法
(例えばリストを順に蓄積するか逆順に蓄積するか、等)を提供できることです。
@c COMMON
@end deftp

@defun make-accumulator kons knil finalizer
[SRFI-158]
@c MOD srfi-158
@c EN
Creates and returns an accumulator with a state,
whose initial value is @var{knil}.
When non-EOF value @var{v} is passed to the accumulator,
@var{kons} is called as @code{(kons v state)}, and its result
becomes the new state value.  When EOF value is passed,
@code{(finalizer state)} is called and its result becomes
the result of accumulator.
@c JP
内部状態をひとつ持つアキュムレータを作って返します。
状態は@var{khil}で初期化されます。
EOFでない値@var{v}がアキュムレータに与えられる度に、手続き@var{kons}が
@code{(kons v state)}と呼ばれ、その戻り値が新たな状態となります。
EOFがアキュムレータに渡されると、@code{(finalizer state)}が呼ばれ、
その結果がアキュムレータの戻り値となります。
@c COMMON
@end defun

@defun list-accumulator
@defunx reverse-list-accumulator
[SRFI-158]
@c MOD srfi-158
@c EN
Creates and returns accumulators that return accumulated value
as a list, in the accumulated order (@code{list-accumulator})
or the reverse order (@code{reverse-list-accumulator}).
@c JP
蓄積された値をリストとして返すアキュムレータを作って返します。
@code{list-accumulator}ではリストは与えられた順に、
@code{reverse-list-accumulator}では逆順になります。
@c COMMON
@end defun

@defun vector-accumulator
@defunx reverse-vector-accumulator
@defunx bytevector-accumulator
[SRFI-158]
@c MOD srfi-158
@c EN
Returns accumulators that return accumulated value
as a fresh vector or bytevector (u8vector),
in the accumulated order (@code{vector-accumulator},
@code{bytevector-accumulator})
or the reverse order (@code{reverse-vector-accumulator}).
There's no @code{reverse-bytevector-accumulator}.
@c JP
蓄積された値をベクタあるいはバイトベクタ(u8vector)として返すアキュムレータを
作って返します。@code{vector-accumulator}と
@code{bytevector-accumulator}では値は先頭から順に、
@code{reverse-vector-accumulator}ではベクタの最後から逆順に詰められます。
@code{reverse-bytevector-accumulator}はありません。
@c COMMON
@end defun

@defun vector-accumulator! vec at
@defunx bytevector-accumulator! bvec at
[SRFI-158]
@c MOD srfi-158
@c EN
The @var{vec} or @var{bvec} argument is a mutable vector or
bytevector (u8vector), and is used as a buffer.

Returns an accumlator that stores the accumulated values in the
buffer, starting from the index @var{at}.
It is an error if the accumulator gets more values after
the buffer reaches at the end.

Once EOF is passed to the accumulator, @var{vec} or @var{bvec}
is returned, respectively.
@c JP
@var{vec}と@var{bvec}はそれぞれ変更可能なベクタとバイトベクタ(u8vector)です。
この引数はバッファとして使われます。

与えられた値を、バッファのインデックス@var{at}から順に格納してゆくアキュムレータを
作って返します。バッファの最後を越えて値を格納しようとした場合はエラーになります。

EOFが与えられたら、@var{vec}または@var{bvec}をそのまま返します。
@c COMMON
@end defun

@defun string-accumulator
[SRFI-158]
@c MOD srfi-158
@c EN
Returns an accumulator that accepts characters and accumulates
them to a string.
@c JP
文字を受け取り、それを蓄積して最後に文字列として返すアキュムレータを生成して返します。
@c COMMON
@end defun

@defun sum-accumulator
@defunx product-accumulator
@defunx count-accumulator
[SRFI-158]
@c MOD srfi-158
@c EN
Returns accumulators that yield a scalar value.

The accumulator created by @code{sum-accumulator} and
@code{product-accumulator} accepts numbers,
and keep adding or multiplying it with the accumulated value
(the default value is 0 and 1, respectively).

The accumulator created by @code{count-accumulator} accepts any
objects and just counting it.
@c JP
スカラー値を生成するアキュムレータを作って返します。

@code{sum-accumulator}と@code{product-accumulator}で作られた
アキュムレータはそれぞれ、
数値を受け取り、それを蓄積された値に加算または乗算してゆきます。
値の初期値はそれぞれ0と1です。

@code{count-accumulator}で作られたアキュムレータは
任意のオブジェクトを受け取ります。
EOFを受け取ったらそれまで受け取ったオブジェクトの数を返します。
@c COMMON
@end defun

@c Local variables:
@c mode: texinfo
@c coding: utf-8
@c end:

