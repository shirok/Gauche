;;;
;;; gauche.uvector - uniform vectors
;;;
;;;   Copyright (c) 2000-2015  Shiro Kawai  <shiro@acm.org>
;;;
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;

;; This module defines the superset of SRFI-4, homogeneous numeric vector
;; types.   Most of basic operations are defined in the DSO module libuvector.
;; Besides defining functions, the DSO sets up a reader hook to enable
;; extended syntax such as #s8(1 2 3).
;; This module also defines methods for collection and sequence frameworks.

(define-module gauche.uvector
  (use gauche.collection)
  (use gauche.sequence)
  (use data.queue)
  (export-all)
  )
(select-module gauche.uvector)

(inline-stub
 "#include <math.h>"
 "#define EXTUVECTOR_EXPORTS"
 "#include \"gauche/uvector.h\""
 "#include \"uvectorP.h\""

 (define-cfn clamp-arg (clamp) ::int :static
   (cond [(SCM_EQ clamp 'both) (return SCM_CLAMP_BOTH)]
         [(SCM_EQ clamp 'low)  (return SCM_CLAMP_LO)]
         [(SCM_EQ clamp 'high) (return SCM_CLAMP_HI)]
         [(not (or (SCM_FALSEP clamp) (SCM_UNBOUNDP clamp)))
          (Scm_Error "clamp argument must be either 'both, 'high, 'low or #f, \
                    but got %S" clamp)])
   (return SCM_CLAMP_ERROR)))

;; uvlib.scm is generated by uvlib.scm.tmpl
(inline-stub
 (include "./uvlib.scm")
 )

;;-------------------------------------------------------------
;; Experimental - compile-time inlining *-ref
;; The TYPE constant must be in sync with ScmUVectorType in gauche/vector.h

(define-inline %uvector-ref (with-module gauche.internal %uvector-ref))

(define-macro (set-reference-inliner ref type)
  `(define-compiler-macro ,ref
     (er-transformer
      (^[x r c] (if (= (length x) 3)
                  (list (r '%uvector-ref) (cadr x) ,type (caddr x))
                  x)))))

(set-reference-inliner s8vector-ref 0)
(set-reference-inliner u8vector-ref 1)
(set-reference-inliner s16vector-ref 2)
(set-reference-inliner u16vector-ref 3)
(set-reference-inliner s32vector-ref 4)
(set-reference-inliner u32vector-ref 5)
(set-reference-inliner s64vector-ref 6)
(set-reference-inliner u64vector-ref 7)
(set-reference-inliner f16vector-ref 8)
(set-reference-inliner f32vector-ref 9)
(set-reference-inliner f64vector-ref 10)


;;;
;;; Generic procedures
;;;

;; uvector-alias
(inline-stub
 (define-cproc uvector-alias
   (klass::<class> v::<uvector> :optional (start::<int> 0) (end::<int> -1))
   Scm_UVectorAlias)
 )

;; byte swapping
(inline-stub
 (define-cise-stmt swap-bytes-common
   [(_ c-fn v type)
    `(let* ([opt::int SWAPB_STD])
       (cond [(== ,type NULL)]
             [(SCM_EQ (SCM_OBJ ,type) 'le:arm-le) (= opt SWAPB_ARM_LE)]
             [(SCM_EQ (SCM_OBJ ,type) 'be:arm-le) (= opt SWAPB_ARM_BE)]
             [else (Scm_TypeError "type" "#f or a symbol le:arm-le or be:arm-le"
                                  (SCM_OBJ ,type))])
       (,c-fn ,v opt))])

 (define-cproc uvector-swap-bytes (v::<uvector> :optional (type::<symbol>? #f)) ::<void>
   (swap-bytes-common Scm_UVectorSwapBytes v type))

 (define-cproc uvector-swap-bytes! (v::<uvector> :optional (type::<symbol>? #f)) ::<void>
   (swap-bytes-common Scm_UVectorSwapBytesX v type))
 )

;; uvector-size
(inline-stub
 (define-cproc uvector-size (v::<uvector>
                             :optional (start::<int> 0) (end::<int> -1))
   ::<int>
   (let* ([len::int (SCM_UVECTOR_SIZE v)])
     (SCM_CHECK_START_END start end len)
     (return (* (- end start)
                (Scm_UVectorElementSize (Scm_ClassOf (SCM_OBJ v)))))))

 (define-cproc uvector-class-element-size (c::<class>) ::<fixnum>
   (let* ([r::int (Scm_UVectorElementSize c)])
     (when (< r 0)
       (Scm_Error "A class of uvector is required, but got: %S" c))
     (return r)))
 )

;; allocation by class
(inline-stub
 (define-cproc make-uvector (klass::<class> size::<fixnum>
                             :optional (init 0))
   (unless (>= size 0) (Scm_Error "invalid uvector size: %d" size))
   (let* ([v (Scm_MakeUVector klass size NULL)])
     (case (Scm_UVectorType klass)
       [(SCM_UVECTOR_S8)
        (Scm_S8VectorFill (SCM_S8VECTOR v) 
                          (Scm_GetInteger8Clamp init SCM_CLAMP_ERROR NULL)
                          0 -1)]
       [(SCM_UVECTOR_U8)
        (Scm_U8VectorFill (SCM_U8VECTOR v) 
                          (Scm_GetIntegerU8Clamp init SCM_CLAMP_ERROR NULL)
                          0 -1)]
       [(SCM_UVECTOR_S16)
        (Scm_S16VectorFill (SCM_S16VECTOR v) 
                           (Scm_GetInteger16Clamp init SCM_CLAMP_ERROR NULL)
                           0 -1)]
       [(SCM_UVECTOR_U16)
        (Scm_U16VectorFill (SCM_U16VECTOR v) 
                           (Scm_GetIntegerU16Clamp init SCM_CLAMP_ERROR NULL)
                           0 -1)]
       [(SCM_UVECTOR_S32)
        (Scm_S32VectorFill (SCM_S32VECTOR v) 
                           (Scm_GetInteger32Clamp init SCM_CLAMP_ERROR NULL)
                           0 -1)]
       [(SCM_UVECTOR_U32)
        (Scm_U32VectorFill (SCM_U32VECTOR v) 
                           (Scm_GetIntegerU32Clamp init SCM_CLAMP_ERROR NULL)
                           0 -1)]
       [(SCM_UVECTOR_S64)
        (Scm_S64VectorFill (SCM_S64VECTOR v) 
                           (Scm_GetInteger64Clamp init SCM_CLAMP_ERROR NULL)
                           0 -1)]
       [(SCM_UVECTOR_U64)
        (Scm_U64VectorFill (SCM_U64VECTOR v) 
                           (Scm_GetIntegerU64Clamp init SCM_CLAMP_ERROR NULL)
                           0 -1)]
       [(SCM_UVECTOR_F16)
        (Scm_F16VectorFill (SCM_F16VECTOR v)
                           (Scm_DoubleToHalf (Scm_GetDouble init))
                           0 -1)]
       [(SCM_UVECTOR_F32)
        (Scm_F32VectorFill (SCM_F32VECTOR v)
                           (cast float (Scm_GetDouble init))
                           0 -1)]
       [(SCM_UVECTOR_F64)
        (Scm_F64VectorFill (SCM_F64VECTOR v)
                           (Scm_GetDouble init)
                           0 -1)]
       [else SCM_UNDEFINED]) ; can't happen
     (return v))))

;; generic copy
(inline-stub
 (define-cproc uvector-copy (v::<uvector>
                             :optional (start::<fixnum> 0)
                                       (end::<fixnum> -1))
   (let* ([len::int (SCM_UVECTOR_SIZE v)]
          [klass::ScmClass* (Scm_ClassOf (SCM_OBJ v))]
          [eltsize::int (Scm_UVectorElementSize klass)]
          [src::(const char *) (cast (const char *) (SCM_UVECTOR_ELEMENTS v))])
     (SCM_CHECK_START_END start end len)
     (let* ([newsize::int (* (- end start) eltsize)]
            [dst::char* (SCM_NEW_ATOMIC_ARRAY (char) newsize)])
       (memcpy dst (+ src (* start eltsize)) newsize)
       (return (Scm_MakeUVector klass (- end start) dst)))))
 )

;; block i/o
(inline-stub
 (define-cproc read-uvector! (v::<uvector>
                              :optional (port::<input-port> (current-input-port))
                                        (start::<fixnum> 0)
                                        (end::<fixnum> -1)
                                        (endian::<symbol>? #f))
   Scm_ReadBlockX)

 (define-cproc read-uvector (klass::<class> size::<fixnum> 
                             :optional (port::<input-port> (current-input-port))
                                       (endian::<symbol>? #f))
   (unless (Scm_SubtypeP klass SCM_CLASS_UVECTOR)
     (Scm_TypeError "class" "uniform vector class" (SCM_OBJ klass)))
   (let* ([v::ScmUVector* (cast ScmUVector* (Scm_MakeUVector klass size NULL))]
          [r (Scm_ReadBlockX v port 0 size endian)])
     (if (SCM_EOFP r)
       (return r)
       (begin
         (SCM_ASSERT (SCM_INTP r))
         (let* ([n::long (SCM_INT_VALUE r)])
           (SCM_ASSERT (and (<= n size) (<= 0 n)))
           ;; NB: If read size is a lot shorter than requested size, we may
           ;; want to copy it instead of just keeping the rest of vector
           ;; unused.
           (if (< n size)
             (return (Scm_UVectorAlias klass v 0 n))
             (return (SCM_OBJ v))))))))

 (define-cproc write-uvector (v::<uvector>
                              :optional (port::<output-port> (current-output-port))
                                        (start::<fixnum> 0)
                                        (end::<fixnum> -1)
                                        (endian::<symbol>? #f))
   Scm_WriteBlock)
 )

;; copy
(inline-stub
 (define-cproc uvector-copy! (dest::<uvector> dstart::<int> src::<uvector>
                              :optional (sstart::<int> 0)
                                        (send::<int> -1))
   ::<void>
   (SCM_UVECTOR_CHECK_MUTABLE dest)
   (SCM_CHECK_START_END sstart send (SCM_UVECTOR_SIZE src))
   (let* ([deltsize::int (Scm_UVectorElementSize (Scm_ClassOf (SCM_OBJ dest)))]
          [doff::int (* dstart deltsize)]
          [seltsize::int (Scm_UVectorElementSize (Scm_ClassOf (SCM_OBJ src)))]
          [soff::int (* sstart seltsize)]
          [size::int (- (* send seltsize) soff)])
     (memmove (+ (cast char* (SCM_UVECTOR_ELEMENTS dest)) doff)
              (+ (cast (const char*) (SCM_UVECTOR_ELEMENTS src)) soff)
              size)))
 )

;; String operations
(inline-stub
 ;; A common operation to extract range of char* from the input string S.
 ;; START and END may be adjusted.
 ;; SP and EP are const char* variable that gets start and end pointers.
 (define-cise-stmt with-input-string-pointers
   [(_ (s start end sp ep) . body)
    (let ([sb (gensym)] [size (gensym)] [len (gensym)] [ss (gensym)])
      `(let* ([,sb :: (const ScmStringBody*) (SCM_STRING_BODY ,s)]
              [,size :: u_int (SCM_STRING_BODY_SIZE ,sb)]
              [,len :: u_int (SCM_STRING_BODY_LENGTH ,sb)]
              [,ss :: (const char*) (SCM_STRING_BODY_START ,sb)])
         (SCM_CHECK_START_END ,start ,end (cast int ,len))
         (let* ([,sp :: (const char*)
                     (?: (== ,start 0)
                         ,ss
                         (Scm_StringBodyPosition ,sb ,start))]
                [,ep :: (const char*)
                     (?: (== ,end ,len)
                         (+ ,ss ,size)
                         (Scm_StringBodyPosition ,sb ,end))])
           ,@body)))])
 
 (define-cfn string->bytevector
   (klass::ScmClass* s::ScmString* start::int end::int immutable::int) :static
   (with-input-string-pointers (s start end sp ep)
     (let* ([buf::char* NULL])
       (if immutable
         (set! buf (cast char* sp))  ; Eek! drop const qualifier
         (begin
           (set! buf (SCM_NEW_ATOMIC2 (char*) (- ep sp)))
           (memcpy buf sp (- ep sp))))
       (return (Scm_MakeUVectorFull klass (cast int (- ep sp)) buf
                                    immutable NULL)))))

 (define-cproc string->s8vector
   (s::<string>
    :optional (start::<fixnum> 0) (end::<fixnum> -1) (immutable?::<boolean> #f))
   (return (string->bytevector SCM_CLASS_S8VECTOR s start end immutable?)))

 (define-cproc string->u8vector
   (s::<string>
    :optional (start::<fixnum> 0) (end::<fixnum> -1) (immutable?::<boolean> #f))
   (return (string->bytevector SCM_CLASS_U8VECTOR s start end immutable?)))

 (define-cfn string->bytevector!
   (v::ScmUVector* tstart::int s::ScmString* start::int end::int) :static
   (let* ([tlen::int (SCM_UVECTOR_SIZE v)])
     (when (and (>= tstart 0) (< tstart tlen))
       (SCM_UVECTOR_CHECK_MUTABLE v)
       (with-input-string-pointers (s start end sp ep)
         (let* ([buf::(char*) (+ (cast char* (SCM_UVECTOR_ELEMENTS v)) tstart)])
           (if (> (- tlen tstart) (- ep sp))
             (memcpy buf sp (- ep sp))
             (memcpy buf sp (- tlen tstart))))))
     (return (SCM_OBJ v))))

 (define-cproc string->s8vector! (v::<s8vector>
                                  tstart::<int>
                                  s::<string>
                                  :optional (start::<fixnum> 0)
                                  (end::<fixnum> -1))
   (return (string->bytevector! (SCM_UVECTOR v) tstart s start end)))

 (define-cproc string->u8vector! (v::<u8vector>
                                  tstart::<int>
                                  s::<string>
                                  :optional (start::<fixnum> 0)
                                  (end::<fixnum> -1))
   (return (string->bytevector! (SCM_UVECTOR v) tstart s start end)))

 (define-cfn bytevector->string (v::ScmUVector* start::int end::int) :static
   (let* ([len::int (SCM_UVECTOR_SIZE v)])
     ;; We automatically avoid copying the string contents when the
     ;; following conditions are met:
     ;; * The source vector is immutable
     ;; * The owner of source vector is NULL (If there's an owner such as
     ;;   mmap handle, it isn't desirable if a string points to the memory
     ;;   without keeping ownership info.)
     ;; * The resulting string is not a small fraction of a large vector.
     ;;   If so, we may waste space by retaining large chunk of memory
     ;;   most of which won't be ever used.  Here we use some heuristics:
     ;;   - If the source vector is not small (>= 256)
     ;;   - and the string covers only a fraction (1/5) or less,
     ;;   - then we copy the content.
     ;; NB: We may add a flag that force the content to be shared, for
     ;; the programs that really want to avoid allocation.
     (SCM_CHECK_START_END start end len)
     (let* ([flags::int (?: (and (SCM_UVECTOR_IMMUTABLE_P v)
                                 (== (-> v owner) NULL)
                                 (not (and (>= len 256)
                                           (<= (- end start) (/ len 5)))))
                            0
                            SCM_STRING_COPYING)])
       (return (Scm_MakeString (+ (cast char* (SCM_UVECTOR_ELEMENTS v)) start)
                               (- end start) -1 flags)))))

 (define-cproc s8vector->string (v::<s8vector>
                                 :optional (start::<fixnum> 0)
                                           (end::<fixnum> -1))
   (return (bytevector->string (SCM_UVECTOR v) start end)))

 (define-cproc u8vector->string (v::<u8vector>
                                 :optional (start::<fixnum> 0)
                                           (end::<fixnum> -1))
   (return (bytevector->string (SCM_UVECTOR v) start end)))

 (define-cfn string->wordvector
   (klass::ScmClass* s::ScmString* start::int end::int) :static
   (with-input-string-pointers (s start end sp ep)
     (let* ([v (Scm_MakeUVector klass (- end start) NULL)]
            [eltp::ScmInt32* (cast ScmInt32* (SCM_UVECTOR_ELEMENTS v))]
            [i::int 0])
       (for [() (< sp ep) (post++ i)]
         (let* ([ch::ScmChar])
           (SCM_CHAR_GET sp ch)
           (set! (aref eltp i) ch)
           (+= sp (SCM_CHAR_NBYTES ch))))
       (return v))))

 (define-cproc string->s32vector (s::<string>
                                  :optional (start::<fixnum> 0)
                                  (end::<fixnum> -1))
   (return (string->wordvector SCM_CLASS_S32VECTOR s start end)))

 (define-cproc string->u32vector (s::<string>
                                  :optional (start::<fixnum> 0)
                                  (end::<fixnum> -1))
   (return (string->wordvector SCM_CLASS_U32VECTOR s start end)))

 (define-cfn string->wordvector!
   (v::ScmUVector* tstart::int s::ScmString* start::int end::int) :static
   (let* ([tlen::int (SCM_UVECTOR_SIZE v)])
     (when (and (>= tstart 0) (< tstart tlen))
       (SCM_UVECTOR_CHECK_MUTABLE v)
       (with-input-string-pointers (s start end sp ep)
         (let* ([buf::ScmInt32* (cast ScmInt32* (SCM_UVECTOR_ELEMENTS v))]
                [i::int tstart])
           (for [() (and (< sp ep) (< i tlen)) (post++ i)]
             (let* ([ch::ScmChar])
               (SCM_CHAR_GET sp ch)
               (set! (aref buf i) ch)
               (+= sp (SCM_CHAR_NBYTES ch)))))))
     (return (SCM_OBJ v))))

 (define-cproc string->s32vector! (v::<s32vector>
                                   tstart::<fixnum>
                                   s::<string>
                                   :optional (start::<fixnum> 0)
                                             (end::<fixnum> -1))
   (return (string->wordvector! (SCM_UVECTOR v) tstart s start end)))

 (define-cproc string->u32vector! (v::<u32vector>
                                   tstart::<fixnum>
                                   s::<string>
                                   :optional (start::<fixnum> 0)
                                             (end::<fixnum> -1))
   (return (string->wordvector! (SCM_UVECTOR v) tstart s start end)))

 (define-cfn wordvector->string (v::ScmUVector* start::int end::int) :static
   (let* ([len::int (SCM_UVECTOR_SIZE v)]
          [s (Scm_MakeOutputStringPort FALSE)])
     (SCM_CHECK_START_END start end len)
     (let* ([eltp::ScmInt32* (cast ScmInt32* (SCM_UVECTOR_ELEMENTS v))])
       (while (< start end)
         (let* ([ch::ScmChar (cast ScmChar (aref eltp (post++ start)))])
           (Scm_PutcUnsafe ch (SCM_PORT s)))))
     (return (Scm_GetOutputStringUnsafe (SCM_PORT s) 0))))

 (define-cproc s32vector->string (v::<s32vector>
                                  :optional (start::<fixnum> 0)
                                            (end::<fixnum> -1))
   (return (wordvector->string (SCM_UVECTOR v) start end)))

 (define-cproc u32vector->string (v::<u32vector>
                                  :optional (start::<fixnum> 0)
                                            (end::<fixnum> -1))
   (return (wordvector->string (SCM_UVECTOR v) start end)))
 )

;; for the bakcward compatibility
(define read-block! read-uvector!)
(define write-block write-uvector)

;;-------------------------------------------------------------
;; Appending vectors
;;

(define-macro (define-appender tag)
  (let ([app   (string->symbol #"~|tag|vector-append")]
        [len   (string->symbol #"~|tag|vector-length")]
        [make  (string->symbol #"make-~|tag|vector")]
        [copy! (string->symbol #"~|tag|vector-copy!")])
    `(define (,app . vs)
       (let* ([size (apply + (map ,len vs))]
              [dest (,make size)])
         (do ([vs vs (cdr vs)]
              [k  0  (+ k (,len (car vs)))])
             [(null? vs) dest]
           (,copy! dest k (car vs)))))
    ))

(define-appender s8)
(define-appender u8)
(define-appender s16)
(define-appender u16)
(define-appender s32)
(define-appender u32)
(define-appender s64)
(define-appender u64)
(define-appender f16)
(define-appender f32)
(define-appender f64)

;;-------------------------------------------------------------
;; Sequence protocol implementation
;;

(define-macro (%define-srfi-4-collection-interface tag)
  (let* ([tagvector (string->symbol #"~|tag|vector")]
         [class     (string->symbol #"<~|tagvector|>")]
         [meta      (string->symbol #"<~|tagvector|-meta>")]
         [len       (string->symbol #"~|tagvector|-length")]
         [ref       (string->symbol #"~|tagvector|-ref")]
         [set       (string->symbol #"~|tagvector|-set!")]
         [copy      (string->symbol #"~|tagvector|-copy")]
         [->list    (string->symbol #"~|tagvector|->list")]
         [list->    (string->symbol #"list->~|tagvector|")]
         [->vec     (string->symbol #"~|tagvector|->vector")]
         [vec->     (string->symbol #"vector->~|tagvector|")]
         [make      (string->symbol #"make-~|tagvector|")])
    `(begin
       (define-method call-with-iterator ((v ,class) proc :key (start #f))
         (let* ([len (,len v)] [i (or start 0)])
           (proc (^[] (>= i len))
                 (^[] (rlet1 r (,ref v i) (inc! i))))))
       (define-method call-with-builder ((c ,meta) proc :key (size #f))
         (if size
           (let ([v (,make size)] [i 0])
             (proc (^[item] (,set v i item) (inc! i))
                   (^[] v)))
           (let1 q (make-queue)
             (proc (^[item] (enqueue! q item))
                   (^[] (,list-> (dequeue-all! q)))))
           ))
       (define-method referencer ((v ,class)) ,ref)
       (define-method modifier   ((v ,class)) ,set)
       (define-method size-of ((v ,class)) (,len v))
       (define-method coerce-to ((c <list-meta>) (v ,class)) (,->list v))
       (define-method coerce-to ((c ,meta) (v <list>)) (,list-> v))
       (define-method coerce-to ((c <vector-meta>) (v ,class)) (,->vec v))
       (define-method coerce-to ((c ,meta) (v <vector>)) (,vec-> v))
       (define-method coerce-to ((c ,meta) (v ,class)) (,copy v))
       (define-method subseq ((v ,class) . args) (apply ,copy v args))
       )))

(%define-srfi-4-collection-interface s8)
(%define-srfi-4-collection-interface u8)
(%define-srfi-4-collection-interface s16)
(%define-srfi-4-collection-interface u16)
(%define-srfi-4-collection-interface s32)
(%define-srfi-4-collection-interface u32)
(%define-srfi-4-collection-interface s64)
(%define-srfi-4-collection-interface u64)
(%define-srfi-4-collection-interface f16)
(%define-srfi-4-collection-interface f32)
(%define-srfi-4-collection-interface f64)

;; some special cases
(define-method coerce-to ((dst <string-meta>) (src <u8vector>))
  (u8vector->string src))
(define-method coerce-to ((dst <string-meta>) (src <s8vector>))
  (s8vector->string src))
(define-method coerce-to ((dst <u8vector-meta>) (src <string>))
  (string->u8vector src))
(define-method coerce-to ((dst <s8vector-meta>) (src <string>))
  (string->s8vector src))
(define-method coerce-to ((dst <string-meta>) (src <u32vector>))
  (u32vector->string src))
(define-method coerce-to ((dst <string-meta>) (src <s32vector>))
  (s32vector->string src))
(define-method coerce-to ((dst <u32vector-meta>) (src <string>))
  (string->u32vector src))
(define-method coerce-to ((dst <s32vector-meta>) (src <string>))
  (string->s32vector src))

