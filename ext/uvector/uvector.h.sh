#! /bin/sh
#
# Generate uvector.h
#
#  $Id: uvector.h.sh,v 1.5 2001-06-26 07:39:08 shirok Exp $
#

cat <<EOF
/*
 * uvector - uniform (homogeneous) numeric vector types (SRFI-4)
 *
 *  Copyright(C) 1999-2001 by Shiro Kawai (shiro@acm.org)
 *
 *  Permission to use, copy, modify, distribute this software and
 *  accompanying documentation for any purpose is hereby granted,
 *  provided that existing copyright notices are retained in all
 *  copies and that this notice is included verbatim in all
 *  distributions.
 *  This software is provided as is, without express or implied
 *  warranty.  In no circumstances the author(s) shall be liable
 *  for any damages arising out of the use of this software.
 *
 *  This file is automatically generated.  DO NOT EDIT.
 *  \$Id: uvector.h.sh,v 1.5 2001-06-26 07:39:08 shirok Exp $
 */

#ifndef GAUCHE_UVECTOR_H
#define GAUCHE_UVECTOR_H

#include <gauche.h>

/*
 * This header file is for other extension modules which need
 * to access uniform vectors in C level.
 */

#if SIZEOF_INT >= 4
typedef int           SCM_UVECTOR_INT32;
typedef unsigned int  SCM_UVECTOR_UINT32;
#else
typedef long          SCM_UVECTOR_INT32;
typedef unsigned long SCM_UVECTOR_UINT32;
#endif

#if SIZEOF_LONG >= 8
typedef long          SCM_UVECTOR_INT64;
typedef unsigned long SCM_UVECTOR_UINT64;
#else
typedef ScmObj        SCM_UVECTOR_INT64;
typedef ScmObj        SCM_UVECTOR_UINT64;
#endif
EOF

#
# emit vecttype itemtype
#
emit() {
    vecttype=$1
    itemtype=$2
    extrafns=$3
    VECTTYPE=`echo $vecttype | tr '[a-z]' '[A-Z]'`
    cat <<EOF

/* ${vecttype} */

typedef struct Scm${vecttype}Rec {
    SCM_HEADER;
    int size;
    $itemtype elements[1];
} Scm${vecttype};

extern ScmClass Scm_${vecttype}Class;
#define SCM_CLASS_${VECTTYPE}  (&Scm_${vecttype}Class)

#define SCM_${VECTTYPE}(obj)        ((Scm${vecttype}*)(obj))
#define SCM_${VECTTYPE}P(obj)       SCM_XTYPEP(obj, SCM_CLASS_${VECTTYPE})
#define SCM_${VECTTYPE}_SIZE(obj)   SCM_${VECTTYPE}(obj)->size
#define SCM_${VECTTYPE}_ELEMENTS(obj) SCM_${VECTTYPE}(obj)->elements

extern ScmObj Scm_Make${vecttype}(int size, ${itemtype} fill);
extern ScmObj Scm_Make${vecttype}FromArray(int size, ${itemtype} array[]);
extern ScmObj Scm_${vecttype}Fill(Scm${vecttype} *vec, ${itemtype} fill);
extern ScmObj Scm_${vecttype}Ref(Scm${vecttype} *vec, int index);
extern ScmObj Scm_${vecttype}Set(Scm${vecttype} *vec, int index, ScmObj val);
extern ScmObj Scm_${vecttype}ToList(Scm${vecttype} *vec);
extern ScmObj Scm_ListTo${vecttype}(ScmObj list);
extern ScmObj Scm_${vecttype}Copy(Scm${vecttype} *vec);
extern ScmObj Scm_${vecttype}CopyX(Scm${vecttype} *dst, Scm${vecttype} *src);
extern ScmObj Scm_${vecttype}ToVector(Scm${vecttype} *vec);
extern ScmObj Scm_VectorTo${vecttype}(ScmVector *vec);

EOF
    if [ "$extrafns" = 1 ]; then
        cat <<EOF
extern ScmObj Scm_${vecttype}Scale(Scm${vecttype} *vec, ${itemtype} factor);
extern ScmObj Scm_${vecttype}ScaleX(Scm${vecttype} *vec, ${itemtype} factor);
extern ScmObj Scm_${vecttype}Add2(Scm${vecttype} *x, Scm${vecttype} *y);
extern ScmObj Scm_${vecttype}AddX2(Scm${vecttype} *x, Scm${vecttype} *y);
extern ScmObj Scm_${vecttype}SubX2(Scm${vecttype} *x, Scm${vecttype} *y);
extern ScmObj Scm_${vecttype}DotProduct(Scm${vecttype} *x, Scm${vecttype} *y);
extern ScmObj Scm_${vecttype}CrossProduct(Scm${vecttype} *x, Scm${vecttype} *y);
EOF
    fi
}

emit S8Vector  "signed char"
emit U8Vector  "unsigned char"
emit S16Vector "signed short"
emit U16Vector "unsigned short"
emit S32Vector "SCM_UVECTOR_INT32"
emit U32Vector "SCM_UVECTOR_UINT32"
emit S64Vector "SCM_UVECTOR_INT64"
emit U64Vector "SCM_UVECTOR_UINT64"
emit F32Vector "float"  1
emit F64Vector "double" 1

cat <<EOF

#endif /* GAUCHE_UVECTOR_H */
EOF
